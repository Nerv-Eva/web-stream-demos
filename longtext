File an issue about the selected text

HTML
Living Standard — Last Updated 15 March 2018
One-Page Version
html.spec.whatwg.org

Multipage Version
/multipage

Developer Version
/dev

PDF Version
/print.pdf
Translations
日本語 • 简体中文
FAQ
on GitHub

Join us on IRC
#whatwg on Freenode
Contribute on GitHub
whatwg/html repository

Commits
on GitHub

Twitter Updates
@htmlstandard
Open Issues
filed on GitHub

Open an Issue
whatwg.org/newbug
Table of contents
1 Introduction
2 Common infrastructure
3 Semantics, structure, and APIs of HTML documents
4 The elements of HTML
5 Microdata
6 User interaction
7 Loading Web pages
8 Web application APIs
9 Communication
10 Web workers
11 Web storage
12 The HTML syntax
13 The XML syntax
14 Rendering
15 Obsolete features
16 IANA considerations
Index
References
Acknowledgments
Full table of contents
1 Introduction
1.1 Where does this specification fit?
1.2 Is this HTML5?
1.3 Background
1.4 Audience
1.5 Scope
1.6 History
1.7 Design notes
1.7.1 Serializability of script execution
1.7.2 Compliance with other specifications
1.7.3 Extensibility
1.8 HTML vs XML syntax
1.9 Structure of this specification
1.9.1 How to read this specification
1.9.2 Typographic conventions
1.10 Privacy concerns
1.10.1 Cross-site communication
1.11 A quick introduction to HTML
1.11.1 Writing secure applications with HTML
1.11.2 Common pitfalls to avoid when using the scripting APIs
1.11.3 How to catch mistakes when writing HTML: validators and conformance checkers
1.12 Conformance requirements for authors
1.12.1 Presentational markup
1.12.2 Syntax errors
1.12.3 Restrictions on content models and on attribute values
1.13 Suggested reading
2 Common infrastructure
2.1 Terminology
2.1.1 Parallelism
2.1.2 Resources
2.1.3 XML compatibility
2.1.4 DOM trees
2.1.5 Scripting
2.1.6 Plugins
2.1.7 Character encodings
2.1.8 Conformance classes
2.1.9 Dependencies
2.1.10 Extensibility
2.1.11 Interactions with XPath and XSLT
2.2 Case-sensitivity and string comparison
2.3 Common microsyntaxes
2.3.1 Common parser idioms
2.3.2 Boolean attributes
2.3.3 Keywords and enumerated attributes
2.3.4 Numbers
2.3.4.1 Signed integers
2.3.4.2 Non-negative integers
2.3.4.3 Floating-point numbers
2.3.4.4 Percentages and lengths
2.3.4.5 Non-zero percentages and lengths
2.3.4.6 Lists of floating-point numbers
2.3.4.7 Lists of dimensions
2.3.5 Dates and times
2.3.5.1 Months
2.3.5.2 Dates
2.3.5.3 Yearless dates
2.3.5.4 Times
2.3.5.5 Local dates and times
2.3.5.6 Time zones
2.3.5.7 Global dates and times
2.3.5.8 Weeks
2.3.5.9 Durations
2.3.5.10 Vaguer moments in time
2.3.6 Colors
2.3.7 Space-separated tokens
2.3.8 Comma-separated tokens
2.3.9 References
2.3.10 Media queries
2.4 URLs
2.4.1 Terminology
2.4.2 Parsing URLs
2.4.3 Dynamic changes to base URLs
2.5 Fetching resources
2.5.1 Terminology
2.5.2 Determining the type of a resource
2.5.3 Extracting character encodings from meta elements
2.5.4 CORS settings attributes
2.5.5 Referrer policy attributes
2.5.6 Nonce attributes
2.6 Common DOM interfaces
2.6.1 Reflecting content attributes in IDL attributes
2.6.2 Collections
2.6.2.1 The HTMLAllCollection interface
2.6.2.1.1 [[Call]] ( thisArgument, argumentsList )
2.6.2.2 The HTMLFormControlsCollection interface
2.6.2.3 The HTMLOptionsCollection interface
2.6.3 The DOMStringList interface
2.6.4 Garbage collection
2.7 Safe passing of structured data
2.7.1 Serializable objects
2.7.2 Transferable objects
2.7.3 StructuredSerializeInternal ( value, forStorage [ , memory ] )
2.7.4 StructuredSerialize ( value )
2.7.5 StructuredSerializeForStorage ( value )
2.7.6 StructuredDeserialize ( serialized, targetRealm [ , memory ] )
2.7.7 StructuredSerializeWithTransfer ( value, transferList )
2.7.8 StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm )
2.7.9 Performing serialization and transferring from other specifications
3 Semantics, structure, and APIs of HTML documents
3.1 Documents
3.1.1 The Document object
3.1.2 Resource metadata management
3.1.3 DOM tree accessors
3.2 Elements
3.2.1 Semantics
3.2.2 Elements in the DOM
3.2.3 HTML element constructors
3.2.4 Element definitions
3.2.4.1 Attributes
3.2.5 Content models
3.2.5.1 The "nothing" content model
3.2.5.2 Kinds of content
3.2.5.2.1 Metadata content
3.2.5.2.2 Flow content
3.2.5.2.3 Sectioning content
3.2.5.2.4 Heading content
3.2.5.2.5 Phrasing content
3.2.5.2.6 Embedded content
3.2.5.2.7 Interactive content
3.2.5.2.8 Palpable content
3.2.5.2.9 Script-supporting elements
3.2.5.3 Transparent content models
3.2.5.4 Paragraphs
3.2.6 Global attributes
3.2.6.1 The title attribute
3.2.6.2 The lang and xml:lang attributes
3.2.6.3 The translate attribute
3.2.6.4 The dir attribute
3.2.6.5 The style attribute
3.2.6.6 Embedding custom non-visible data with the data-* attributes
3.2.7 The innerText IDL attribute
3.2.8 Requirements relating to the bidirectional algorithm
3.2.8.1 Authoring conformance criteria for bidirectional-algorithm formatting characters
3.2.8.2 User agent conformance criteria
3.2.9 Requirements related to ARIA and to platform accessibility APIs
4 The elements of HTML
4.1 The document element
4.1.1 The html element
4.2 Document metadata
4.2.1 The head element
4.2.2 The title element
4.2.3 The base element
4.2.4 The link element
4.2.4.1 Processing the media attribute
4.2.4.2 Processing the type attribute
4.2.4.3 Obtaining a resource from a link element
4.2.4.4 Processing `Link` headers
4.2.4.5 Providing users with a means to follow hyperlinks created using the link element
4.2.5 The meta element
4.2.5.1 Standard metadata names
4.2.5.2 Other metadata names
4.2.5.3 Pragma directives
4.2.5.4 Specifying the document's character encoding
4.2.6 The style element
4.2.7 Interactions of styling and scripting
4.3 Sections
4.3.1 The body element
4.3.2 The article element
4.3.3 The section element
4.3.4 The nav element
4.3.5 The aside element
4.3.6 The h1, h2, h3, h4, h5, and h6 elements
4.3.7 The hgroup element
4.3.8 The header element
4.3.9 The footer element
4.3.10 The address element
4.3.11 Headings and sections
4.3.11.1 Creating an outline
4.3.11.2 Sample outlines
4.3.11.3 Exposing outlines to users
4.3.12 Usage summary
4.3.12.1 Article or section?
4.4 Grouping content
4.4.1 The p element
4.4.2 The hr element
4.4.3 The pre element
4.4.4 The blockquote element
4.4.5 The ol element
4.4.6 The ul element
4.4.7 The menu element
4.4.8 The li element
4.4.9 The dl element
4.4.10 The dt element
4.4.11 The dd element
4.4.12 The figure element
4.4.13 The figcaption element
4.4.14 The main element
4.4.15 The div element
4.5 Text-level semantics
4.5.1 The a element
4.5.2 The em element
4.5.3 The strong element
4.5.4 The small element
4.5.5 The s element
4.5.6 The cite element
4.5.7 The q element
4.5.8 The dfn element
4.5.9 The abbr element
4.5.10 The ruby element
4.5.11 The rt element
4.5.12 The rp element
4.5.13 The data element
4.5.14 The time element
4.5.15 The code element
4.5.16 The var element
4.5.17 The samp element
4.5.18 The kbd element
4.5.19 The sub and sup elements
4.5.20 The i element
4.5.21 The b element
4.5.22 The u element
4.5.23 The mark element
4.5.24 The bdi element
4.5.25 The bdo element
4.5.26 The span element
4.5.27 The br element
4.5.28 The wbr element
4.5.29 Usage summary
4.6 Links
4.6.1 Introduction
4.6.2 Links created by a and area elements
4.6.3 API for a and area elements
4.6.4 Following hyperlinks
4.6.5 Downloading resources
4.6.5.1 Hyperlink auditing
4.6.6 Link types
4.6.6.1 Link type "alternate"
4.6.6.2 Link type "author"
4.6.6.3 Link type "bookmark"
4.6.6.4 Link type "canonical"
4.6.6.5 Link type "dns-prefetch"
4.6.6.6 Link type "external"
4.6.6.7 Link type "help"
4.6.6.8 Link type "icon"
4.6.6.9 Link type "license"
4.6.6.10 Link type "modulepreload"
4.6.6.11 Link type "nofollow"
4.6.6.12 Link type "noopener"
4.6.6.13 Link type "noreferrer"
4.6.6.14 Link type "pingback"
4.6.6.15 Link type "preconnect"
4.6.6.16 Link type "prefetch"
4.6.6.17 Link type "preload"
4.6.6.18 Link type "prerender"
4.6.6.19 Link type "search"
4.6.6.20 Link type "stylesheet"
4.6.6.21 Link type "tag"
4.6.6.22 Sequential link types
4.6.6.22.1 Link type "next"
4.6.6.22.2 Link type "prev"
4.6.6.23 Other link types
4.7 Edits
4.7.1 The ins element
4.7.2 The del element
4.7.3 Attributes common to ins and del elements
4.7.4 Edits and paragraphs
4.7.5 Edits and lists
4.7.6 Edits and tables
4.8 Embedded content
4.8.1 The picture element
4.8.2 The source element
4.8.3 The img element
4.8.4 Images
4.8.4.1 Introduction
4.8.4.1.1 Adaptive images
4.8.4.2 Attributes common to source and img elements
4.8.4.2.1 Srcset attributes
4.8.4.2.2 Sizes attributes
4.8.4.3 Processing model
4.8.4.3.1 When to obtain images
4.8.4.3.2 Reacting to DOM mutations
4.8.4.3.3 The list of available images
4.8.4.3.4 Decoding images
4.8.4.3.5 Updating the image data
4.8.4.3.6 Selecting an image source
4.8.4.3.7 Updating the source set
4.8.4.3.8 Parsing a srcset attribute
4.8.4.3.9 Parsing a sizes attribute
4.8.4.3.10 Normalizing the source densities
4.8.4.3.11 Reacting to environment changes
4.8.4.4 Requirements for providing text to act as an alternative for images
4.8.4.4.1 General guidelines
4.8.4.4.2 A link or button containing nothing but the image
4.8.4.4.3 A phrase or paragraph with an alternative graphical representation: charts, diagrams, graphs, maps, illustrations
4.8.4.4.4 A short phrase or label with an alternative graphical representation: icons, logos
4.8.4.4.5 Text that has been rendered to a graphic for typographical effect
4.8.4.4.6 A graphical representation of some of the surrounding text
4.8.4.4.7 Ancillary images
4.8.4.4.8 A purely decorative image that doesn't add any information
4.8.4.4.9 A group of images that form a single larger picture with no links
4.8.4.4.10 A group of images that form a single larger picture with links
4.8.4.4.11 A key part of the content
4.8.4.4.12 An image not intended for the user
4.8.4.4.13 An image in an e-mail or private document intended for a specific person who is known to be able to view images
4.8.4.4.14 Guidance for markup generators
4.8.4.4.15 Guidance for conformance checkers
4.8.5 The iframe element
4.8.6 The embed element
4.8.7 The object element
4.8.8 The param element
4.8.9 The video element
4.8.10 The audio element
4.8.11 The track element
4.8.12 Media elements
4.8.12.1 Error codes
4.8.12.2 Location of the media resource
4.8.12.3 MIME types
4.8.12.4 Network states
4.8.12.5 Loading the media resource
4.8.12.6 Offsets into the media resource
4.8.12.7 Ready states
4.8.12.8 Playing the media resource
4.8.12.9 Seeking
4.8.12.10 Media resources with multiple media tracks
4.8.12.10.1 AudioTrackList and VideoTrackList objects
4.8.12.10.2 Selecting specific audio and video tracks declaratively
4.8.12.11 Timed text tracks
4.8.12.11.1 Text track model
4.8.12.11.2 Sourcing in-band text tracks
4.8.12.11.3 Sourcing out-of-band text tracks
4.8.12.11.4 Guidelines for exposing cues in various formats as text track cues
4.8.12.11.5 Text track API
4.8.12.11.6 Event handlers for objects of the text track APIs
4.8.12.11.7 Best practices for metadata text tracks
4.8.12.12 Identifying a track kind through a URL
4.8.12.13 User interface
4.8.12.14 Time ranges
4.8.12.15 The TrackEvent interface
4.8.12.16 Events summary
4.8.12.17 Security and privacy considerations
4.8.12.18 Best practices for authors using media elements
4.8.12.19 Best practices for implementers of media elements
4.8.13 The map element
4.8.14 The area element
4.8.15 Image maps
4.8.15.1 Authoring
4.8.15.2 Processing model
4.8.16 MathML
4.8.17 SVG
4.8.18 Dimension attributes
4.9 Tabular data
4.9.1 The table element
4.9.1.1 Techniques for describing tables
4.9.1.2 Techniques for table design
4.9.2 The caption element
4.9.3 The colgroup element
4.9.4 The col element
4.9.5 The tbody element
4.9.6 The thead element
4.9.7 The tfoot element
4.9.8 The tr element
4.9.9 The td element
4.9.10 The th element
4.9.11 Attributes common to td and th elements
4.9.12 Processing model
4.9.12.1 Forming a table
4.9.12.2 Forming relationships between data cells and header cells
4.9.13 Examples
4.10 Forms
4.10.1 Introduction
4.10.1.1 Writing a form's user interface
4.10.1.2 Implementing the server-side processing for a form
4.10.1.3 Configuring a form to communicate with a server
4.10.1.4 Client-side form validation
4.10.1.5 Enabling client-side automatic filling of form controls
4.10.1.6 Improving the user experience on mobile devices
4.10.1.7 The difference between the field type, the autofill field name, and the input modality
4.10.1.8 Date, time, and number formats
4.10.2 Categories
4.10.3 The form element
4.10.4 The label element
4.10.5 The input element
4.10.5.1 States of the type attribute
4.10.5.1.1 Hidden state (type=hidden)
4.10.5.1.2 Text (type=text) state and Search state (type=search)
4.10.5.1.3 Telephone state (type=tel)
4.10.5.1.4 URL state (type=url)
4.10.5.1.5 E-mail state (type=email)
4.10.5.1.6 Password state (type=password)
4.10.5.1.7 Date state (type=date)
4.10.5.1.8 Month state (type=month)
4.10.5.1.9 Week state (type=week)
4.10.5.1.10 Time state (type=time)
4.10.5.1.11 Local Date and Time state (type=datetime-local)
4.10.5.1.12 Number state (type=number)
4.10.5.1.13 Range state (type=range)
4.10.5.1.14 Color state (type=color)
4.10.5.1.15 Checkbox state (type=checkbox)
4.10.5.1.16 Radio Button state (type=radio)
4.10.5.1.17 File Upload state (type=file)
4.10.5.1.18 Submit Button state (type=submit)
4.10.5.1.19 Image Button state (type=image)
4.10.5.1.20 Reset Button state (type=reset)
4.10.5.1.21 Button state (type=button)
4.10.5.2 Implementation notes regarding localization of form controls
4.10.5.3 Common input element attributes
4.10.5.3.1 The maxlength and minlength attributes
4.10.5.3.2 The size attribute
4.10.5.3.3 The readonly attribute
4.10.5.3.4 The required attribute
4.10.5.3.5 The multiple attribute
4.10.5.3.6 The pattern attribute
4.10.5.3.7 The min and max attributes
4.10.5.3.8 The step attribute
4.10.5.3.9 The list attribute
4.10.5.3.10 The placeholder attribute
4.10.5.4 Common input element APIs
4.10.5.5 Common event behaviors
4.10.6 The button element
4.10.7 The select element
4.10.8 The datalist element
4.10.9 The optgroup element
4.10.10 The option element
4.10.11 The textarea element
4.10.12 The output element
4.10.13 The progress element
4.10.14 The meter element
4.10.15 The fieldset element
4.10.16 The legend element
4.10.17 Form control infrastructure
4.10.17.1 A form control's value
4.10.17.2 Mutability
4.10.17.3 Association of controls and forms
4.10.18 Attributes common to form controls
4.10.18.1 Naming form controls: the name attribute
4.10.18.2 Submitting element directionality: the dirname attribute
4.10.18.3 Limiting user input length: the maxlength attribute
4.10.18.4 Setting minimum input length requirements: the minlength attribute
4.10.18.5 Enabling and disabling form controls: the disabled attribute
4.10.18.6 Form submission
4.10.18.6.1 Autofocusing a form control: the autofocus attribute
4.10.18.7 Autofill
4.10.18.7.1 Autofilling form controls: the autocomplete attribute
4.10.18.7.2 Processing model
4.10.19 APIs for the text control selections
4.10.20 Constraints
4.10.20.1 Definitions
4.10.20.2 Constraint validation
4.10.20.3 The constraint validation API
4.10.20.4 Security
4.10.21 Form submission
4.10.21.1 Introduction
4.10.21.2 Implicit submission
4.10.21.3 Form submission algorithm
4.10.21.4 Constructing the form data set
4.10.21.5 Selecting a form submission encoding
4.10.21.6 URL-encoded form data
4.10.21.7 Multipart form data
4.10.21.8 Plain text form data
4.10.22 Resetting a form
4.11 Interactive elements
4.11.1 The details element
4.11.2 The summary element
4.11.3 Commands
4.11.3.1 Facets
4.11.3.2 Using the a element to define a command
4.11.3.3 Using the button element to define a command
4.11.3.4 Using the input element to define a command
4.11.3.5 Using the option element to define a command
4.11.3.6 Using the accesskey attribute on a legend element to define a command
4.11.3.7 Using the accesskey attribute to define a command on other elements
4.11.4 The dialog element
4.12 Scripting
4.12.1 The script element
4.12.1.1 Processing model
4.12.1.2 Scripting languages
4.12.1.3 Restrictions for contents of script elements
4.12.1.4 Inline documentation for external scripts
4.12.1.5 Interaction of script elements and XSLT
4.12.2 The noscript element
4.12.3 The template element
4.12.3.1 Interaction of template elements with XSLT and XPath
4.12.4 The slot element
4.12.5 The canvas element
4.12.5.1 The 2D rendering context
4.12.5.1.1 Implementation notes
4.12.5.1.2 The canvas state
4.12.5.1.3 Line styles
4.12.5.1.4 Text styles
4.12.5.1.5 Building paths
4.12.5.1.6 Path2D objects
4.12.5.1.7 Transformations
4.12.5.1.8 Image sources for 2D rendering contexts
4.12.5.1.9 Fill and stroke styles
4.12.5.1.10 Drawing rectangles to the bitmap
4.12.5.1.11 Drawing text to the bitmap
4.12.5.1.12 Drawing paths to the canvas
4.12.5.1.13 Drawing focus rings and scrolling paths into view
4.12.5.1.14 Drawing images
4.12.5.1.15 Pixel manipulation
4.12.5.1.16 Compositing
4.12.5.1.17 Image smoothing
4.12.5.1.18 Shadows
4.12.5.1.19 Filters
4.12.5.1.20 Working with externally-defined SVG filters
4.12.5.1.21 Drawing model
4.12.5.1.22 Best practices
4.12.5.1.23 Examples
4.12.5.2 The ImageBitmap rendering context
4.12.5.2.1 Introduction
4.12.5.2.2 The ImageBitmapRenderingContext interface
4.12.5.3 The OffscreenCanvas interface
4.12.5.3.1 The offscreen 2D rendering context
4.12.5.4 Color spaces and color correction
4.12.5.5 Serializing bitmaps to a file
4.12.5.6 Security with canvas elements
4.13 Custom elements
4.13.1 Introduction
4.13.1.1 Creating an autonomous custom element
4.13.1.2 Creating a customized built-in element
4.13.1.3 Drawbacks of autonomous custom elements
4.13.1.4 Upgrading elements after their creation
4.13.2 Requirements for custom element constructors
4.13.3 Core concepts
4.13.4 The CustomElementRegistry interface
4.13.5 Upgrades
4.13.6 Custom element reactions
4.14 Common idioms without dedicated elements
4.14.1 The main part of the content
4.14.2 Bread crumb navigation
4.14.3 Tag clouds
4.14.4 Conversations
4.14.5 Footnotes
4.15 Disabled elements
4.16 Matching HTML elements using selectors and CSS
4.16.1 Case-sensitivity of the CSS 'attr()' function
4.16.2 Case-sensitivity of selectors
4.16.3 Pseudo-classes
5 Microdata
5.1 Introduction
5.1.1 Overview
5.1.2 The basic syntax
5.1.3 Typed items
5.1.4 Global identifiers for items
5.1.5 Selecting names when defining vocabularies
5.2 Encoding microdata
5.2.1 The microdata model
5.2.2 Items
5.2.3 Names: the itemprop attribute
5.2.4 Values
5.2.5 Associating names with items
5.2.6 Microdata and other namespaces
5.3 Sample microdata vocabularies
5.3.1 vCard
5.3.1.1 Conversion to vCard
5.3.1.2 Examples
5.3.2 vEvent
5.3.2.1 Conversion to iCalendar
5.3.2.2 Examples
5.3.3 Licensing works
5.3.3.1 Examples
5.4 Converting HTML to other formats
5.4.1 JSON
6 User interaction
6.1 The hidden attribute
6.2 Inert subtrees
6.3 Activation
6.4 Focus
6.4.1 Introduction
6.4.2 Data model
6.4.3 The tabindex attribute
6.4.4 Processing model
6.4.5 Sequential focus navigation
6.4.6 Focus management APIs
6.5 Assigning keyboard shortcuts
6.5.1 Introduction
6.5.2 The accesskey attribute
6.5.3 Processing model
6.6 Editing
6.6.1 Making document regions editable: The contenteditable content attribute
6.6.2 Making entire documents editable: the designMode IDL attribute
6.6.3 Best practices for in-page editors
6.6.4 Editing APIs
6.6.5 Spelling and grammar checking
6.6.6 Autocapitalization
6.6.7 Input modalities: the inputmode attribute
6.7 Drag and drop
6.7.1 Introduction
6.7.2 The drag data store
6.7.3 The DataTransfer interface
6.7.3.1 The DataTransferItemList interface
6.7.3.2 The DataTransferItem interface
6.7.4 The DragEvent interface
6.7.5 Processing model
6.7.6 Events summary
6.7.7 The draggable attribute
6.7.8 Security risks in the drag-and-drop model
7 Loading Web pages
7.1 Browsing contexts
7.1.1 Nested browsing contexts
7.1.1.1 Navigating nested browsing contexts in the DOM
7.1.2 Auxiliary browsing contexts
7.1.2.1 Navigating auxiliary browsing contexts in the DOM
7.1.3 Security
7.1.4 Groupings of browsing contexts
7.1.5 Browsing context names
7.2 Security infrastructure for Window, WindowProxy, and Location objects
7.2.1 Integration with IDL
7.2.2 Shared internal slot: [[CrossOriginPropertyDescriptorMap]]
7.2.3 Shared abstract operations
7.2.3.1 CrossOriginProperties ( O )
7.2.3.2 IsPlatformObjectSameOrigin ( O )
7.2.3.3 CrossOriginGetOwnPropertyHelper ( O, P )
7.2.3.4 CrossOriginGet ( O, P, Receiver )
7.2.3.5 CrossOriginSet ( O, P, V, Receiver )
7.2.3.6 CrossOriginOwnPropertyKeys ( O )
7.3 The Window object
7.3.1 APIs for creating and navigating browsing contexts by name
7.3.2 Accessing other browsing contexts
7.3.3 Named access on the Window object
7.3.4 Garbage collection and browsing contexts
7.3.5 Closing browsing contexts
7.3.6 Browser interface elements
7.3.7 Script settings for Window objects
7.4 The WindowProxy exotic object
7.4.1 [[GetPrototypeOf]] ( )
7.4.2 [[SetPrototypeOf]] ( V )
7.4.3 [[IsExtensible]] ( )
7.4.4 [[PreventExtensions]] ( )
7.4.5 [[GetOwnProperty]] ( P )
7.4.6 [[DefineOwnProperty]] ( P, Desc )
7.4.7 [[Get]] ( P, Receiver )
7.4.8 [[Set]] ( P, V, Receiver )
7.4.9 [[Delete]] ( P )
7.4.10 [[OwnPropertyKeys]] ( )
7.5 Origin
7.5.1 Relaxing the same-origin restriction
7.6 Sandboxing
7.7 Session history and navigation
7.7.1 The session history of browsing contexts
7.7.2 The History interface
7.7.3 Implementation notes for session history
7.7.4 The Location interface
7.7.4.1 [[GetPrototypeOf]] ( )
7.7.4.2 [[SetPrototypeOf]] ( V )
7.7.4.3 [[IsExtensible]] ( )
7.7.4.4 [[PreventExtensions]] ( )
7.7.4.5 [[GetOwnProperty]] ( P )
7.7.4.6 [[DefineOwnProperty]] ( P, Desc )
7.7.4.7 [[Get]] ( P, Receiver )
7.7.4.8 [[Set]] ( P, V, Receiver )
7.7.4.9 [[Delete]] ( P )
7.7.4.10 [[OwnPropertyKeys]] ( )
7.8 Browsing the Web
7.8.1 Navigating across documents
7.8.2 Page load processing model for HTML files
7.8.3 Page load processing model for XML files
7.8.4 Page load processing model for text files
7.8.5 Page load processing model for multipart/x-mixed-replace resources
7.8.6 Page load processing model for media
7.8.7 Page load processing model for content that uses plugins
7.8.8 Page load processing model for inline content that doesn't have a DOM
7.8.9 Navigating to a fragment
7.8.10 History traversal
7.8.10.1 Persisted user state restoration
7.8.10.2 The PopStateEvent interface
7.8.10.3 The HashChangeEvent interface
7.8.10.4 The PageTransitionEvent interface
7.8.11 Unloading documents
7.8.11.1 The BeforeUnloadEvent interface
7.8.12 Aborting a document load
7.9 Offline Web applications
7.9.1 Introduction
7.9.1.1 Supporting offline caching for legacy applications
7.9.1.2 Events summary
7.9.2 Application caches
7.9.3 The cache manifest syntax
7.9.3.1 Some sample manifests
7.9.3.2 Writing cache manifests
7.9.3.3 Parsing cache manifests
7.9.4 Downloading or updating an application cache
7.9.5 The application cache selection algorithm
7.9.6 Changes to the networking model
7.9.7 Expiring application caches
7.9.8 Disk space
7.9.9 Security concerns with offline applications caches
7.9.10 Application cache API
7.9.11 Browser state
8 Web application APIs
8.1 Scripting
8.1.1 Introduction
8.1.2 Enabling and disabling scripting
8.1.3 Processing model
8.1.3.1 Definitions
8.1.3.2 Fetching scripts
8.1.3.3 Creating scripts
8.1.3.4 Calling scripts
8.1.3.5 Realms, settings objects, and global objects
8.1.3.5.1 Entry
8.1.3.5.2 Incumbent
8.1.3.5.3 Current
8.1.3.5.4 Relevant
8.1.3.6 Killing scripts
8.1.3.7 Integration with the JavaScript job queue
8.1.3.7.1 EnqueueJob(queueName, job, arguments)
8.1.3.8 Integration with the JavaScript module system
8.1.3.8.1 HostResolveImportedModule(referencingScriptOrModule, specifier)
8.1.3.8.2 HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability)
8.1.3.8.3 HostGetImportMetaProperties(moduleRecord)
8.1.3.9 Integration with the JavaScript agent formalism
8.1.3.10 Integration with the JavaScript agent cluster formalism
8.1.3.11 Runtime script errors
8.1.3.11.1 Runtime script errors in documents
8.1.3.11.2 The ErrorEvent interface
8.1.3.12 Unhandled promise rejections
8.1.3.12.1 HostPromiseRejectionTracker(promise, operation)
8.1.3.12.2 The PromiseRejectionEvent interface
8.1.3.13 HostEnsureCanCompileStrings(callerRealm, calleeRealm)
8.1.4 Event loops
8.1.4.1 Definitions
8.1.4.2 Processing model
8.1.4.3 Generic task sources
8.1.4.4 Dealing with the event loop from other specifications
8.1.5 Events
8.1.5.1 Event handlers
8.1.5.2 Event handlers on elements, Document objects, and Window objects
8.1.5.2.1 IDL definitions
8.1.5.3 Event firing
8.2 The WindowOrWorkerGlobalScope mixin
8.3 Base64 utility methods
8.4 Dynamic markup insertion
8.4.1 Opening the input stream
8.4.2 Closing the input stream
8.4.3 document.write()
8.4.4 document.writeln()
8.5 Timers
8.6 User prompts
8.6.1 Simple dialogs
8.6.2 Printing
8.7 System state and capabilities
8.7.1 The Navigator object
8.7.1.1 Client identification
8.7.1.2 Language preferences
8.7.1.3 Custom scheme handlers: the registerProtocolHandler() method
8.7.1.3.1 Security and privacy
8.7.1.4 Cookies
8.7.1.5 Plugins
8.8 Images
8.9 Animation frames
9 Communication
9.1 The MessageEvent interface
9.2 Server-sent events
9.2.1 Introduction
9.2.2 The EventSource interface
9.2.3 Processing model
9.2.4 Parsing an event stream
9.2.5 Interpreting an event stream
9.2.6 Authoring notes
9.2.7 Connectionless push and other features
9.2.8 Garbage collection
9.2.9 Implementation advice
9.3 Web sockets
9.3.1 Introduction
9.3.2 The WebSocket interface
9.3.3 Feedback from the protocol
9.3.4 Ping and Pong frames
9.3.5 The CloseEvent interface
9.3.6 Garbage collection
9.4 Cross-document messaging
9.4.1 Introduction
9.4.2 Security
9.4.2.1 Authors
9.4.2.2 User agents
9.4.3 Posting messages
9.5 Channel messaging
9.5.1 Introduction
9.5.1.1 Examples
9.5.1.2 Ports as the basis of an object-capability model on the Web
9.5.1.3 Ports as the basis of abstracting out service implementations
9.5.2 Message channels
9.5.3 Message ports
9.5.4 Broadcasting to many ports
9.5.5 Ports and garbage collection
9.6 Broadcasting to other browsing contexts
10 Web workers
10.1 Introduction
10.1.1 Scope
10.1.2 Examples
10.1.2.1 A background number-crunching worker
10.1.2.2 Using a JavaScript module as a worker
10.1.2.3 Shared workers introduction
10.1.2.4 Shared state using a shared worker
10.1.2.5 Delegation
10.1.2.6 Providing libraries
10.1.3 Tutorials
10.1.3.1 Creating a dedicated worker
10.1.3.2 Communicating with a dedicated worker
10.1.3.3 Shared workers
10.2 Infrastructure
10.2.1 The global scope
10.2.1.1 The WorkerGlobalScope common interface
10.2.1.2 Dedicated workers and the DedicatedWorkerGlobalScope interface
10.2.1.3 Shared workers and the SharedWorkerGlobalScope interface
10.2.2 The event loop
10.2.3 The worker's lifetime
10.2.4 Processing model
10.2.5 Runtime script errors
10.2.6 Creating workers
10.2.6.1 The AbstractWorker mixin
10.2.6.2 Script settings for workers
10.2.6.3 Dedicated workers and the Worker interface
10.2.6.4 Shared workers and the SharedWorker interface
10.2.7 Concurrent hardware capabilities
10.3 APIs available to workers
10.3.1 Importing scripts and libraries
10.3.2 The WorkerNavigator interface
10.3.3 The WorkerLocation interface
11 Web storage
11.1 Introduction
11.2 The API
11.2.1 The Storage interface
11.2.2 The sessionStorage attribute
11.2.3 The localStorage attribute
11.2.4 The storage event
11.2.4.1 The StorageEvent interface
11.3 Disk space
11.4 Privacy
11.4.1 User tracking
11.4.2 Sensitivity of data
11.5 Security
11.5.1 DNS spoofing attacks
11.5.2 Cross-directory attacks
11.5.3 Implementation risks
12 The HTML syntax
12.1 Writing HTML documents
12.1.1 The DOCTYPE
12.1.2 Elements
12.1.2.1 Start tags
12.1.2.2 End tags
12.1.2.3 Attributes
12.1.2.4 Optional tags
12.1.2.5 Restrictions on content models
12.1.2.6 Restrictions on the contents of raw text and escapable raw text elements
12.1.3 Text
12.1.3.1 Newlines
12.1.4 Character references
12.1.5 CDATA sections
12.1.6 Comments
12.2 Parsing HTML documents
12.2.1 Overview of the parsing model
12.2.2 Parse errors
12.2.3 The input byte stream
12.2.3.1 Parsing with a known character encoding
12.2.3.2 Determining the character encoding
12.2.3.3 Character encodings
12.2.3.4 Changing the encoding while parsing
12.2.3.5 Preprocessing the input stream
12.2.4 Parse state
12.2.4.1 The insertion mode
12.2.4.2 The stack of open elements
12.2.4.3 The list of active formatting elements
12.2.4.4 The element pointers
12.2.4.5 Other parsing state flags
12.2.5 Tokenization
12.2.5.1 Data state
12.2.5.2 RCDATA state
12.2.5.3 RAWTEXT state
12.2.5.4 Script data state
12.2.5.5 PLAINTEXT state
12.2.5.6 Tag open state
12.2.5.7 End tag open state
12.2.5.8 Tag name state
12.2.5.9 RCDATA less-than sign state
12.2.5.10 RCDATA end tag open state
12.2.5.11 RCDATA end tag name state
12.2.5.12 RAWTEXT less-than sign state
12.2.5.13 RAWTEXT end tag open state
12.2.5.14 RAWTEXT end tag name state
12.2.5.15 Script data less-than sign state
12.2.5.16 Script data end tag open state
12.2.5.17 Script data end tag name state
12.2.5.18 Script data escape start state
12.2.5.19 Script data escape start dash state
12.2.5.20 Script data escaped state
12.2.5.21 Script data escaped dash state
12.2.5.22 Script data escaped dash dash state
12.2.5.23 Script data escaped less-than sign state
12.2.5.24 Script data escaped end tag open state
12.2.5.25 Script data escaped end tag name state
12.2.5.26 Script data double escape start state
12.2.5.27 Script data double escaped state
12.2.5.28 Script data double escaped dash state
12.2.5.29 Script data double escaped dash dash state
12.2.5.30 Script data double escaped less-than sign state
12.2.5.31 Script data double escape end state
12.2.5.32 Before attribute name state
12.2.5.33 Attribute name state
12.2.5.34 After attribute name state
12.2.5.35 Before attribute value state
12.2.5.36 Attribute value (double-quoted) state
12.2.5.37 Attribute value (single-quoted) state
12.2.5.38 Attribute value (unquoted) state
12.2.5.39 After attribute value (quoted) state
12.2.5.40 Self-closing start tag state
12.2.5.41 Bogus comment state
12.2.5.42 Markup declaration open state
12.2.5.43 Comment start state
12.2.5.44 Comment start dash state
12.2.5.45 Comment state
12.2.5.46 Comment less-than sign state
12.2.5.47 Comment less-than sign bang state
12.2.5.48 Comment less-than sign bang dash state
12.2.5.49 Comment less-than sign bang dash dash state
12.2.5.50 Comment end dash state
12.2.5.51 Comment end state
12.2.5.52 Comment end bang state
12.2.5.53 DOCTYPE state
12.2.5.54 Before DOCTYPE name state
12.2.5.55 DOCTYPE name state
12.2.5.56 After DOCTYPE name state
12.2.5.57 After DOCTYPE public keyword state
12.2.5.58 Before DOCTYPE public identifier state
12.2.5.59 DOCTYPE public identifier (double-quoted) state
12.2.5.60 DOCTYPE public identifier (single-quoted) state
12.2.5.61 After DOCTYPE public identifier state
12.2.5.62 Between DOCTYPE public and system identifiers state
12.2.5.63 After DOCTYPE system keyword state
12.2.5.64 Before DOCTYPE system identifier state
12.2.5.65 DOCTYPE system identifier (double-quoted) state
12.2.5.66 DOCTYPE system identifier (single-quoted) state
12.2.5.67 After DOCTYPE system identifier state
12.2.5.68 Bogus DOCTYPE state
12.2.5.69 CDATA section state
12.2.5.70 CDATA section bracket state
12.2.5.71 CDATA section end state
12.2.5.72 Character reference state
12.2.5.73 Named character reference state
12.2.5.74 Ambiguous ampersand state
12.2.5.75 Numeric character reference state
12.2.5.76 Hexademical character reference start state
12.2.5.77 Decimal character reference start state
12.2.5.78 Hexademical character reference state
12.2.5.79 Decimal character reference state
12.2.5.80 Numeric character reference end state
12.2.6 Tree construction
12.2.6.1 Creating and inserting nodes
12.2.6.2 Parsing elements that contain only text
12.2.6.3 Closing elements that have implied end tags
12.2.6.4 The rules for parsing tokens in HTML content
12.2.6.4.1 The "initial" insertion mode
12.2.6.4.2 The "before html" insertion mode
12.2.6.4.3 The "before head" insertion mode
12.2.6.4.4 The "in head" insertion mode
12.2.6.4.5 The "in head noscript" insertion mode
12.2.6.4.6 The "after head" insertion mode
12.2.6.4.7 The "in body" insertion mode
12.2.6.4.8 The "text" insertion mode
12.2.6.4.9 The "in table" insertion mode
12.2.6.4.10 The "in table text" insertion mode
12.2.6.4.11 The "in caption" insertion mode
12.2.6.4.12 The "in column group" insertion mode
12.2.6.4.13 The "in table body" insertion mode
12.2.6.4.14 The "in row" insertion mode
12.2.6.4.15 The "in cell" insertion mode
12.2.6.4.16 The "in select" insertion mode
12.2.6.4.17 The "in select in table" insertion mode
12.2.6.4.18 The "in template" insertion mode
12.2.6.4.19 The "after body" insertion mode
12.2.6.4.20 The "in frameset" insertion mode
12.2.6.4.21 The "after frameset" insertion mode
12.2.6.4.22 The "after after body" insertion mode
12.2.6.4.23 The "after after frameset" insertion mode
12.2.6.5 The rules for parsing tokens in foreign content
12.2.7 The end
12.2.8 Coercing an HTML DOM into an infoset
12.2.9 An introduction to error handling and strange cases in the parser
12.2.9.1 Misnested tags: <b><i></b></i>
12.2.9.2 Misnested tags: <b><p></b></p>
12.2.9.3 Unexpected markup in tables
12.2.9.4 Scripts that modify the page as it is being parsed
12.2.9.5 The execution of scripts that are moving across multiple documents
12.2.9.6 Unclosed formatting elements
12.3 Serializing HTML fragments
12.4 Parsing HTML fragments
12.5 Named character references
13 The XML syntax
13.1 Writing documents in the XML syntax
13.2 Parsing XML documents
13.3 Serializing XML fragments
13.4 Parsing XML fragments
14 Rendering
14.1 Introduction
14.2 The CSS user agent style sheet and presentational hints
14.3 Non-replaced elements
14.3.1 Hidden elements
14.3.2 The page
14.3.3 Flow content
14.3.4 Phrasing content
14.3.5 Bidirectional text
14.3.6 Quotes
14.3.7 Sections and headings
14.3.8 Lists
14.3.9 Tables
14.3.10 Margin collapsing quirks
14.3.11 Form controls
14.3.12 The hr element
14.3.13 The fieldset and legend elements
14.4 Replaced elements
14.4.1 Embedded content
14.4.2 Images
14.4.3 Attributes for embedded content and images
14.4.4 Image maps
14.5 Widgets
14.5.1 Introduction
14.5.2 The button element
14.5.3 The details and summary elements
14.5.4 The input element as a text entry widget
14.5.5 The input element as domain-specific widgets
14.5.6 The input element as a range control
14.5.7 The input element as a color well
14.5.8 The input element as a checkbox and radio button widgets
14.5.9 The input element as a file upload control
14.5.10 The input element as a button
14.5.11 The marquee element
14.5.12 The meter element
14.5.13 The progress element
14.5.14 The select element
14.5.15 The textarea element
14.6 Frames and framesets
14.7 Interactive media
14.7.1 Links, forms, and navigation
14.7.2 The title attribute
14.7.3 Editing hosts
14.7.4 Text rendered in native user interfaces
14.8 Print media
14.9 Unstyled XML documents
15 Obsolete features
15.1 Obsolete but conforming features
15.1.1 Warnings for obsolete but conforming features
15.2 Non-conforming features
15.3 Requirements for implementations
15.3.1 The marquee element
15.3.2 Frames
15.3.3 Other elements, attributes and APIs
16 IANA considerations
16.1 text/html
16.2 multipart/x-mixed-replace
16.3 application/xhtml+xml
16.4 text/cache-manifest
16.5 text/ping
16.6 application/microdata+json
16.7 text/event-stream
16.8 `Ping-From`
16.9 `Ping-To`
16.10 `Refresh`
16.11 `Last-Event-ID`
16.12 web+ scheme prefix
Index
Elements
Element content categories
Attributes
Element Interfaces
All Interfaces
Events
MIME Types
References
Acknowledgments
1 Introduction

Spec bugs: 23036

1.1 Where does this specification fit?
This specification defines a big part of the Web platform, in lots of detail. Its place in the Web platform specification stack relative to other specifications can be best summed up as follows:

CSS SVG MathML NPAPI
Geo Fetch CSP
JPEG GIF PNG
THIS SPECIFICATION
HTTP TLS MQ DOM Unicode Web IDL
MIME URL XML JavaScript Encodings
1.2 Is this HTML5?
This section is non-normative.

In short: Yes.

In more length: the term "HTML5" is widely used as a buzzword to refer to modern Web technologies, many of which (though by no means all) are developed at the WHATWG. This document is one such; others are available from the WHATWG specification index.

Although we have asked them to stop doing so, the W3C also republishes some parts of this specification as separate documents.

1.3 Background
This section is non-normative.

HTML is the World Wide Web's core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents. Its general design, however, has enabled it to be adapted, over the subsequent years, to describe a number of other types of documents and even applications.

1.4 Audience
This section is non-normative.

This specification is intended for authors of documents and scripts that use the features defined in this specification, implementers of tools that operate on pages that use the features defined in this specification, and individuals wishing to establish the correctness of documents or implementations with respect to the requirements of this specification.

This document is probably not suited to readers who do not already have at least a passing familiarity with Web technologies, as in places it sacrifices clarity for precision, and brevity for completeness. More approachable tutorials and authoring guides can provide a gentler introduction to the topic.

In particular, familiarity with the basics of DOM is necessary for a complete understanding of some of the more technical parts of this specification. An understanding of Web IDL, HTTP, XML, Unicode, character encodings, JavaScript, and CSS will also be helpful in places but is not essential.

1.5 Scope
This section is non-normative.

This specification is limited to providing a semantic-level markup language and associated semantic-level scripting APIs for authoring accessible pages on the Web ranging from static documents to dynamic applications.

The scope of this specification does not include providing mechanisms for media-specific customization of presentation (although default rendering rules for Web browsers are included at the end of this specification, and several mechanisms for hooking into CSS are provided as part of the language).

The scope of this specification is not to describe an entire operating system. In particular, hardware configuration software, image manipulation tools, and applications that users would be expected to use with high-end workstations on a daily basis are out of scope. In terms of applications, this specification is targeted specifically at applications that would be expected to be used by users on an occasional basis, or regularly but from disparate locations, with low CPU requirements. Examples of such applications include online purchasing systems, searching systems, games (especially multiplayer online games), public telephone books or address books, communications software (e-mail clients, instant messaging clients, discussion software), document editing software, etc.

1.6 History
This section is non-normative.

For its first five years (1990-1995), HTML went through a number of revisions and experienced a number of extensions, primarily hosted first at CERN, and then at the IETF.

With the creation of the W3C, HTML's development changed venue again. A first abortive attempt at extending HTML in 1995 known as HTML 3.0 then made way to a more pragmatic approach known as HTML 3.2, which was completed in 1997. HTML4 quickly followed later that same year.

The following year, the W3C membership decided to stop evolving HTML and instead begin work on an XML-based equivalent, called XHTML. This effort started with a reformulation of HTML4 in XML, known as XHTML 1.0, which added no new features except the new serialization, and which was completed in 2000. After XHTML 1.0, the W3C's focus turned to making it easier for other working groups to extend XHTML, under the banner of XHTML Modularization. In parallel with this, the W3C also worked on a new language that was not compatible with the earlier HTML and XHTML languages, calling it XHTML2.

Around the time that HTML's evolution was stopped in 1998, parts of the API for HTML developed by browser vendors were specified and published under the name DOM Level 1 (in 1998) and DOM Level 2 Core and DOM Level 2 HTML (starting in 2000 and culminating in 2003). These efforts then petered out, with some DOM Level 3 specifications published in 2004 but the working group being closed before all the Level 3 drafts were completed.

In 2003, the publication of XForms, a technology which was positioned as the next generation of Web forms, sparked a renewed interest in evolving HTML itself, rather than finding replacements for it. This interest was borne from the realization that XML's deployment as a Web technology was limited to entirely new technologies (like RSS and later Atom), rather than as a replacement for existing deployed technologies (like HTML).

A proof of concept to show that it was possible to extend HTML4's forms to provide many of the features that XForms 1.0 introduced, without requiring browsers to implement rendering engines that were incompatible with existing HTML Web pages, was the first result of this renewed interest. At this early stage, while the draft was already publicly available, and input was already being solicited from all sources, the specification was only under Opera Software's copyright.

The idea that HTML's evolution should be reopened was tested at a W3C workshop in 2004, where some of the principles that underlie the HTML5 work (described below), as well as the aforementioned early draft proposal covering just forms-related features, were presented to the W3C jointly by Mozilla and Opera. The proposal was rejected on the grounds that the proposal conflicted with the previously chosen direction for the Web's evolution; the W3C staff and membership voted to continue developing XML-based replacements instead.

Shortly thereafter, Apple, Mozilla, and Opera jointly announced their intent to continue working on the effort under the umbrella of a new venue called the WHATWG. A public mailing list was created, and the draft was moved to the WHATWG site. The copyright was subsequently amended to be jointly owned by all three vendors, and to allow reuse of the specification.

The WHATWG was based on several core principles, in particular that technologies need to be backwards compatible, that specifications and implementations need to match even if this means changing the specification rather than the implementations, and that specifications need to be detailed enough that implementations can achieve complete interoperability without reverse-engineering each other.

The latter requirement in particular required that the scope of the HTML5 specification include what had previously been specified in three separate documents: HTML4, XHTML1, and DOM2 HTML. It also meant including significantly more detail than had previously been considered the norm.

In 2006, the W3C indicated an interest to participate in the development of HTML5 after all, and in 2007 formed a working group chartered to work with the WHATWG on the development of the HTML5 specification. Apple, Mozilla, and Opera allowed the W3C to publish the specification under the W3C copyright, while keeping a version with the less restrictive license on the WHATWG site.

For a number of years, both groups then worked together. In 2011, however, the groups came to the conclusion that they had different goals: the W3C wanted to publish a "finished" version of "HTML5", while the WHATWG wanted to continue working on a Living Standard for HTML, continuously maintaining the specification rather than freezing it in a state with known problems, and adding new features as needed to evolve the platform.

Since then, the WHATWG has been working on this specification (amongst others), and the W3C has been copying fixes made by the WHATWG into their fork of the document (which also has other changes).

1.7 Design notes
This section is non-normative.

It must be admitted that many aspects of HTML appear at first glance to be nonsensical and inconsistent.

HTML, its supporting DOM APIs, as well as many of its supporting technologies, have been developed over a period of several decades by a wide array of people with different priorities who, in many cases, did not know of each other's existence.

Features have thus arisen from many sources, and have not always been designed in especially consistent ways. Furthermore, because of the unique characteristics of the Web, implementation bugs have often become de-facto, and now de-jure, standards, as content is often unintentionally written in ways that rely on them before they can be fixed.

Despite all this, efforts have been made to adhere to certain design goals. These are described in the next few subsections.

1.7.1 Serializability of script execution
This section is non-normative.

To avoid exposing Web authors to the complexities of multithreading, the HTML and DOM APIs are designed such that no script can ever detect the simultaneous execution of other scripts. Even with workers, the intent is that the behavior of implementations can be thought of as completely serializing the execution of all scripts in all browsing contexts.

The exception to this general design principle is the JavaScript SharedArrayBuffer class. Using SharedArrayBuffer objects, it can in fact be observed that scripts in other agents are executing simultaneously. Furthermore, due to the JavaScript memory model, there are situations which not only are un-representable via serialized script execution, but also un-representable via serialized statement execution among those scripts.

1.7.2 Compliance with other specifications
This section is non-normative.

This specification interacts with and relies on a wide variety of other specifications. In certain circumstances, unfortunately, conflicting needs have led to this specification violating the requirements of these other specifications. Whenever this has occurred, the transgressions have each been noted as a "willful violation", and the reason for the violation has been noted.

1.7.3 Extensibility
This section is non-normative.

HTML has a wide array of extensibility mechanisms that can be used for adding semantics in a safe manner:

Authors can use the class attribute to extend elements, effectively creating their own elements, while using the most applicable existing "real" HTML element, so that browsers and other tools that don't know of the extension can still support it somewhat well. This is the tack used by microformats, for example.

Authors can include data for inline client-side scripts or server-side site-wide scripts to process using the data-*="" attributes. These are guaranteed to never be touched by browsers, and allow scripts to include data on HTML elements that scripts can then look for and process.

Authors can use the <meta name="" content=""> mechanism to include page-wide metadata.

Authors can use the rel="" mechanism to annotate links with specific meanings by registering extensions to the predefined set of link types. This is also used by microformats.

Authors can embed raw data using the <script type=""> mechanism with a custom type, for further handling by inline or server-side scripts.

Authors can create plugins and invoke them using the embed element. This is how Flash works.

Authors can extend APIs using the JavaScript prototyping mechanism. This is widely used by script libraries, for instance.

Authors can use the microdata feature (the itemscope="" and itemprop="" attributes) to embed nested name-value pairs of data to be shared with other applications and sites.

1.8 HTML vs XML syntax
This section is non-normative.

This specification defines an abstract language for describing documents and applications, and some APIs for interacting with in-memory representations of resources that use this language.

The in-memory representation is known as "DOM HTML", or "the DOM" for short.

There are various concrete syntaxes that can be used to transmit resources that use this abstract language, two of which are defined in this specification.

The first such concrete syntax is the HTML syntax. This is the format suggested for most authors. It is compatible with most legacy Web browsers. If a document is transmitted with the text/html MIME type, then it will be processed as an HTML document by Web browsers. This specification defines the latest HTML syntax, known simply as "HTML".

The second concrete syntax is XML. When a document is transmitted with an XML MIME type, such as application/xhtml+xml, then it is treated as an XML document by Web browsers, to be parsed by an XML processor. Authors are reminded that the processing for XML and HTML differs; in particular, even minor syntax errors will prevent a document labeled as XML from being rendered fully, whereas they would be ignored in the HTML syntax.

The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons, because no such term is used for the HTML syntaxes of MathML and SVG).

The DOM, the HTML syntax, and the XML syntax cannot all represent the same content. For example, namespaces cannot be represented using the HTML syntax, but they are supported in the DOM and in the XML syntax. Similarly, documents that use the noscript feature can be represented using the HTML syntax, but cannot be represented with the DOM or in the XML syntax. Comments that contain the string "-->" can only be represented in the DOM, not in the HTML and XML syntaxes.

1.9 Structure of this specification
This section is non-normative.

This specification is divided into the following major sections:

Introduction
Non-normative materials providing a context for the HTML standard.
Common infrastructure
The conformance classes, algorithms, definitions, and the common underpinnings of the rest of the specification.
Semantics, structure, and APIs of HTML documents
Documents are built from elements. These elements form a tree using the DOM. This section defines the features of this DOM, as well as introducing the features common to all elements, and the concepts used in defining elements.
The elements of HTML
Each element has a predefined meaning, which is explained in this section. Rules for authors on how to use the element, along with user agent requirements for how to handle each element, are also given. This includes large signature features of HTML such as video playback and subtitles, form controls and form submission, and a 2D graphics API known as the HTML canvas.
Microdata
This specification introduces a mechanism for adding machine-readable annotations to documents, so that tools can extract trees of name-value pairs from the document. This section describes this mechanism and some algorithms that can be used to convert HTML documents into other formats. This section also defines some sample Microdata vocabularies for contact information, calendar events, and licensing works.
User interaction
HTML documents can provide a number of mechanisms for users to interact with and modify content, which are described in this section, such as how focus works, and drag-and-drop.
Loading Web pages
HTML documents do not exist in a vacuum — this section defines many of the features that affect environments that deal with multiple pages, such as Web browsers and offline caching of Web applications.
Web application APIs
This section introduces basic features for scripting of applications in HTML.
Web workers
This section defines an API for background threads in JavaScript.
The communication APIs
This section describes some mechanisms that applications written in HTML can use to communicate with other applications from different domains running on the same client. It also introduces a server-push event stream mechanism known as Server Sent Events or EventSource, and a two-way full-duplex socket protocol for scripts known as Web Sockets.
Web storage
This section defines a client-side storage mechanism based on name-value pairs.
The HTML syntax
The XML syntax
All of these features would be for naught if they couldn't be represented in a serialized form and sent to other people, and so these sections define the syntaxes of HTML and XML, along with rules for how to parse content using those syntaxes.
Rendering
This section defines the default rendering rules for Web browsers.
There are also some appendices, listing obsolete features and IANA considerations, and several indices.

1.9.1 How to read this specification
This specification should be read like all other specifications. First, it should be read cover-to-cover, multiple times. Then, it should be read backwards at least once. Then it should be read by picking random sections from the contents list and following all the cross-references.

As described in the conformance requirements section below, this specification describes conformance criteria for a variety of conformance classes. In particular, there are conformance requirements that apply to producers, for example authors and the documents they create, and there are conformance requirements that apply to consumers, for example Web browsers. They can be distinguished by what they are requiring: a requirement on a producer states what is allowed, while a requirement on a consumer states how software is to act.

For example, "the foo attribute's value must be a valid integer" is a requirement on producers, as it lays out the allowed values; in contrast, the requirement "the foo attribute's value must be parsed using the rules for parsing integers" is a requirement on consumers, as it describes how to process the content.

Requirements on producers have no bearing whatsoever on consumers.

Continuing the above example, a requirement stating that a particular attribute's value is constrained to being a valid integer emphatically does not imply anything about the requirements on consumers. It might be that the consumers are in fact required to treat the attribute as an opaque string, completely unaffected by whether the value conforms to the requirements or not. It might be (as in the previous example) that the consumers are required to parse the value using specific rules that define how invalid (non-numeric in this case) values are to be processed.

1.9.2 Typographic conventions
This is a definition, requirement, or explanation.

This is a note.

This is an example.

This is an open issue.

This is a warning.

[Exposed=Window]
interface Example {
  // this is an IDL definition
};
variable = object . method( [ optionalArgument ] )
This is a note to authors describing the usage of an interface.

/* this is a CSS fragment */
The defining instance of a term is marked up like this. Uses of that term are marked up like this or like this.

The defining instance of an element, attribute, or API is marked up like this. References to that element, attribute, or API are marked up like this.

Other code fragments are marked up like this.

Variables are marked up like this.

In an algorithm, steps in synchronous sections are marked with ⌛.

In some cases, requirements are given in the form of lists with conditions and corresponding requirements. In such cases, the requirements that apply to a condition are always the first set of requirements that follow the condition, even in the case of there being multiple sets of conditions for those requirements. Such cases are presented as follows:

This is a condition
This is another condition
This is the requirement that applies to the conditions above.
This is a third condition
This is the requirement that applies to the third condition.
1.10 Privacy concerns
This section is non-normative.

Some features of HTML trade user convenience for a measure of user privacy.

In general, due to the Internet's architecture, a user can be distinguished from another by the user's IP address. IP addresses do not perfectly match to a user; as a user moves from device to device, or from network to network, their IP address will change; similarly, NAT routing, proxy servers, and shared computers enable packets that appear to all come from a single IP address to actually map to multiple users. Technologies such as onion routing can be used to further anonymize requests so that requests from a single user at one node on the Internet appear to come from many disparate parts of the network.

However, the IP address used for a user's requests is not the only mechanism by which a user's requests could be related to each other. Cookies, for example, are designed specifically to enable this, and are the basis of most of the Web's session features that enable you to log into a site with which you have an account.

There are other mechanisms that are more subtle. Certain characteristics of a user's system can be used to distinguish groups of users from each other; by collecting enough such information, an individual user's browser's "digital fingerprint" can be computed, which can be as good as, if not better than, an IP address in ascertaining which requests are from the same user.

Grouping requests in this manner, especially across multiple sites, can be used for both benign (and even arguably positive) purposes, as well as for malevolent purposes. An example of a reasonably benign purpose would be determining whether a particular person seems to prefer sites with dog illustrations as opposed to sites with cat illustrations (based on how often they visit the sites in question) and then automatically using the preferred illustrations on subsequent visits to participating sites. Malevolent purposes, however, could include governments combining information such as the person's home address (determined from the addresses they use when getting driving directions on one site) with their apparent political affiliations (determined by examining the forum sites that they participate in) to determine whether the person should be prevented from voting in an election.

Since the malevolent purposes can be remarkably evil, user agent implementers are encouraged to consider how to provide their users with tools to minimize leaking information that could be used to fingerprint a user.

Unfortunately, as the first paragraph in this section implies, sometimes there is great benefit to be derived from exposing the very information that can also be used for fingerprinting purposes, so it's not as easy as simply blocking all possible leaks. For instance, the ability to log into a site to post under a specific identity requires that the user's requests be identifiable as all being from the same user, more or less by definition. More subtly, though, information such as how wide text is, which is necessary for many effects that involve drawing text onto a canvas (e.g. any effect that involves drawing a border around the text) also leaks information that can be used to group a user's requests. (In this case, by potentially exposing, via a brute force search, which fonts a user has installed, information which can vary considerably from user to user.)

Features in this specification which can be used to fingerprint the user are marked as this paragraph is.
Other features in the platform can be used for the same purpose, though, including, though not limited to:

The exact list of which features a user agents supports.
The maximum allowed stack depth for recursion in script.
Features that describe the user's environment, like Media Queries and the Screen object. [MQ] [CSSOMVIEW]
The user's time zone.
1.10.1 Cross-site communication
The postMessage() API provides a mechanism by which two sites can communicate directly. At first glance, this might appear to open a new way by which the problems described above can occur. However, in practice, multiple mechanisms exist by which two sites can communicate that predate this API: a site embedding another can send data via an iframe element's dimensions; a site can use a cross-site image request with a unique identifier known to the server to initiate a server-side data exchange; or indeed the fingerprinting techniques described above can be used by two sites to uniquely identify a visitor such that information can then be exchanged on the server side.

Fundamentally, users that do not trust a site to treat their information with respect have to avoid visiting that site at all.

1.11 A quick introduction to HTML
This section is non-normative.

A basic HTML document looks like this:

<!DOCTYPE html>
<html lang="en">
 <head>
  <title>Sample page</title>
 </head>
 <body>
  <h1>Sample page</h1>
  <p>This is a <a href="demo.html">simple</a> sample.</p>
  <!-- this is a comment -->
 </body>
</html>
HTML documents consist of a tree of elements and text. Each element is denoted in the source by a start tag, such as "<body>", and an end tag, such as "</body>". (Certain start tags and end tags can in certain cases be omitted and are implied by other tags.)

Tags have to be nested such that elements are all completely within each other, without overlapping:

<p>This is <em>very <strong>wrong</em>!</strong></p>
<p>This <em>is <strong>correct</strong>.</em></p>
This specification defines a set of elements that can be used in HTML, along with rules about the ways in which the elements can be nested.

Elements can have attributes, which control how the elements work. In the example below, there is a hyperlink, formed using the a element and its href attribute:

<a href="demo.html">simple</a>
Attributes are placed inside the start tag, and consist of a name and a value, separated by an "=" character. The attribute value can remain unquoted if it doesn't contain ASCII whitespace or any of " ' ` = < or >. Otherwise, it has to be quoted using either single or double quotes. The value, along with the "=" character, can be omitted altogether if the value is the empty string.

<!-- empty attributes -->
<input name=address disabled>
<input name=address disabled="">

<!-- attributes with a value -->
<input name=address maxlength=200>
<input name=address maxlength='200'>
<input name=address maxlength="200">
HTML user agents (e.g. Web browsers) then parse this markup, turning it into a DOM (Document Object Model) tree. A DOM tree is an in-memory representation of a document.

DOM trees contain several kinds of nodes, in particular a DocumentType node, Element nodes, Text nodes, Comment nodes, and in some cases ProcessingInstruction nodes.

The markup snippet at the top of this section would be turned into the following DOM tree:

DOCTYPE: html
html lang="en"
head
#text: ⏎␣␣
title
#text: Sample page
#text: ⏎␣
#text: ⏎␣
body
#text: ⏎␣␣
h1
#text: Sample page
#text: ⏎␣␣
p
#text: This is a
a href="demo.html"
#text: simple
#text: sample.
#text: ⏎␣␣
#comment: this is a comment
#text: ⏎␣⏎
The document element of this tree is the html element, which is the element always found in that position in HTML documents. It contains two elements, head and body, as well as a Text node between them.

There are many more Text nodes in the DOM tree than one would initially expect, because the source contains a number of spaces (represented here by "␣") and line breaks ("⏎") that all end up as Text nodes in the DOM. However, for historical reasons not all of the spaces and line breaks in the original markup appear in the DOM. In particular, all the whitespace before head start tag ends up being dropped silently, and all the whitespace after the body end tag ends up placed at the end of the body.

The head element contains a title element, which itself contains a Text node with the text "Sample page". Similarly, the body element contains an h1 element, a p element, and a comment.

This DOM tree can be manipulated from scripts in the page. Scripts (typically in JavaScript) are small programs that can be embedded using the script element or using event handler content attributes. For example, here is a form with a script that sets the value of the form's output element to say "Hello World":

<form name="main">
 Result: <output name="result"></output>
 <script>
  document.forms.main.elements.result.value = 'Hello World';
 </script>
</form>
Each element in the DOM tree is represented by an object, and these objects have APIs so that they can be manipulated. For instance, a link (e.g. the a element in the tree above) can have its "href" attribute changed in several ways:

var a = document.links[0]; // obtain the first link in the document
a.href = 'sample.html'; // change the destination URL of the link
a.protocol = 'https'; // change just the scheme part of the URL
a.setAttribute('href', 'https://example.com/'); // change the content attribute directly
Since DOM trees are used as the way to represent HTML documents when they are processed and presented by implementations (especially interactive implementations like Web browsers), this specification is mostly phrased in terms of DOM trees, instead of the markup described above.

HTML documents represent a media-independent description of interactive content. HTML documents might be rendered to a screen, or through a speech synthesizer, or on a braille display. To influence exactly how such rendering takes place, authors can use a styling language such as CSS.

In the following example, the page has been made yellow-on-blue using CSS.

<!DOCTYPE html>
<html lang="en">
 <head>
  <title>Sample styled page</title>
  <style>
   body { background: navy; color: yellow; }
  </style>
 </head>
 <body>
  <h1>Sample styled page</h1>
  <p>This page is just a demo.</p>
 </body>
</html>
For more details on how to use HTML, authors are encouraged to consult tutorials and guides. Some of the examples included in this specification might also be of use, but the novice author is cautioned that this specification, by necessity, defines the language with a level of detail that might be difficult to understand at first.

1.11.1 Writing secure applications with HTML
This section is non-normative.

When HTML is used to create interactive sites, care needs to be taken to avoid introducing vulnerabilities through which attackers can compromise the integrity of the site itself or of the site's users.

A comprehensive study of this matter is beyond the scope of this document, and authors are strongly encouraged to study the matter in more detail. However, this section attempts to provide a quick introduction to some common pitfalls in HTML application development.

The security model of the Web is based on the concept of "origins", and correspondingly many of the potential attacks on the Web involve cross-origin actions. [ORIGIN]

Not validating user input
Cross-site scripting (XSS)
SQL injection
When accepting untrusted input, e.g. user-generated content such as text comments, values in URL parameters, messages from third-party sites, etc, it is imperative that the data be validated before use, and properly escaped when displayed. Failing to do this can allow a hostile user to perform a variety of attacks, ranging from the potentially benign, such as providing bogus user information like a negative age, to the serious, such as running scripts every time a user looks at a page that includes the information, potentially propagating the attack in the process, to the catastrophic, such as deleting all data in the server.

When writing filters to validate user input, it is imperative that filters always be safelist-based, allowing known-safe constructs and disallowing all other input. Blocklist-based filters that disallow known-bad inputs and allow everything else are not secure, as not everything that is bad is yet known (for example, because it might be invented in the future).

For example, suppose a page looked at its URL's query string to determine what to display, and the site then redirected the user to that page to display a message, as in:

<ul>
 <li><a href="message.cgi?say=Hello">Say Hello</a>
 <li><a href="message.cgi?say=Welcome">Say Welcome</a>
 <li><a href="message.cgi?say=Kittens">Say Kittens</a>
</ul>
If the message was just displayed to the user without escaping, a hostile attacker could then craft a URL that contained a script element:

https://example.com/message.cgi?say=%3Cscript%3Ealert%28%27Oh%20no%21%27%29%3C/script%3E
If the attacker then convinced a victim user to visit this page, a script of the attacker's choosing would run on the page. Such a script could do any number of hostile actions, limited only by what the site offers: if the site is an e-commerce shop, for instance, such a script could cause the user to unknowingly make arbitrarily many unwanted purchases.

This is called a cross-site scripting attack.

There are many constructs that can be used to try to trick a site into executing code. Here are some that authors are encouraged to consider when writing safelist filters:

When allowing harmless-seeming elements like img, it is important to safelist any provided attributes as well. If one allowed all attributes then an attacker could, for instance, use the onload attribute to run arbitrary script.
When allowing URLs to be provided (e.g. for links), the scheme of each URL also needs to be explicitly safelisted, as there are many schemes that can be abused. The most prominent example is "javascript:", but user agents can implement (and indeed, have historically implemented) others.
Allowing a base element to be inserted means any script elements in the page with relative links can be hijacked, and similarly that any form submissions can get redirected to a hostile site.
Cross-site request forgery (CSRF)
If a site allows a user to make form submissions with user-specific side-effects, for example posting messages on a forum under the user's name, making purchases, or applying for a passport, it is important to verify that the request was made by the user intentionally, rather than by another site tricking the user into making the request unknowingly.

This problem exists because HTML forms can be submitted to other origins.

Sites can prevent such attacks by populating forms with user-specific hidden tokens, or by checking `Origin` headers on all requests.

Clickjacking
A page that provides users with an interface to perform actions that the user might not wish to perform needs to be designed so as to avoid the possibility that users can be tricked into activating the interface.

One way that a user could be so tricked is if a hostile site places the victim site in a small iframe and then convinces the user to click, for instance by having the user play a reaction game. Once the user is playing the game, the hostile site can quickly position the iframe under the mouse cursor just as the user is about to click, thus tricking the user into clicking the victim site's interface.

To avoid this, sites that do not expect to be used in frames are encouraged to only enable their interface if they detect that they are not in a frame (e.g. by comparing the window object to the value of the top attribute).

1.11.2 Common pitfalls to avoid when using the scripting APIs
This section is non-normative.

Scripts in HTML have "run-to-completion" semantics, meaning that the browser will generally run the script uninterrupted before doing anything else, such as firing further events or continuing to parse the document.

On the other hand, parsing of HTML files happens incrementally, meaning that the parser can pause at any point to let scripts run. This is generally a good thing, but it does mean that authors need to be careful to avoid hooking event handlers after the events could have possibly fired.

There are two techniques for doing this reliably: use event handler content attributes, or create the element and add the event handlers in the same script. The latter is safe because, as mentioned earlier, scripts are run to completion before further events can fire.

One way this could manifest itself is with img elements and the load event. The event could fire as soon as the element has been parsed, especially if the image has already been cached (which is common).

Here, the author uses the onload handler on an img element to catch the load event:

<img src="games.png" alt="Games" onload="gamesLogoHasLoaded(event)">
If the element is being added by script, then so long as the event handlers are added in the same script, the event will still not be missed:

<script>
 var img = new Image();
 img.src = 'games.png';
 img.alt = 'Games';
 img.onload = gamesLogoHasLoaded;
 // img.addEventListener('load', gamesLogoHasLoaded, false); // would work also
</script>
However, if the author first created the img element and then in a separate script added the event listeners, there's a chance that the load event would be fired in between, leading it to be missed:

<!-- Do not use this style, it has a race condition! -->
 <img id="games" src="games.png" alt="Games">
 <!-- the 'load' event might fire here while the parser is taking a
      break, in which case you will not see it! -->
 <script>
  var img = document.getElementById('games');
  img.onload = gamesLogoHasLoaded; // might never fire!
 </script>
1.11.3 How to catch mistakes when writing HTML: validators and conformance checkers
This section is non-normative.

Authors are encouraged to make use of conformance checkers (also known as validators) to catch common mistakes. The WHATWG maintains a list of such tools at: https://whatwg.org/validator/

1.12 Conformance requirements for authors
This section is non-normative.

Unlike previous versions of the HTML specification, this specification defines in some detail the required processing for invalid documents as well as valid documents.

However, even though the processing of invalid content is in most cases well-defined, conformance requirements for documents are still important: in practice, interoperability (the situation in which all implementations process particular content in a reliable and identical or equivalent way) is not the only goal of document conformance requirements. This section details some of the more common reasons for still distinguishing between a conforming document and one with errors.

1.12.1 Presentational markup
This section is non-normative.

The majority of presentational features from previous versions of HTML are no longer allowed. Presentational markup in general has been found to have a number of problems:

The use of presentational elements leads to poorer accessibility
While it is possible to use presentational markup in a way that provides users of assistive technologies (ATs) with an acceptable experience (e.g. using ARIA), doing so is significantly more difficult than doing so when using semantically-appropriate markup. Furthermore, even using such techniques doesn't help make pages accessible for non-AT non-graphical users, such as users of text-mode browsers.

Using media-independent markup, on the other hand, provides an easy way for documents to be authored in such a way that they work for more users (e.g. users of text browsers).

Higher cost of maintenance
It is significantly easier to maintain a site written in such a way that the markup is style-independent. For example, changing the color of a site that uses <font color=""> throughout requires changes across the entire site, whereas a similar change to a site based on CSS can be done by changing a single file.

Larger document sizes
Presentational markup tends to be much more redundant, and thus results in larger document sizes.

For those reasons, presentational markup has been removed from HTML in this version. This change should not come as a surprise; HTML4 deprecated presentational markup many years ago and provided a mode (HTML4 Transitional) to help authors move away from presentational markup; later, XHTML 1.1 went further and obsoleted those features altogether.

The only remaining presentational markup features in HTML are the style attribute and the style element. Use of the style attribute is somewhat discouraged in production environments, but it can be useful for rapid prototyping (where its rules can be directly moved into a separate style sheet later) and for providing specific styles in unusual cases where a separate style sheet would be inconvenient. Similarly, the style element can be useful in syndication or for page-specific styles, but in general an external style sheet is likely to be more convenient when the styles apply to multiple pages.

It is also worth noting that some elements that were previously presentational have been redefined in this specification to be media-independent: b, i, hr, s, small, and u.

1.12.2 Syntax errors
This section is non-normative.

The syntax of HTML is constrained to avoid a wide variety of problems.

Unintuitive error-handling behavior
Certain invalid syntax constructs, when parsed, result in DOM trees that are highly unintuitive.

For example, the following markup fragment results in a DOM with an hr element that is an earlier sibling of the corresponding table element:

<table><hr>...
Errors with optional error recovery
To allow user agents to be used in controlled environments without having to implement the more bizarre and convoluted error handling rules, user agents are permitted to fail whenever encountering a parse error.

Errors where the error-handling behavior is not compatible with streaming user agents
Some error-handling behavior, such as the behavior for the <table><hr>... example mentioned above, are incompatible with streaming user agents (user agents that process HTML files in one pass, without storing state). To avoid interoperability problems with such user agents, any syntax resulting in such behavior is considered invalid.

Errors that can result in infoset coercion
When a user agent based on XML is connected to an HTML parser, it is possible that certain invariants that XML enforces, such as element or attribute names never contain multiple colons, will be violated by an HTML file. Handling this can require that the parser coerce the HTML DOM into an XML-compatible infoset. Most syntax constructs that require such handling are considered invalid. (Comments containing two consecutive hyphens, or ending with a hyphen, are exceptions that are allowed in the HTML syntax.)

Errors that result in disproportionately poor performance
Certain syntax constructs can result in disproportionately poor performance. To discourage the use of such constructs, they are typically made non-conforming.

For example, the following markup results in poor performance, since all the unclosed i elements have to be reconstructed in each paragraph, resulting in progressively more elements in each paragraph:

<p><i>She dreamt.
<p><i>She dreamt that she ate breakfast.
<p><i>Then lunch.
<p><i>And finally dinner.
The resulting DOM for this fragment would be:

p
i
#text: She dreamt.
p
i
i
#text: She dreamt that she ate breakfast.
p
i
i
i
#text: Then lunch.
p
i
i
i
i
#text: And finally dinner.
Errors involving fragile syntax constructs
There are syntax constructs that, for historical reasons, are relatively fragile. To help reduce the number of users who accidentally run into such problems, they are made non-conforming.

For example, the parsing of certain named character references in attributes happens even with the closing semicolon being omitted. It is safe to include an ampersand followed by letters that do not form a named character reference, but if the letters are changed to a string that does form a named character reference, they will be interpreted as that character instead.

In this fragment, the attribute's value is "?bill&ted":

<a href="?bill&ted">Bill and Ted</a>
In the following fragment, however, the attribute's value is actually "?art©", not the intended "?art&copy", because even without the final semicolon, "&copy" is handled the same as "&copy;" and thus gets interpreted as "©":

<a href="?art&copy">Art and Copy</a>
To avoid this problem, all named character references are required to end with a semicolon, and uses of named character references without a semicolon are flagged as errors.

Thus, the correct way to express the above cases is as follows:

<a href="?bill&ted">Bill and Ted</a> <!-- &ted is ok, since it's not a named character reference -->
<a href="?art&amp;copy">Art and Copy</a> <!-- the & has to be escaped, since &copy is a named character reference -->
Errors involving known interoperability problems in legacy user agents
Certain syntax constructs are known to cause especially subtle or serious problems in legacy user agents, and are therefore marked as non-conforming to help authors avoid them.

For example, this is why the U+0060 GRAVE ACCENT character (`) is not allowed in unquoted attributes. In certain legacy user agents, it is sometimes treated as a quote character.

Another example of this is the DOCTYPE, which is required to trigger no-quirks mode, because the behavior of legacy user agents in quirks mode is often largely undocumented.

Errors that risk exposing authors to security attacks
Certain restrictions exist purely to avoid known security problems.

For example, the restriction on using UTF-7 exists purely to avoid authors falling prey to a known cross-site-scripting attack using UTF-7. [UTF7]

Cases where the author's intent is unclear
Markup where the author's intent is very unclear is often made non-conforming. Correcting these errors early makes later maintenance easier.

For example, it is unclear whether the author intended the following to be an h1 heading or an h2 heading:

<h1>Contact details</h2>
Cases that are likely to be typos
When a user makes a simple typo, it is helpful if the error can be caught early, as this can save the author a lot of debugging time. This specification therefore usually considers it an error to use element names, attribute names, and so forth, that do not match the names defined in this specification.

For example, if the author typed <capton> instead of <caption>, this would be flagged as an error and the author could correct the typo immediately.

Errors that could interfere with new syntax in the future
In order to allow the language syntax to be extended in the future, certain otherwise harmless features are disallowed.

For example, "attributes" in end tags are ignored currently, but they are invalid, in case a future change to the language makes use of that syntax feature without conflicting with already-deployed (and valid!) content.

Some authors find it helpful to be in the practice of always quoting all attributes and always including all optional tags, preferring the consistency derived from such custom over the minor benefits of terseness afforded by making use of the flexibility of the HTML syntax. To aid such authors, conformance checkers can provide modes of operation wherein such conventions are enforced.

1.12.3 Restrictions on content models and on attribute values
This section is non-normative.

Beyond the syntax of the language, this specification also places restrictions on how elements and attributes can be specified. These restrictions are present for similar reasons:

Errors involving content with dubious semantics
To avoid misuse of elements with defined meanings, content models are defined that restrict how elements can be nested when such nestings would be of dubious value.

For example, this specification disallows nesting a section element inside a kbd element, since it is highly unlikely for an author to indicate that an entire section should be keyed in.

Errors that involve a conflict in expressed semantics
Similarly, to draw the author's attention to mistakes in the use of elements, clear contradictions in the semantics expressed are also considered conformance errors.

In the fragments below, for example, the semantics are nonsensical: a separator cannot simultaneously be a cell, nor can a radio button be a progress bar.

<hr role="cell">
<input type=radio role=progressbar>
Another example is the restrictions on the content models of the ul element, which only allows li element children. Lists by definition consist just of zero or more list items, so if a ul element contains something other than an li element, it's not clear what was meant.

Cases where the default styles are likely to lead to confusion
Certain elements have default styles or behaviors that make certain combinations likely to lead to confusion. Where these have equivalent alternatives without this problem, the confusing combinations are disallowed.

For example, div elements are rendered as block boxes, and span elements as inline boxes. Putting a block box in an inline box is unnecessarily confusing; since either nesting just div elements, or nesting just span elements, or nesting span elements inside div elements all serve the same purpose as nesting a div element in a span element, but only the latter involves a block box in an inline box, the latter combination is disallowed.

Another example would be the way interactive content cannot be nested. For example, a button element cannot contain a textarea element. This is because the default behavior of such nesting interactive elements would be highly confusing to users. Instead of nesting these elements, they can be placed side by side.

Errors that indicate a likely misunderstanding of the specification
Sometimes, something is disallowed because allowing it would likely cause author confusion.

For example, setting the disabled attribute to the value "false" is disallowed, because despite the appearance of meaning that the element is enabled, it in fact means that the element is disabled (what matters for implementations is the presence of the attribute, not its value).

Errors involving limits that have been imposed merely to simplify the language
Some conformance errors simplify the language that authors need to learn.

For example, the area element's shape attribute, despite accepting both circ and circle values in practice as synonyms, disallows the use of the circ value, so as to simplify tutorials and other learning aids. There would be no benefit to allowing both, but it would cause extra confusion when teaching the language.

Errors that involve peculiarities of the parser
Certain elements are parsed in somewhat eccentric ways (typically for historical reasons), and their content model restrictions are intended to avoid exposing the author to these issues.

For example, a form element isn't allowed inside phrasing content, because when parsed as HTML, a form element's start tag will imply a p element's end tag. Thus, the following markup results in two paragraphs, not one:

<p>Welcome. <form><label>Name:</label> <input></form>
It is parsed exactly like the following:

<p>Welcome. </p><form><label>Name:</label> <input></form>
Errors that would likely result in scripts failing in hard-to-debug ways
Some errors are intended to help prevent script problems that would be hard to debug.

This is why, for instance, it is non-conforming to have two id attributes with the same value. Duplicate IDs lead to the wrong element being selected, with sometimes disastrous effects whose cause is hard to determine.

Errors that waste authoring time
Some constructs are disallowed because historically they have been the cause of a lot of wasted authoring time, and by encouraging authors to avoid making them, authors can save time in future efforts.

For example, a script element's src attribute causes the element's contents to be ignored. However, this isn't obvious, especially if the element's contents appear to be executable script — which can lead to authors spending a lot of time trying to debug the inline script without realizing that it is not executing. To reduce this problem, this specification makes it non-conforming to have executable script in a script element when the src attribute is present. This means that authors who are validating their documents are less likely to waste time with this kind of mistake.

Errors that involve areas that affect authors migrating between the HTML and XML syntaxes
Some authors like to write files that can be interpreted as both XML and HTML with similar results. Though this practice is discouraged in general due to the myriad of subtle complications involved (especially when involving scripting, styling, or any kind of automated serialization), this specification has a few restrictions intended to at least somewhat mitigate the difficulties. This makes it easier for authors to use this as a transitionary step when migrating between the HTML and XML syntaxes.

For example, there are somewhat complicated rules surrounding the lang and xml:lang attributes intended to keep the two synchronized.

Another example would be the restrictions on the values of xmlns attributes in the HTML serialization, which are intended to ensure that elements in conforming documents end up in the same namespaces whether processed as HTML or XML.

Errors that involve areas reserved for future expansion
As with the restrictions on the syntax intended to allow for new syntax in future revisions of the language, some restrictions on the content models of elements and values of attributes are intended to allow for future expansion of the HTML vocabulary.

For example, limiting the values of the target attribute that start with an U+005F LOW LINE character (_) to only specific predefined values allows new predefined values to be introduced at a future time without conflicting with author-defined values.

Errors that indicate a mis-use of other specifications
Certain restrictions are intended to support the restrictions made by other specifications.

For example, requiring that attributes that take media query lists use only valid media query lists reinforces the importance of following the conformance rules of that specification.

1.13 Suggested reading
This section is non-normative.

The following documents might be of interest to readers of this specification.

Character Model for the World Wide Web 1.0: Fundamentals [CHARMOD]
This Architectural Specification provides authors of specifications, software developers, and content developers with a common reference for interoperable text manipulation on the World Wide Web, building on the Universal Character Set, defined jointly by the Unicode Standard and ISO/IEC 10646. Topics addressed include use of the terms 'character', 'encoding' and 'string', a reference processing model, choice and identification of character encodings, character escaping, and string indexing.

Unicode Security Considerations [UTR36]
Because Unicode contains such a large number of characters and incorporates the varied writing systems of the world, incorrect usage can expose programs or systems to possible security attacks. This is especially important as more and more products are internationalized. This document describes some of the security considerations that programmers, system analysts, standards developers, and users should take into account, and provides specific recommendations to reduce the risk of problems.

Web Content Accessibility Guidelines (WCAG) 2.0 [WCAG]
Web Content Accessibility Guidelines (WCAG) 2.0 covers a wide range of recommendations for making Web content more accessible. Following these guidelines will make content accessible to a wider range of people with disabilities, including blindness and low vision, deafness and hearing loss, learning disabilities, cognitive limitations, limited movement, speech disabilities, photosensitivity and combinations of these. Following these guidelines will also often make your Web content more usable to users in general.

Authoring Tool Accessibility Guidelines (ATAG) 2.0 [ATAG]
This specification provides guidelines for designing Web content authoring tools that are more accessible for people with disabilities. An authoring tool that conforms to these guidelines will promote accessibility by providing an accessible user interface to authors with disabilities as well as by enabling, supporting, and promoting the production of accessible Web content by all authors.

User Agent Accessibility Guidelines (UAAG) 2.0 [UAAG]
This document provides guidelines for designing user agents that lower barriers to Web accessibility for people with disabilities. User agents include browsers and other types of software that retrieve and render Web content. A user agent that conforms to these guidelines will promote accessibility through its own user interface and through other internal facilities, including its ability to communicate with other technologies (especially assistive technologies). Furthermore, all users, not just users with disabilities, should find conforming user agents to be more usable.

2 Common infrastructure
This specification depends on the WHATWG Infra standard. [INFRA]

2.1 Terminology
This specification refers to both HTML and XML attributes and IDL attributes, often in the same context. When it is not clear which is being referred to, they are referred to as content attributes for HTML and XML attributes, and IDL attributes for those defined on IDL interfaces. Similarly, the term "properties" is used for both JavaScript object properties and CSS properties. When these are ambiguous they are qualified as object properties and CSS properties respectively.

Generally, when the specification states that a feature applies to the HTML syntax or the XML syntax, it also includes the other. When a feature specifically only applies to one of the two languages, it is called out by explicitly stating that it does not apply to the other format, as in "for HTML, ... (this does not apply to XML)".

This specification uses the term document to refer to any use of HTML, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications. The term is used to refer both to Document objects and their descendant DOM trees, and to serialized byte streams using the HTML syntax or the XML syntax, depending on context.

In the context of the DOM structures, the terms HTML document and XML document are used as defined in the DOM specification, and refer specifically to two different modes that Document objects can find themselves in. [DOM] (Such uses are always hyperlinked to their definition.)

In the context of byte streams, the term HTML document refers to resources labeled as text/html, and the term XML document refers to resources labeled with an XML MIME type.

For simplicity, terms such as shown, displayed, and visible might sometimes be used when referring to the way a document is rendered to the user. These terms are not meant to imply a visual medium; they must be considered to apply to other media in equivalent ways.

2.1.1 Parallelism
To run steps in parallel means those steps are to be run, one after another, at the same time as other logic in the standard (e.g., at the same time as the event loop). This standard does not define the precise mechanism by which this is achieved, be it time-sharing cooperative multitasking, fibers, threads, processes, using different hyperthreads, cores, CPUs, machines, etc. By contrast, an operation that is to run immediately must interrupt the currently running task, run itself, and then resume the previously running task.

To avoid race conditions between different in parallel algorithms that operate on the same data, a parallel queue can be used.

A parallel queue represents a queue of algorithm steps that must be run in series.

A parallel queue has an algorithm queue (a queue), initially empty.

To enqueue steps to a parallel queue, enqueue the algorithm steps to the parallel queue's algorithm queue.

To start a new parallel queue, run the following steps:

Let parallelQueue be a new parallel queue.

Run the following steps in parallel:

While true:

Let steps be the result of dequeueing from parallelQueue's algorithm queue.

If steps is not nothing, then run steps.

Assert: running steps did not throw an exception, as steps running in parallel are not allowed to throw.

Implementations are not expected to implement this as a continuously running loop. Algorithms in standards are to be easy to understand and are not necessarily great for battery life or performance.

Return parallelQueue.

Steps running in parallel can themselves run other steps in in parallel. E.g., inside a parallel queue it can be useful to run a series of steps in parallel with the queue.

Imagine a standard defined nameList (a list), along with a method to add a name to nameList, unless nameList already contains name, in which case it rejects.

The following solution suffers from race conditions:

Let p be a new promise.

Run the following steps in parallel:

If nameList contains name, reject p with a TypeError and abort these steps.

Do some potentially lengthy work.

Append name to nameList.

Resolve p with undefined.

Return p.

Two invocations of the above could run simultaneously, meaning name isn't in nameList during step 2.1, but it might be added before step 2.3 runs, meaning name ends up in nameList twice.

Parallel queues solve this. The standard would let nameListQueue be the result of starting a new parallel queue, then:

Let p be a new promise.

Enqueue the following steps to nameListQueue:

If nameList contains name, reject p with a TypeError and abort these steps.

Do some potentially lengthy work.

Append name to nameList.

Resolve p with undefined.

Return p.

The steps would now queue and the race is avoided.

2.1.2 Resources
The specification uses the term supported when referring to whether a user agent has an implementation capable of decoding the semantics of an external resource. A format or type is said to be supported if the implementation can process an external resource of that format or type without critical aspects of the resource being ignored. Whether a specific resource is supported can depend on what features of the resource's format are in use.

For example, a PNG image would be considered to be in a supported format if its pixel data could be decoded and rendered, even if, unbeknownst to the implementation, the image also contained animation data.

An MPEG-4 video file would not be considered to be in a supported format if the compression format used was not supported, even if the implementation could determine the dimensions of the movie from the file's metadata.

What some specifications, in particular the HTTP specification, refer to as a representation is referred to in this specification as a resource. [HTTP]

A resource's critical subresources are those that the resource needs to have available to be correctly processed. Which resources are considered critical or not is defined by the specification that defines the resource's format.

2.1.3 XML compatibility
To ease migration from HTML to XML, UAs conforming to this specification will place elements in HTML in the http://www.w3.org/1999/xhtml namespace, at least for the purposes of the DOM and CSS. The term "HTML elements" refers to any element in that namespace, even in XML documents.

Except where otherwise stated, all elements defined or mentioned in this specification are in the HTML namespace ("http://www.w3.org/1999/xhtml"), and all attributes defined or mentioned in this specification have no namespace.

The term element type is used to refer to the set of elements that have a given local name and namespace. For example, button elements are elements with the element type button, meaning they have the local name "button" and (implicitly as defined above) the HTML namespace.

Attribute names are said to be XML-compatible if they match the Name production defined in XML and they contain no U+003A COLON characters (:). [XML]

2.1.4 DOM trees
When it is stated that some element or attribute is ignored, or treated as some other value, or handled as if it was something else, this refers only to the processing of the node after it is in the DOM. A user agent must not mutate the DOM in such situations.

A content attribute is said to change value only if its new value is different than its previous value; setting an attribute to a value it already has does not change it.

The term empty, when used for an attribute value, Text node, or string, means that the length of the text is zero (i.e., not even containing controls or U+0020 SPACE).

A node A is inserted into a node B when the insertion steps are invoked with A as the argument and A's new parent is B. Similarly, a node A is removed from a node B when the removing steps are invoked with A as the removedNode argument and B as the oldParent argument.

A node is inserted into a document when the insertion steps are invoked with it as the argument and it is now in a document tree. Analogously, a node is removed from a document when the removing steps are invoked with it as the argument and it is now no longer in a document tree.

A node becomes connected when the insertion steps are invoked with it as the argument and it is now connected. Analogously, a node becomes disconnected when the removing steps are invoked with it as the argument and it is now no longer connected.

A node is browsing-context connected when it is connected and its shadow-including root has a browsing context. A node becomes browsing-context connected when the insertion steps are invoked with it as the argument and it is now browsing-context connected. A node becomes browsing-context disconnected either when the removing steps are invoked with it as the argument and it is now no longer browsing-context connected, or when its shadow-including root no longer has a browsing context.

2.1.5 Scripting
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo".

An IDL attribute is said to be getting when its value is being retrieved (e.g. by author script), and is said to be setting when a new value is assigned to it.

If a DOM object is said to be live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.

2.1.6 Plugins
The term plugin refers to a user-agent defined set of content handlers used by the user agent that can take part in the user agent's rendering of a Document object, but that neither act as child browsing contexts of the Document nor introduce any Node objects to the Document's DOM.

Typically such content handlers are provided by third parties, though a user agent can also designate built-in content handlers as plugins.

A user agent must not consider the types text/plain and application/octet-stream as having a registered plugin.

One example of a plugin would be a PDF viewer that is instantiated in a browsing context when the user navigates to a PDF file. This would count as a plugin regardless of whether the party that implemented the PDF viewer component was the same as that which implemented the user agent itself. However, a PDF viewer application that launches separate from the user agent (as opposed to using the same interface) is not a plugin by this definition.

This specification does not define a mechanism for interacting with plugins, as it is expected to be user-agent- and platform-specific. Some UAs might opt to support a plugin mechanism such as the Netscape Plugin API; others might use remote content converters or have built-in support for certain types. Indeed, this specification doesn't require user agents to support plugins at all. [NPAPI]

A plugin can be secured if it honors the semantics of the sandbox attribute.

For example, a secured plugin would prevent its contents from creating pop-up windows when the plugin is instantiated inside a sandboxed iframe.

Browsers should take extreme care when interacting with external content intended for plugins. When third-party software is run with the same privileges as the user agent itself, vulnerabilities in the third-party software become as dangerous as those in the user agent.

Since different users having different sets of plugins provides a fingerprinting vector that increases the chances of users being uniquely identified, user agents are encouraged to support the exact same set of plugins for each user.
2.1.7 Character encodings
A character encoding, or just encoding where that is not ambiguous, is a defined way to convert between byte streams and Unicode strings, as defined in the WHATWG Encoding standard. An encoding has an encoding name and one or more encoding labels, referred to as the encoding's name and labels in the Encoding standard. [ENCODING]

A UTF-16 encoding is UTF-16BE or UTF-16LE. [ENCODING]

An ASCII-compatible encoding is any encoding that is not a UTF-16 encoding. [ENCODING]

Since support for encodings that are not defined in the WHATWG Encoding standard is prohibited, UTF-16 encodings are the only encodings that this specification needs to treat as not being ASCII-compatible encodings.

2.1.8 Conformance classes
This specification describes the conformance criteria for user agents (relevant to implementers) and documents (relevant to authors and authoring tool implementers).

Conforming documents are those that comply with all the conformance criteria for documents. For readability, some of these conformance requirements are phrased as conformance requirements on authors; such requirements are implicitly requirements on documents: by definition, all documents are assumed to have had an author. (In some cases, that author may itself be a user agent — such user agents are subject to additional rules, as explained below.)

For example, if a requirement states that "authors must not use the foobar element", it would imply that documents are not allowed to contain elements named foobar.

There is no implied relationship between document conformance requirements and implementation conformance requirements. User agents are not free to handle non-conformant documents as they please; the processing model described in this specification applies to implementations regardless of the conformity of the input documents.

User agents fall into several (overlapping) categories with different conformance requirements.

Web browsers and other interactive user agents
Web browsers that support the XML syntax must process elements and attributes from the HTML namespace found in XML documents as described in this specification, so that users can interact with them, unless the semantics of those elements have been overridden by other specifications.

A conforming Web browser would, upon finding a script element in an XML document, execute the script contained in that element. However, if the element is found within a transformation expressed in XSLT (assuming the user agent also supports XSLT), then the processor would instead treat the script element as an opaque element that forms part of the transform.

Web browsers that support the HTML syntax must process documents labeled with an HTML MIME type as described in this specification, so that users can interact with them.

User agents that support scripting must also be conforming implementations of the IDL fragments in this specification, as described in the Web IDL specification. [WEBIDL]

Unless explicitly stated, specifications that override the semantics of HTML elements do not override the requirements on DOM objects representing those elements. For example, the script element in the example above would still implement the HTMLScriptElement interface.

Non-interactive presentation user agents
User agents that process HTML and XML documents purely to render non-interactive versions of them must comply to the same conformance criteria as Web browsers, except that they are exempt from requirements regarding user interaction.

Typical examples of non-interactive presentation user agents are printers (static UAs) and overhead displays (dynamic UAs). It is expected that most static non-interactive presentation user agents will also opt to lack scripting support.

A non-interactive but dynamic presentation UA would still execute scripts, allowing forms to be dynamically submitted, and so forth. However, since the concept of "focus" is irrelevant when the user cannot interact with the document, the UA would not need to support any of the focus-related DOM APIs.

Visual user agents that support the suggested default rendering
User agents, whether interactive or not, may be designated (possibly as a user option) as supporting the suggested default rendering defined by this specification.

This is not required. In particular, even user agents that do implement the suggested default rendering are encouraged to offer settings that override this default to improve the experience for the user, e.g. changing the color contrast, using different focus styles, or otherwise making the experience more accessible and usable to the user.

User agents that are designated as supporting the suggested default rendering must, while so designated, implement the rules the rendering section defines as the behavior that user agents are expected to implement.

User agents with no scripting support
Implementations that do not support scripting (or which have their scripting features disabled entirely) are exempt from supporting the events and DOM interfaces mentioned in this specification. For the parts of this specification that are defined in terms of an events model or in terms of the DOM, such user agents must still act as if events and the DOM were supported.

Scripting can form an integral part of an application. Web browsers that do not support scripting, or that have scripting disabled, might be unable to fully convey the author's intent.

Conformance checkers
Conformance checkers must verify that a document conforms to the applicable conformance criteria described in this specification. Automated conformance checkers are exempt from detecting errors that require interpretation of the author's intent (for example, while a document is non-conforming if the content of a blockquote element is not a quote, conformance checkers running without the input of human judgement do not have to check that blockquote elements only contain quoted material).

Conformance checkers must check that the input document conforms when parsed without a browsing context (meaning that no scripts are run, and that the parser's scripting flag is disabled), and should also check that the input document conforms when parsed with a browsing context in which scripts execute, and that the scripts never cause non-conforming states to occur other than transiently during script execution itself. (This is only a "SHOULD" and not a "MUST" requirement because it has been proven to be impossible. [COMPUTABLE])

The term "HTML validator" can be used to refer to a conformance checker that itself conforms to the applicable requirements of this specification.

XML DTDs cannot express all the conformance requirements of this specification. Therefore, a validating XML processor and a DTD cannot constitute a conformance checker. Also, since neither of the two authoring formats defined in this specification are applications of SGML, a validating SGML system cannot constitute a conformance checker either.

To put it another way, there are three types of conformance criteria:

Criteria that can be expressed in a DTD.
Criteria that cannot be expressed by a DTD, but can still be checked by a machine.
Criteria that can only be checked by a human.
A conformance checker must check for the first two. A simple DTD-based validator only checks for the first class of errors and is therefore not a conforming conformance checker according to this specification.

Data mining tools
Applications and tools that process HTML and XML documents for reasons other than to either render the documents or check them for conformance should act in accordance with the semantics of the documents that they process.

A tool that generates document outlines but increases the nesting level for each paragraph and does not increase the nesting level for each section would not be conforming.

Authoring tools and markup generators
Authoring tools and markup generators must generate conforming documents. Conformance criteria that apply to authors also apply to authoring tools, where appropriate.

Authoring tools are exempt from the strict requirements of using elements only for their specified purpose, but only to the extent that authoring tools are not yet able to determine author intent. However, authoring tools must not automatically misuse elements or encourage their users to do so.

For example, it is not conforming to use an address element for arbitrary contact information; that element can only be used for marking up contact information for its nearest article or body element ancestor. However, since an authoring tool is likely unable to determine the difference, an authoring tool is exempt from that requirement. This does not mean, though, that authoring tools can use address elements for any block of italics text (for instance); it just means that the authoring tool doesn't have to verify that when the user uses a tool for inserting contact information for an article element, that the user really is doing that and not inserting something else instead.

In terms of conformance checking, an editor has to output documents that conform to the same extent that a conformance checker will verify.

When an authoring tool is used to edit a non-conforming document, it may preserve the conformance errors in sections of the document that were not edited during the editing session (i.e. an editing tool is allowed to round-trip erroneous content). However, an authoring tool must not claim that the output is conformant if errors have been so preserved.

Authoring tools are expected to come in two broad varieties: tools that work from structure or semantic data, and tools that work on a What-You-See-Is-What-You-Get media-specific editing basis (WYSIWYG).

The former is the preferred mechanism for tools that author HTML, since the structure in the source information can be used to make informed choices regarding which HTML elements and attributes are most appropriate.

However, WYSIWYG tools are legitimate. WYSIWYG tools should use elements they know are appropriate, and should not use elements that they do not know to be appropriate. This might in certain extreme cases mean limiting the use of flow elements to just a few elements, like div, b, i, and span and making liberal use of the style attribute.

All authoring tools, whether WYSIWYG or not, should make a best effort attempt at enabling users to create well-structured, semantically rich, media-independent content.

User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
For compatibility with existing content and prior specifications, this specification describes two authoring formats: one based on XML, and one using a custom format inspired by SGML (referred to as the HTML syntax). Implementations must support at least one of these two formats, although supporting both is encouraged.

Some conformance requirements are phrased as requirements on elements, attributes, methods or objects. Such requirements fall into two categories: those describing content model restrictions, and those describing implementation behavior. Those in the former category are requirements on documents and authoring tools. Those in the second category are requirements on user agents. Similarly, some conformance requirements are phrased as requirements on authors; such requirements are to be interpreted as conformance requirements on the documents that authors produce. (In other words, this specification does not distinguish between conformance criteria on authors and conformance criteria on documents.)

2.1.9 Dependencies
This specification relies on several other underlying specifications.

Infra
The following terms are defined in the WHATWG Infra standard: [INFRA]

The general iteration terms while, continue, and break.
code point and its synonym character
surrogate
scalar value
noncharacter
JavaScript string, code unit, and JavaScript string length
scalar value string
string length
ASCII whitespace
control
ASCII digit
ASCII upper hex digit
ASCII lower hex digit
ASCII hex digit
ASCII upper alpha
ASCII lower alpha
ASCII alpha
ASCII alphanumeric
ASCII lowercase
ASCII uppercase
ASCII case-insensitive
strip newlines
strip leading and trailing ASCII whitespace
strip and collapse ASCII whitespace
split a string on ASCII whitespace
split a string on commas
collect a sequence of code points and its associated position variable
skip ASCII whitespace
The ordered map data structure and the associated definitions for exists, getting the value of an entry, and setting the value of an entry
The list data structure and the associated definitions for append, replace, remove, empty, contains, size, is empty, and iterate
The stack data structure and the associated definitions for push and pop
The queue data structure and the associated definitions for enqueue and dequeue
The ordered set data structure and the associated definition for append
The struct specification type and the associated definition for item
The forgiving-base64 encode and forgiving-base64 decode algorithms
HTML namespace
MathML namespace
SVG namespace
XLink namespace
XML namespace
XMLNS namespace
Unicode and Encoding
The Unicode character set is used to represent textual data, and the WHATWG Encoding standard defines requirements around character encodings. [UNICODE]

This specification introduces terminology based on the terms defined in those specifications, as described earlier.

The following terms are used as defined in the WHATWG Encoding standard: [ENCODING]

Getting an encoding
Get an output encoding
The generic decode algorithm which takes a byte stream and an encoding and returns a character stream
The UTF-8 decode algorithm which takes a byte stream and returns a character stream, additionally stripping one leading UTF-8 Byte Order Mark (BOM), if any
The UTF-8 decode without BOM algorithm which is identical to UTF-8 decode except that it does not strip one leading UTF-8 Byte Order Mark (BOM)
The UTF-8 decode without BOM or fail algorithm which is identical to UTF-8 decode without BOM except that it returns failure upon encountering an error
The encode algorithm which takes a character stream and an encoding and returns a byte stream
The UTF-8 encode algorithm which takes a character stream and returns a byte stream
XML and related specifications
Implementations that support the XML syntax for HTML must support some version of XML, as well as its corresponding namespaces specification, because that syntax uses an XML serialization with namespaces. [XML] [XMLNS]

Data mining tools and other user agents that perform operations on content without running scripts, evaluating CSS or XPath expressions, or otherwise exposing the resulting DOM to arbitrary content, may "support namespaces" by just asserting that their DOM node analogues are in certain namespaces, without actually exposing the namespace strings.

In the HTML syntax, namespace prefixes and namespace declarations do not have the same effect as in XML. For instance, the colon has no special meaning in HTML element names.

The attribute with the tag name xml:space in the XML namespace is defined by the XML specification. [XML]

The Name production is defined in the XML specification. [XML]

This specification also references the <?xml-stylesheet?> processing instruction, defined in the Associating Style Sheets with XML documents specification. [XMLSSPI]

This specification also non-normatively mentions the XSLTProcessor interface and its transformToFragment() and transformToDocument() methods. [XSLTP]

URLs
The following terms are defined in the WHATWG URL standard: [URL]

host
domain
IPv4 address
IPv6 address
URL
Origin of URLs
Absolute URL
Relative URL
The URL parser and basic URL parser as well as these parser states:
scheme start state
host state
hostname state
port state
path start state
query state
fragment state
URL record, as well as its individual components:
scheme
username
password
host
port
path
query
fragment
cannot-be-a-base-URL flag
object
valid URL string
The cannot have a username/password/port concept
The URL serializer
The host parser
The host serializer
Host equals
URL equals
serialize an integer
Default encode set
UTF-8 percent encode
Percent decode
set the username
set the password
The application/x-www-form-urlencoded format
The application/x-www-form-urlencoded serializer
A number of schemes and protocols are referenced by this specification also:

The about: scheme [ABOUT]
The blob: scheme [FILEAPI]
The data: scheme [RFC2397]
The http: scheme [HTTP]
The https: scheme [HTTP]
The mailto: scheme [MAILTO]
The sms: scheme [SMS]
The urn: scheme [URN]
Media fragment syntax is defined in the Media Fragments URI specification. [MEDIAFRAG]

HTTP and related specifications
The following terms are defined in the HTTP specifications: [HTTP]

`Accept` header
`Accept-Language` header
`Cache-Control` header
`Content-Disposition` header
`Content-Language` header
`Last-Modified` header
`Referer` header
The following terms are defined in the Cookie specification: [COOKIES]

cookie-string
receives a set-cookie-string
`Cookie` header
The following term is defined in the Web Linking specification: [WEBLINK]

`Link` header
The following terms are defined in the WHATWG MIME Sniffing standard: [MIMESNIFF]

MIME type
valid MIME type string
valid MIME type string with no parameters
HTML MIME type
JavaScript MIME type and JavaScript MIME type essence match
JSON MIME type
XML MIME type
Fetch
The following terms are defined in the WHATWG Fetch standard: [FETCH]

about:blank
An HTTP(S) scheme
A network scheme
A fetch scheme
HTTPS state value
CORS protocol
default `User-Agent` value
extract a MIME type
fetch
HTTP-redirect fetch
ok status
navigation request
network error
`Origin` header
process response
set
terminate
the RequestCredentials enumeration
the RequestDestination enumeration
response and its associated:
type
url
url list
status
header list
body
internal response
CSP list
HTTPS state
location URL
request and its associated:
url
method
header list
body
client
reserved client
target client id
initiator
destination
potential destination
translating a potential destination
script-like destinations
priority
origin
referrer
synchronous flag
mode
credentials mode
use-URL-credentials flag
unsafe-request flag
cache mode
redirect mode
referrer policy
cryptographic nonce metadata
integrity metadata
parser metadata
The following terms are defined in Referrer Policy: [REFERRERPOLICY]

referrer policy
The `Referrer-Policy` HTTP header
The parse a referrer policy from a `Referrer-Policy` header algorithm
The "no-referrer", "no-referrer-when-downgrade", "no-referrer-when-downgrade", and "unsafe-url" referrer policies
The following terms are defined in Mixed Content: [MIX]

a priori authenticated URL
Web IDL
The IDL fragments in this specification must be interpreted as required for conforming IDL fragments, as described in the Web IDL specification. [WEBIDL]

The following terms are defined in the Web IDL specification:

extended attribute
named constructor
array index property name
supported property indices
determine the value of an indexed property
set the value of an existing indexed property
set the value of a new indexed property
support named properties
supported property names
determine the value of a named property
set the value of an existing named property
set the value of a new named property
delete an existing named property
perform a security check
platform object
legacy platform object
primary interface
interface object
interface prototype object
global environment associated with a platform object
callback context
frozen array and creating a frozen array
callback this value
converting between Web IDL types and JS types
invoking and constructing callback functions
converting to a sequence of Unicode scalar values
The Web IDL specification also defines the following types that are used in Web IDL fragments in this specification:

ArrayBuffer
ArrayBufferView
boolean
DOMString
double
enumeration
Error
Function
long
object
Uint8ClampedArray
unrestricted double
unsigned long
USVString
The term throw in this specification is used as defined in the Web IDL specification. The DOMException type and the following exception names are defined by Web IDL and used by this specification:

"IndexSizeError"
"HierarchyRequestError"
"InvalidCharacterError"
"NotFoundError"
"NotSupportedError"
"InvalidStateError"
"SyntaxError"
"InvalidAccessError"
"SecurityError"
"NetworkError"
"AbortError"
"QuotaExceededError"
"DataCloneError"
"EncodingError"
"NotAllowedError"
When this specification requires a user agent to create a Date object representing a particular time (which could be the special value Not-a-Number), the milliseconds component of that time, if any, must be truncated to an integer, and the time value of the newly created Date object must represent the resulting truncated time.

For instance, given the time 23045 millionths of a second after 01:00 UTC on January 1st 2000, i.e. the time 2000-01-01T00:00:00.023045Z, then the Date object created representing that time would represent the same time as that created representing the time 2000-01-01T00:00:00.023Z, 45 millionths earlier. If the given time is NaN, then the result is a Date object that represents a time value NaN (indicating that the object does not represent a specific instant of time).

JavaScript
Some parts of the language described by this specification only support JavaScript as the underlying scripting language. [JAVASCRIPT]

Users agents that support JavaScript must also implement the ECMAScript Internationalization API Specification. [JSINTL]

The term "JavaScript" is used to refer to ECMA-262, rather than the official term ECMAScript, since the term JavaScript is more widely known. Similarly, the MIME type used to refer to JavaScript in this specification is text/javascript, since that is the most commonly used type, despite it being an officially obsoleted type according to RFC 4329. [RFC4329]

The following terms are defined in the JavaScript specification and used in this specification:

active function object
agent and agent cluster
automatic semicolon insertion
The current Realm Record
early error
Directive Prologue
invariants of the essential internal methods
JavaScript execution context
JavaScript execution context stack
JavaScript realm
running JavaScript execution context
Use Strict Directive
Well-Known Symbols, including @@hasInstance, @@isConcatSpreadable, @@toPrimitive, and @@toStringTag
Well-Known Intrinsic Objects, including %ArrayBuffer%, %ArrayPrototype%, and %ObjProto_valueOf%
The FunctionBody production
The Module production
The Pattern production
The Script production
The Type notation
The List and Record specification types
The Property Descriptor specification type
The Script Record specification type
The Source Text Module Record specification type and its Evaluate and Instantiate methods
The ArrayCreate abstract operation
The Call abstract operation
The Construct abstract operation
The CopyDataBlockBytes abstract operation
The CreateByteDataBlock abstract operation
The CreateDataProperty abstract operation
The DetachArrayBuffer abstract operation
The EnqueueJob abstract operation
The EnumerableOwnProperties abstract operation
The FunctionCreate abstract operation
The Get abstract operation
The GetActiveScriptOrModule abstract operation
The GetFunctionRealm abstract operation
The HasOwnProperty abstract operation
The HostEnsureCanCompileStrings abstract operation
The HostPromiseRejectionTracker abstract operation
The HostResolveImportedModule abstract operation
The InitializeHostDefinedRealm abstract operation
The IsAccessorDescriptor abstract operation
The IsCallable abstract operation
The IsConstructor abstract operation
The IsDataDescriptor abstract operation
The IsDetachedBuffer abstract operation
The IsSharedArrayBuffer abstract operation
The NewObjectEnvironment abstract operation
The NormalCompletion abstract operation
The OrdinaryGetPrototypeOf abstract operation
The OrdinarySetPrototypeOf abstract operation
The OrdinaryIsExtensible abstract operation
The OrdinaryPreventExtensions abstract operation
The OrdinaryGetOwnProperty abstract operation
The OrdinaryDefineOwnProperty abstract operation
The OrdinaryGet abstract operation
The OrdinarySet abstract operation
The OrdinaryDelete abstract operation
The OrdinaryOwnPropertyKeys abstract operation
The ParseModule abstract operation
The ParseScript abstract operation
The RunJobs abstract operation
The SameValue abstract operation
The ScriptEvaluation abstract operation
The SetImmutablePrototype abstract operation
The ToBoolean abstract operation
The ToString abstract operation
The ToUint32 abstract operation
The TypedArrayCreate abstract operation
The Abstract Equality Comparison algorithm
The Strict Equality Comparison algorithm
The Date class
The SharedArrayBuffer class
The TypeError class
The RangeError class
The eval() function
The [[IsHTMLDDA]] internal slot
The typeof operator
The delete operator
The TypedArray Constructors table
User agents that support JavaScript must also implement the import() proposal. The following terms are defined there, and used in this specification: [JSIMPORT]

import()
The HostImportModuleDynamically abstract operation
The FinishDynamicImport abstract operation
User agents that support JavaScript must also implement the import.meta proposal. The following term is defined there, and used in this specification: [JSIMPORTMETA]

The HostGetImportMetaProperties abstract operation
User agents that support JavaScript must also implement the BigInt proposal. [JSBIGINT]

DOM
The Document Object Model (DOM) is a representation — a model — of a document and its content. The DOM is not just an API; the conformance criteria of HTML implementations are defined, in this specification, in terms of operations on the DOM. [DOM]

Implementations must support DOM and the events defined in UI Events, because this specification is defined in terms of the DOM, and some of the features are defined as extensions to the DOM interfaces. [DOM] [UIEVENTS]

In particular, the following features are defined in the WHATWG DOM standard: [DOM]

Attr interface
Comment interface
DOMImplementation interface
Document interface
DocumentFragment interface
DocumentType interface
ChildNode interface
Element interface
Node interface
NodeList interface
ProcessingInstruction interface
ShadowRoot interface
Text interface
node document concept
host concept
shadow root concept
HTMLCollection interface
HTMLCollection.length attribute
HTMLCollection.item() method
HTMLCollection.namedItem() method
The terms collection and represented by the collection
DOMTokenList interface
DOMTokenList.value attribute
createDocument() method
createHTMLDocument() method
createElement() method
createElementNS() method
getElementById() method
getElementsByClassName() method
appendChild() method
cloneNode() method
importNode() method
preventDefault() method
id attribute
textContent attribute
The tree and shadow tree concepts
The tree order and shadow-including tree order concepts
The child concept
The root and shadow-including root concepts
The inclusive ancestor, shadow-including descendant, and shadow-including inclusive descendant concepts
The first child and next sibling concepts
The document element concept
The in a document tree, in a document (legacy), and connected concepts
The slot concept, and its name and assigned nodes
The find flattened slotables algorithm
The assign a slot algorithm
The pre-insert, insert, append, replace, replace all, remove, and adopt algorithms for nodes
The change, append, remove, replace, and set value algorithms for attributes
The insertion steps, removing steps, adopting steps, and child text content change steps hooks
The attribute list concept
The data of a text node
The child text content of a node
Event interface
EventTarget interface
The activation behavior hook
The legacy-pre-activation behavior hook
The legacy-canceled-activation behavior hook
The create an event algorithm
The fire an event algorithm
The canceled flag
The dispatch algorithm
EventInit dictionary type
type attribute
target attribute
currentTarget attribute
bubbles attribute
cancelable attribute
composed flag
isTrusted attribute
initEvent() method
add an event listener
addEventListener() method
EventListener callback interface
The type of an event
An event listener and its type and callback
The encoding (herein the character encoding) and content type of a Document
The distinction between XML documents and HTML documents
The terms quirks mode, limited-quirks mode, and no-quirks mode
The algorithm to clone a Node, and the concept of cloning steps used by that algorithm
The concept of base URL change steps and the definition of what happens when an element is affected by a base URL change
The concept of an element's unique identifier (ID)
The concept of an element's classes
The term supported tokens
The concept of a DOM range, and the terms start, end, and boundary point as applied to ranges.
The create an element algorithm
The element interface concept
The concepts of custom element state, and of defined and custom elements
An element's custom element definition
An element's is value
MutationObserver interface and mutation observers in general
The following features are defined in the UI Events specification: [UIEVENTS]

The MouseEvent interface
The MouseEvent interface's relatedTarget attribute
MouseEventInit dictionary type
The FocusEvent interface
The FocusEvent interface's relatedTarget attribute
The UIEvent interface
The UIEvent interface's view attribute
auxclick event
click event
dblclick event
mousedown event
mouseenter event
mouseleave event
mousemove event
mouseout event
mouseover event
mouseup event
wheel event
keydown event
keypress event
keyup event
The following features are defined in the Touch Events specification: [TOUCH]

Touch interface
Touch point concept
touchend event
The following features are defined in the Pointer Events specification: [POINTEREVENTS]

pointerup event
This specification sometimes uses the term name to refer to the event's type; as in, "an event named click" or "if the event name is keypress". The terms "name" and "type" for events are synonymous.

The following features are defined in the DOM Parsing and Serialization specification: [DOMPARSING]

DOMParser
innerHTML
outerHTML
The Selection interface is defined in the Selection API specification. [SELECTION]

User agents are encouraged to implement the features described in the execCommand specification. [EXECCOMMAND]

The following parts of the WHATWG Fullscreen API standard are referenced from this specification, in part to define the rendering of dialog elements, and also to define how the Fullscreen API interacts with HTML: [FULLSCREEN]

top layer (an ordered set) and its add operation
requestFullscreen()
run the fullscreen steps
The High Resolution Time specification provides the DOMHighResTimeStamp typedef and the Performance interface's now() method. [HRT]

File API
This specification uses the following features defined in the File API specification: [FILEAPI]

The Blob interface and its type attribute
The File interface and its name and lastModified attributes
The FileList interface
The concept of a Blob's snapshot state
The concept of read errors
Blob URL Store
Indexed Database API
This specification uses cleanup Indexed Database transactions defined by the Indexed Database API specification. [INDEXEDDB]

Media Source Extensions
The following terms are defined in the Media Source Extensions specification: [MEDIASOURCE]

MediaSource interface
detaching from a media element
Media Capture and Streams
The following terms are defined in the Media Capture and Streams specification: [MEDIASTREAM]

MediaStream interface
getUserMedia() method
XMLHttpRequest
This specification references the XMLHttpRequest specification to describe how the two specifications interact and to use its ProgressEvent features. The following features and terms are defined in the XMLHttpRequest specification: [XHR]

XMLHttpRequest interface
XMLHttpRequest.responseXML attribute
ProgressEvent interface
ProgressEvent.lengthComputable attribute
ProgressEvent.loaded attribute
ProgressEvent.total attribute
Fire a progress event named e
Battery Status
The following features are defined in the Battery Status API specification: [BATTERY]

getBattery() method
Media Queries
Implementations must support Media Queries. The <media-condition> feature is defined therein. [MQ]

CSS modules
While support for CSS as a whole is not required of implementations of this specification (though it is encouraged, at least for Web browsers), some features are defined in terms of specific CSS requirements.

When this specification requires that something be parsed according to a particular CSS grammar, the relevant algorithm in the CSS Syntax specification must be followed, including error handling rules. [CSSSYNTAX]

For example, user agents are required to close all open constructs upon finding the end of a style sheet unexpectedly. Thus, when parsing the string "rgb(0,0,0" (with a missing close-parenthesis) for a color value, the close parenthesis is implied by this error handling rule, and a value is obtained (the color 'black'). However, the similar construct "rgb(0,0," (with both a missing parenthesis and a missing "blue" value) cannot be parsed, as closing the open construct does not result in a viable value.

To parse a CSS <color> value, given a string input with an optional element element, run these steps:

Let color be the result of parsing input as a CSS <color>. [CSSCOLOR]

If color is failure, then return failure.

If color is 'currentcolor', then:

If element is not given, then set color to opaque black.

Otherwise, set color to the computed value of the 'color' property of element.

Return color.

The following terms and features are defined in the CSS specification: [CSS]

viewport
line box
out-of-flow
in-flow
replaced element
intrinsic dimensions
content area
content box
border box
margin box
border edge
margin edge
collapsing margins
containing block
inline box
block box
The 'margin-top', 'margin-bottom', 'margin-left', and 'margin-right' properties
The 'padding-top', 'padding-bottom', 'padding-left', and 'padding-right' properties
The 'top', 'bottom', 'left', and 'right' properties
The 'float' property
The 'clear' property
The 'width' property
The 'height' property
The 'line-height' property
The 'vertical-align' property
The 'content' property
The 'inline-block' value of the 'display' property
The 'visibility' property
The CSS specification also defines the following border properties: [CSS]

Border properties
Top	Bottom	Left	Right
Width	'border-top-width'	'border-bottom-width'	'border-left-width'	'border-right-width'
Style	'border-top-style'	'border-bottom-style'	'border-left-style'	'border-right-style'
Color	'border-top-color'	'border-bottom-color'	'border-left-color'	'border-right-color'
The terms intrinsic width and intrinsic height refer to the width dimension and the height dimension, respectively, of intrinsic dimensions.

The basic version of the 'display' property is defined in the CSS specification, and the property is extended by other CSS modules. [CSS] [CSSRUBY] [CSSTABLE]

The following terms and features are defined in the CSS Logical Properties specification: [CSSLOGICAL]

The 'margin-block-start', 'margin-block-end', 'margin-inline-start', and 'margin-inline-end' properties
The 'padding-block-start', 'padding-block-end', 'padding-inline-start', and 'padding-inline-end' properties
The following terms and features are defined in the CSS Color specification: [CSSCOLOR]

named color
<color>
The 'color' property
The 'currentcolor' value
opaque black
transparent black
The term paint source is used as defined in the CSS Image Values and Replaced Content specification to define the interaction of certain HTML elements with the CSS 'element()' function. [CSSIMAGES]

The term default object size and the 'object-fit' property are also defined in the CSS Image Values and Replaced Content specification. [CSSIMAGES]

The following features are defined in the CSS Backgrounds and Borders specification: [CSSBG]

The 'background-color' property
The 'background-image' property
The term block-level is defined in the CSS Display specification. [CSSDISPLAY]

The following features are defined in the CSS Fonts specification: [CSSFONTS]

The 'font-family' property
The 'font-weight' property
The 'font-size' property
The 'font' property
The 'list-style-type' property is defined in the CSS Lists and Counters specification. [CSSLISTS]

The 'overflow' property and its 'hidden' value are defined in the CSS Overflow specification. [CSSOVERFLOW]

The following features are defined in the CSS Positioned Layout specification: [CSSPOSITION]

The 'position' property and its 'static' value
The 'ruby-base' value of the 'display' property is defined in the CSS Ruby Layout specification. [CSSRUBY]

The following features are defined in the CSS Table specification: [CSSTABLE]

The 'border-spacing' property
The 'border-collapse' property
The 'table-cell', 'table-row', 'table-caption', and 'table' values of the 'display' property
The following features are defined in the CSS Text specification: [CSSTEXT]

The 'text-transform' property
The 'white-space' property
The 'text-align' property
The 'letter-spacing' property
The following features are defined in the CSS Writing Modes specification: [CSSWM]

The 'direction' property
The 'unicode-bidi' property
The block flow direction, block size, inline size, block-start, block-end, inline-start, inline-end, line-left, and line-right concepts
The following features are defined in the CSS Basic User Interface specification: [CSSUI]

The 'outline' property
The 'cursor' property
The 'appearance' property
The algorithm to update animations and send events is defined in the Web Animations specification. [WEBANIMATIONS].

Implementations that support scripting must support the CSS Object Model. The following features and terms are defined in the CSSOM specifications: [CSSOM] [CSSOMVIEW]

Screen interface
LinkStyle interface
CSSStyleDeclaration interface
cssText attribute of CSSStyleDeclaration
StyleSheet interface
create a CSS style sheet
remove a CSS style sheet
associated CSS style sheet
CSS style sheets and their properties:
type
location
parent CSS style sheet
owner node
owner CSS rule
media
title
alternate flag
disabled flag
CSS rules
origin-clean flag
CSS style sheet set
CSS style sheet set name
preferred CSS style sheet set name
change the preferred CSS style sheet set name
Serializing a CSS value
run the resize steps
run the scroll steps
evaluate media queries and report changes
Scroll an element into view
Scroll to the beginning of the document
The resize event
The scroll event
set up browsing context features
The following features and terms are defined in the CSS Syntax specifications: [CSSSYNTAX]

conformant style sheet
parse a comma-separated list of component values
component value
environment encoding
<whitespace-token>
The following terms are defined in the Selectors specification: [SELECTORS]

type selector
attribute selector
pseudo-class
The following features are defined in the CSS Values and Units specification: [CSSVALUES]

<length>
The 'em' unit
The 'ex' unit
The 'vw' unit
The 'in' unit
The 'px' unit
The 'attr()' function
The 'calc()' function
The term style attribute is defined in the CSS Style Attributes specification. [CSSATTR]

The following terms are defined in the CSS Cascading and Inheritance specification: [CSSCASCADE]

specified value
computed value
used value
The CanvasRenderingContext2D object's use of fonts depends on the features described in the CSS Fonts and Font Loading specifications, including in particular FontFace objects and the font source concept. [CSSFONTS] [CSSFONTLOAD]

The following interfaces and terms are defined in the Geometry Interfaces Module specification: [GEOMETRY]

DOMMatrix interface, and associated m11 element, m12 element, m21 element, m22 element, m41 element, and m42 element
DOMMatrix2DInit and DOMMatrixInit dictionaries
The create a DOMMatrix from a dictionary and create a DOMMatrix from a 2D dictionary algorithms for DOMMatrix2DInit or DOMMatrixInit
Intersection Observer
The following term is defined in the Intersection Observer specification: [INTERSECTIONOBSERVER]

run the update intersection observations steps
WebGL
The following interface is defined in the WebGL specification: [WEBGL]

WebGLRenderingContext interface
WebVTT
Implementations may support WebVTT as a text track format for subtitles, captions, metadata, etc., for media resources. [WEBVTT]

The following terms, used in this specification, are defined in the WebVTT specification:

WebVTT file
WebVTT file using cue text
WebVTT file using only nested cues
WebVTT parser
The rules for updating the display of WebVTT text tracks
The WebVTT text track cue writing direction
VTTCue interface
The WebSocket protocol
The following terms are defined in the WHATWG Fetch standard: [FETCH]

establish a WebSocket connection
The following terms are defined in the WebSocket protocol specification: [WSP]

the WebSocket connection is established
extensions in use
subprotocol in use
a WebSocket message has been received
send a WebSocket Message
fail the WebSocket connection
close the WebSocket connection
start the WebSocket closing handshake
the WebSocket closing handshake is started
the WebSocket connection is closed (possibly cleanly)
the WebSocket connection close code
the WebSocket connection close reason
Sec-WebSocket-Protocol field
ARIA
The role attribute is defined in the ARIA specification, as are the following roles: [ARIA]

button
presentation
In addition, the following aria-* content attributes are defined in the ARIA specification: [ARIA]

aria-describedby
aria-disabled
aria-label
Finally, the following terms are defined in the ARIA specification: [ARIA]

accessible name
Content Security Policy
The following terms are defined in Content Security Policy: [CSP]

Content Security Policy
Content Security Policy directive
CSP list
The Content Security Policy syntax
enforce the policy
The parse a serialized Content Security Policy algorithm
The Initialize a global object's CSP list algorithm
The Initialize a Document's CSP list algorithm
The Should element's inline behavior be blocked by Content Security Policy? algorithm
The Should navigation request of type from source in target be blocked by Content Security Policy? algorithm
The Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? algorithm
The report-uri directive
The EnsureCSPDoesNotBlockStringCompilation abstract operation
The Is base allowed for Document? algorithm
The frame-ancestors directive
The sandbox directive
The Should element be blocked a priori by Content Security Policy? algorithm
The contains a header-delivered Content Security Policy property.
Service Workers
The following terms are defined in Service Workers: [SW]

active worker
client message queue
control
handle fetch
match service worker registration
service worker
service worker client
ServiceWorker interface
ServiceWorkerContainer interface
ServiceWorkerGlobalScope interface
Secure Contexts
The following terms are defined in Secure Contexts: [SECURE-CONTEXTS]

Is environment settings object a secure context?
non-secure context
secure context
Payment Request API
The following feature is defined in the Payment Request API specification: [PAYMENTREQUEST]

PaymentRequest interface
MathML
While support for MathML as a whole is not required by this specification (though it is encouraged, at least for Web browsers), certain features depend upon small parts of MathML being implemented. [MATHML]

The following features are defined in the MathML specification:

MathML annotation-xml element
MathML math element
MathML merror element
MathML mi element
MathML mn element
MathML mo element
MathML ms element
MathML mtext element
SVG
While support for SVG as a whole is not required by this specification (though it is encouraged, at least for Web browsers), certain features depend upon parts of SVG being implemented.

Also, the SVG specifications do not reflect implementation reality. Implementations implement subsets of SVG 1.1 and SVG Tiny 1.2. Although it is hoped that the in-progress SVG 2 specification is a more realistic target for implementations, until that specification is ready, user agents that implement SVG must do so with the following willful violations and additions. [SVG] [SVGTINY12] [SVG2]

User agents that implement SVG must not implement the following features from SVG 1.1:

The tref element
The cursor element (use CSS's cursor property instead)
The font-defining SVG elements: font, glyph, missing-glyph, hkern, vkern, font-face, font-face-src, font-face-uri, font-face-format, and font-face-name (use CSS's @font-face instead)
The externalResourcesRequired attribute
The enable-background property
The contentScriptType and contentStyleType attributes (use the type attribute on the SVG script and style elements instead)
User agents that implement SVG must implement the following features from SVG Tiny 1.2:

The non-scaling-stroke value for the vector-effect property
The class attribute is allowed on all SVG elements
The tabindex attribute is allowed on visible SVG elements
The ARIA accessibility attributes are allowed on all SVG elements
The following features are defined in the SVG specifications:

SVGImageElement interface
SVGScriptElement interface
SVGSVGElement interface
SVG desc element
SVG foreignObject element
SVG image element
SVG script element
SVG svg element
SVG title element
SVG use element
Filter Effects
The following feature is defined in the Filter Effects specification: [FILTERS]

<filter-function-list>
Worklets
The following feature is defined in the Worklets specification: [WORKLETS]

WorkletGlobalScope
This specification does not require support of any particular network protocol, style sheet language, scripting language, or any of the DOM specifications beyond those required in the list above. However, the language described by this specification is biased towards CSS as the styling language, JavaScript as the scripting language, and HTTP as the network protocol, and several features assume that those languages and protocols are in use.

A user agent that implements the HTTP protocol must implement HTTP State Management Mechanism (Cookies) as well. [HTTP] [COOKIES]

This specification might have certain additional requirements on character encodings, image formats, audio formats, and video formats in the respective sections.

2.1.10 Extensibility
Vendor-specific proprietary user agent extensions to this specification are strongly discouraged. Documents must not use such extensions, as doing so reduces interoperability and fragments the user base, allowing only users of specific user agents to access the content in question.

All extensions must be defined so that the use of extensions neither contradicts nor causes the non-conformance of functionality defined in the specification.

For example, while strongly discouraged from doing so, an implementation could add a new IDL attribute "typeTime" to a control that returned the time it took the user to select the current value of a control (say). On the other hand, defining a new control that appears in a form's elements array would be in violation of the above requirement, as it would violate the definition of elements given in this specification.

When vendor-neutral extensions to this specification are needed, either this specification can be updated accordingly, or an extension specification can be written that overrides the requirements in this specification. When someone applying this specification to their activities decides that they will recognize the requirements of such an extension specification, it becomes an applicable specification for the purposes of conformance requirements in this specification.

Someone could write a specification that defines any arbitrary byte stream as conforming, and then claim that their random junk is conforming. However, that does not mean that their random junk actually is conforming for everyone's purposes: if someone else decides that that specification does not apply to their work, then they can quite legitimately say that the aforementioned random junk is just that, junk, and not conforming at all. As far as conformance goes, what matters in a particular community is what that community agrees is applicable.

User agents must treat elements and attributes that they do not understand as semantically neutral; leaving them in the DOM (for DOM processors), and styling them according to CSS (for CSS processors), but not inferring any meaning from them.

When support for a feature is disabled (e.g. as an emergency measure to mitigate a security problem, or to aid in development, or for performance reasons), user agents must act as if they had no support for the feature whatsoever, and as if the feature was not mentioned in this specification. For example, if a particular feature is accessed via an attribute in a Web IDL interface, the attribute itself would be omitted from the objects that implement that interface — leaving the attribute on the object but making it return null or throw an exception is insufficient.

2.1.11 Interactions with XPath and XSLT

Spec bugs: 18460

Implementations of XPath 1.0 that operate on HTML documents parsed or created in the manners described in this specification (e.g. as part of the document.evaluate() API) must act as if the following edit was applied to the XPath 1.0 specification.

First, remove this paragraph:

A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. This is the same way expansion is done for element type names in start and end-tags except that the default namespace declared with xmlns is not used: if the QName does not have a prefix, then the namespace URI is null (this is the same way attribute names are expanded). It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.

Then, insert in its place the following:

A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. If the QName has a prefix, then there must be a namespace declaration for this prefix in the expression context, and the corresponding namespace URI is the one that is associated with this prefix. It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.

If the QName has no prefix and the principal node type of the axis is element, then the default element namespace is used. Otherwise if the QName has no prefix, the namespace URI is null. The default element namespace is a member of the context for the XPath expression. The value of the default element namespace when executing an XPath expression through the DOM3 XPath API is determined in the following way:

If the context node is from an HTML DOM, the default element namespace is "http://www.w3.org/1999/xhtml".
Otherwise, the default element namespace URI is null.
This is equivalent to adding the default element namespace feature of XPath 2.0 to XPath 1.0, and using the HTML namespace as the default element namespace for HTML documents. It is motivated by the desire to have implementations be compatible with legacy HTML content while still supporting the changes that this specification introduces to HTML regarding the namespace used for HTML elements, and by the desire to use XPath 1.0 rather than XPath 2.0.

This change is a willful violation of the XPath 1.0 specification, motivated by desire to have implementations be compatible with legacy content while still supporting the changes that this specification introduces to HTML regarding which namespace is used for HTML elements. [XPATH10]

XSLT 1.0 processors outputting to a DOM when the output method is "html" (either explicitly or via the defaulting rule in XSLT 1.0) are affected as follows:

If the transformation program outputs an element in no namespace, the processor must, prior to constructing the corresponding DOM element node, change the namespace of the element to the HTML namespace, ASCII-lowercase the element's local name, and ASCII-lowercase the names of any non-namespaced attributes on the element.

This requirement is a willful violation of the XSLT 1.0 specification, required because this specification changes the namespaces and case-sensitivity rules of HTML in a manner that would otherwise be incompatible with DOM-based XSLT transformations. (Processors that serialize the output are unaffected.) [XSLT10]

This specification does not specify precisely how XSLT processing interacts with the HTML parser infrastructure (for example, whether an XSLT processor acts as if it puts any elements into a stack of open elements). However, XSLT processors must stop parsing if they successfully complete, and must set the current document readiness first to "interactive" and then to "complete" if they are aborted.

This specification does not specify how XSLT interacts with the navigation algorithm, how it fits in with the event loop, nor how error pages are to be handled (e.g. whether XSLT errors are to replace an incremental XSLT output, or are rendered inline, etc).

There are also additional non-normative comments regarding the interaction of XSLT and HTML in the script element section, and of XSLT, XPath, and HTML in the template element section.

2.2 Case-sensitivity and string comparison
Comparing two strings in a case-sensitive manner means comparing them exactly, code point for code point.

Except where otherwise stated, string comparisons must be performed in a case-sensitive manner.

A string pattern is a prefix match for a string s when pattern is not longer than s and truncating s to pattern's length leaves the two strings as matches of each other.

2.3 Common microsyntaxes
There are various places in HTML that accept particular data types, such as dates or numbers. This section describes what the conformance criteria for content in those formats is, and how to parse them.

Implementors are strongly urged to carefully examine any third-party libraries they might consider using to implement the parsing of syntaxes described below. For example, date libraries are likely to implement error handling behavior that differs from what is required in this specification, since error-handling behavior is often not defined in specifications that describe date syntaxes similar to those used in this specification, and thus implementations tend to vary greatly in how they handle errors.

2.3.1 Common parser idioms
The White_Space characters are those that have the Unicode property "White_Space" in the Unicode PropList.txt data file. [UNICODE]

This is not to be confused with the "White_Space" value (abbreviated "WS") of the "Bidi_Class" property in the Unicode.txt data file.

Some of the micro-parsers described below follow the pattern of having an input variable that holds the string being parsed, and having a position variable pointing at the next character to parse in input.

2.3.2 Boolean attributes
A number of attributes are boolean attributes. The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.

If the attribute is present, its value must either be the empty string or a value that is an ASCII case-insensitive match for the attribute's canonical name, with no leading or trailing whitespace.

The values "true" and "false" are not allowed on boolean attributes. To represent a false value, the attribute has to be omitted altogether.

Here is an example of a checkbox that is checked and disabled. The checked and disabled attributes are the boolean attributes.

<label><input type=checkbox checked name=cheese disabled> Cheese</label>
This could be equivalently written as this:

<label><input type=checkbox checked=checked name=cheese disabled=disabled> Cheese</label>
You can also mix styles; the following is still equivalent:

<label><input type='checkbox' checked name=cheese disabled=""> Cheese</label>
2.3.3 Keywords and enumerated attributes
Some attributes are defined as taking one of a finite set of keywords. Such attributes are called enumerated attributes. The keywords are each defined to map to a particular state (several keywords might map to the same state, in which case some of the keywords are synonyms of each other; additionally, some of the keywords can be said to be non-conforming, and are only in the specification for historical reasons). In addition, two default states can be given. The first is the invalid value default, the second is the missing value default.

If an enumerated attribute is specified, the attribute's value must be an ASCII case-insensitive match for one of the given keywords that are not said to be non-conforming, with no leading or trailing whitespace.

When the attribute is specified, if its value is an ASCII case-insensitive match for one of the given keywords then that keyword's state is the state that the attribute represents. If the attribute value matches none of the given keywords, but the attribute has an invalid value default, then the attribute represents that state. Otherwise, there is no default, and invalid values mean that there is no state represented.

When the attribute is not specified, if there is a missing value default state defined, then that is the state represented by the (missing) attribute. Otherwise, the absence of the attribute means that there is no state represented.

The empty string can be a valid keyword.

2.3.4 Numbers
2.3.4.1 Signed integers
A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a U+002D HYPHEN-MINUS character (-).

A valid integer without a U+002D HYPHEN-MINUS (-) prefix represents the number that is represented in base ten by that string of digits. A valid integer with a U+002D HYPHEN-MINUS (-) prefix represents the number represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS, subtracted from zero.

The rules for parsing integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Let sign have the value "positive".

Skip ASCII whitespace within input given position.

If position is past the end of input, return an error.

If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-):

Let sign be "negative".
Advance position to the next character.
If position is past the end of input, return an error.
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):

Advance position to the next character. (The "+" is ignored, but it is not conforming.)
If position is past the end of input, return an error.
If the character indicated by position is not an ASCII digit, then return an error.

Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Let value be that integer.

If sign is "positive", return value, otherwise return the result of subtracting value from zero.

2.3.4.2 Non-negative integers
A string is a valid non-negative integer if it consists of one or more ASCII digits.

A valid non-negative integer represents the number that is represented in base ten by that string of digits.

The rules for parsing non-negative integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.

Let input be the string being parsed.

Let value be the result of parsing input using the rules for parsing integers.

If value is an error, return an error.

If value is less than zero, return an error.

Return value.

2.3.4.3 Floating-point numbers
A string is a valid floating-point number if it consists of:

Optionally, a U+002D HYPHEN-MINUS character (-).
One or both of the following, in the given order:
A series of one or more ASCII digits.
Both of the following, in the given order:
A single U+002E FULL STOP character (.).
A series of one or more ASCII digits.
Optionally:
Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E).
Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character (+).
A series of one or more ASCII digits.
A valid floating-point number represents the number obtained by multiplying the significand by ten raised to the power of the exponent, where the significand is the first number, interpreted as base ten (including the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative number if the whole string starts with a U+002D HYPHEN-MINUS character (-) and the number is not zero), and where the exponent is the number after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS character (-) between the E and the number and the number is not zero, or else ignoring a U+002B PLUS SIGN character (+) between the E and the number if there is one). If there is no E, then the exponent is treated as zero.

The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.

The valid floating-point number concept is typically only used to restrict what is allowed for authors, while the user agent requirements use the rules for parsing floating-point number values below (e.g., the max attribute of the progress element). However, in some cases the user agent requirements include checking if a string is a valid floating-point number (e.g., the value sanitization algorithm for the Number state of the input element, or the parse a srcset attribute algorithm).

The best representation of the number n as a floating-point number is the string obtained from running ToString(n). The abstract operation ToString is not uniquely determined. When there are multiple possible strings that could be obtained from ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).

The rules for parsing floating-point number values are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Let value have the value 1.

Let divisor have the value 1.

Let exponent have the value 1.

Skip ASCII whitespace within input given position.

If position is past the end of input, return an error.

If the character indicated by position is a U+002D HYPHEN-MINUS character (-):

Change value and divisor to −1.
Advance position to the next character.
If position is past the end of input, return an error.
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):

Advance position to the next character. (The "+" is ignored, but it is not conforming.)
If position is past the end of input, return an error.
If the character indicated by position is a U+002E FULL STOP (.), and that is not the last character in input, and the character after the character indicated by position is an ASCII digit, then set value to zero and jump to the step labeled fraction.

If the character indicated by position is not an ASCII digit, then return an error.

Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply value by that integer.

If position is past the end of input, jump to the step labeled conversion.
Fraction: If the character indicated by position is a U+002E FULL STOP (.), run these substeps:

Advance position to the next character.

If position is past the end of input, or if the character indicated by position is not an ASCII digit, U+0065 LATIN SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER E (E), then jump to the step labeled conversion.

If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E), skip the remainder of these substeps.

Fraction loop: Multiply divisor by ten.

Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
Advance position to the next character.

If position is past the end of input, then jump to the step labeled conversion.

If the character indicated by position is an ASCII digit, jump back to the step labeled fraction loop in these substeps.

If the character indicated by position is U+0065 (e) or a U+0045 (E), then:

Advance position to the next character.

If position is past the end of input, then jump to the step labeled conversion.

If the character indicated by position is a U+002D HYPHEN-MINUS character (-):

Change exponent to −1.
Advance position to the next character.
If position is past the end of input, then jump to the step labeled conversion.

Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+):

Advance position to the next character.
If position is past the end of input, then jump to the step labeled conversion.

If the character indicated by position is not an ASCII digit, then jump to the step labeled conversion.

Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply exponent by that integer.

Multiply value by ten raised to the exponentth power.

Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values added: 21024 and −21024.

Let rounded-value be the number in S that is closest to value, selecting the number with an even significand if there are two equally close values. (The two special values 21024 and −21024 are considered to have even significands for this purpose.)

If rounded-value is 21024 or −21024, return an error.

Return rounded-value.

2.3.4.4 Percentages and lengths
The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Skip ASCII whitespace within input given position.

If position is past the end of input, return an error.

If the character indicated by position is a U+002B PLUS SIGN character (+), advance position to the next character.

If position is past the end of input, return an error.

If the character indicated by position is not an ASCII digit, then return an error.

Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Let value be that number.

If position is past the end of input, return value as a length.

If the character indicated by position is a U+002E FULL STOP character (.):

Advance position to the next character.

If position is past the end of input, or if the character indicated by position is not an ASCII digit, then return value as a length.

Let divisor have the value 1.

Fraction loop: Multiply divisor by ten.

Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
Advance position to the next character.

If position is past the end of input, then return value as a length.

If the character indicated by position is an ASCII digit, return to the step labeled fraction loop in these substeps.

If position is past the end of input, return value as a length.

If the character indicated by position is a U+0025 PERCENT SIGN character (%), return value as a percentage.

Return value as a length.

2.3.4.5 Non-zero percentages and lengths
The rules for parsing nonzero dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.

Let input be the string being parsed.

Let value be the result of parsing input using the rules for parsing dimension values.

If value is an error, return an error.

If value is zero, return an error.

If value is a percentage, return value as a percentage.

Return value as a length.

2.3.4.6 Lists of floating-point numbers
A valid list of floating-point numbers is a number of valid floating-point numbers separated by U+002C COMMA characters, with no other characters (e.g. no ASCII whitespace). In addition, there might be restrictions on the number of floating-point numbers that can be given, or on the range of values allowed.

The rules for parsing a list of floating-point numbers are as follows:

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Let numbers be an initially empty list of floating-point numbers. This list will be the result of this algorithm.

Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past any leading delimiters.

While position is not past the end of input:

Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, U+003B SEMICOLON, ASCII digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters from input given position. This skips past leading garbage.

Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position, and let unparsed number be the result.

Let number be the result of parsing unparsed number using the rules for parsing floating-point number values.

If number is an error, set number to zero.

Append number to numbers.

Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past the delimiter.

Return numbers.

2.3.4.7 Lists of dimensions
The rules for parsing a list of dimensions are as follows. These rules return a list of zero or more pairs consisting of a number and a unit, the unit being one of percentage, relative, and absolute.

Let raw input be the string being parsed.

If the last character in raw input is a U+002C COMMA character (,), then remove that character from raw input.

Split the string raw input on commas. Let raw tokens be the resulting list of tokens.

Let result be an empty list of number/unit pairs.

For each token in raw tokens, run the following substeps:

Let input be the token.

Let position be a pointer into input, initially pointing at the start of the string.

Let value be the number 0.

Let unit be absolute.

If position is past the end of input, set unit to relative and jump to the last substep.

If the character at position is an ASCII digit, collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as an integer in base ten, and increment value by that integer.

If the character at position is U+002E (.), then:

Collect a sequence of code points consisting of ASCII whitespace and ASCII digits from input given position. Let s be the resulting sequence.

Remove all ASCII whitespace in s.

If s is not the empty string, then:

Let length be the number of characters in s (after the spaces were removed).

Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.

Increment value by fraction.

Skip ASCII whitespace within input given position.

If the character at position is a U+0025 PERCENT SIGN character (%), then set unit to percentage.

Otherwise, if the character at position is a U+002A ASTERISK character (*), then set unit to relative.

Add an entry to result consisting of the number given by value and the unit given by unit.

Return the list result.

2.3.5 Dates and times
In the algorithms below, the number of days in month month of year year is: 31 if month is 1, 3, 5, 7, 8, 10, or 12; 30 if month is 4, 6, 9, or 11; 29 if month is 2 and year is a number divisible by 400, or if year is a number divisible by 4 but not by 100; and 28 otherwise. This takes into account leap years in the Gregorian calendar. [GREGORIAN]

When ASCII digits are used in the date and time syntaxes defined in this section, they express numbers in base ten.

While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines parsing rules in much more detail than ISO8601. Implementors are therefore encouraged to carefully examine any date parsing libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in exactly the same manner. [ISO8601]

Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian calendar, extrapolated backwards to year 1. A date in the proleptic Gregorian calendar, sometimes explicitly referred to as a proleptic-Gregorian date, is one that is described using that calendar even if that calendar was not in use at the time (or place) in question. [GREGORIAN]

The use of the Gregorian calendar as the wire format in this specification is an arbitrary choice resulting from the cultural biases of those involved in the decision. See also the section discussing date, time, and number formats in forms (for authors), implementation notes regarding localization of form controls, and the time element.

2.3.5.1 Months
A month consists of a specific proleptic-Gregorian date with no time-zone information and no date information beyond a year and a month. [GREGORIAN]

A string is a valid month string representing a year year and month month if it consists of the following components in the given order:

Four or more ASCII digits, representing year, where year > 0
A U+002D HYPHEN-MINUS character (-)
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
The rules to parse a month string are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a month component to obtain year and month. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Return year and month.

The rules to parse a month component, given an input string and a position, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.

If year is not a number greater than zero, then fail.

If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.

If month is not a number in the range 1 ≤ month ≤ 12, then fail.

Return year and month.

2.3.5.2 Dates
A date consists of a specific proleptic-Gregorian date with no time-zone information, consisting of a year, a month, and a day. [GREGORIAN]

A string is a valid date string representing a year year, month month, and day day if it consists of the following components in the given order:

A valid month string, representing year and month
A U+002D HYPHEN-MINUS character (-)
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and year year
The rules to parse a date string are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Let date be the date with year year, month month, and day day.

Return date.

The rules to parse a date component, given an input string and a position, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Parse a month component to obtain year and month. If this returns nothing, then fail.

Let maxday be the number of days in month month of year year.

If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.

If day is not a number in the range 1 ≤ day ≤ maxday, then fail.

Return year, month, and day.

2.3.5.3 Yearless dates
A yearless date consists of a Gregorian month and a day within that month, but with no associated year. [GREGORIAN]

A string is a valid yearless date string representing a month month and a day day if it consists of the following components in the given order:

Optionally, two U+002D HYPHEN-MINUS characters (-)
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
A U+002D HYPHEN-MINUS character (-)
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and any arbitrary leap year (e.g. 4 or 2000)
In other words, if the month is "02", meaning February, then the day can be 29, as if the year was a leap year.

The rules to parse a yearless date string are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a yearless date component to obtain month and day. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Return month and day.

The rules to parse a yearless date component, given an input string and a position, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Collect a sequence of code points that are U+002D HYPHEN-MINUS characters (-) from input given position. If the collected sequence is not exactly zero or two characters long, then fail.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.

If month is not a number in the range 1 ≤ month ≤ 12, then fail.

Let maxday be the number of days in month month of any arbitrary leap year (e.g. 4 or 2000).

If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.

If day is not a number in the range 1 ≤ day ≤ maxday, then fail.

Return month and day.

2.3.5.4 Times
A time consists of a specific time with no time-zone information, consisting of an hour, a minute, a second, and a fraction of a second.

A string is a valid time string representing an hour hour, a minute minute, and a second second if it consists of the following components in the given order:

Two ASCII digits, representing hour, in the range 0 ≤ hour ≤ 23
A U+003A COLON character (:)
Two ASCII digits, representing minute, in the range 0 ≤ minute ≤ 59
If second is nonzero, or optionally if second is zero:
A U+003A COLON character (:)
Two ASCII digits, representing the integer part of second, in the range 0 ≤ s ≤ 59
If second is not an integer, or optionally if second is an integer:
A U+002E FULL STOP character (.)
One, two, or three ASCII digits, representing the fractional part of second
The second component cannot be 60 or 61; leap seconds cannot be represented.

The rules to parse a time string are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Let time be the time with hour hour, minute minute, and second second.

Return time.

The rules to parse a time component, given an input string and a position, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the hour.

If hour is not a number in the range 0 ≤ hour ≤ 23, then fail.
If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the minute.

If minute is not a number in the range 0 ≤ minute ≤ 59, then fail.
Let second be 0.

If position is not beyond the end of input and the character at position is U+003A (:), then:

Advance position to the next character in input.

If position is beyond the end of input, or at the last character in input, or if the next two characters in input starting at position are not both ASCII digits, then fail.

Collect a sequence of code points that are either ASCII digits or U+002E FULL STOP characters from input given position. If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, interpret the resulting sequence as a base-ten number (possibly with a fractional part). Set second to that number.

If second is not a number in the range 0 ≤ second < 60, then fail.

Return hour, minute, and second.

2.3.5.5 Local dates and times
A local date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, but expressed without a time zone. [GREGORIAN]

A string is a valid local date and time string representing a date and time if it consists of the following components in the given order:

A valid date string representing the date
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
A valid time string representing the time
A string is a valid normalized local date and time string representing a date and time if it consists of the following components in the given order:

A valid date string representing the date
A U+0054 LATIN CAPITAL LETTER T character (T)
A valid time string representing the time, expressed as the shortest possible string for the given time (e.g. omitting the seconds component entirely if the given time is zero seconds past the minute)
The rules to parse a local date and time string are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.

Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Let date be the date with year year, month month, and day day.

Let time be the time with hour hour, minute minute, and second second.

Return date and time.

2.3.5.6 Time zones
A time-zone offset consists of a signed number of hours and minutes.

A string is a valid time-zone offset string representing a time-zone offset if it consists of either:

A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC

Or, the following components, in the given order:

Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero, a U+002D HYPHEN-MINUS character (-), representing the sign of the time-zone offset
Two ASCII digits, representing the hours component hour of the time-zone offset, in the range 0 ≤ hour ≤ 23
Optionally, a U+003A COLON character (:)
Two ASCII digits, representing the minutes component minute of the time-zone offset, in the range 0 ≤ minute ≤ 59
This format allows for time-zone offsets from -23:59 to +23:59. Right now, in practice, the range of offsets of actual time zones is -12:00 to +14:00, and the minutes component of offsets of actual time zones is always either 00, 30, or 45. There is no guarantee that this will remain so forever, however, since time zones are used as political footballs and are thus subject to very whimsical policy decisions.

See also the usage notes and examples in the global date and time section below for details on using time-zone offsets with historical times that predate the formation of formal time zones.

The rules to parse a time-zone offset string are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Return the time-zone offset that is timezonehours hours and timezoneminutes minutes from UTC.

The rules to parse a time-zone offset component, given an input string and a position, are as follows. This will return either time-zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:

Let timezonehours be 0.

Let timezoneminutes be 0.

Advance position to the next character in input.

Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D HYPHEN-MINUS (-), then:

If the character at position is a U+002B PLUS SIGN (+), let sign be "positive". Otherwise, it's a U+002D HYPHEN-MINUS (-); let sign be "negative".

Advance position to the next character in input.

Collect a sequence of code points that are ASCII digits from input given position. Let s be the collected sequence.

If s is exactly two characters long, then:

Interpret s as a base-ten integer. Let that number be the timezonehours.

If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the timezoneminutes.

If s is exactly four characters long, then:

Interpret the first two characters of s as a base-ten integer. Let that number be the timezonehours.

Interpret the last two characters of s as a base-ten integer. Let that number be the timezoneminutes.

Otherwise, fail.

If timezonehours is not a number in the range 0 ≤ timezonehours ≤ 23, then fail.
If sign is "negative", then negate timezonehours.
If timezoneminutes is not a number in the range 0 ≤ timezoneminutes ≤ 59, then fail.
If sign is "negative", then negate timezoneminutes.
Otherwise, fail.

Return timezonehours and timezoneminutes.

2.3.5.7 Global dates and times
A global date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, expressed with a time-zone offset, consisting of a signed number of hours and minutes. [GREGORIAN]

A string is a valid global date and time string representing a date, time, and a time-zone offset if it consists of the following components in the given order:

A valid date string representing the date
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
A valid time string representing the time
A valid time-zone offset string representing the time-zone offset
Times in dates before the formation of UTC in the mid twentieth century must be expressed and interpreted in terms of UT1 (contemporary Earth solar time at the 0° longitude), not UTC (the approximation of UT1 that ticks in SI seconds). Time before the formation of time zones must be expressed and interpreted as UT1 times with explicit time zones that approximate the contemporary difference between the appropriate local time and the time observed at the location of Greenwich, London.

The following are some examples of dates written as valid global date and time strings.

"0037-12-13 00:00Z"
Midnight in areas using London time on the birthday of Nero (the Roman Emperor). See below for further discussion on which date this actually corresponds to.
"1979-10-14T12:00:00.001-04:00"
One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the USA during daylight saving time.
"8592-01-01T02:09+02:09"
Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.
Several things are notable about these dates:

Years with fewer than four digits have to be zero-padded. The date "37-12-13" would not be a valid date.
If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21  12:00Z" (with two spaces between the components) would not be parsed successfully.
To unambiguously identify a moment in time prior to the introduction of the Gregorian calendar (insofar as moments in time before the formation of UTC can be unambiguously identified), the date has to be first converted to the Gregorian calendar from the calendar in use at the time (e.g. from the Julian calendar). The date of Nero's birth is the 15th of December 37, in the Julian Calendar, which is the 13th of December 37 in the proleptic Gregorian calendar.
The time and time-zone offset components are not optional.
Dates before the year one can't be represented as a datetime in this version of HTML.
Times of specific events in ancient times are, at best, approximations, since time was not well coordinated or measured until relatively recent decades.
Time-zone offsets differ based on daylight saving time.
The rules to parse a global date and time string are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.

Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

If position is beyond the end of input, then fail.

Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

Let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes. That moment in time is a moment in the UTC time zone.

Let timezone be timezonehours hours and timezoneminutes minutes from UTC.

Return time and timezone.

2.3.5.8 Weeks
A week consists of a week-year number and a week number representing a seven-day period starting on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods, as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969 (1969-12-29) is defined as week number 1 in week-year 1970. Consecutive weeks are numbered sequentially. The week before the number 1 week in a week-year is the last week in the previous week-year, and vice versa. [GREGORIAN]

A week-year with a number year has 53 weeks if it corresponds to either a year year in the proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year year in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st) and where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other week-years have 52 weeks.

The week number of the last day of a week-year with 53 weeks is 53; the week number of the last day of a week-year with 52 weeks is 52.

The week-year number of a particular day can be different than the number of the year that contains that day in the proleptic Gregorian calendar. The first week in a week-year y is the week that contains the first Thursday of the Gregorian year y.

For modern purposes, a week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]

A string is a valid week string representing a week-year year and week week if it consists of the following components in the given order:

Four or more ASCII digits, representing year, where year > 0
A U+002D HYPHEN-MINUS character (-)
A U+0057 LATIN CAPITAL LETTER W character (W)
Two ASCII digits, representing the week week, in the range 1 ≤ week ≤ maxweek, where maxweek is the week number of the last day of week-year year
The rules to parse a week string are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.

If year is not a number greater than zero, then fail.

If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.

If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL LETTER W character (W), then fail. Otherwise, move position forwards one character.

Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the week.

Let maxweek be the week number of the last day of year year.

If week is not a number in the range 1 ≤ week ≤ maxweek, then fail.

If position is not beyond the end of input, then fail.

Return the week-year number year and the week number week.

2.3.5.9 Durations
A duration consists of a number of seconds.

Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a period whose exact length depends on the precise day from which it is measured) a duration as defined in this specification cannot include months (or years, which are equivalent to twelve months). Only durations that describe a specific number of seconds can be described.

A string is a valid duration string representing a duration t if it consists of either of the following:

A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents, in the order given, where the number of days, hours, minutes, and seconds corresponds to the same number of seconds as in t:

One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a number of days.

A U+0054 LATIN CAPITAL LETTER T character followed by one or more of the following subcomponents, in the order given:

One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing a number of hours.

One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing a number of minutes.

The following components:

One or more ASCII digits, representing a number of seconds.

Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.

A U+0053 LATIN CAPITAL LETTER S character.

This, as with a number of other date- and time-related microsyntaxes defined in this specification, is based on one of the formats defined in ISO 8601. [ISO8601]

One or more duration time components, each with a different duration time component scale, in any order; the sum of the represented seconds being equal to the number of seconds in t.

A duration time component is a string consisting of the following components:

Zero or more ASCII whitespace.

One or more ASCII digits, representing a number of time units, scaled by the duration time component scale specified (see below) to represent a number of seconds.

If the duration time component scale specified is 1 (i.e. the units are seconds), then, optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.

Zero or more ASCII whitespace.

One of the following characters, representing the duration time component scale of the time unit used in the numeric part of the duration time component:

U+0057 LATIN CAPITAL LETTER W character
U+0077 LATIN SMALL LETTER W character
Weeks. The scale is 604800.
U+0044 LATIN CAPITAL LETTER D character
U+0064 LATIN SMALL LETTER D character
Days. The scale is 86400.
U+0048 LATIN CAPITAL LETTER H character
U+0068 LATIN SMALL LETTER H character
Hours. The scale is 3600.
U+004D LATIN CAPITAL LETTER M character
U+006D LATIN SMALL LETTER M character
Minutes. The scale is 60.
U+0053 LATIN CAPITAL LETTER S character
U+0073 LATIN SMALL LETTER S character
Seconds. The scale is 1.
Zero or more ASCII whitespace.

This is not based on any of the formats in ISO 8601. It is intended to be a more human-readable alternative to the ISO 8601 duration format.

The rules to parse a duration string are as follows. This will return either a duration or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Let months, seconds, and component count all be zero.

Let M-disambiguator be minutes.

This flag's other value is months. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.

Skip ASCII whitespace within input given position.

If position is past the end of input, then fail.

If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character, then advance position to the next character, set M-disambiguator to months, and skip ASCII whitespace within input given position.

While true:

Let units be undefined. It will be assigned one of the following values: years, months, weeks, days, hours, minutes, and seconds.

Let next character be undefined. It is used to process characters from the input.

If position is past the end of input, then break.

If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then advance position to the next character, set M-disambiguator to minutes, skip ASCII whitespace within input given position, and continue.

Set next character to the character in input pointed to by position.

If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position. That is taken care of below.)

Otherwise, if next character is an ASCII digit, then collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as a base-ten integer, and let N be that number.

Otherwise next character is not part of a number; fail.

If position is past the end of input, then fail.

Set next character to the character in input pointed to by position, and this time advance position to the next character. (If next character was a U+002E FULL STOP character (.) before, it will still be that character this time.)

If next character is U+002E (.), then:

Collect a sequence of code points that are ASCII digits from input given position. Let s be the resulting sequence.

If s is the empty string, then fail.

Let length be the number of characters in s.

Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.

Increment N by fraction.

Skip ASCII whitespace within input given position.

If position is past the end of input, then fail.

Set next character to the character in input pointed to by position, and advance position to the next character.

If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL LETTER S character, then fail.

Set units to seconds.

Otherwise:

If next character is ASCII whitespace, then skip ASCII whitespace within input given position, set next character to the character in input pointed to by position, and advance position to the next character.

If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y character, set units to years and set M-disambiguator to months.

If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is months, then set units to months.

If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set units to weeks and set M-disambiguator to minutes.

If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set units to days and set M-disambiguator to minutes.

If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set units to hours and set M-disambiguator to minutes.

If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is minutes, then set units to minutes.

If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set units to seconds and set M-disambiguator to minutes.

Otherwise if next character is none of the above characters, then fail.

Increment component count.

Let multiplier be 1.

If units is years, multiply multiplier by 12 and set units to months.

If units is months, add the product of N and multiplier to months.

Otherwise:

If units is weeks, multiply multiplier by 7 and set units to days.

If units is days, multiply multiplier by 24 and set units to hours.

If units is hours, multiply multiplier by 60 and set units to minutes.

If units is minutes, multiply multiplier by 60 and set units to seconds.

Forcibly, units is now seconds. Add the product of N and multiplier to seconds.

Skip ASCII whitespace within input given position.

If component count is zero, fail.

If months is not zero, fail.

Return the duration consisting of seconds seconds.

2.3.5.10 Vaguer moments in time
A string is a valid date string with optional time if it is also one of the following:

A valid date string
A valid global date and time string
The rules to parse a date or time string are as follows. The algorithm will return either a date, a time, a global date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

Let input be the string being parsed.

Let position be a pointer into input, initially pointing at the start of the string.

Set start position to the same position as position.

Set the date present and time present flags to true.

Parse a date component to obtain year, month, and day. If this fails, then set the date present flag to false.

If date present is true, and position is not beyond the end of input, and the character at position is either a U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character, then advance position to the next character in input.

Otherwise, if date present is true, and either position is beyond the end of input or the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then set time present to false.

Otherwise, if date present is false, set position back to the same position as start position.

If the time present flag is true, then parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

If the date present and time present flags are both true, but position is beyond the end of input, then fail.

If the date present and time present flags are both true, parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.

If position is not beyond the end of input, then fail.

If the date present flag is true and the time present flag is false, then let date be the date with year year, month month, and day day, and return date.

Otherwise, if the time present flag is true and the date present flag is false, then let time be the time with hour hour, minute minute, and second second, and return time.

Otherwise, let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes, that moment in time being a moment in the UTC time zone; let timezone be timezonehours hours and timezoneminutes minutes from UTC; and return time and timezone.

2.3.6 Colors
A simple color consists of three 8-bit numbers in the range 0..255, representing the red, green, and blue components of the color respectively, in the sRGB color space. [SRGB]

A string is a valid simple color if it is exactly seven characters long, and the first character is a U+0023 NUMBER SIGN character (#), and the remaining six characters are all ASCII hex digits, with the first two digits representing the red component, the middle two digits representing the green component, and the last two digits representing the blue component, in hexadecimal.

A string is a valid lowercase simple color if it is a valid simple color and doesn't use any characters in the range U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL LETTER F.

The rules for parsing simple color values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.

Let input be the string being parsed.

If input is not exactly seven characters long, then return an error.

If the first character in input is not a U+0023 NUMBER SIGN character (#), then return an error.

If the last six characters of input are not all ASCII hex digits, then return an error.

Let result be a simple color.

Interpret the second and third characters as a hexadecimal number and let the result be the red component of result.

Interpret the fourth and fifth characters as a hexadecimal number and let the result be the green component of result.

Interpret the sixth and seventh characters as a hexadecimal number and let the result be the blue component of result.

Return result.

The rules for serializing simple color values given a simple color are as given in the following algorithm:

Let result be a string consisting of a single U+0023 NUMBER SIGN character (#).

Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using ASCII lower hex digits, zero-padding if necessary, and append these numbers to result, in the order red, green, blue.

Return result, which will be a valid lowercase simple color.

Some obsolete legacy attributes parse colors in a more complicated manner, using the rules for parsing a legacy color value, which are given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.

Let input be the string being parsed.

If input is the empty string, then return an error.

Strip leading and trailing ASCII whitespace from input.

If input is an ASCII case-insensitive match for the string "transparent", then return an error.

If input is an ASCII case-insensitive match for one of the named colors, then return the simple color corresponding to that keyword. [CSSCOLOR]

CSS2 System Colors are not recognized.

If input is four characters long, and the first character in input is U+0023 (#), and the last three characters of input are all ASCII hex digits, then:

Let result be a simple color.

Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting number multiplied by 17.

Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting number multiplied by 17.

Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting number multiplied by 17.

Return result.

Replace any characters in input that have a code point greater than U+FFFF (i.e., any characters that are not in the basic multilingual plane) with the two-character string "00".

If input is longer than 128 characters, truncate input, leaving only the first 128 characters.

If the first character in input is a U+0023 NUMBER SIGN character (#), remove it.

Replace any character in input that is not an ASCII hex digit with the character U+0030 DIGIT ZERO (0).

While input's length is zero or not a multiple of three, append a U+0030 DIGIT ZERO (0) character to input.

Split input into three strings of equal length, to obtain three components. Let length be the length of those components (one third the length of input).

If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.

While length is greater than two and the first character in each component is a U+0030 DIGIT ZERO (0) character, remove that character and reduce length by one.

If length is still greater than two, truncate each component, leaving only the first two characters in each.

Let result be a simple color.

Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.

Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.

Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.

Return result.

The 2D graphics context has a separate color syntax that also handles opacity.

2.3.7 Space-separated tokens
A set of space-separated tokens is a string containing zero or more words (known as tokens) separated by one or more ASCII whitespace, where words consist of any string of one or more characters, none of which are ASCII whitespace.

A string containing a set of space-separated tokens may have leading or trailing ASCII whitespace.

An unordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated.

An ordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated but where the order of the tokens is meaningful.

Sets of space-separated tokens sometimes have a defined set of allowed values. When a set of allowed values is defined, the tokens must all be from that list of allowed values; other values are non-conforming. If no such set of allowed values is provided, then all values are conforming.

How tokens in a set of space-separated tokens are to be compared (e.g. case-sensitively or not) is defined on a per-set basis.

2.3.8 Comma-separated tokens
A set of comma-separated tokens is a string containing zero or more tokens each separated from the next by a single U+002C COMMA character (,), where tokens consist of any string of zero or more characters, neither beginning nor ending with ASCII whitespace, nor containing any U+002C COMMA characters (,), and optionally surrounded by ASCII whitespace.

For instance, the string " a ,b,,d d " consists of four tokens: "a", "b", the empty string, and "d d". Leading and trailing whitespace around each token doesn't count as part of the token, and the empty string can be a token.

Sets of comma-separated tokens sometimes have further restrictions on what consists a valid token. When such restrictions are defined, the tokens must all fit within those restrictions; other values are non-conforming. If no such restrictions are specified, then all values are conforming.

2.3.9 References
A valid hash-name reference to an element of type type is a string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches the value of the name attribute of an element with type type in the same tree.

The rules for parsing a hash-name reference to an element of type type, given a context node scope, are as follows:

If the string being parsed does not contain a U+0023 NUMBER SIGN character, or if the first such character in the string is the last character in the string, then return null.

Let s be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed up to the end of that string.

Return the first element of type type in scope's tree, in tree order, that has an id or name attribute whose value is s, or null if there is no such element.

Although id attributes are accounted for when parsing, they are not used in determining whether a value is a valid hash-name reference. That is, a hash-name reference that refers to an element based on id is a conformance error (unless that element also has a name attribute with the same value).

2.3.10 Media queries
A string is a valid media query list if it matches the <media-query-list> production of the Media Queries specification. [MQ]

A string matches the environment of the user if it is the empty string, a string consisting of only ASCII whitespace, or is a media query list that matches the user's environment according to the definitions given in the Media Queries specification. [MQ]

2.4 URLs
2.4.1 Terminology
A string is a valid non-empty URL if it is a valid URL string but it is not the empty string.

A string is a valid URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid URL string.

A string is a valid non-empty URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid non-empty URL.

This specification defines the URL about:legacy-compat as a reserved, though unresolvable, about: URL, for use in DOCTYPEs in HTML documents when needed for compatibility with XML tools. [ABOUT]

This specification defines the URL about:html-kind as a reserved, though unresolvable, about: URL, that is used as an identifier for kinds of media tracks. [ABOUT]

This specification defines the URL about:srcdoc as a reserved, though unresolvable, about: URL, that is used as the URL of iframe srcdoc documents. [ABOUT]

The fallback base URL of a Document object document is the URL record obtained by running these steps:

If document is an iframe srcdoc document, then return the document base URL of document's browsing context's browsing context container's node document.

If document's URL is about:blank, and document's browsing context has a creator browsing context, then return the creator base URL.

Return document's URL.

The document base URL of a Document object is the absolute URL obtained by running these steps:

If there is no base element that has an href attribute in the Document, then return the Document's fallback base URL.

Otherwise, return the frozen base URL of the first base element in the Document that has an href attribute, in tree order.

2.4.2 Parsing URLs
Parsing a URL is the process of taking a string and obtaining the URL record that it represents. While this process is defined in the WHATWG URL standard, the HTML standard defines a wrapper for convenience. [URL]

This wrapper is only useful when the character encoding for the URL parser has to match that of the document or environment settings object for legacy reasons. When that is not the case the URL parser can be used directly.

To parse a URL url, relative to either a document or environment settings object, the user agent must use the following steps. Parsing a URL either results in failure or a resulting URL string and resulting URL record.

Let encoding be document's character encoding, if document was given, and environment settings object's API URL character encoding otherwise.

Let baseURL be document's base URL, if document was given, and environment settings object's API base URL otherwise.

Let urlRecord be the result of applying the URL parser to url, with baseURL and encoding.

If urlRecord is failure, then return failure.

Let urlString be the result of applying the URL serializer to urlRecord.

Return urlString as the resulting URL string and urlRecord as the resulting URL record.

2.4.3 Dynamic changes to base URLs
When a document's document base URL changes, all elements in that document are affected by a base URL change.

The following are base URL change steps, which run when an element is affected by a base URL change (as defined by the DOM specification):

If the element creates a hyperlink
If the URL identified by the hyperlink is being shown to the user, or if any data derived from that URL is affecting the display, then the href attribute should be reparsed relative to the element's node document and the UI updated appropriately.

For example, the CSS :link/:visited pseudo-classes might have been affected.

If the hyperlink has a ping attribute and its URL(s) are being shown to the user, then the ping attribute's tokens should be reparsed relative to the element's node document and the UI updated appropriately.

If the element is a q, blockquote, ins, or del element with a cite attribute
If the URL identified by the cite attribute is being shown to the user, or if any data derived from that URL is affecting the display, then the URL should be reparsed relative to the element's node document and the UI updated appropriately.

Otherwise
The element is not directly affected.

For instance, changing the base URL doesn't affect the image displayed by img elements, although subsequent accesses of the src IDL attribute from script will return a new absolute URL that might no longer correspond to the image being shown.

2.5 Fetching resources

Spec bugs: 11235

2.5.1 Terminology
A response whose type is "basic", "cors", or "default" is CORS-same-origin. [FETCH]

A response whose type is "opaque" or "opaqueredirect" is CORS-cross-origin.

A response's unsafe response is its internal response if it has one, and the response itself otherwise.

To create a potential-CORS request, given a url, destination, corsAttributeState, and an optional same-origin fallback flag, run these steps:

Let mode be "no-cors" if corsAttributeState is No CORS, and "cors" otherwise.

If same-origin fallback flag is set and mode is "no-cors", set mode to "same-origin".

Let credentialsMode be "include".

If corsAttributeState is Anonymous, set credentialsMode to "same-origin".

Let request be a new request whose url is url, destination is destination, mode is mode, credentials mode is credentialsMode, and whose use-URL-credentials flag is set.

2.5.2 Determining the type of a resource
The Content-Type metadata of a resource must be obtained and interpreted in a manner consistent with the requirements of the WHATWG MIME Sniffing standard. [MIMESNIFF]

The computed MIME type of a resource must be found in a manner consistent with the requirements given in the WHATWG MIME Sniffing standard. [MIMESNIFF]

The rules for sniffing images specifically, the rules for distinguishing if a resource is text or binary, and the rules for sniffing audio and video specifically are also defined in the WHATWG MIME Sniffing standard. These rules return a MIME type as their result. [MIMESNIFF]

It is imperative that the rules in the WHATWG MIME Sniffing standard be followed exactly. When a user agent uses different heuristics for content type detection than the server expects, security problems can occur. For more details, see the WHATWG MIME Sniffing standard. [MIMESNIFF]

2.5.3 Extracting character encodings from meta elements
The algorithm for extracting a character encoding from a meta element, given a string s, is as follows. It either returns a character encoding or nothing.

Let position be a pointer into s, initially pointing at the start of the string.

Loop: Find the first seven characters in s after position that are an ASCII case-insensitive match for the word "charset". If no such match is found, return nothing.

Skip any ASCII whitespace that immediately follow the word "charset" (there might not be any).

If the next character is not a U+003D EQUALS SIGN (=), then move position to point just before that next character, and jump back to the step labeled loop.

Skip any ASCII whitespace that immediately follow the equals sign (there might not be any).

Process the next character as follows:

If it is a U+0022 QUOTATION MARK character (") and there is a later U+0022 QUOTATION MARK character (") in s
If it is a U+0027 APOSTROPHE character (') and there is a later U+0027 APOSTROPHE character (') in s
Return the result of getting an encoding from the substring that is between this character and the next earliest occurrence of this character.
If it is an unmatched U+0022 QUOTATION MARK character (")
If it is an unmatched U+0027 APOSTROPHE character (')
If there is no next character
Return nothing.
Otherwise
Return the result of getting an encoding from the substring that consists of this character up to but not including the first ASCII whitespace or U+003B SEMICOLON character (;), or the end of s, whichever comes first.
This algorithm is distinct from those in the HTTP specification (for example, HTTP doesn't allow the use of single quotes and requires supporting a backslash-escape mechanism that is not supported by this algorithm). While the algorithm is used in contexts that, historically, were related to HTTP, the syntax as supported by implementations diverged some time ago. [HTTP]

2.5.4 CORS settings attributes
A CORS settings attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

Keyword	State	Brief description
anonymous	Anonymous	Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
use-credentials	Use Credentials	Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
The empty string is also a valid keyword, and maps to the Anonymous state. The attribute's invalid value default is the Anonymous state. For the purposes of reflection, the canonical case for the Anonymous state is the anonymous keyword. The missing value default, used when the attribute is omitted, is the No CORS state.

The majority of fetches governed by CORS settings attributes will be done via the create a potential-CORS request algorithm.

For module scripts, certain CORS settings attributes have been repurposed to have a slightly different meaning, wherein they only impact the request's credentials mode (since the mode is always "cors"). To perform this translation, we define the module script credentials mode for a given CORS settings attribute to be determined by switching on the attribute's state:

No CORS
"omit"
Anonymous
"same-origin"
Use Credentials
"include"
2.5.5 Referrer policy attributes
A referrer policy attribute is an enumerated attribute. Each referrer policy, including the empty string, is a keyword for this attribute, mapping to a state of the same name.

The attribute's invalid value default and missing value default are both the empty string state.

The impact of these states on the processing model of various fetches is defined in more detail throughout this specification, in the WHATWG Fetch standard, and in Referrer Policy. [FETCH] [REFERRERPOLICY]

Several signals can contribute to which processing model is used for a given fetch; a referrer policy attribute is only one of them. In general, the order in which these signals are processed are:

First, the presence of a noreferrer link type;

Then, the value of a referrer policy attribute;

Then, the presence of any meta element with name attribute set to referrer.

Finally, the `Referrer-Policy` HTTP header.

2.5.6 Nonce attributes
A nonce content attribute represents a cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether or not a given fetch will be allowed to proceed. The value is text. [CSP]

Elements that have a nonce content attribute ensure that the crytographic nonce is only exposed to script (and not to side-channels like CSS attribute selectors) by extracting the value from the content attribute, moving it into an internal slot named [[CryptographicNonce]], and exposing it to script via the NoncedElement interface defined below. Unless otherwise specified, the slot's value is the empty string.

interface mixin NoncedElement {
  attribute DOMString nonce;
};
element . nonce
Returns the value of the element's [[CryptographicNonce]] internal slot.

Can be set, to update that slot's value.

The nonce IDL attribute must, on getting, return the value of this element's [[CryptographicNonce]]; and on setting, set this element's [[CryptographicNonce]] to the given value.

Whenever a NoncedElement's nonce attribute is set or changed, set this element's [[CryptographicNonce]] to the given value.

Whenever a NoncedElement becomes browsing-context connected, the user agent must executing the following steps on the element:

Let CSP list be element's shadow-including root's CSP list.

If CSP list contains a header-delivered Content Security Policy, and element has a nonce content attribute attr whose value is not the empty string, then:

Set an attribute value for element using "nonce" and the empty string.

As each Document's CSP list is append-only, user agents can optimize away the contains a header-delivered Content Security Policy check by, for example, holding a flag on the Document, set during Document initialization.

The cloning steps for elements that implement NoncedElement must set the [[CryptographicNonce]] slot on the copy to the value of the slot on the element being cloned.

2.6 Common DOM interfaces
2.6.1 Reflecting content attributes in IDL attributes
Some IDL attributes are defined to reflect a particular content attribute. This means that on getting, the IDL attribute returns the current value of the content attribute, and on setting, the IDL attribute changes the value of the content attribute to the given value.

In general, on getting, if the content attribute is not present, the IDL attribute must act as if the content attribute's value is the empty string; and on setting, if the content attribute is not present, it must first be added.

If a reflecting IDL attribute is a USVString attribute whose content attribute is defined to contain a URL, then on getting, if the content attribute is absent, the IDL attribute must return the empty string. Otherwise, the IDL attribute must parse the value of the content attribute relative to the element's node document and if that is successful, return the resulting URL string. If parsing fails, then the value of the content attribute must be returned instead, converted to a USVString. On setting, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a DOMString attribute whose content attribute is an enumerated attribute, and the IDL attribute is limited to only known values, then, on getting, the IDL attribute must return the conforming value associated with the state the attribute is in (in its canonical case), if any, or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is not in a defined state (e.g. the attribute is missing and there is no missing value default). On setting, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a nullable DOMString attribute whose content attribute is an enumerated attribute, then, on getting, if the corresponding content attribute is in its missing value default then the IDL attribute must return null, otherwise, the IDL attribute must return the conforming value associated with the state the attribute is in (in its canonical case). On setting, if the new value is null, the content attribute must be removed, and otherwise, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a DOMString or USVString attribute but doesn't fall into any of the above categories, then the getting and setting must be done in a transparent, case-preserving manner.

If a reflecting IDL attribute is a boolean attribute, then on getting the IDL attribute must return true if the content attribute is set, and false if it is absent. On setting, the content attribute must be removed if the IDL attribute is set to false, and must be set to the empty string if the IDL attribute is set to true. (This corresponds to the rules for boolean content attributes.)

If a reflecting IDL attribute has a signed integer type (long) then, on getting, the content attribute must be parsed according to the rules for parsing signed integers, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, then the default value must be returned instead, or 0 if there is no default value. On setting, the given value must be converted to the shortest possible string representing the number as a valid integer and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has a signed integer type (long) that is limited to only non-negative numbers then, on getting, the content attribute must be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or −1 if there is no default value. On setting, if the value is negative, the user agent must throw an "IndexSizeError" DOMException. Otherwise, the given value must be converted to the shortest possible string representing the number as a valid non-negative integer and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) then, on getting, the content attribute must be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 0 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0 if there is no default value. On setting, first, if the new value is in the range 0 to 2147483647, then let n be the new value, otherwise let n be the default value, or 0 if there is no default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero, then the behavior is similar to the previous case, but zero is not allowed. On getting, the content attribute must first be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 1 if there is no default value. On setting, if the value is zero, the user agent must throw an "IndexSizeError" DOMException. Otherwise, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value, or 1 if there is no default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero with fallback, then the behavior is similar to the previous case, but disallowed values are converted to the default value. On getting, the content attribute must first be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead. On setting, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is clamped to the range [min, max], then on getting, the content attribute must first be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is between min and max inclusive, the resulting value must be returned. If it fails, the default value must be returned. If it succeeds but the value is less than min, min must be returned. If it succeeds but the value is greater than max, max must be returned. On setting, it behaves the same as setting a regular reflected unsigned integer.

If a reflecting IDL attribute has a floating-point number type (double or unrestricted double), then, on getting, the content attribute must be parsed according to the rules for parsing floating-point number values, and if that is successful, the resulting value must be returned. If, on the other hand, it fails, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has a floating-point number type (double or unrestricted double) that is limited to numbers greater than zero, then the behavior is similar to the previous case, but zero and negative values are not allowed. On getting, the content attribute must be parsed according to the rules for parsing floating-point number values, and if that is successful and the value is greater than 0.0, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, if the value is less than or equal to zero, then the value must be ignored. Otherwise, the given value must be converted to the best representation of the number as a floating-point number and then that string must be used as the new content attribute value.

The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in the Web IDL specification. [WEBIDL]

If a reflecting IDL attribute has the type DOMTokenList, then on getting it must return a DOMTokenList object whose associated element is the element in question and whose associated attribute's local name is the name of the attribute in question.

2.6.2 Collections
The HTMLFormControlsCollection and HTMLOptionsCollection interfaces are collections derived from the HTMLCollection interface. The HTMLAllCollection interface is a collection, but is not so derived.

2.6.2.1 The HTMLAllCollection interface
The HTMLAllCollection interface is used for the legacy document.all attribute. It operates similarly to HTMLCollection; the main differences are that it allows a staggering variety of different (ab)uses of its methods to all end up returning something, and that it can be called as a function as an alternative to property access.

All HTMLAllCollection objects are rooted at a Document and have a filter that matches all elements, so the elements represented by the collection of an HTMLAllCollection object consist of all the descendant elements of the root Document.

Objects that implement the HTMLAllCollection interface are legacy platform objects with an additonal [[Call]] internal method described in the section below. They also have an [[IsHTMLDDA]] internal slot.

Objects that implement the HTMLAllCollection interface have several unusual behaviors, due of the fact that they have an [[IsHTMLDDA]] internal slot:

The ToBoolean abstract operation in JavaScript returns false when given objects implementing the HTMLAllCollection interface.

The Abstract Equality Comparison algorithm, when given objects implementing the HTMLAllCollection interface, returns true when compared to the undefined and null values. (Comparisons using the Strict Equality Comparison algorithm, and Abstract Equality comparisons to other values such as strings or objects, are unaffected.)

The typeof operator in JavaScript returns the string "undefined" when applied to objects implementing the HTMLAllCollection interface.

These special behaviors are motivated by a desire for compatibility with two classes of legacy content: one that uses the presence of document.all as a way to detect legacy user agents, and one that only supports those legacy user agents and uses the document.all object without testing for its presence first. [JAVASCRIPT]

[Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface HTMLAllCollection {
  readonly attribute unsigned long length;
  getter Element (unsigned long index);
  getter (HTMLCollection or Element)? namedItem(DOMString name);
  (HTMLCollection or Element)? item(optional DOMString nameOrIndex);

  // Note: HTMLAllCollection objects have a custom [[Call]] internal method and an [[IsHTMLDDA]] internal slot.
};
collection . length
Returns the number of elements in the collection.

element = collection . item(index)
element = collection(index)
element = collection[index]
Returns the item with index index from the collection (determined by tree order).

element = collection . item(name)
collection = collection . item(name)
element = collection . namedItem(name)
collection = collection . namedItem(name)
element = collection(name)
collection = collection(name)
element = collection[name]
collection = collection[name]
Returns the item with ID or name name from the collection.

If there are multiple matching items, then an HTMLCollection object containing all those elements is returned.

Only button, form, iframe, input, map, meta, object, select, and textarea elements can have a name for the purpose of this method; their name is given by the value of their name attribute.

The object's supported property indices are as defined for HTMLCollection objects.

The supported property names consist of the non-empty values of all the id attributes of all the elements represented by the collection, and the non-empty values of all the name attributes of all the "all"-named elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

On getting, the length attribute must return the number of nodes represented by the collection.

The indexed property getter must return the result of getting the "all"-indexed element from this HTMLAllCollection given the passed index.

The namedItem(name) method must return the result of getting the "all"-named element(s) from this HTMLAllCollection given name.

The item(nameOrIndex) method must perform the following steps:

If nameOrIndex was not provided, return null.

Return the result of getting the "all"-indexed or named element(s) from this HTMLAllCollection, given nameOrIndex.

The following elements are "all"-named elements: a, button, embed, form, frame, frameset, iframe, img, input, map, meta, object, select, and textarea

To get the "all"-indexed element from an HTMLAllCollection collection given an index index, return the indexth element in collection, or null if there is no such indexth element.

To get the "all"-named element(s) from an HTMLAllCollection collection given a name name, perform the following steps:

If name is the empty string, return null.

Let subCollection be an HTMLCollection object rooted at the same Document as collection, whose filter matches only elements that are either:

"all"-named elements with a name attribute equal to name, or,

elements with an ID equal to name.

If there is exactly one element in subCollection, then return that element.

Otherwise, if subCollection is empty, return null.

Otherwise, return subCollection.

To get the "all"-indexed or named element(s) from an HTMLAllCollection collection given nameOrIndex:

If nameOrIndex, converted to a JavaScript String value, is an array index property name, return the result of getting the "all"-indexed element from this HTMLAllCollection given the number represented by nameOrIndex.

Return the result of getting the "all"-named element(s) from this HTMLAllCollection given nameOrIndex.

2.6.2.1.1 [[Call]] ( thisArgument, argumentsList )
If argumentsList's size is zero, or if argumentsList[0] is undefined, return null.

Let nameOrIndex be the result of converting argumentsList[0] to a DOMString.

Let result be the result of getting the "all"-indexed or named element(s) from this HTMLAllCollection given nameOrIndex.

Return the result of converting result to an ECMAScript value.

The thisArgument is ignored, and thus code such as Function.prototype.call.call(document.all, null, "x") will still search for elements. (document.all.call does not exist, since document.all does not inherit from Function.prototype.)

2.6.2.2 The HTMLFormControlsCollection interface
The HTMLFormControlsCollection interface is used for collections of listed elements in form elements.

[Exposed=Window]
interface HTMLFormControlsCollection : HTMLCollection {
  // inherits length and item()
  getter (RadioNodeList or Element)? namedItem(DOMString name); // shadows inherited namedItem()
};

[Exposed=Window]
interface RadioNodeList : NodeList {
  attribute DOMString value;
};
collection . length
Returns the number of elements in the collection.

element = collection . item(index)
element = collection[index]
Returns the item with index index from the collection. The items are sorted in tree order.

element = collection . namedItem(name)
radioNodeList = collection . namedItem(name)
element = collection[name]
radioNodeList = collection[name]
Returns the item with ID or name name from the collection.

If there are multiple matching items, then a RadioNodeList object containing all those elements is returned.

radioNodeList . value [ = value ]
Returns the value of the first checked radio button represented by the object.

Can be set, to check the first radio button with the given value represented by the object.

The object's supported property indices are as defined for HTMLCollection objects.

The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

The namedItem(name) method must act according to the following algorithm:

If name is the empty string, return null and stop the algorithm.
If, at the time the method is called, there is exactly one node in the collection that has either an id attribute or a name attribute equal to name, then return that node and stop the algorithm.
Otherwise, if there are no nodes in the collection that have either an id attribute or a name attribute equal to name, then return null and stop the algorithm.
Otherwise, create a new RadioNodeList object representing a live view of the HTMLFormControlsCollection object, further filtered so that the only nodes in the RadioNodeList object are those that have either an id attribute or a name attribute equal to name. The nodes in the RadioNodeList object must be sorted in tree order.
Return that RadioNodeList object.
Members of the RadioNodeList interface inherited from the NodeList interface must behave as they would on a NodeList object.

The value IDL attribute on the RadioNodeList object, on getting, must return the value returned by running the following steps:

Let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose checkedness is true. Otherwise, let it be null.

If element is null, return the empty string.

If element is an element with no value attribute, return the string "on".

Otherwise, return the value of element's value attribute.

On setting, the value IDL attribute must run the following steps:

If the new value is the string "on": let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is either absent, or present and equal to the new value, if any. If no such element exists, then instead let element be null.

Otherwise: let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is present and equal to the new value, if any. If no such element exists, then instead let element be null.

If element is not null, then set its checkedness to true.

2.6.2.3 The HTMLOptionsCollection interface
The HTMLOptionsCollection interface is used for collections of option elements. It is always rooted on a select element and has attributes and methods that manipulate that element's descendants.

[Exposed=Window]
interface HTMLOptionsCollection : HTMLCollection {
  // inherits item(), namedItem()
  [CEReactions] attribute unsigned long length; // shadows inherited length
  [CEReactions] setter void (unsigned long index, HTMLOptionElement? option);
  [CEReactions] void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  [CEReactions] void remove(long index);
  attribute long selectedIndex;
};
collection . length [ = value ]
Returns the number of elements in the collection.

When set to a smaller number, truncates the number of option elements in the corresponding container.

When set to a greater number, adds new blank option elements to that container.

element = collection . item(index)
element = collection[index]
Returns the item with index index from the collection. The items are sorted in tree order.

collection[index] = element
When index is a greater number than the number of items in the collection, adds new blank option elements in the corresponding container.

When set to null, removes the item at index index from the collection.

When set to an option element, adds or replaces it at index index from the collection.

element = collection . namedItem(name)
element = collection[name]
Returns the item with ID or name name from the collection.

If there are multiple matching items, then the first is returned.

collection . add(element [, before ] )
Inserts element before the node given by before.

The before argument can be a number, in which case element is inserted before the item with that number, or an element from the collection, in which case element is inserted before that element.

If before is omitted, null, or a number out of range, then element will be added at the end of the list.

This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.

collection . remove(index)
Removes the item with index index from the collection.

collection . selectedIndex [ = value ]
Returns the index of the first selected item, if any, or −1 if there is no selected item.

Can be set, to change the selection.

The object's supported property indices are as defined for HTMLCollection objects.

On getting, the length attribute must return the number of nodes represented by the collection.

On setting, the behavior depends on whether the new value is equal to, greater than, or less than the number of nodes represented by the collection at that time. If the number is the same, then setting the attribute must do nothing. If the new value is greater, then n new option elements with no attributes and no child nodes must be appended to the select element on which the HTMLOptionsCollection is rooted, where n is the difference between the two numbers (new value minus old value). Mutation events must be fired as if a DocumentFragment containing the new option elements had been inserted. If the new value is lower, then the last n nodes in the collection must be removed from their parent nodes, where n is the difference between the two numbers (old value minus new value).

Setting length never removes or adds any optgroup elements, and never adds new children to existing optgroup elements (though it can remove children from them).

The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

When the user agent is to set the value of a new indexed property or set the value of an existing indexed property for a given property index index to a new value value, it must run the following algorithm:

If value is null, invoke the steps for the remove method with index as the argument, and return.

Let length be the number of nodes represented by the collection.

Let n be index minus length.

If n is greater than zero, then append a DocumentFragment consisting of n-1 new option elements with no attributes and no child nodes to the select element on which the HTMLOptionsCollection is rooted.

If n is greater than or equal to zero, append value to the select element. Otherwise, replace the indexth element in the collection by value.

The add(element, before) method must act according to the following algorithm:

If element is an ancestor of the select element on which the HTMLOptionsCollection is rooted, then throw a "HierarchyRequestError" DOMException.

If before is an element, but that element isn't a descendant of the select element on which the HTMLOptionsCollection is rooted, then throw a "NotFoundError" DOMException.

If element and before are the same element, then return.

If before is a node, then let reference be that node. Otherwise, if before is an integer, and there is a beforeth node in the collection, let reference be that node. Otherwise, let reference be null.

If reference is not null, let parent be the parent node of reference. Otherwise, let parent be the select element on which the HTMLOptionsCollection is rooted.

Pre-insert element into parent node before reference.

The remove(index) method must act according to the following algorithm:

If the number of nodes represented by the collection is zero, return.

If index is not a number greater than or equal to 0 and less than the number of nodes represented by the collection, return.

Let element be the indexth element in the collection.

Remove element from its parent node.

The selectedIndex IDL attribute must act like the identically named attribute on the select element on which the HTMLOptionsCollection is rooted

2.6.3 The DOMStringList interface
The DOMStringList interface is a non-fashionable retro way of representing a list of strings.

[Exposed=(Window,Worker)]
interface DOMStringList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString string);
};
New APIs must use sequence<DOMString> or equivalent rather than DOMStringList.

strings . length
Returns the number of strings in strings.

strings[index]
strings . item(index)
Returns the string with index index from strings.

strings . contains(string)
Returns true if strings contains string, and false otherwise.

Each DOMStringList object has an associated list.

The supported property indices for a DOMStringList object are the numbers zero to the associated list's size minus one. If its associated list is empty, it has no supported property indices.

The length attribute's getter must return this DOMStringList object's associated list's size.

The item(index) method, when invoked, must return the indexth item in this DOMStringList object's associated list, or null if index plus one is greater than this DOMStringList object's associated list's size.

The contains(string) method, when invoked, must return true if this DOMStringList object's associated list contains string, and false otherwise.

2.6.4 Garbage collection
There is an implied strong reference from any IDL attribute that returns a pre-existing object to that object.

For example, the window.document attribute means that there is a strong reference from a Window object to its Document object. Similarly, there is always a strong reference from a Document to any descendant nodes, and from any node to its node document.

2.7 Safe passing of structured data
This section uses the terminology and typographic conventions from the JavaScript specification. [JAVASCRIPT]

2.7.1 Serializable objects
Serializable objects support being serialized, and later deserialized, in a way that is independent of any given JavaScript Realm. This allows them to be stored on disk and later restored, or cloned across document and worker boundaries (including across documents of different origins or in different event loops).

Not all objects are serializable objects, and not all aspects of objects that are serializable objects are necessarily preserved when they are serialized.

Platform objects can be serializable objects if they implement only interfaces decorated with the [Serializable] IDL extended attribute. Such interfaces must also define the following algorithms:

serialization steps, taking a platform object value, a Record serialized, and a boolean forStorage
A set of steps that serializes the data in value into fields of serialized. The resulting data serialized into serialized must be independent of any JavaScript Realm.

These steps may throw an exception if serialization is not possible.

These steps may perform a sub-serialization to serialize nested data structures. They should not call StructuredSerialize directly, as doing so will omit the important memory argument.

The introduction of these steps should omit mention of the forStorage argument if it is not relevant to the algorithm.

deserialization steps, taking a Record serialized and a platform object value
A set of steps that deserializes the data in serialized, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.

These steps may throw an exception if deserialization is not possible.

These steps may perform a sub-deserialization to deserialize nested data structures. They should not call StructuredDeserialize directly, as doing so will omit the important targetRealm and memory arguments.

It is up to the definition of individual platform objects to determine what data is serialized and deserialized by these steps. Typically the steps are very symmetric.

The [Serializable] extended attribute must take no arguments, and must not appear on anything other than an interface. It must appear only once on an interface. It must not be used on a callback interface. If it appears on a partial interface or an interface that is really a mixin, then it must also appear on the original or mixed-in-to interface, and any supplied serialization steps and deserialization steps for the partial interface or mixin should be understood as being appended to those of the original or mixed-in-to interface.

Let's say we were defining a platform object Person, which had associated with it two pieces of associated data:

a name value, which is a string;
and a best friend value, which is either another Person instance or null
We could then define Person instances to be serializable objects by annotating the Person interface with the [Serializable] extended attribute, and defining the following accompanying algorithms:

serialization steps
Set serialized.[[Name]] to value's associated name value.

Let serializedBestFriend be the sub-serialization of value's associated best friend value.

Set serialized.[[BestFriend]] to serializedBestFriend.

deserialization steps
Set value's associated name value to serialized.[[Name]].

Let deserializedBestFriend be the sub-deserialization of serialized.[[BestFriend]].

Set value's associated best friend value to deserializedBestFriend.

Objects defined in the JavaScript specification are handled by the StructuredSerialize abstract operation directly.

Originally, this specification defined the concept of "cloneable objects", which could be cloned from one JavaScript Realm to another. However, to better specify the behavior of certain more complex situations, the model was updated to make the serialization and deserialization explicit.

2.7.2 Transferable objects
Transferable objects support being transferred across event loops. Transferring is effectively recreating the object while sharing a reference to the underlying data and then detaching the object being transferred. This is useful to transfer ownership of expensive resources. Not all objects are transferable objects and not all aspects of objects that are transferable objects are necessarily preserved when transferred.

Transferring is an irreversible and non-idempotent operation. Once an object has been transferred, it cannot be transferred, or indeed used, again.

Platform objects can be transferable objects if they implement only interfaces decorated with the [Transferable] IDL extended attribute. Such interfaces must also define the following algorithms:

transfer steps, taking a platform object value and a Record dataHolder
A set of steps that transfers the data in value into fields of dataHolder. The resulting data held in dataHolder must be independent of any JavaScript Realm.

These steps may throw an exception if transferral is not possible.

transfer-receiving steps, taking a Record dataHolder and a platform object value
A set of steps that receives the data in dataHolder, using it to set up value as appropriate. value will be a newly-created instance of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.

These steps may throw an exception if it is not possible to receive the transfer.

It is up to the definition of individual platform objects to determine what data is transferred by these steps. Typically the steps are very symmetric.

The [Transferable] extended attribute must take no arguments, and must not appear on anything other than an interface. It must appear only once on an interface. It must not be used on a callback interface. If it appears on a partial interface or an interface that is really a mixin, then it must also appear on the original or mixed-in-to interface, and any supplied serialization steps and deserialization steps for the partial interface or mixin should be understood as being appended to those of the original or mixed-in-to interface.

Platform objects that are transferable objects have a [[Detached]] internal slot. This is used to ensure that once a platform object has been transferred, it cannot be transferred again.

Objects defined in the JavaScript specification are handled by the StructuredSerializeWithTransfer abstract operation directly.

2.7.3 StructuredSerializeInternal ( value, forStorage [ , memory ] )
The StructuredSerializeInternal abstract operation takes as input a JavaScript value value and serializes it to a Realm-independent form, represented here as a Record. This serialized form has all the information necessary to later deserialize into a new JavaScript value in a different Realm.

This process can throw an exception, for example when trying to serialize un-serializable objects.

If memory was not supplied, let memory be an empty map.

The purpose of the memory map is to avoid serializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.

If memory[value] exists, then return memory[value].

Let deep be false.

If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String, then return { [[Type]]: "primitive", [[Value]]: value }. [JSBIGINT]

If Type(value) is Symbol, then throw a "DataCloneError" DOMException.

Let serialized be an uninitialized value.

If value has a [[BooleanData]] internal slot, then set serialized to { [[Type]]: "Boolean", [[BooleanData]]: value.[[BooleanData]] }.

Otherwise, if value has a [[NumberData]] internal slot, then set serialized to { [[Type]]: "Number", [[NumberData]]: value.[[NumberData]] }.

Otherwise, if value has a [[BigIntData]] internal slot, then set serialized to { [[Type]]: "BigInt", [[BigIntData]]: value.[[BigIntData]] }. [JSBIGINT]

Otherwise, if value has a [[StringData]] internal slot, then set serialized to { [[Type]]: "String", [[StringData]]: value.[[StringData]] }.

Otherwise, if value has a [[DateValue]] internal slot, then set serialized to { [[Type]]: "Date", [[DateValue]]: value.[[DateValue]] }.

Otherwise, if value has a [[RegExpMatcher]] internal slot, then set serialized to { [[Type]]: "RegExp", [[RegExpMatcher]]: value.[[RegExpMatcher]], [[OriginalSource]]: value.[[OriginalSource]], [[OriginalFlags]]: value.[[OriginalFlags]] }.

Otherwise, if value has an [[ArrayBufferData]] internal slot, then:

Let size be value.[[ArrayBufferByteLength]].

If ! IsSharedArrayBuffer(value) is true, then:

If forStorage is true, then throw a "DataCloneError" DOMException.

Set serialized to { [[Type]]: "SharedArrayBuffer", [[ArrayBufferData]]: value.[[ArrayBufferData]], [[ArrayBufferByteLength]]: size, [[AgentCluster]]: the current Realm Record's corresponding agent cluster }.

Otherwise:

If ! IsDetachedBuffer(value) is true, then throw a "DataCloneError" DOMException.

Let dataCopy be ? CreateByteDataBlock(size).

This can throw a RangeError exception upon allocation failure.

Perform ! CopyDataBlockBytes(dataCopy, 0, value.[[ArrayBufferData]], 0, size).

Set serialized to { [[Type]]: "ArrayBuffer", [[ArrayBufferData]]: dataCopy, [[ArrayBufferByteLength]]: size }.

Otherwise, if value has a [[ViewedArrayBuffer]] internal slot, then:

Let buffer be the value of value's [[ViewedArrayBuffer]] internal slot.

Let bufferSerialized be ? StructuredSerializeInternal(buffer, forStorage, memory).

Assert: bufferSerialized.[[Type]] is "ArrayBuffer".

If value has a [[DataView]] internal slot, then set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: "DataView", [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]] }.

Otherwise:

Assert: value has a [[TypedArrayName]] internal slot.

Set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: value.[[TypedArrayName]], [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]], [[ArrayLength]]: value.[[ArrayLength]] }.

Otherwise, if value has [[MapData]] internal slot, then:

Set serialized to { [[Type]]: "Map", [[MapData]]: a new empty List }.

Set deep to true.

Otherwise, if value has [[SetData]] internal slot, then:

Set serialized to { [[Type]]: "Set", [[SetData]]: a new empty List }.

Set deep to true.

Otherwise, if value is an Array exotic object, then:

Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, "length").

Let valueLen be valueLenDescriptor.[[Value]].

Set serialized to { [[Type]]: "Array", [[Length]]: valueLen, [[Properties]]: a new empty List }.

Set deep to true.

Otherwise, if value is a platform object that is a serializable object:

If value has a [[Detached]] internal slot whose value is true, then throw a "DataCloneError" DOMException.

Let typeString be the identifier of the primary interface of value.

Set serialized to { [[Type]]: typeString }.

Set deep to true.

Otherwise, if value is a platform object, then throw a "DataCloneError" DOMException.

Otherwise, if IsCallable(value) is true, then throw a "DataCloneError" DOMException.

Otherwise, if value has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError" DOMException.

For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.

Otherwise, if value is an exotic object, then throw a "DataCloneError" DOMException.

For instance, a proxy object.

Otherwise:

Set serialized to { [[Type]]: "Object", [[Properties]]: a new empty List }.

Set deep to true.

Set memory[value] to serialized.

If deep is true, then:

If value has a [[MapData]] internal slot, then:

Let copiedList be a new empty List.

For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]:

Let copiedEntry be a new Record { [[Key]]: entry.[[Key]], [[Value]]: entry.[[Value]] }.

If copiedEntry.[[Key]] is not the special value empty, append copiedEntry to copiedList.

For each Record { [[Key]], [[Value]] } entry of copiedList:

Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

Append { [[Key]]: serializedKey, [[Value]]: serializedValue } to serialized.[[MapData]].

Otherwise, if value has a [[SetData]] internal slot, then:

Let copiedList be a new empty List.

For each entry of value.[[SetData]]:

If entry is not the special value empty, append entry to copiedList.

For each entry of copiedList:

Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).

Append serializedEntry to serialized.[[SetData]].

Otherwise, if value is a platform object that is a serializable object, then perform the appropriate serialization steps given value, serialized, and forStorage.

The serialization steps may need to perform a sub-serialization. This is an operation which takes as input a value subValue, and returns StructuredSerializeInternal(subValue, forStorage, memory). (In other words, a sub-serialization is a specialization of StructuredSerializeInternal to be consistent within this invocation.)

Otherwise:

Let enumerableKeys be a new empty List.

For each key in ! value.[[OwnPropertyKeys]]():

If Type(key) is String, then:

Let valueDesc be ! value.[[GetOwnProperty]](key).

If valueDesc.[[Enumerable]] is true, then append key to enumerableKeys.

For each key in enumerableKeys:

If ! HasOwnProperty(value, key) is true, then:

Let inputValue be ? value.[[Get]](key, value).

Let outputValue be ? StructuredSerializeInternal(inputValue, forStorage, memory).

Append { [[Key]]: key, [[Value]]: outputValue } to serialized.[[Properties]].

The key collection performed above is very similar to the JavaScript specification's EnumerableOwnProperties operation, but crucially it uses the deterministic ordering provided by the [[OwnPropertyKeys]] internal method, instead of reordering the keys in an unspecified manner as EnumerableOwnProperties does. [JAVASCRIPT]

Return serialized.

It's important to realize that the Records produced by StructuredSerializeInternal might contain "pointers" to other records that create circular references. For example, when we pass the following JavaScript object into StructuredSerializeInternal:

const o = {};
o.myself = o;
it produces the following result:

{
  [[Type]]: "Object",
  [[Properties]]: «
    {
      [[Key]]: "myself",
      [[Value]]: <a pointer to this whole structure>
    }
  »
}
2.7.4 StructuredSerialize ( value )
Return ? StructuredSerializeInternal(value, false).

2.7.5 StructuredSerializeForStorage ( value )
Return ? StructuredSerializeInternal(value, true).

2.7.6 StructuredDeserialize ( serialized, targetRealm [ , memory ] )
The StructuredDeserialize abstract operation takes as input a Record serialized, which was previously produced by StructuredSerialize or StructuredSerializeForStorage, and deserializes it into a new JavaScript value, created in targetRealm.

This process can throw an exception, for example when trying to allocate memory for the new objects (especially ArrayBuffer objects).

If memory was not supplied, let memory be an empty map.

The purpose of the memory map is to avoid deserializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.

If memory[serialized] exists, then return memory[serialized].

Let deep be false.

Let value be an uninitialized value.

If serialized.[[Type]] is "primitive", then set value to serialized.[[Value]].

Otherwise, if serialized.[[Type]] is "Boolean", then set value to a new Boolean object in targetRealm whose [[BooleanData]] internal slot value is serialized.[[BooleanData]].

Otherwise, if serialized.[[Type]] is "Number", then set value to a new Number object in targetRealm whose [[NumberData]] internal slot value is serialized.[[NumberData]].

Otherwise, if serialized.[[Type]] is "BigInt", then set value to a new BigInt object in targetRealm whose [[BigIntData]] internal slot value is serialized.[[BigIntData]]. [JSBIGINT]

Otherwise, if serialized.[[Type]] is "String", then set value to a new String object in targetRealm whose [[StringData]] internal slot value is serialized.[[StringData]].

Otherwise, if serialized.[[Type]] is "Date", then set value to a new Date object in targetRealm whose [[DateValue]] internal slot value is serialized.[[DateValue]].

Otherwise, if serialized.[[Type]] is "RegExp", then set value to a new RegExp object in targetRealm whose [[RegExpMatcher]] internal slot value is serialized.[[RegExpMatcher]], whose [[OriginalSource]] internal slot value is serialized.[[OriginalSource]], and whose [[OriginalFlags]] internal slot value is serialized.[[OriginalFlags]].

Otherwise, if serialized.[[Type]] is "SharedArrayBuffer", then:

If targetRealm's corresponding agent cluster is not serialized.[[AgentCluster]], then then throw a "DataCloneError" DOMException.

Otherwise, set value to a new SharedArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]] and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].

Otherwise, if serialized.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].

If this throws an exception, catch it, and then throw a "DataCloneError" DOMException.

This step might throw an exception if there is not enough memory available to create such an ArrayBuffer object.

Otherwise, if serialized.[[Type]] is "ArrayBufferView", then:

Let deserializedArrayBuffer be ? StructuredDeserialize(serialized.[[ArrayBufferSerialized]], targetRealm, memory).

If serialized.[[Constructor]] is "DataView", then set value to a new DataView object in targetRealm whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], and whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]].

Otherwise, set value to a new typed array object in targetRealm, using the constructor given by serialized.[[Constructor]], whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[TypedArrayName]] internal slot value is serialized.[[Constructor]], whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]], and whose [[ArrayLength]] internal slot value is serialized.[[ArrayLength]].

Otherwise, if serialized.[[Type]] is "Map", then:

Set value to a new Map object in targetRealm whose [[MapData]] internal slot value is a new empty List.

Set deep to true.

Otherwise, if serialized.[[Type]] is "Set", then:

Set value to a new Set object in targetRealm whose [[SetData]] internal slot value is a new empty List.

Set deep to true.

Otherwise, if serialized.[[Type]] is "Array", then:

Let outputProto be the %ArrayPrototype% intrinsic object in targetRealm.

Set value to ! ArrayCreate(serialized.[[Length]], outputProto).

Set deep to true.

Otherwise, if serialized.[[Type]] is "Object", then:

Set value to a new Object in targetRealm.

Set deep to true.

Otherwise:

Let interfaceName be serialized.[[Type]].

If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.

Set value to a new instance of the interface identified by interfaceName, created in targetRealm.

Set deep to true.

Set memory[serialized] to value.

If deep is true, then:

If serialized.[[Type]] is "Map", then:

For each Record { [[Key]], [[Value]] } entry of serialized.[[MapData]]:

Let deserializedKey be ? StructuredDeserialize(entry.[[Key]], targetRealm, memory).

Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).

Append { [[Key]]: deserializedKey, [[Value]]: deserializedValue } to value.[[MapData]].

Otherwise, if serialized.[[Type]] is "Set", then:

For each entry of serialized.[[SetData]]:

Let deserializedEntry be ? StructuredDeserialize(entry, targetRealm, memory).

Append deserializedEntry to value.[[SetData]].

Otherwise, if serialized.[[Type]] is "Array" or "Object", then:

For each Record { [[Key]], [[Value]] } entry of serialized.[[Properties]]:

Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory).

Let result be ! CreateDataProperty(value, entry.[[Key]], deserializedValue).

Assert: result is true.

Otherwise:

Perform the appropriate deserialization steps for the interface identified by serialized.[[Type]], given serialized and value.

The deserialization steps may need to perform a sub-deserialization. This is an operation which takes as input a previously-serialized Record subSerialized, and returns StructuredDeserialize(subSerialized, targetRealm, memory). (In other words, a sub-deserialization is a specialization of StructuredDeserialize to be consistent within this invocation.)

Return value.

2.7.7 StructuredSerializeWithTransfer ( value, transferList )
Let memory be an empty map.

In addition to how it is used normally by StructuredSerializeInternal, in this algorithm memory is also used to ensure that StructuredSerializeInternal ignores items in transferList, and let us do our own handling instead.

For each transferable of transferList:

If transferable has neither an [[ArrayBufferData]] internal slot nor a [[Detached]] internal slot, then throw a "DataCloneError" DOMException.

If transferable has an [[ArrayBufferData]] internal slot and either ! IsSharedArrayBuffer(transferable) is true or ! IsDetachedBuffer(transferable) is true, then throw a "DataCloneError" DOMException.

If transferable has a [[Detached]] internal slot and transferable.[[Detached]] is true, then throw a "DataCloneError" DOMException.

If memory[transferable] exists, then throw a "DataCloneError" DOMException.

Set memory[transferable] to { [[Type]]: an uninitialized value }.

transferable is not transferred yet as transferring has side effects and StructuredSerializeInternal needs to be able to throw first.

Let serialized be ? StructuredSerializeInternal(value, false, memory).

Let transferDataHolders be a new empty List.

For each transferable of transferList:

Let dataHolder be memory[transferable].

If transferable has an [[ArrayBufferData]] internal slot, then:

Set dataHolder.[[Type]] to "ArrayBuffer".

Set dataHolder.[[ArrayBufferData]] to transferable.[[ArrayBufferData]].

Set dataHolder.[[ArrayBufferByteLength]] to transferable.[[ArrayBufferByteLength]].

Perform ! DetachArrayBuffer(transferable).

Otherwise:

Assert: transferable is a platform object that is a transferable object.

Let interfaceName be the identifier of the primary interface of transferable.

Set dataHolder.[[Type]] to interfaceName.

Perform the appropriate transfer steps for the interface identified by interfaceName, given transferable and dataHolder.

Set transferable.[[Detached]] to true.

Append dataHolder to transferDataHolders.

Return { [[Serialized]]: serialized, [[TransferDataHolders]]: transferDataHolders }.

2.7.8 StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm )
Let memory be an empty map.

Analogous to StructuredSerializeWithTransfer, in addition to how it is used normally by StructuredDeserialize, in this algorithm memory is also used to ensure that StructuredDeserialize ignores items in serializeWithTransferResult.[[TransferDataHolders]], and let us do our own handling instead.

Let transferredValues be a new empty List.

For each transferDataHolder of serializeWithTransferResult.[[TransferDataHolders]]:

Let value be an uninitialized value.

If transferDataHolder.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot value is transferDataHolder.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is transferDataHolder.[[ArrayBufferByteLength]].

In cases where the original memory occupied by [[ArrayBufferData]] is accessible during the deserialization, this step is unlikely to throw an exception, as no new memory needs to be allocated: the memory occupied by [[ArrayBufferData]] is instead just getting transferred into the new ArrayBuffer. This could be true, for example, when both the source and target Realms are in the same process.

Otherwise:

Let interfaceName be transferDataHolder.[[Type]].

If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError" DOMException.

Set value to a new instance of the interface identified by interfaceName, created in targetRealm.

Perform the appropriate transfer-receiving steps for the interface identified by interfaceName given transferDataHolder and value.

Set memory[transferDataHolder] to value.

Append value to transferredValues.

Let deserialized be ? StructuredDeserialize(serializeWithTransferResult.[[Serialized]], targetRealm, memory).

Return { [[Deserialized]]: deserialized, [[TransferredValues]]: transferredValues }.

2.7.9 Performing serialization and transferring from other specifications
Other specifications may use the abstract operations defined here. The following provides some guidance on when each abstract operation is typically useful, with examples.

StructuredSerializeWithTransfer
StructuredDeserializeWithTransfer
Cloning a value to another JavaScript Realm, with a transfer list, but where the target Realm is not known ahead of time. In this case the serialization step can be performed immediately, with the deserialization step delayed until the target Realm becomes known.

messagePort.postMessage() uses this pair of abstract operations, as the destination Realm is not known until the MessagePort has been shipped.

StructuredSerialize
StructuredSerializeForStorage
StructuredDeserialize
Creating a JavaScript Realm-independent snapshot of a given value which can be saved for an indefinite amount of time, and then reified back into a JavaScript value later, possibly multiple times.

StructuredSerializeForStorage can be used for situations where the serialization is anticipated to be stored in a persistent manner, instead of passed between Realms. It throws when attempting to serialize SharedArrayBuffer objects, since storing shared memory does not make sense. Similarly, it can throw or possibly have different behavior when given a platform object with custom serialization steps when the forStorage argument is true.

history.pushState() and history.replaceState() use StructuredSerializeForStorage on author-supplied state objects, storing them as serialized state in the appropriate session history entry. Then, StructuredDeserialize is used so that the history.state property can return a clone of the originally-supplied state object.

broadcastChannel.postMessage() uses StructuredSerialize on its input, then uses StructuredDeserialize multiple times on the result to produce a fresh clone for each destination being broadcast to. Note that transferring does not make sense in multi-destination situations.

Any API for persisting JavaScript values to the filesystem would also use StructuredSerializeForStorage on its input and StructuredDeserialize on its output.

In general, call sites may pass in Web IDL values instead of JavaScript values; this is to be understood to perform an implicit conversion to the JavaScript value before invoking these algorithms.

This specification used to define a "structured clone" algorithm, and more recently a StructuredClone abstract operation. However, in practice all known uses of it were better served by separate serialization and deserialization steps, so it was removed.

Call sites that are not invoked as a result of author code synchronously calling into a user agent method must take care to properly prepare to run script and prepare to run a callback before invoking StructuredSerialize, StructuredSerializeForStorage, or StructuredSerializeWithTransfer abstract operations, if they are being performed on arbitrary objects. This is necessary because the serialization process can invoke author-defined accessors as part of its final deep-serialization steps, and these accessors could call into operations that rely on the entry and incumbent concepts being properly set up.

window.postMessage() performs StructuredSerializeWithTransfer on its arguments, but is careful to do so immediately, inside the synchronous portion of its algorithm. Thus it is able to use the algorithms without needing to prepare to run script and prepare to run a callback.

In contrast, a hypothetical API that used StructuredSerialize to serialize some author-supplied object periodically, directly from a task on the event loop, would need to ensure it performs the appropriate preparations beforehand. As of this time, we know of no such APIs on the platform; usually it is simpler to perform the serialization ahead of time, as a synchronous consequence of author code.

3 Semantics, structure, and APIs of HTML documents
3.1 Documents
Every XML and HTML document in an HTML UA is represented by a Document object. [DOM]

The Document object's URL is defined in the WHATWG DOM standard. It is initially set when the Document object is created, but can change during the lifetime of the Document object; for example, it changes when the user navigates to a fragment on the page and when the pushState() method is called with a new URL. [DOM]

Interactive user agents typically expose the Document object's URL in their user interface. This is the primary mechanism by which a user can tell if a site is attempting to impersonate another.

When a Document is created by a script using the createDocument() or createHTMLDocument() the Document is both ready for post-load tasks and completely loaded immediately.

The document's referrer is a string (representing a URL) that can be set when the Document is created. If it is not explicitly set, then its value is the empty string.

Each Document object has a reload override flag that is originally unset. The flag is set by the document.open() and document.write() methods in certain situations. When the flag is set, the Document also has a reload override buffer which is a Unicode string that is used as the source of the document when it is reloaded.

When the user agent is to perform an overridden reload, given a source browsing context, it must act as follows:

Let source be the value of the browsing context's active document's reload override buffer.

Let address be the browsing context's active document's URL.

Let HTTPS state be the HTTPS state of the browsing context's active document.

Let referrer policy be the referrer policy of the browsing context's active document.

Let CSP list be the CSP list of the browsing context's active document.

Navigate the browsing context to a new response whose body is source, header list is `Referrer-Policy`/referrer policy, CSP list is CSP list and HTTPS state is HTTPS state, with the exceptions enabled flag set and replacement enabled. The source browsing context is that given to the overridden reload algorithm. When the navigate algorithm creates a Document object for this purpose, set that Document's reload override flag and set its reload override buffer to source. Rethrow any exceptions.

When it comes time to set the document's address in the navigation algorithm, use address as the override URL.

3.1.1 The Document object
The WHATWG DOM standard defines a Document interface, which this specification extends significantly.

enum DocumentReadyState { "loading", "interactive", "complete" };
typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;

[OverrideBuiltins]
partial interface Document {
  // resource metadata management
  [PutForwards=href, Unforgeable] readonly attribute Location? location;
  attribute USVString domain;
  readonly attribute USVString referrer;
  attribute USVString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute DocumentReadyState readyState;

  // DOM tree accessors
  getter object (DOMString name);
  [CEReactions] attribute DOMString title;
  [CEReactions] attribute DOMString dir;
  [CEReactions] attribute HTMLElement? body;
  readonly attribute HTMLHeadElement? head;
  [SameObject] readonly attribute HTMLCollection images;
  [SameObject] readonly attribute HTMLCollection embeds;
  [SameObject] readonly attribute HTMLCollection plugins;
  [SameObject] readonly attribute HTMLCollection links;
  [SameObject] readonly attribute HTMLCollection forms;
  [SameObject] readonly attribute HTMLCollection scripts;
  NodeList getElementsByName(DOMString elementName);
  readonly attribute HTMLOrSVGScriptElement? currentScript; // classic scripts in a document tree only

  // dynamic markup insertion
  [CEReactions] Document open(optional DOMString type, optional DOMString replace = ""); // type is ignored
  WindowProxy open(USVString url, DOMString name, DOMString features);
  [CEReactions] void close();
  [CEReactions] void write(DOMString... text);
  [CEReactions] void writeln(DOMString... text);

  // user interaction
  readonly attribute WindowProxy? defaultView;
  readonly attribute Element? activeElement;
  boolean hasFocus();
  [CEReactions] attribute DOMString designMode;
  [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = "");
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);

  // special event handler IDL attributes that only apply to Document objects
  [LenientThis] attribute EventHandler onreadystatechange;
};
Document includes GlobalEventHandlers;
Document includes DocumentAndElementEventHandlers;
The Document has an HTTPS state (an HTTPS state value), initially "none", which represents the security properties of the network channel used to deliver the Document's data.

The Document has a referrer policy (a referrer policy), initially the empty string, which represents the default referrer policy used by fetches initiated by the Document.

The Document has a CSP list, which is a CSP list containing all of the Content Security Policy objects active for the document. The list is empty unless otherwise specified.

The Document has a module map, which is a module map, initially empty.

3.1.2 Resource metadata management
document . referrer
Returns the URL of the Document from which the user navigated to this one, unless it was blocked or there was no such document, in which case it returns the empty string.

The noreferrer link type can be used to block the referrer.

The referrer attribute must return the document's referrer.

document . cookie [ = value ]
Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.

Can be set, to add a new cookie to the element's set of HTTP cookies.

If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.

The cookie attribute represents the cookies of the resource identified by the document's URL.

A Document object that falls into one of the following conditions is a cookie-averse Document object:

A Document that has no browsing context.
A Document whose URL's scheme is not a network scheme.
On getting, if the document is a cookie-averse Document object, then the user agent must return the empty string. Otherwise, if the Document's origin is an opaque origin, the user agent must throw a "SecurityError" DOMException. Otherwise, the user agent must return the cookie-string for the document's URL for a "non-HTTP" API, decoded using UTF-8 decode without BOM. [COOKIES]

On setting, if the document is a cookie-averse Document object, then the user agent must do nothing. Otherwise, if the Document's origin is an opaque origin, the user agent must throw a "SecurityError" DOMException. Otherwise, the user agent must act as it would when receiving a set-cookie-string for the document's URL via a "non-HTTP" API, consisting of the new value encoded as UTF-8. [COOKIES] [ENCODING]

Since the cookie attribute is accessible across frames, the path restrictions on cookies are only a tool to help manage which cookies are sent to which parts of the site, and are not in any way a security feature.

The cookie attribute's getter and setter synchronously access shared state. Since there is no locking mechanism, other browsing contexts in a multiprocess user agent can modify cookies while scripts are running. A site could, for instance, try to read a cookie, increment its value, then write it back out, using the new value of the cookie as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.

document . lastModified
Returns the date of the last modification to the document, as reported by the server, in the form "MM/DD/YYYY hh:mm:ss", in the user's local time zone.

If the last modification date is not known, the current time is returned instead.

The lastModified attribute, on getting, must return the date and time of the Document's source file's last modification, in the user's local time zone, in the following format:

The month component of the date.
A U+002F SOLIDUS character (/).
The day component of the date.
A U+002F SOLIDUS character (/).
The year component of the date.
A U+0020 SPACE character.
The hours component of the time.
A U+003A COLON character (:).
The minutes component of the time.
A U+003A COLON character (:).
The seconds component of the time.
All the numeric components above, other than the year, must be given as two ASCII digits representing the number in base ten, zero-padded if necessary. The year must be given as the shortest possible string of four or more ASCII digits representing the number in base ten, zero-padded if necessary.

The Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.

document . readyState
Returns "loading" while the Document is loading, "interactive" once it is finished parsing but still loading subresources, and "complete" once it has loaded.

The readystatechange event fires on the Document object when this value changes.

The DOMContentLoaded event fires after the transition to "interactive" but before the transition to "complete", at the point where all subresources apart from async script elements have loaded.

Each document has a current document readiness. When a Document object is created, it must have its current document readiness set to the string "loading" if the document is associated with an HTML parser, an XML parser, or an XSLT processor, and to the string "complete" otherwise. Various algorithms during page loading affect this value. When the value is set, the user agent must fire an event named readystatechange at the Document object.

A Document is said to have an active parser if it is associated with an HTML parser or an XML parser that has not yet been stopped or aborted.

The readyState IDL attribute must, on getting, return the current document readiness.

3.1.3 DOM tree accessors
The html element of a document is its document element, if it's an html element, and null otherwise.

document . head
Returns the head element.

The head element of a document is the first head element that is a child of the html element, if there is one, or null otherwise.

The head attribute, on getting, must return the head element of the document (a head element or null).


Support: documenthead
Chrome for Android	64+
Chrome	4+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	9+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	2.3+
Opera	11+

Source: caniuse.com

document . title [ = value ]
Returns the document's title, as given by the title element for HTML and as given by the SVG title element for SVG.

Can be set, to update the document's title. If there is no appropriate element to update, the new value is ignored.

The title element of a document is the first title element in the document (in tree order), if there is one, or null otherwise.

The title attribute must, on getting, run the following algorithm:

If the document element is an SVG svg element, then let value be the child text content of the first SVG title element that is a child of the document element.

Otherwise, let value be the child text content of the title element, or the empty string if the title element is null.

Strip and collapse ASCII whitespace in value.

Return value.

On setting, the steps corresponding to the first matching condition in the following list must be run:

If the document element is an SVG svg element
If there is an SVG title element that is a child of the document element, let element be the first such element.

Otherwise:

Let element be the result of creating an element given the document element's node document, title, and the SVG namespace.

Insert element as the first child of the document element.

Act as if the textContent IDL attribute of element was set to the new value being assigned.

If the document element is in the HTML namespace
If the title element is null and the head element is null, then return.

If the title element is non-null, let element be the title element.

Otherwise:

Let element be the result of creating an element given the document element's node document, title, and the HTML namespace.

Append element to the head element.

Act as if the textContent IDL attribute of element was set to the new value being assigned.

Otherwise
Do nothing.

document . body [ = value ]
Returns the body element.

Can be set, to replace the body element.

If the new value is not a body or frameset element, this will throw a "HierarchyRequestError" DOMException.

The body element of a document is the first of the html element's children that is either a body element or a frameset element, or null if there is no such element.

The body attribute, on getting, must return the body element of the document (either a body element, a frameset element, or null). On setting, the following algorithm must be run:

If the new value is not a body or frameset element, then throw a "HierarchyRequestError" DOMException.
Otherwise, if the new value is the same as the body element, return.
Otherwise, if the body element is not null, then replace the body element with the new value within the body element's parent and return.
Otherwise, if there is no document element, throw a "HierarchyRequestError" DOMException.
Otherwise, the body element is null, but there's a document element. Append the new value to the document element.
The value returned by the body getter is not always the one passed to the setter.

In this example, the setter successfully inserts a body element (though this is non-conforming since SVG does not allow a body as child of SVG svg). However the getter will return null because the document element is not html.

<svg xmlns="http://www.w3.org/2000/svg">
 <script>
  document.body = document.createElementNS("http://www.w3.org/1999/xhtml", "body");
  console.assert(document.body === null);
 </script>
</svg>
document . images
Returns an HTMLCollection of the img elements in the Document.

document . embeds
document . plugins
Return an HTMLCollection of the embed elements in the Document.

document . links
Returns an HTMLCollection of the a and area elements in the Document that have href attributes.

document . forms
Return an HTMLCollection of the form elements in the Document.

document . scripts
Return an HTMLCollection of the script elements in the Document.

The images attribute must return an HTMLCollection rooted at the Document node, whose filter matches only img elements.

The embeds attribute must return an HTMLCollection rooted at the Document node, whose filter matches only embed elements.

The plugins attribute must return the same object as that returned by the embeds attribute.

The links attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with href attributes and area elements with href attributes.

The forms attribute must return an HTMLCollection rooted at the Document node, whose filter matches only form elements.

The scripts attribute must return an HTMLCollection rooted at the Document node, whose filter matches only script elements.

collection = document . getElementsByName(name)
Returns a NodeList of elements in the Document that have a name attribute with the value name.

The getElementsByName(name) method takes a string name, and must return a live NodeList containing all the HTML elements in that document that have a name attribute whose value is equal to the name argument (in a case-sensitive manner), in tree order. When the method is invoked on a Document object again with the same argument, the user agent may return the same as the object returned by the earlier call. In other cases, a new NodeList object must be returned.

document . currentScript
Returns the script element, or the SVG script element, that is currently executing, as long as the element represents a classic script. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.

Returns null if the Document is not currently executing a script or SVG script element (e.g., because the running script is an event handler, or a timeout), or if the currently executing script or SVG script element represents a module script.

The currentScript attribute, on getting, must return the value to which it was most recently set. When the Document is created, the currentScript must be initialized to null.


Support: document-currentscript
Chrome for Android	64+
Chrome	29+
iOS Safari	8+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	8+
Edge	12+
Android Browser	4.4+
Opera	16+

Source: caniuse.com

This API has fallen out of favor in the implementer and standards community, as it globally exposes script or SVG script elements. As such, it is not available in newer contexts, such as when running module scripts or when running scripts in a shadow tree. We are looking into creating a new solution for identifying the running script in such contexts, which does not make it globally available: see issue #1013.

The Document interface supports named properties. The supported property names of a Document object document at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates, and with values from id attributes coming before values from name attributes when the same element contributes both:

the value of the name content attribute for all exposed embed, form, iframe, img, and exposed object elements that have a non-empty name content attribute and are in a document tree with document as their root;

the value of the id content attribute for all exposed object elements that have a non-empty id content attribute and are in a document tree with document as their root; and

the value of the id content attribute for all img elements that have both a non-empty id content attribute and a non-empty name content attribute, and are in a document tree with document as their root.

To determine the value of a named property name for a Document, the user agent must return the value obtained using the following steps:

Let elements be the list of named elements with the name name that are in a document tree with the Document as their root.

There will be at least one such element, by definition.

If elements has only one element, and that element is an iframe element, and that iframe element's nested browsing context is not null, then return the WindowProxy object of the element's nested browsing context.

Otherwise, if elements has only one element, return that element.

Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named elements with the name name.

Named elements with the name name, for the purposes of the above algorithm, are those that are either:

Exposed embed, form, iframe, img, or exposed object elements that have a name content attribute whose value is name, or
Exposed object elements that have an id content attribute whose value is name, or
img elements that have an id content attribute whose value is name, and that have a non-empty name content attribute present also.
An embed or object element is said to be exposed if it has no exposed object ancestor, and, for object elements, is additionally either not showing its fallback content or has no object or embed descendants.

The dir attribute on the Document interface is defined along with the dir content attribute.

3.2 Elements
3.2.1 Semantics
Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics). For example, the ol element represents an ordered list, and the lang attribute represents the language of the content.

These definitions allow HTML processors, such as Web browsers or search engines, to present and use documents and applications in a wide variety of contexts that the author might not have considered.

As a simple example, consider a Web page written by an author who only considered desktop computer Web browsers:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>My Page</title>
 </head>
 <body>
  <h1>Welcome to my page</h1>
  <p>I like cars and lorries and have a big Jeep!</p>
  <h2>Where I live</h2>
  <p>I live in a small hut on a mountain!</p>
 </body>
</html>
Because HTML conveys meaning, rather than presentation, the same page can also be used by a small browser on a mobile phone, without any change to the page. Instead of headings being in large letters as on the desktop, for example, the browser on the mobile phone might use the same size text for the whole page, but with the headings in bold.

But it goes further than just differences in screen size: the same page could equally be used by a blind user using a browser based around speech synthesis, which instead of displaying the page on a screen, reads the page to the user, e.g. using headphones. Instead of large text for the headings, the speech browser might use a different volume or a slower voice.

That's not all, either. Since the browsers know which parts of the page are the headings, they can create a document outline that the user can use to quickly navigate around the document, using keys for "jump to next heading" or "jump to previous heading". Such features are especially common with speech browsers, where users would otherwise find quickly navigating a page quite difficult.

Even beyond browsers, software can make use of this information. Search engines can use the headings to more effectively index a page, or to provide quick links to subsections of the page from their results. Tools can use the headings to create a table of contents (that is in fact how this very specification's table of contents is generated).

This example has focused on headings, but the same principle applies to all of the semantics in HTML.

Authors must not use elements, attributes, or attribute values for purposes other than their appropriate intended semantic purpose, as doing so prevents software from correctly processing the page.

For example, the following snippet, intended to represent the heading of a corporate site, is non-conforming because the second line is not intended to be a heading of a subsection, but merely a subheading or subtitle (a subordinate heading for the same section).

<body>
 <h1>ACME Corporation</h1>
 <h2>The leaders in arbitrary fast delivery since 1920</h2>
 ...
The hgroup element is intended for these kinds of situations:

<body>
 <hgroup>
  <h1>ACME Corporation</h1>
  <h2>The leaders in arbitrary fast delivery since 1920</h2>
 </hgroup>
 ...
The document in this next example is similarly non-conforming, despite being syntactically correct, because the data placed in the cells is clearly not tabular data, and the cite element mis-used:

<!DOCTYPE HTML>
<html lang="en-GB">
 <head> <title> Demonstration </title> </head>
 <body>
  <table>
   <tr> <td> My favourite animal is the cat. </td> </tr>
   <tr>
    <td>
     —<a href="https://example.org/~ernest/"><cite>Ernest</cite></a>,
     in an essay from 1992
    </td>
   </tr>
  </table>
 </body>
</html>
This would make software that relies on these semantics fail: for example, a speech browser that allowed a blind user to navigate tables in the document would report the quote above as a table, confusing the user; similarly, a tool that extracted titles of works from pages would extract "Ernest" as the title of a work, even though it's actually a person's name, not a title.

A corrected version of this document might be:

<!DOCTYPE HTML>
<html lang="en-GB">
 <head> <title> Demonstration </title> </head>
 <body>
  <blockquote>
   <p> My favourite animal is the cat. </p>
  </blockquote>
  <p>
   —<a href="https://example.org/~ernest/">Ernest</a>,
   in an essay from 1992
  </p>
 </body>
</html>
Authors must not use elements, attributes, or attribute values that are not permitted by this specification or other applicable specifications, as doing so makes it significantly harder for the language to be extended in the future.

In the next example, there is a non-conforming attribute value ("carpet") and a non-conforming attribute ("texture"), which is not permitted by this specification:

<label>Carpet: <input type="carpet" name="c" texture="deep pile"></label>
Here would be an alternative and correct way to mark this up:

<label>Carpet: <input type="text" class="carpet" name="c" data-texture="deep pile"></label>
DOM nodes whose node document does not have a browsing context are exempt from all document conformance requirements other than the HTML syntax requirements and XML syntax requirements.

In particular, the template element's template contents's node document does not have a browsing context. For example, the content model requirements and attribute value microsyntax requirements do not apply to a template element's template contents. In this example an img element has attribute values that are placeholders that would be invalid outside a template element.

<template>
 <article>
  <img src="{{src}}" alt="{{alt}}">
  <h1></h1>
 </article>
</template>
However, if the above markup were to omit the </h1> end tag, that would be a violation of the HTML syntax, and would thus be flagged as an error by conformance checkers.

Through scripting and using other mechanisms, the values of attributes, text, and indeed the entire structure of the document may change dynamically while a user agent is processing it. The semantics of a document at an instant in time are those represented by the state of the document at that instant in time, and the semantics of a document can therefore change over time. User agents must update their presentation of the document as this occurs.

HTML has a progress element that describes a progress bar. If its "value" attribute is dynamically updated by a script, the UA would update the rendering to show the progress changing.

3.2.2 Elements in the DOM
The nodes representing HTML elements in the DOM must implement, and expose to scripts, the interfaces listed for them in the relevant sections of this specification. This includes HTML elements in XML documents, even when those documents are in another context (e.g. inside an XSLT transform).

Elements in the DOM represent things; that is, they have intrinsic meaning, also known as semantics.

For example, an ol element represents an ordered list.

Elements can be referenced (referred to) in some way, either explicitly or implicitly. One way that an element in the DOM can be explicitly referenced is by giving an id attribute to the element, and then creating a hyperlink with that id attribute's value as the fragment for the hyperlink's href attribute value. Hyperlinks are not necessary for a reference, however; any manner of referring to the element in question will suffice.

Consider the following figure element, which is given an id attribute:

<figure id="module-script-graph">
  <img src="module-script-graph.svg"
       alt="Module A depends on module B, which depends
            on modules C and D.">
  <figcaption>Figure 27: a simple module graph</figcaption>
</figure>
A hyperlink-based reference could be created using the a element, like so:

As we can see in <a href="#module-script-graph">figure 27</a>, ...
However, there are many other ways of referencing the figure element, such as:

"As depicted in the figure of modules A, B, C, and D..."

"In Figure 27..." (without a hyperlink)

"From the contents of the 'simple module graph' figure..."

"In the figure below..." (but this is discouraged)

The basic interface, from which all the HTML elements' interfaces inherit, and which must be used by elements that have no additional requirements, is the HTMLElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLElement : Element {
  // metadata attributes
  [CEReactions] attribute DOMString title;
  [CEReactions] attribute DOMString lang;
  [CEReactions] attribute boolean translate;
  [CEReactions] attribute DOMString dir;
  [SameObject] readonly attribute DOMStringMap dataset;

  // user interaction
  [CEReactions] attribute boolean hidden;
  void click();
  [CEReactions] attribute long tabIndex;
  void focus(optional FocusOptions options);
  void blur();
  [CEReactions] attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
  [CEReactions] attribute boolean draggable;
  [CEReactions] attribute boolean spellcheck;
  [CEReactions] attribute DOMString autocapitalize;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString innerText;
};

HTMLElement includes GlobalEventHandlers;
HTMLElement includes DocumentAndElementEventHandlers;
HTMLElement includes ElementContentEditable;
HTMLElement includes NoncedElement;

// Note: intentionally not [HTMLConstructor]
[Exposed=Window]
interface HTMLUnknownElement : HTMLElement { };
The HTMLElement interface holds methods and attributes related to a number of disparate features, and the members of this interface are therefore described in various different sections of this specification.

The element interface for an element with name name in the HTML namespace is determined as follows:

If name is applet, bgsound, blink, isindex, keygen, multicol, nextid, or spacer, then return HTMLUnknownElement.

If name is acronym, basefont, big, center, nobr, noembed, noframes, plaintext, rb, rtc, strike, or tt, then return HTMLElement.

If name is listing or xmp, then return HTMLPreElement.

Otherwise, if this specification defines an interface appropriate for the element type corresponding to the local name name, then return that interface.

If other applicable specifications define an appropriate interface for name, then return the interface they define.

If name is a valid custom element name, then return HTMLElement.

Return HTMLUnknownElement.

The use of HTMLElement instead of HTMLUnknownElement in the case of valid custom element names is done to ensure that any potential future upgrades only cause a linear transition of the element's prototype chain, from HTMLElement to a subclass, instead of a lateral one, from HTMLUnknownElement to an unrelated subclass.

3.2.3 HTML element constructors
To support the custom elements feature, all HTML elements have special constructor behavior. This is indicated via the [HTMLConstructor] IDL extended attribute. It indicates that the interface object for the given interface will have a specific behavior when called, as defined in detail below.

The [HTMLConstructor] extended attribute must take no arguments, and must not appear on anything other than an interface. It must appear only once on an interface, and the interface must not be annotated with the [Constructor] or [NoInterfaceObject] extended attributes. (However, the interface may be annotated with [NamedConstructor]; there is no conflict there.) It must not be used on a callback interface.

Interface objects for interfaces annotated with the [HTMLConstructor] extended attribute must run the following steps as the function body behavior for both [[Call]] and [[Construct]] invocations of the corresponding JavaScript function object. When invoked with [[Call]], the NewTarget value is undefined, and so the algorithm below will immediately throw. When invoked with [[Construct]], the [[Construct]] newTarget parameter provides the NewTarget value.

Let registry be the current global object's CustomElementRegistry object.

If NewTarget is equal to the active function object, then throw a TypeError.

This can occur when a custom element is defined using an element interface as its constructor:

customElements.define("bad-1", HTMLButtonElement);
new HTMLButtonElement();          // (1)
document.createElement("bad-1");  // (2)
In this case, during the execution of HTMLButtonElement (either explicitly, as in (1), or implicitly, as in (2)), both the active function object and NewTarget are HTMLButtonElement. If this check was not present, it would be possible to create an instance of HTMLButtonElement whose local name was bad-1.

Let definition be the entry in registry with constructor equal to NewTarget. If there is no such definition, then throw a TypeError.

Since there can be no entry in registry with a constructor of undefined, this step also prevents HTML element constructors from being called as functions (since in that case NewTarget will be undefined).

If definition's local name is equal to definition's name (i.e., definition is for an autonomous custom element), then:

If the active function object is not HTMLElement, then throw a TypeError.

This can occur when a custom element is defined to not extend any local names, but inherits from a non-HTMLElement class:

customElements.define("bad-2", class Bad2 extends HTMLParagraphElement {});
In this case, during the (implicit) super() call that occurs when constructing an instance of Bad2, the active function object is HTMLParagraphElement, not HTMLElement.

Otherwise (i.e., if definition is for a customized built-in element):

Let valid local names be the list of local names for elements defined in this specification or in other applicable specifications that use the active function object as their element interface.

If valid local names does not contain definition's local name, then throw a TypeError.

This can occur when a custom element is defined to extend a given local name but inherits from the wrong class:

customElements.define("bad-3", class Bad3 extends HTMLQuoteElement {}, { extends: "p" });
In this case, during the (implicit) super() call that occurs when constructing an instance of Bad3, valid local names is the list containing q and blockquote, but definition's local name is p, which is not in that list.

Let prototype be Get(NewTarget, "prototype"). Rethrow any exceptions.

If Type(prototype) is not Object, then:

Let realm be GetFunctionRealm(NewTarget).

Set prototype to the interface prototype object of realm whose interface is the same as the interface of the active function object.

The realm of the active function object might not be realm, so we are using the more general concept of "the same interface" across realms; we are not looking for equality of interface objects. This fallback behavior, including using the realm of NewTarget and looking up the appropriate prototype there, is designed to match analogous behavior for the JavaScript built-ins.

If definition's construction stack is empty, then:

Let element be a new element that implements the interface to which the active function object corresponds, with no attributes, namespace set to the HTML namespace, local name set to definition's local name, and node document set to the current global object's associated Document.

Perform element.[[SetPrototypeOf]](prototype). Rethrow any exceptions.

Set element's custom element state to "custom".

Set element's custom element definition to definition.

Return element.

This occurs when author script constructs a new custom element directly, e.g. via new MyCustomElement().

Let element be the last entry in definition's construction stack.

If element is an already constructed marker, then throw an "InvalidStateError" DOMException.

This can occur when the author code inside the custom element constructor non-conformantly creates another instance of the class being constructed, before calling super():

let doSillyThing = false;

class DontDoThis extends HTMLElement {
  constructor() {
    if (doSillyThing) {
      doSillyThing = false;
      new DontDoThis();
      // Now the construction stack will contain an already constructed marker.
    }

    // This will then fail with an "InvalidStateError" DOMException:
    super();
  }
}
This can also occur when author code inside the custom element constructor non-conformantly calls super() twice, since per the JavaScript specification, this actually executes the superclass constructor (i.e. this algorithm) twice, before throwing an error:

class DontDoThisEither extends HTMLElement {
  constructor() {
    super();

    // This will throw, but not until it has already called into the HTMLElement constructor
    super();
  }
}
Perform element.[[SetPrototypeOf]](prototype). Rethrow any exceptions.

Replace the last entry in definition's construction stack with an already constructed marker.

Return element.

This step is normally reached when upgrading a custom element; the existing element is returned, so that the super() call inside the custom element constructor assigns that existing element to this.

In addition to the constructor behavior implied by [HTMLConstructor], some elements also have named constructors (which are really factory functions with a modified prototype property).

Named constructors for HTML elements can also be used in an extends clause when defining a custom element constructor:

class AutoEmbiggenedImage extends Image {
  constructor(width, height) {
    super(width * 10, height * 10);
  }
}

customElements.define("auto-embiggened", AutoEmbiggenedImage, { extends: "img" });

const image = new AutoEmbiggenedImage(15, 20);
console.assert(image.width === 150);
console.assert(image.height === 200);
3.2.4 Element definitions
Each element in this specification has a definition that includes the following information:

Categories
A list of categories to which the element belongs. These are used when defining the content models for each element.

Contexts in which this element can be used
A non-normative description of where the element can be used. This information is redundant with the content models of elements that allow this one as a child, and is provided only as a convenience.

For simplicity, only the most specific expectations are listed. For example, an element that is both flow content and phrasing content can be used anywhere that either flow content or phrasing content is expected, but since anywhere that flow content is expected, phrasing content is also expected (since all phrasing content is flow content), only "where phrasing content is expected" will be listed.

Content model
A normative description of what content must be included as children and descendants of the element.

Tag omission in text/html
A non-normative description of whether, in the text/html syntax, the start and end tags can be omitted. This information is redundant with the normative requirements given in the optional tags section, and is provided in the element definitions only as a convenience.

Content attributes
A normative list of attributes that may be specified on the element (except where otherwise disallowed), along with non-normative descriptions of those attributes. (The content to the left of the dash is normative, the content to the right of the dash is not.)

DOM interface
A normative definition of a DOM interface that such elements must implement.

This is then followed by a description of what the element represents, along with any additional normative conformance criteria that may apply to authors and implementations. Examples are sometimes also included.

3.2.4.1 Attributes
An attribute value is a string. Except where otherwise specified, attribute values on HTML elements may be any string value, including the empty string, and there is no restriction on what text can be specified in such attribute values.

3.2.5 Content models
Each element defined in this specification has a content model: a description of the element's expected contents. An HTML element must have contents that match the requirements described in the element's content model. The contents of an element are its children in the DOM.

ASCII whitespace is always allowed between elements. User agents represent these characters between elements in the source markup as Text nodes in the DOM. Empty Text nodes and Text nodes consisting of just sequences of those characters are considered inter-element whitespace.

Inter-element whitespace, comment nodes, and processing instruction nodes must be ignored when establishing whether an element's contents match the element's content model or not, and must be ignored when following algorithms that define document and element semantics.

Thus, an element A is said to be preceded or followed by a second element B if A and B have the same parent node and there are no other element nodes or Text nodes (other than inter-element whitespace) between them. Similarly, a node is the only child of an element if that element contains no other nodes other than inter-element whitespace, comment nodes, and processing instruction nodes.

Authors must not use HTML elements anywhere except where they are explicitly allowed, as defined for each element, or as explicitly required by other specifications. For XML compound documents, these contexts could be inside elements from other namespaces, if those elements are defined as providing the relevant contexts.

For example, the Atom specification defines a content element. When its type attribute has the value xhtml, the Atom specification requires that it contain a single HTML div element. Thus, a div element is allowed in that context, even though this is not explicitly normatively stated by this specification. [ATOM]

In addition, HTML elements may be orphan nodes (i.e. without a parent node).

For example, creating a td element and storing it in a global variable in a script is conforming, even though td elements are otherwise only supposed to be used inside tr elements.

var data = {
  name: "Banana",
  cell: document.createElement('td'),
};
3.2.5.1 The "nothing" content model
When an element's content model is nothing, the element must contain no Text nodes (other than inter-element whitespace) and no element nodes.

Most HTML elements whose content model is "nothing" are also, for convenience, void elements (elements that have no end tag in the HTML syntax). However, these are entirely separate concepts.

3.2.5.2 Kinds of content
Each element in HTML falls into zero or more categories that group elements with similar characteristics together. The following broad categories are used in this specification:

Metadata content
Flow content
Sectioning content
Heading content
Phrasing content
Embedded content
Interactive content
Some elements also fall into other categories, which are defined in other parts of this specification.

These categories are related as follows:



Sectioning content, heading content, phrasing content, embedded content, and interactive content are all types of flow content. Metadata is sometimes flow content. Metadata and interactive content are sometimes phrasing content. Embedded content is also a type of phrasing content, and sometimes is interactive content.

Other categories are also used for specific purposes, e.g. form controls are specified using a number of categories to define common requirements. Some elements have unique requirements and do not fit into any particular category.

3.2.5.2.1 Metadata content
Metadata content is content that sets up the presentation or behavior of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other "out of band" information.

baselinkmetanoscriptscriptstyletemplatetitle
Elements from other namespaces whose semantics are primarily metadata-related (e.g. RDF) are also metadata content.

Thus, in the XML serialization, one can use RDF, like this:

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:r="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xml:lang="en">
 <head>
  <title>Hedral's Home Page</title>
  <r:RDF>
   <Person xmlns="http://www.w3.org/2000/10/swap/pim/contact#"
           r:about="https://hedral.example.com/#">
    <fullName>Cat Hedral</fullName>
    <mailbox r:resource="mailto:hedral@damowmow.com"/>
    <personalTitle>Sir</personalTitle>
   </Person>
  </r:RDF>
 </head>
 <body>
  <h1>My home page</h1>
  <p>I like playing with string, I guess. Sister says squirrels are fun
  too so sometimes I follow her to play with them.</p>
 </body>
</html>
This isn't possible in the HTML serialization, however.

3.2.5.2.2 Flow content
Most elements that are used in the body of documents and applications are categorized as flow content.

aabbraddressarea (if it is a descendant of a map element)articleasideaudiobbdibdoblockquotebrbuttoncanvascitecodedatadatalistdeldetailsdfndialogdivdlemembedfieldsetfigurefooterformh1h2h3h4h5h6headerhgrouphriiframeimginputinskbdlabellink (if it is allowed in the body)main (if it is a hierarchically correct main element)mapmarkMathML mathmenumeta (if the itemprop attribute is present)meternavnoscriptobjectoloutputppicturepreprogressqrubyssampscriptsectionselectslotsmallspanstrongsubsupSVG svgtabletemplatetextareatimeuulvarvideowbrautonomous custom elementstext
3.2.5.2.3 Sectioning content
Sectioning content is content that defines the scope of headings and footers.

articleasidenavsection
Each sectioning content element potentially has a heading and an outline. See the section on headings and sections for further details.

There are also certain elements that are sectioning roots. These are distinct from sectioning content, but they can also have an outline.

3.2.5.2.4 Heading content
Heading content defines the header of a section (whether explicitly marked up using sectioning content elements, or implied by the heading content itself).

h1h2h3h4h5h6hgroup
3.2.5.2.5 Phrasing content

Spec bugs: 25493

Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.

aabbrarea (if it is a descendant of a map element)audiobbdibdobrbuttoncanvascitecodedatadatalistdeldfnemembediiframeimginputinskbdlabellink (if it is allowed in the body)mapmarkMathML mathmeta (if the itemprop attribute is present)meternoscriptobjectoutputpictureprogressqrubyssampscriptselectslotsmallspanstrongsubsupSVG svgtemplatetextareatimeuvarvideowbrautonomous custom elementstext
Most elements that are categorized as phrasing content can only contain elements that are themselves categorized as phrasing content, not any flow content.

Text, in the context of content models, means either nothing, or Text nodes. Text is sometimes used as a content model on its own, but is also phrasing content, and can be inter-element whitespace (if the Text nodes are empty or contain just ASCII whitespace).

Text nodes and attribute values must consist of scalar values, excluding noncharacters, and controls other than ASCII whitespace. This specification includes extra constraints on the exact value of Text nodes and attribute values depending on their precise context.

3.2.5.2.6 Embedded content
Embedded content is content that imports another resource into the document, or content from another vocabulary that is inserted into the document.

audiocanvasembediframeimgMathML mathobjectpictureSVG svgvideo
Elements that are from namespaces other than the HTML namespace and that convey content but not metadata, are embedded content for the purposes of the content models defined in this specification. (For example, MathML, or SVG.)

Some embedded content elements can have fallback content: content that is to be used when the external resource cannot be used (e.g. because it is of an unsupported format). The element definitions state what the fallback is, if any.

3.2.5.2.7 Interactive content
Interactive content is content that is specifically intended for user interaction.

a (if the href attribute is present)audio (if the controls attribute is present)buttondetailsembediframeimg (if the usemap attribute is present)input (if the type attribute is not in the Hidden state)labelobject (if the usemap attribute is present)selecttextareavideo (if the controls attribute is present)
The tabindex attribute can also make any element into interactive content.

3.2.5.2.8 Palpable content
As a general rule, elements whose content model allows any flow content or phrasing content should have at least one node in its contents that is palpable content and that does not have the hidden attribute specified.

Palpable content makes an element non-empty by providing either some descendant non-empty text, or else something users can hear (audio elements) or view (video or img or canvas elements) or otherwise interact with (for example, interactive form controls).

This requirement is not a hard requirement, however, as there are many cases where an element can be empty legitimately, for example when it is used as a placeholder which will later be filled in by a script, or when the element is part of a template and would on most pages be filled in but on some pages is not relevant.

Conformance checkers are encouraged to provide a mechanism for authors to find elements that fail to fulfill this requirement, as an authoring aid.

The following elements are palpable content:

aabbraddressarticleasideaudio (if the controls attribute is present)bbdibdoblockquotebuttoncanvascitecodedatadetailsdfndivdl (if the element's children include at least one name-value group)emembedfieldsetfigurefooterformh1h2h3h4h5h6headerhgroupiiframeimginput (if the type attribute is not in the Hidden state)inskbdlabelmainmapmarkMathML mathmenu (if the element's children include at least one li element)meternavobjectol (if the element's children include at least one li element)outputppreprogressqrubyssampsectionselectsmallspanstrongsubsupSVG svgtabletextareatimeuul (if the element's children include at least one li element)varvideoautonomous custom elementstext that is not inter-element whitespace
3.2.5.2.9 Script-supporting elements
Script-supporting elements are those that do not represent anything themselves (i.e. they are not rendered), but are used to support scripts, e.g. to provide functionality for the user.

The following elements are script-supporting elements:

scripttemplate
3.2.5.3 Transparent content models
Some elements are described as transparent; they have "transparent" in the description of their content model. The content model of a transparent element is derived from the content model of its parent element: the elements required in the part of the content model that is "transparent" are the same elements as required in the part of the content model of the parent of the transparent element in which the transparent element finds itself.

For instance, an ins element inside a ruby element cannot contain an rt element, because the part of the ruby element's content model that allows ins elements is the part that allows phrasing content, and the rt element is not phrasing content.

In some cases, where transparent elements are nested in each other, the process has to be applied iteratively.

Consider the following markup fragment:

<p><object><param><ins><map><a href="/">Apples</a></map></ins></object></p>
To check whether "Apples" is allowed inside the a element, the content models are examined. The a element's content model is transparent, as is the map element's, as is the ins element's, as is the part of the object element's in which the ins element is found. The object element is found in the p element, whose content model is phrasing content. Thus, "Apples" is allowed, as text is phrasing content.

When a transparent element has no parent, then the part of its content model that is "transparent" must instead be treated as accepting any flow content.

3.2.5.4 Paragraphs
The term paragraph as defined in this section is used for more than just the definition of the p element. The paragraph concept defined here is used to describe how to interpret documents. The p element is merely one of several ways of marking up a paragraph.

A paragraph is typically a run of phrasing content that forms a block of text with one or more sentences that discuss a particular topic, as in typography, but can also be used for more general thematic grouping. For instance, an address is also a paragraph, as is a part of a form, a byline, or a stanza in a poem.

In the following example, there are two paragraphs in a section. There is also a heading, which contains phrasing content that is not a paragraph. Note how the comments and inter-element whitespace do not form paragraphs.

<section>
  <h1>Example of paragraphs</h1>
  This is the <em>first</em> paragraph in this example.
  <p>This is the second.</p>
  <!-- This is not a paragraph. -->
</section>
Paragraphs in flow content are defined relative to what the document looks like without the a, ins, del, and map elements complicating matters, since those elements, with their hybrid content models, can straddle paragraph boundaries, as shown in the first two examples below.

Generally, having elements straddle paragraph boundaries is best avoided. Maintaining such markup can be difficult.

The following example takes the markup from the earlier example and puts ins and del elements around some of the markup to show that the text was changed (though in this case, the changes admittedly don't make much sense). Notice how this example has exactly the same paragraphs as the previous one, despite the ins and del elements — the ins element straddles the heading and the first paragraph, and the del element straddles the boundary between the two paragraphs.

<section>
  <ins><h1>Example of paragraphs</h1>
  This is the <em>first</em> paragraph in</ins> this example<del>.
  <p>This is the second.</p></del>
  <!-- This is not a paragraph. -->
</section>
Let view be a view of the DOM that replaces all a, ins, del, and map elements in the document with their contents. Then, in view, for each run of sibling phrasing content nodes uninterrupted by other types of content, in an element that accepts content other than phrasing content as well as phrasing content, let first be the first node of the run, and let last be the last node of the run. For each such run that consists of at least one node that is neither embedded content nor inter-element whitespace, a paragraph exists in the original DOM from immediately before first to immediately after last. (Paragraphs can thus span across a, ins, del, and map elements.)

Conformance checkers may warn authors of cases where they have paragraphs that overlap each other (this can happen with object, video, audio, and canvas elements, and indirectly through elements in other namespaces that allow HTML to be further embedded therein, like SVG svg or MathML math).

A paragraph is also formed explicitly by p elements.

The p element can be used to wrap individual paragraphs when there would otherwise not be any content other than phrasing content to separate the paragraphs from each other.

In the following example, the link spans half of the first paragraph, all of the heading separating the two paragraphs, and half of the second paragraph. It straddles the paragraphs and the heading.

<header>
 Welcome!
 <a href="about.html">
  This is home of...
  <h1>The Falcons!</h1>
  The Lockheed Martin multirole jet fighter aircraft!
 </a>
 This page discusses the F-16 Fighting Falcon's innermost secrets.
</header>
Here is another way of marking this up, this time showing the paragraphs explicitly, and splitting the one link element into three:

<header>
 <p>Welcome! <a href="about.html">This is home of...</a></p>
 <h1><a href="about.html">The Falcons!</a></h1>
 <p><a href="about.html">The Lockheed Martin multirole jet
 fighter aircraft!</a> This page discusses the F-16 Fighting
 Falcon's innermost secrets.</p>
</header>
It is possible for paragraphs to overlap when using certain elements that define fallback content. For example, in the following section:

<section>
 <h1>My Cats</h1>
 You can play with my cat simulator.
 <object data="cats.sim">
  To see the cat simulator, use one of the following links:
  <ul>
   <li><a href="cats.sim">Download simulator file</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a>
  </ul>
  Alternatively, upgrade to the Mellblom Browser.
 </object>
 I'm quite proud of it.
</section>
There are five paragraphs:

The paragraph that says "You can play with my cat simulator. object I'm quite proud of it.", where object is the object element.
The paragraph that says "To see the cat simulator, use one of the following links:".
The paragraph that says "Download simulator file".
The paragraph that says "Use online simulator".
The paragraph that says "Alternatively, upgrade to the Mellblom Browser.".
The first paragraph is overlapped by the other four. A user agent that supports the "cats.sim" resource will only show the first one, but a user agent that shows the fallback will confusingly show the first sentence of the first paragraph as if it was in the same paragraph as the second one, and will show the last paragraph as if it was at the start of the second sentence of the first paragraph.

To avoid this confusion, explicit p elements can be used. For example:

<section>
 <h1>My Cats</h1>
 <p>You can play with my cat simulator.</p>
 <object data="cats.sim">
  <p>To see the cat simulator, use one of the following links:</p>
  <ul>
   <li><a href="cats.sim">Download simulator file</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a>
  </ul>
  <p>Alternatively, upgrade to the Mellblom Browser.</p>
 </object>
 <p>I'm quite proud of it.</p>
</section>
3.2.6 Global attributes
The following attributes are common to and may be specified on all HTML elements (even those not defined in this specification):

accesskey
autocapitalize
contenteditable
dir
draggable
hidden
inputmode
is
itemid
itemprop
itemref
itemscope
itemtype
lang
nonce
spellcheck
style
tabindex
title
translate
These attributes are only defined by this specification as attributes for HTML elements. When this specification refers to elements having these attributes, elements from namespaces that are not defined as having these attributes must not be considered as being elements with these attributes.

For example, in the following XML fragment, the "bogus" element does not have a dir attribute as defined in this specification, despite having an attribute with the literal name "dir". Thus, the directionality of the inner-most span element is 'rtl', inherited from the div element indirectly through the "bogus" element.

<div xmlns="http://www.w3.org/1999/xhtml" dir="rtl">
 <bogus xmlns="https://example.net/ns" dir="ltr">
  <span xmlns="http://www.w3.org/1999/xhtml">
  </span>
 </bogus>
</div>
The WHATWG DOM standard defines the user agent requirements for the class, id, and slot attributes for any element in any namespace. [DOM]

The class, id, and slot attributes may be specified on all HTML elements.

When specified on HTML elements, the class attribute must have a value that is a set of space-separated tokens representing the various classes that the element belongs to.

Assigning classes to an element affects class matching in selectors in CSS, the getElementsByClassName() method in the DOM, and other such features.

There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content.

When specified on HTML elements, the id attribute value must be unique amongst all the IDs in the element's tree and must contain at least one character. The value must not contain any ASCII whitespace.

The id attribute specifies its element's unique identifier (ID).

There are no other restrictions on what form an ID can take; in particular, IDs can consist of just digits, start with a digit, start with an underscore, consist of just punctuation, etc.

An element's unique identifier can be used for a variety of purposes, most notably as a way to link to specific parts of a document using fragments, as a way to target an element when scripting, and as a way to style a specific element from CSS.

Identifiers are opaque strings. Particular meanings should not be derived from the value of the id attribute.

There are no conformance requirements for the slot attribute specific to HTML elements.

The slot attribute is used to assign a slot to an element: an element with a slot attribute is assigned to the slot created by the slot element whose name attribute's value matches that slot attribute's value — but only if that slot element finds itself in the shadow tree whose root's host has the corresponding slot attribute value.

To enable assistive technology products to expose a more fine-grained interface than is otherwise possible with HTML elements and attributes, a set of annotations for assistive technology products can be specified (the ARIA role and aria-* attributes). [ARIA]

The following event handler content attributes may be specified on any HTML element:

onabort
onauxclick
onblur*
oncancel
oncanplay
oncanplaythrough
onchange
onclick
onclose
oncontextmenu
oncuechange
ondblclick
ondrag
ondragend
ondragenter
ondragexit
ondragleave
ondragover
ondragstart
ondrop
ondurationchange
onemptied
onended
onerror*
onfocus*
oninput
oninvalid
onkeydown
onkeypress
onkeyup
onload*
onloadeddata
onloadedmetadata
onloadend
onloadstart
onmousedown
onmouseenter
onmouseleave
onmousemove
onmouseout
onmouseover
onmouseup
onwheel
onpause
onplay
onplaying
onprogress
onratechange
onreset
onresize*
onscroll*
onsecuritypolicyviolation
onseeked
onseeking
onselect
onstalled
onsubmit
onsuspend
ontimeupdate
ontoggle
onvolumechange
onwaiting
The attributes marked with an asterisk have a different meaning when specified on body elements as those elements expose event handlers of the Window object with the same names.

While these attributes apply to all elements, they are not useful on all elements. For example, only media elements will ever receive a volumechange event fired by the user agent.

Custom data attributes (e.g. data-foldername or data-msgid) can be specified on any HTML element, to store custom data, state, annotations, and similar, specific to the page.

In HTML documents, elements in the HTML namespace may have an xmlns attribute specified, if, and only if, it has the exact value "http://www.w3.org/1999/xhtml". This does not apply to XML documents.

In HTML, the xmlns attribute has absolutely no effect. It is basically a talisman. It is allowed merely to make migration to and from XML mildly easier. When parsed by an HTML parser, the attribute ends up in no namespace, not the "http://www.w3.org/2000/xmlns/" namespace like namespace declaration attributes in XML do.

In XML, an xmlns attribute is part of the namespace declaration mechanism, and an element cannot actually have an xmlns attribute in no namespace specified.

The XML specification also allows the use of the xml:space attribute in the XML namespace on any element in an XML document. This attribute has no effect on HTML elements, as the default behavior in HTML is to preserve whitespace. [XML]

There is no way to serialize the xml:space attribute on HTML elements in the text/html syntax.

3.2.6.1 The title attribute
The title attribute represents advisory information for the element, such as would be appropriate for a tooltip. On a link, this could be the title or a description of the target resource; on an image, it could be the image credit or a description of the image; on a paragraph, it could be a footnote or commentary on the text; on a citation, it could be further information about the source; on interactive content, it could be a label for, or instructions for, use of the element; and so forth. The value is text.

Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g., requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).

If this attribute is omitted from an element, then it implies that the title attribute of the nearest ancestor HTML element with a title attribute set is also relevant to this element. Setting the attribute overrides this, explicitly stating that the advisory information of any ancestors is not relevant to this element. Setting the attribute to the empty string indicates that the element has no advisory information.

If the title attribute's value contains U+000A LINE FEED (LF) characters, the content is split into multiple lines. Each U+000A LINE FEED (LF) character represents a line break.

Caution is advised with respect to the use of newlines in title attributes.

For instance, the following snippet actually defines an abbreviation's expansion with a line break in it:

<p>My logs show that there was some interest in <abbr title="Hypertext
Transport Protocol">HTTP</abbr> today.</p>
Some elements, such as link, abbr, and input, define additional semantics for the title attribute beyond the semantics described above.

The advisory information of an element is the value that the following algorithm returns, with the algorithm being aborted once a value is returned. When the algorithm returns the empty string, then there is no advisory information.

If the element has a title attribute, then return its value.

If the element has a parent element, then return the parent element's advisory information.

Return the empty string.

User agents should inform the user when elements have advisory information, otherwise the information would not be discoverable.

The title IDL attribute must reflect the title content attribute.

3.2.6.2 The lang and xml:lang attributes
The lang attribute (in no namespace) specifies the primary language for the element's contents and for any of the element's attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47]

The lang attribute in the XML namespace is defined in XML. [XML]

If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.

The lang attribute in no namespace may be used on any HTML element.

The lang attribute in the XML namespace may be used on HTML elements in XML documents, as well as elements in other namespaces if the relevant specifications allow it (in particular, MathML and SVG allow lang attributes in the XML namespace to be specified on their elements). If both the lang attribute in no namespace and the lang attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.

Authors must not use the lang attribute in the XML namespace on HTML elements in HTML documents. To ease migration to and from XML, authors may specify an attribute in no namespace with no prefix and with the literal localname "xml:lang" on HTML elements in HTML documents, but such attributes must only be specified if a lang attribute in no namespace is also specified, and both attributes must have the same value when compared in an ASCII case-insensitive manner.

The attribute in no namespace with no prefix and with the literal localname "xml:lang" has no effect on language processing.

To determine the language of a node, user agents must look at the nearest ancestor element (including the element itself if the node is an element) that has a lang attribute in the XML namespace set or is an HTML element and has a lang in no namespace attribute set. That attribute specifies the language of the node (regardless of its value).

If both the lang attribute in no namespace and the lang attribute in the XML namespace are set on an element, user agents must use the lang attribute in the XML namespace, and the lang attribute in no namespace must be ignored for the purposes of determining the element's language.

If node's inclusive ancestors do not have either attribute set, but there is a pragma-set default language set, then that is the language of the node. If there is no pragma-set default language set, then language information from a higher-level protocol (such as HTTP), if any, must be used as the final fallback language instead. In the absence of any such language information, and in cases where the higher-level protocol reports multiple languages, the language of the node is unknown, and the corresponding language tag is the empty string.

If the resulting value is not a recognized language tag, then it must be treated as an unknown language having the given language tag, distinct from all other languages. For the purposes of round-tripping or communicating with other services that expect language tags, user agents should pass unknown language tags through unmodified, and tagged as being BCP 47 language tags, so that subsequent services do not interpret the data as another type of language description. [BCP47]

Thus, for instance, an element with lang="xyzzy" would be matched by the selector :lang(xyzzy) (e.g. in CSS), but it would not be matched by :lang(abcde), even though both are equally invalid. Similarly, if a Web browser and screen reader working in unison communicated about the language of the element, the browser would tell the screen reader that the language was "xyzzy", even if it knew it was invalid, just in case the screen reader actually supported a language with that tag after all. Even if the screen reader supported both BCP 47 and another syntax for encoding language names, and in that other syntax the string "xyzzy" was a way to denote the Belarusian language, it would be incorrect for the screen reader to then start treating text as Belarusian, because "xyzzy" is not how Belarusian is described in BCP 47 codes (BCP 47 uses the code "be" for Belarusian).

If the resulting value is the empty string, then it must be interpreted as meaning that the language of the node is explicitly unknown.

User agents may use the element's language to determine proper processing or rendering (e.g. in the selection of appropriate fonts or pronunciations, for dictionary selection, or for the user interfaces of form controls such as date pickers).

The lang IDL attribute must reflect the lang content attribute in no namespace.

3.2.6.3 The translate attribute
The translate attribute is an enumerated attribute that is used to specify whether an element's attribute values and the values of its Text node children are to be translated when the page is localized, or whether to leave them unchanged.

The attribute's keywords are the empty string, yes, and no. The empty string and the yes keyword map to the yes state. The no keyword maps to the no state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid value default.

Each element (even non-HTML elements) has a translation mode, which is in either the translate-enabled state or the no-translate state. If an HTML element's translate attribute is in the yes state, then the element's translation mode is in the translate-enabled state; otherwise, if the element's translate attribute is in the no state, then the element's translation mode is in the no-translate state. Otherwise, either the element's translate attribute is in the inherit state, or the element is not an HTML element and thus does not have a translate attribute; in either case, the element's translation mode is in the same state as its parent element's, if any, or in the translate-enabled state, if the element is a document element.

When an element is in the translate-enabled state, the element's translatable attributes and the values of its Text node children are to be translated when the page is localized.

When an element is in the no-translate state, the element's attribute values and the values of its Text node children are to be left as-is when the page is localized, e.g. because the element contains a person's name or a name of a computer program.

The following attributes are translatable attributes:

abbr on th elements
alt on area, img, and input elements
content on meta elements, if the name attribute specifies a metadata name whose value is known to be translatable
download on a and area elements
label on optgroup, option, and track elements
lang on HTML elements; must be "translated" to match the language used in the translation
placeholder on input and textarea elements
srcdoc on iframe elements; must be parsed and recursively processed
style on HTML elements; must be parsed and recursively processed (e.g. for the values of 'content' properties)
title on all HTML elements
value on input elements with a type attribute in the Button state or the Reset Button state
Other specifications may define other attributes that are also translatable attributes. For example, ARIA would define the aria-label attribute as translatable.

The translate IDL attribute must, on getting, return true if the element's translation mode is translate-enabled, and false otherwise. On setting, it must set the content attribute's value to "yes" if the new value is true, and set the content attribute's value to "no" otherwise.

In this example, everything in the document is to be translated when the page is localized, except the sample keyboard input and sample program output:

<!DOCTYPE HTML>
<html lang=en> <!-- default on the document element is translate=yes -->
 <head>
  <title>The Bee Game</title> <!-- implied translate=yes inherited from ancestors -->
 </head>
 <body>
  <p>The Bee Game is a text adventure game in English.</p>
  <p>When the game launches, the first thing you should do is type
  <kbd translate=no>eat honey</kbd>. The game will respond with:</p>
  <pre><samp translate=no>Yum yum! That was some good honey!</samp></pre>
 </body>
</html>
3.2.6.4 The dir attribute
The dir attribute specifies the element's text directionality. The attribute is an enumerated attribute with the following keywords and states:

The ltr keyword, which maps to the ltr state
Indicates that the contents of the element are explicitly directionally isolated left-to-right text.

The rtl keyword, which maps to the rtl state
Indicates that the contents of the element are explicitly directionally isolated right-to-left text.

The auto keyword, which maps to the auto state
Indicates that the contents of the element are explicitly directionally isolated text, but that the direction is to be determined programmatically using the contents of the element (as described below).

The heuristic used by this state is very crude (it just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm). Authors are urged to only use this value as a last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied. [BIDI]

For textarea and pre elements, the heuristic is applied on a per-paragraph level.

The attribute has no invalid value default and no missing value default.

The directionality of an element (any element, not just an HTML element) is either 'ltr' or 'rtl', and is determined as per the first appropriate set of steps from the following list:

If the element's dir attribute is in the ltr state
If the element is a document element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
If the element is an input element whose type attribute is in the Telephone state, and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
The directionality of the element is 'ltr'.

If the element's dir attribute is in the rtl state
The directionality of the element is 'rtl'.

If the element is an input element whose type attribute is in the Text, Search, Telephone, URL, or E-mail state, and the dir attribute is in the auto state
If the element is a textarea element and the dir attribute is in the auto state
If the element's value contains a character of bidirectional character type AL or R, and there is no character of bidirectional character type L anywhere before it in the element's value, then the directionality of the element is 'rtl'. [BIDI]

Otherwise, if the element's value is not the empty string, or if the element is a document element, the directionality of the element is 'ltr'.

Otherwise, the directionality of the element is the same as the element's parent element's directionality.

If the element's dir attribute is in the auto state
If the element is a bdi element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
Find the first character in tree order that matches the following criteria:

The character is from a Text node that is a descendant of the element whose directionality is being determined.

The character is of bidirectional character type L, AL, or R. [BIDI]

The character is not in a Text node that has an ancestor element that is a descendant of the element whose directionality is being determined and that is either:

A bdi element.
A script element.
A style element.
A textarea element.
An element with a dir attribute in a defined state.
If such a character is found and it is of bidirectional character type AL or R, the directionality of the element is 'rtl'.

If such a character is found and it is of bidirectional character type L, the directionality of the element is 'ltr'.

Otherwise, if the element is a document element, the directionality of the element is 'ltr'.

Otherwise, the directionality of the element is the same as the element's parent element's directionality.

If the element has a parent element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
The directionality of the element is the same as the element's parent element's directionality.

Since the dir attribute is only defined for HTML elements, it cannot be present on elements from other namespaces. Thus, elements from other namespaces always just inherit their directionality from their parent element, or, if they don't have one, default to 'ltr'.

This attribute has rendering requirements involving the bidirectional algorithm.

The directionality of an attribute of an HTML element, which is used when the text of that attribute is to be included in the rendering in some manner, is determined as per the first appropriate set of steps from the following list:

If the attribute is a directionality-capable attribute and the element's dir attribute is in the auto state
Find the first character (in logical order) of the attribute's value that is of bidirectional character type L, AL, or R. [BIDI]

If such a character is found and it is of bidirectional character type AL or R, the directionality of the attribute is 'rtl'.

Otherwise, the directionality of the attribute is 'ltr'.

Otherwise
The directionality of the attribute is the same as the element's directionality.
The following attributes are directionality-capable attributes:

abbr on th elements
alt on area, img, and input elements
content on meta elements, if the name attribute specifies a metadata name whose value is primarily intended to be human-readable rather than machine-readable
label on optgroup, option, and track elements
placeholder on input and textarea elements
title on all HTML elements
document . dir [ = value ]
Returns the html element's dir attribute's value, if any.

Can be set, to either "ltr", "rtl", or "auto" to replace the html element's dir attribute's value.

If there is no html element, returns the empty string and ignores new values.

The dir IDL attribute on an element must reflect the dir content attribute of that element, limited to only known values.

The dir IDL attribute on Document objects must reflect the dir content attribute of the html element, if any, limited to only known values. If there is no such element, then the attribute must return the empty string and do nothing on setting.

Authors are strongly encouraged to use the dir attribute to indicate text direction rather than using CSS, since that way their documents will continue to render correctly even in the absence of CSS (e.g. as interpreted by search engines).

This markup fragment is of an IM conversation.

<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> How do you write "What's your name?" in Arabic?</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> ما اسمك؟</p>
<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> Thanks.</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> That's written "شكرًا".</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> Do you know how to write "Please"?</p>
<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> "من فضلك", right?</p>
Given a suitable style sheet and the default alignment styles for the p element, namely to align the text to the start edge of the paragraph, the resulting rendering could be as follows:



As noted earlier, the auto value is not a panacea. The final paragraph in this example is misinterpreted as being right-to-left text, since it begins with an Arabic character, which causes the "right?" to be to the left of the Arabic text.

3.2.6.5 The style attribute
All HTML elements may have the style content attribute set. This is a style attribute as defined by the CSS Style Attributes specification. [CSSATTR]

In user agents that support CSS, the attribute's value must be parsed when the attribute is added or has its value changed, according to the rules given for style attributes. [CSSATTR]

However, if the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "style attribute", and the attribute's value, then the style rules defined in the attribute's value must not be applied to the element. [CSP]

Documents that use style attributes on any of their elements must still be comprehensible and usable if those attributes were removed.

In particular, using the style attribute to hide and show content, or to convey meaning that is otherwise not included in the document, is non-conforming. (To hide and show content, use the hidden attribute.)

element . style
Returns a CSSStyleDeclaration object for the element's style attribute.

The style IDL attribute is defined in the CSS Object Model (CSSOM) specification. [CSSOM]

In the following example, the words that refer to colors are marked up using the span element and the style attribute to make those words show up in the relevant colors in visual media.

<p>My sweat suit is <span style="color: green; background:
transparent">green</span> and my eyes are <span style="color: blue;
background: transparent">blue</span>.</p>
3.2.6.6 Embedding custom non-visible data with the data-* attributes

Support: dataset
Chrome for Android	64+
Chrome	7+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	6+
Samsung Internet	4+
IE	11+
Opera Mini (limited)	all+
Safari	5.1+
Edge	12+
Android Browser	3+
Opera	11.1+

Source: caniuse.com

A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is XML-compatible, and contains no ASCII upper alphas.

All attribute names on HTML elements in HTML documents get ASCII-lowercased automatically, so the restriction on ASCII uppercase letters doesn't affect such documents.

Custom data attributes are intended to store custom data, state, annotations, and similar, private to the page or application, for which there are no more appropriate attributes or elements.

These attributes are not intended for use by software that is not known to the administrators of the site that uses the attributes. For generic extensions that are to be used by multiple independent tools, either this specification should be extended to provide the feature explicitly, or a technology like microdata should be used (with a standardized vocabulary).

For instance, a site about music could annotate list items representing tracks in an album with custom data attributes containing the length of each track. This information could then be used by the site itself to allow the user to sort the list by track length, or to filter the list for tracks of certain lengths.

<ol>
 <li data-length="2m11s">Beyond The Sea</li>
 ...
</ol>
It would be inappropriate, however, for the user to use generic software not associated with that music site to search for tracks of a certain length by looking at this data.

This is because these attributes are intended for use by the site's own scripts, and are not a generic extension mechanism for publicly-usable metadata.

Similarly, a page author could write markup that provides information for a translation tool that they are intending to use:

<p>The third <span data-mytrans-de="Anspruch">claim</span> covers the case of <span
translate="no">HTML</span> markup.</p>
In this example, the "data-mytrans-de" attribute gives specific text for the MyTrans product to use when translating the phrase "claim" to German. However, the standard translate attribute is used to tell it that in all languages, "HTML" is to remain unchanged. When a standard attribute is available, there is no need for a custom data attribute to be used.

In this example, custom data attributes are used to store the result of a feature detection for PaymentRequest, which could be used in CSS to style a checkout page differently.

<script>
 if ('PaymentRequest' in window) {
   document.documentElement.dataset.hasPaymentRequest = '';
 }
</script>
Here, the data-has-payment-request attribute is effectively being used as a boolean attribute; it is enough to check the presence of the attribute. However, if the author so wishes, it could later be populated with some value, maybe to indicate limited functionality of the feature.

Every HTML element may have any number of custom data attributes specified, with any value.

Authors should carefully design such extensions so that when the attributes are ignored and any associated CSS dropped, the page is still usable.

User agents must not derive any implementation behavior from these attributes or values. Specifications intended for user agents must not define these attributes to have any meaningful values.

JavaScript libraries may use the custom data attributes, as they are considered to be part of the page on which they are used. Authors of libraries that are reused by many authors are encouraged to include their name in the attribute names, to reduce the risk of clashes. Where it makes sense, library authors are also encouraged to make the exact name used in the attribute names customizable, so that libraries whose authors unknowingly picked the same name can be used on the same page, and so that multiple versions of a particular library can be used on the same page even when those versions are not mutually compatible.

For example, a library called "DoQuery" could use attribute names like data-doquery-range, and a library called "jJo" could use attributes names like data-jjo-range. The jJo library could also provide an API to set which prefix to use (e.g. J.setDataPrefix('j2'), making the attributes have names like data-j2-range).

element . dataset
Returns a DOMStringMap object for the element's data-* attributes.

Hyphenated names become camel-cased. For example, data-foo-bar="" becomes element.dataset.fooBar.

The dataset IDL attribute provides convenient accessors for all the data-* attributes on an element. On getting, the dataset IDL attribute must return a DOMStringMap whose associated element is this element.

The DOMStringMap interface is used for the dataset attribute. Each DOMStringMap has an associated element.

[Exposed=Window,
 OverrideBuiltins]
interface DOMStringMap {
  getter DOMString (DOMString name);
  [CEReactions] setter void (DOMString name, DOMString value);
  [CEReactions] deleter void (DOMString name);
};
To get a DOMStringMap's name-value pairs, run the following algorithm:

Let list be an empty list of name-value pairs.

For each content attribute on the DOMStringMap's associated element whose first five characters are the string "data-" and whose remaining characters (if any) do not include any ASCII upper alphas, in the order that those attributes are listed in the element's attribute list, add a name-value pair to list whose name is the attribute's name with the first five characters removed and whose value is the attribute's value.

For each name in list, for each U+002D HYPHEN-MINUS character (-) in the name that is followed by an ASCII lower alpha, remove the U+002D HYPHEN-MINUS character (-) and replace the character that followed it by the same character converted to ASCII uppercase.

Return list.

The supported property names on a DOMStringMap object at any instant are the names of each pair returned from getting the DOMStringMap's name-value pairs at that instant, in the order returned.

To determine the value of a named property name for a DOMStringMap, return the value component of the name-value pair whose name component is name in the list returned from getting the DOMStringMap's name-value pairs.

To set the value of a new named property or set the value of an existing named property for a DOMStringMap, given a property name name and a new value value, run the following steps:

If name contains a U+002D HYPHEN-MINUS character (-) followed by an ASCII lower alpha, then throw a "SyntaxError" DOMException.

For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.

Insert the string data- at the front of name.

If name does not match the XML Name production, throw an "InvalidCharacterError" DOMException.

Set an attribute value for the DOMStringMap's associated element using name and value.

To delete an existing named property name for a DOMStringMap, run the following steps:

For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.

Insert the string data- at the front of name.

Remove an attribute by name given name and the DOMStringMap's associated element.

This algorithm will only get invoked by the Web IDL specification for names that are given by the earlier algorithm for getting the DOMStringMap's name-value pairs. [WEBIDL]

If a Web page wanted an element to represent a space ship, e.g. as part of a game, it would have to use the class attribute along with data-* attributes:

<div class="spaceship" data-ship-id="92432"
     data-weapons="laser 2" data-shields="50%"
     data-x="30" data-y="10" data-z="90">
 <button class="fire"
         onclick="spaceships[this.parentNode.dataset.shipId].fire()">
  Fire
 </button>
</div>
Notice how the hyphenated attribute name becomes camel-cased in the API.

Given the following fragment and elements with similar constructions:

<img class="tower" id="tower5" data-x="12" data-y="5"
     data-ai="robotarget" data-hp="46" data-ability="flames"
     src="towers/rocket.png" alt="Rocket Tower">
...one could imagine a function splashDamage() that takes some arguments, the first of which is the element to process:

function splashDamage(node, x, y, damage) {
  if (node.classList.contains('tower') && // checking the 'class' attribute
      node.dataset.x == x && // reading the 'data-x' attribute
      node.dataset.y == y) { // reading the 'data-y' attribute
    var hp = parseInt(node.dataset.hp); // reading the 'data-hp' attribute
    hp = hp - damage;
    if (hp < 0) {
      hp = 0;
      node.dataset.ai = 'dead'; // setting the 'data-ai' attribute
      delete node.dataset.ability; // removing the 'data-ability' attribute
    }
    node.dataset.hp = hp; // setting the 'data-hp' attribute
  }
}
3.2.7 The innerText IDL attribute

Support: innertext
Chrome for Android	64+
Chrome	4+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	45+
Samsung Internet	4+
IE	6+
Opera Mini	all+
Safari	3.2+
Edge	12+
Android Browser	2.3+
Opera	9.5+

Source: caniuse.com

element . innerText [ = value ]
Returns the element's text content "as rendered".

Can be set, to replace the element's children with the given value, but with line breaks converted to br elements.

On getting, the innerText attribute must follow these steps:

If this element is not being rendered, or if the user agent is a non-CSS user agent, then return the same value as the textContent IDL attribute on this element.

This step can produce surprising results, as when the innerText attribute is accessed on an element not being rendered, its text contents are returned, but when accessed on an element that is being rendered, all of its children that are not being rendered have their text contents ignored.

Let results be the list resulting in running the inner text collection steps with this element. Each item in results will either be a JavaScript string or a positive integer (a required line break count).

Intuitively, a required line break count item means that a certain number of line breaks appear at that point, but they can be collapsed with the line breaks induced by adjacent required line break count items, reminiscent to CSS margin-collapsing.

Remove any items from results that are the empty string.

Remove any runs of consecutive required line break count items at the start or end of results.

Replace each remaining run of consecutive required line break count items with a string consisting of as many U+000A LINE FEED (LF) characters as the maximum of the values in the required line break count items.

Return the concatenation of the string items in results.

The inner text collection steps, given a node node, are as follows:

Let items be the result of running the inner text collection steps with each child node of node in tree order, and then concatenating the results to a single list.

If node's computed value of 'visibility' is not 'visible', then return items.

If node is not being rendered, then return items. For the purpose of this step, the following elements must act as described if the computed value of the 'display' property is not 'none':

select elements have an associated non-replaced inline CSS box whose child boxes include only those of optgroup and option element child nodes;
optgroup elements have an associated non-replaced block-level CSS box whose child boxes include only those of option element child nodes; and
option element have an associated non-replaced block-level CSS box whose child boxes are as normal for non-replaced block-level CSS boxes.
items can be non-empty due to 'display:contents'.

If node is a Text node, then for each CSS text box produced by node, in content order, compute the text of the box after application of the CSS 'white-space' processing rules and 'text-transform' rules, set items to the list of the resulting strings, and return items. The CSS 'white-space' processing rules are slightly modified: collapsible spaces at the end of lines are always collapsed, but they are only removed if the line is the last line of the block, or it ends with a br element. Soft hyphens should be preserved. [CSSTEXT]

If node is a br element, then append a string containing a single U+000A LINE FEED (LF) character to items.

If node's computed value of 'display' is 'table-cell', and node's CSS box is not the last 'table-cell' box of its enclosing 'table-row' box, then append a string containing a single U+0009 CHARACTER TABULATION (tab) character to items.

If node's computed value of 'display' is 'table-row', and node's CSS box is not the last 'table-row' box of the nearest ancestor 'table' box, then append a string containing a single U+000A LINE FEED (LF) character to items.

If node is a p element, then append 2 (a required line break count) at the beginning and end of items.

If node's used value of 'display' is block-level or 'table-caption', then append 1 (a required line break count) at the beginning and end of items. [CSSDISPLAY]

Floats and absolutely-positioned elements fall into this category.

Return items.

Note that descendant nodes of most replaced elements (e.g., textarea, input, and video — but not button) are not rendered by CSS, strictly speaking, and therefore have no CSS boxes for the purposes of this algorithm.

This algorithm is amenable to being generalized to work on ranges. Then we can use it as the basis for Selection's stringifier and maybe expose it directly on ranges. See Bugzilla bug 10583.

On setting, the innerText attribute must follow these steps:

Let document be this element's node document.

Let fragment be a new DocumentFragment object whose node document is document.

Let input be the given value.

Let position be a pointer into input, initially pointing at the start of the string.

Let text be the empty string.

While position is not past the end of input:

Collect a sequence of code points that are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters from input given position. Set text to the collected characters.

If text is not the empty string, then append a new Text node whose data is text and node document is document to fragment.

While position is not past the end of input, and the character at position is either a U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) character:

If the character at position is a U+000D CARRIAGE RETURN (CR) character and the next character is a U+000A LINE FEED (LF) character, then advance position to the next character in input.

Advance position to the next character in input.

Append the result of creating an element given document, br, and the HTML namespace to fragment.

Replace all with fragment within this element.

3.2.8 Requirements relating to the bidirectional algorithm
3.2.8.1 Authoring conformance criteria for bidirectional-algorithm formatting characters
Text content in HTML elements with Text nodes in their contents, and text in attributes of HTML elements that allow free-form text, may contain characters in the ranges U+202A to U+202E and U+2066 to U+2069 (the bidirectional-algorithm formatting characters). [BIDI]

Authors are encouraged to use the dir attribute, the bdo element, and the bdi element, rather than maintaining the bidirectional-algorithm formatting characters manually. The bidirectional-algorithm formatting characters interact poorly with CSS.

3.2.8.2 User agent conformance criteria
User agents must implement the Unicode bidirectional algorithm to determine the proper ordering of characters when rendering documents and parts of documents. [BIDI]

The mapping of HTML to the Unicode bidirectional algorithm must be done in one of three ways. Either the user agent must implement CSS, including in particular the CSS 'unicode-bidi', 'direction', and 'content' properties, and must have, in its user agent style sheet, the rules using those properties given in this specification's rendering section, or, alternatively, the user agent must act as if it implemented just the aforementioned properties and had a user agent style sheet that included all the aforementioned rules, but without letting style sheets specified in documents override them, or, alternatively, the user agent must implement another styling language with equivalent semantics. [CSSGC]

The following elements and attributes have requirements defined by the rendering section that, due to the requirements in this section, are requirements on all user agents (not just those that support the suggested default rendering):

dir attribute
bdi element
bdo element
br element
pre element
textarea element
wbr element
3.2.9 Requirements related to ARIA and to platform accessibility APIs
User agent requirements for implementing Accessibility API semantics on HTML elements are defined in HTML Accessibility API Mappings. [HTMLAAM]

Conformance checker requirements for checking use of ARIA role and aria-* attributes on HTML elements are defined in ARIA in HTML. [ARIAHTML]

4 The elements of HTML
4.1 The document element
4.1.1 The html element
Categories:
None.
Contexts in which this element can be used:
As document's document element.
Wherever a subdocument fragment is allowed in a compound document.
Content model:
A head element followed by a body element.
Tag omission in text/html:
An html element's start tag can be omitted if the first thing inside the html element is not a comment.
An html element's end tag can be omitted if the html element is not immediately followed by a comment.
Content attributes:
Global attributes
manifest — Application cache manifest
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLHtmlElement : HTMLElement {
  // also has obsolete members
};
The html element represents the root of an HTML document.

Authors are encouraged to specify a lang attribute on the root html element, giving the document's language. This aids speech synthesis tools to determine what pronunciations to use, translation tools to determine what rules to use, and so forth.

The manifest attribute gives the address of the document's application cache manifest, if there is one. If the attribute is present, the attribute's value must be a valid non-empty URL potentially surrounded by spaces.

The manifest attribute is part of the legacy "offline Web applications" feature, which is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using the manifest attribute at this time is highly discouraged. Use service workers instead. [SW]

The manifest attribute only has an effect during the early stages of document load. Changing the attribute dynamically thus has no effect (and thus, no DOM API is provided for this attribute).

For the purposes of application cache selection, later base elements cannot affect the parsing of URLs in manifest attributes, as the attributes are processed before those elements are seen.

The window.applicationCache IDL attribute provides scripted access to the offline application cache mechanism.

The html element in the following example declares that the document's language is English.

<!DOCTYPE html>
<html lang="en">
<head>
<title>Swapping Songs</title>
</head>
<body>
<h1>Swapping Songs</h1>
<p>Tonight I swapped some of the songs I wrote with some friends, who
gave me some of the songs they wrote. I love sharing my music.</p>
</body>
</html>
4.2 Document metadata
4.2.1 The head element
Categories:
None.
Contexts in which this element can be used:
As the first element in an html element.
Content model:
If the document is an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more elements of metadata content, of which no more than one is a title element and no more than one is a base element.
Otherwise: One or more elements of metadata content, of which exactly one is a title element and no more than one is a base element.
Tag omission in text/html:
A head element's start tag can be omitted if the element is empty, or if the first thing inside the head element is an element.
A head element's end tag can be omitted if the head element is not immediately followed by ASCII whitespace or a comment.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLHeadElement : HTMLElement {};
The head element represents a collection of metadata for the Document.

The collection of metadata in a head element can be large or small. Here is an example of a very short one:

<!doctype html>
<html lang=en>
 <head>
  <title>A document with a short head</title>
 </head>
 <body>
 ...
Here is an example of a longer one:

<!DOCTYPE HTML>
<HTML LANG="EN">
 <HEAD>
  <META CHARSET="UTF-8">
  <BASE HREF="https://www.example.com/">
  <TITLE>An application with a long head</TITLE>
  <LINK REL="STYLESHEET" HREF="default.css">
  <LINK REL="STYLESHEET ALTERNATE" HREF="big.css" TITLE="Big Text">
  <SCRIPT SRC="support.js"></SCRIPT>
  <META NAME="APPLICATION-NAME" CONTENT="Long headed application">
 </HEAD>
 <BODY>
 ...
The title element is a required child in most situations, but when a higher-level protocol provides title information, e.g. in the Subject line of an e-mail when HTML is used as an e-mail authoring format, the title element can be omitted.

4.2.2 The title element
Categories:
Metadata content.
Contexts in which this element can be used:
In a head element containing no other title elements.
Content model:
Text that is not inter-element whitespace.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTitleElement : HTMLElement {
  [CEReactions] attribute DOMString text;
};
The title element represents the document's title or name. Authors should use titles that identify their documents even when they are used out of context, for example in a user's history or bookmarks, or in search results. The document's title is often different from its first heading, since the first heading does not have to stand alone when taken out of context.

There must be no more than one title element per document.

If it's reasonable for the Document to have no title, then the title element is probably not required. See the head element's content model for a description of when the element is required.

title . text [ = value ]
Returns the child text content of the element.

Can be set, to replace the element's children with the given value.

The IDL attribute text must return the child text content of the title element. On setting, it must act the same way as the textContent IDL attribute.

Here are some examples of appropriate titles, contrasted with the top-level headings that might be used on those same pages.

  <title>Introduction to The Mating Rituals of Bees</title>
    ...
  <h1>Introduction</h1>
  <p>This companion guide to the highly successful
  <cite>Introduction to Medieval Bee-Keeping</cite> book is...
The next page might be a part of the same site. Note how the title describes the subject matter unambiguously, while the first heading assumes the reader knows what the context is and therefore won't wonder if the dances are Salsa or Waltz:

  <title>Dances used during bee mating rituals</title>
    ...
  <h1>The Dances</h1>
The string to use as the document's title is given by the document.title IDL attribute.

User agents should use the document's title when referring to the document in their user interface. When the contents of a title element are used in this way, the directionality of that title element should be used to set the directionality of the document's title in the user interface.

4.2.3 The base element
Categories:
Metadata content.
Contexts in which this element can be used:
In a head element containing no other base elements.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
href — Document base URL
target — Default browsing context for hyperlink navigation and form submission
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLBaseElement : HTMLElement {
  [CEReactions] attribute USVString href;
  [CEReactions] attribute DOMString target;
};
The base element allows authors to specify the document base URL for the purposes of parsing URLs, and the name of the default browsing context for the purposes of following hyperlinks. The element does not represent any content beyond this information.

There must be no more than one base element per document.

A base element must have either an href attribute, a target attribute, or both.

The href content attribute, if specified, must contain a valid URL potentially surrounded by spaces.

A base element, if it has an href attribute, must come before any other elements in the tree that have attributes defined as taking URLs, except the html element (its manifest attribute isn't affected by base elements).

If there are multiple base elements with href attributes, all but the first are ignored.

The target attribute, if specified, must contain a valid browsing context name or keyword, which specifies which browsing context is to be used as the default when hyperlinks and forms in the Document cause navigation.

A base element, if it has a target attribute, must come before any elements in the tree that represent hyperlinks.

If there are multiple base elements with target attributes, all but the first are ignored.

To get an element's target, given an a, area, or form element element, run these steps:

If element has a target attribute, then return that attribute's value.

If element's node document contains a base element with a target attribute, then return the value of the target attribute of the first such base element.

Return the empty string.

A base element that is the first base element with an href content attribute in a document tree has a frozen base URL. The frozen base URL must be immediately set for an element whenever any of the following situations occur:

The base element becomes the first base element in tree order with an href content attribute in its Document.
The base element is the first base element in tree order with an href content attribute in its Document, and its href content attribute is changed.
To set the frozen base URL for an element element:

Let document be element's node document.

Let urlRecord be the result of parsing the value of element's href content attribute with document's fallback base URL, and document's character encoding. (Thus, the base element isn't affected by itself.)

Set element's frozen base URL to document's fallback base URL, if urlRecord is failure or running Is base allowed for Document? on the resulting URL record and document returns "Blocked", and to urlRecord otherwise.

The href IDL attribute, on getting, must return the result of running the following algorithm:

Let document be element's node document.

Let url be the value of the href attribute of this element, if it has one, and the empty string otherwise.

Let urlRecord be the result of parsing url with document's fallback base URL, and document's character encoding. (Thus, the base element isn't affected by other base elements or itself.)

If urlRecord is failure, return url.

Return the serialization of urlRecord.

The href IDL attribute, on setting, must set the href content attribute to the given new value.

The target IDL attribute must reflect the content attribute of the same name.

In this example, a base element is used to set the document base URL:

<!DOCTYPE html>
<html lang="en">
    <head>
        <title>This is an example for the &lt;base&gt; element</title>
        <base href="https://www.example.com/news/index.html">
    </head>
    <body>
        <p>Visit the <a href="archives.html">archives</a>.</p>
    </body>
</html>
The link in the above example would be a link to "https://www.example.com/news/archives.html".

4.2.4 The link element

Spec bugs: 21622

Categories:
Metadata content.
If the element is allowed in the body: flow content.
If the element is allowed in the body: phrasing content.
Contexts in which this element can be used:
Where metadata content is expected.
In a noscript element that is a child of a head element.
If the element is allowed in the body: where phrasing content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
href — Address of the hyperlink
crossorigin — How the element handles crossorigin requests
rel — Relationship between the document containing the hyperlink and the destination resource
media — Applicable media
integrity — Integrity metadata used in Subresource Integrity checks [SRI]
hreflang — Language of the linked resource
type — Hint for the type of the referenced resource
referrerpolicy — Referrer policy for fetches initiated by the element
sizes — Sizes of the icons (for rel="icon")
as — Potential destination for a preload request (for rel="preload" and rel="modulepreload")
color — Color to use when customizing a site's icon (for rel="mask-icon")
Also, the title attribute has special semantics on this element: Title of the link; CSS style sheet set name.
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLLinkElement : HTMLElement {
  [CEReactions] attribute USVString href;
  [CEReactions] attribute DOMString? crossOrigin;
  [CEReactions] attribute DOMString rel;
  [CEReactions] attribute DOMString as; // (default "")
  [SameObject, PutForwards=value] readonly attribute DOMTokenList relList;
  [CEReactions] attribute DOMString media;
  [CEReactions] attribute DOMString integrity;
  [CEReactions] attribute DOMString hreflang;
  [CEReactions] attribute DOMString type;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList sizes;
  [CEReactions] attribute DOMString referrerPolicy;

  // also has obsolete members
};
HTMLLinkElement includes LinkStyle;
The link element allows authors to link their document to other resources.

The destination of the link(s) is given by the href attribute, which must be present and must contain a valid non-empty URL potentially surrounded by spaces. If the href attribute is absent, then the element does not define a link.

The crossorigin attribute is a CORS settings attribute. It is intended for use with external resource links.

The types of link indicated (the relationships) are given by the value of the rel attribute, which, if present, must have a value that is a set of space-separated tokens. The allowed keywords and their meanings are defined in a later section. If the rel attribute is absent, has no keywords, or if none of the keywords used are allowed according to the definitions in this specification, then the element does not create any links.

rel's supported tokens are the keywords defined in HTML link types which are allowed on link elements, impact the processing model, and are supported by the user agent. The possible supported tokens are alternate, dns-prefetch, icon, modulepreload, next, pingback, preconnect, prefetch, preload, prerender, search, and stylesheet. rel's supported tokens must only include the tokens from this list that the user agent implements the processing model for.

Theoretically a user agent could support the processing model for the canonical keyword — if it were a search engine that executed JavaScript. But in practice that's quite unlikely. So in most cases, canonical ought not be included in rel's supported tokens.

A link element must have either a rel attribute or an itemprop attribute, but not both.

If a link element has an itemprop attribute, or has a rel attribute that contains only keywords that are body-ok, then the element is said to be allowed in the body. This means that the element can be used where phrasing content is expected.

If the rel attribute is used, the element can only sometimes be used in the body of the page. When used with the itemprop attribute, the element can be used both in the head element and in the body of the page, subject to the constraints of the microdata model.

Two categories of links can be created using the link element: Links to external resources and hyperlinks. The link types section defines whether a particular link type is an external resource or a hyperlink. One link element can create multiple links (of which some might be external resource links and some might be hyperlinks); exactly which and how many links are created depends on the keywords given in the rel attribute. User agents must process the links on a per-link basis, not a per-element basis.

Each link created for a link element is handled separately. For instance, if there are two link elements with rel="stylesheet", they each count as a separate external resource, and each is affected by its own attributes independently. Similarly, if a single link element has a rel attribute with the value next stylesheet, it creates both a hyperlink (for the next keyword) and an external resource link (for the stylesheet keyword), and they are affected by other attributes (such as media or title) differently.

For example, the following link element creates two hyperlinks (to the same page):

<link rel="author license" href="/about">
The two links created by this element are one whose semantic is that the target page has information about the current page's author, and one whose semantic is that the target page has information regarding the license under which the current page is provided.

Hyperlinks created with the link element and its rel attribute apply to the whole document. This contrasts with the rel attribute of a and area elements, which indicates the type of a link whose context is given by the link's location within the document.

The exact behavior for links to external resources depends on the exact relationship, as defined for the relevant link type.

The media attribute says which media the resource applies to. The value must be a valid media query list.

The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The attribute must not be specified on link elements that do not have a rel attribute that contains the stylesheet keyword. [SRI]

The hreflang attribute on the link element has the same semantics as the hreflang attribute on the a element.

The type attribute gives the MIME type of the linked resource. It is purely advisory. The value must be a valid MIME type string.

For external resource links, the type attribute is used as a hint to user agents so that they can avoid fetching resources they do not support.

The referrerpolicy attribute is a referrer policy attribute. It is intended for use with external resource links, where it helps set the referrer policy used when obtaining the external resource. [REFERRERPOLICY].

The title attribute gives the title of the link. With one exception, it is purely advisory. The value is text. The exception is for style sheet links that are in a document tree, for which the title attribute defines CSS style sheet sets.

The title attribute on link elements differs from the global title attribute of most other elements in that a link without a title does not inherit the title of the parent element: it merely has no title.

The sizes attribute gives the sizes of icons for visual media. Its value, if present, is merely advisory. User agents may use the value to decide which icon(s) to use if multiple icons are available. If specified, the attribute must have a value that is an unordered set of unique space-separated tokens which are ASCII case-insensitive. Each value must be either an ASCII case-insensitive match for the string "any", or a value that consists of two valid non-negative integers that do not have a leading U+0030 DIGIT ZERO (0) character and that are separated by a single U+0078 LATIN SMALL LETTER X or U+0058 LATIN CAPITAL LETTER X character. The attribute must not be specified on link elements that do not have a rel attribute that specifies the icon keyword or the apple-touch-icon keyword.

The apple-touch-icon keyword is a registered extension to the predefined set of link types, but user agents are not required to support it in any way.

The as attribute specifies the potential destination for a preload request for the resource given by the href attribute. It is an enumerated attribute. Each potential destination is a keyword for this attribute, mapping to a state of the same name. The attribute must be specified on link elements that have a rel attribute that contains the preload keyword. It may be specified on link elements that have a rel attribute that contains the modulepreload keyword; in such cases it must have a value which is a script-like destination. For other link elements, it must not be specified.

The processing model for how the as attribute is used is given in the steps to obtain the resource, for for preload links and for modulepreload links, respectively.

The attribute does not have a missing value default or invalid value default, meaning that invalid or missing values for the attribute map to no state. This is accounted for in the processing model. For preload links, both conditions are an error; for modulepreload links, a missing value will be treated as "script".

The color attribute is used with the mask-icon link type. The attribute must not be specified on link elements that do not have a rel attribute that contains the mask-icon keyword. The value must be a string that matches the CSS <color> production, defining a suggested color that user agents can use to customize the display of the icon that the user sees when they pin your site.

This specification does not have any user agent requirements for the color attribute.

The mask-icon keyword is a registered extension to the predefined set of link types, but user agents are not required to support it in any way.

The IDL attributes href, hreflang, integrity, media, rel, sizes, and type each must reflect the respective content attributes of the same name.

There is no reflecting IDL attribute for the color attribute, but this might be added later.

The as IDL attribute must reflect the as content attribute, limited to only known values.

The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The relList IDL attribute must reflect the rel content attribute.

4.2.4.1 Processing the media attribute
If the link is a hyperlink then the media attribute is purely advisory, and describes for which media the document in question was designed.

However, if the link is an external resource link, then the media attribute is prescriptive. The user agent must apply the external resource when the media attribute's value matches the environment and the other relevant conditions apply, and must not apply it otherwise.

The default, if the media attribute is omitted, is "all", meaning that by default links apply to all media.

The external resource might have further restrictions defined within that limit its applicability. For example, a CSS style sheet might have some @media blocks. This specification does not override such further restrictions or requirements.

4.2.4.2 Processing the type attribute
If the type attribute is present, then the user agent must assume that the resource is of the given type (even if that is not a valid MIME type string, e.g. the empty string). If the attribute is omitted, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type. If the UA does not support the given MIME type for the given link relationship, then the UA should not obtain the resource; if the UA does support the given MIME type for the given link relationship, then the UA should obtain the resource at the appropriate time as specified for the external resource link's particular type. If the attribute is omitted, and the external resource link type does not have a default type defined, but the user agent would obtain the resource if the type was known and supported, then the user agent should obtain the resource under the assumption that it will be supported.

User agents must not consider the type attribute authoritative — upon fetching the resource, user agents must not use the type attribute to determine its actual type. Only the actual type (as defined in the next paragraph) is used to determine whether to apply the resource, not the aforementioned assumed type.

If the external resource link type defines rules for processing the resource's Content-Type metadata, then those rules apply. Otherwise, if the resource is expected to be an image, user agents may apply the image sniffing rules, with the official type being the type determined from the resource's Content-Type metadata, and use the resulting computed type of the resource as if it was the actual type. Otherwise, if neither of these conditions apply or if the user agent opts not to apply the image sniffing rules, then the user agent must use the resource's Content-Type metadata to determine the type of the resource. If there is no type metadata, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type.

The stylesheet link type defines rules for processing the resource's Content-Type metadata.

Once the user agent has established the type of the resource, the user agent must apply the resource if it is of a supported type and the other relevant conditions apply, and must ignore the resource otherwise.

If a document contains style sheet links labeled as follows:

<link rel="stylesheet" href="A" type="text/plain">
<link rel="stylesheet" href="B" type="text/css">
<link rel="stylesheet" href="C">
...then a compliant UA that supported only CSS style sheets would fetch the B and C files, and skip the A file (since text/plain is not the MIME type for CSS style sheets).

For files B and C, it would then check the actual types returned by the server. For those that are sent as text/css, it would apply the styles, but for those labeled as text/plain, or any other type, it would not.

If one of the two files was returned without a Content-Type metadata, or with a syntactically incorrect type like Content-Type: "null", then the default type for stylesheet links would kick in. Since that default type is text/css, the style sheet would nonetheless be applied.

4.2.4.3 Obtaining a resource from a link element
For external resources that are represented in the DOM (for example, style sheets), the DOM representation must be made available (modulo cross-origin restrictions) even if the resource is not applied. To obtain the resource, the user agent must run the following steps:

If the href attribute's value is the empty string, then return.

Parse the URL given by the href attribute, relative to the element's node document. If that fails, then return. Otherwise, let url be the resulting URL record.

Let corsAttributeState be the current state of the element's crossorigin content attribute.

Let request be the result of creating a potential-CORS request given url, the empty string, and corsAttributeState.

Set request's client to the link element's node document's Window object's environment settings object.

Set request's cryptographic nonce metadata to the current value of the link element's [[CryptographicNonce]] internal slot.

Set request's integrity metadata to the current value of the link element's integrity content attribute.

Set request's referrer policy to the current state of the link element's referrerpolicy attribute.

If the rel attribute contains the preload keyword, then:

Let as be the current state of the as attribute.

If as is no state, then return.

Set request's destination to the result of translating as.

Fetch request.

User agents may opt to only try to obtain such resources when they are needed, instead of pro-actively fetching all the external resources that are not applied.

The semantics of the protocol used (e.g. HTTP) must be followed when fetching external resources. (For example, redirects will be followed and 404 responses will cause the external resource to not be applied.)

Once the attempts to obtain the resource and its critical subresources are complete, the user agent must, if the loads were successful, queue a task to fire an event named load at the link element, or, if the resource or one of its critical subresources failed to completely load for any reason (e.g. DNS error, HTTP 404 response, a connection being prematurely closed, unsupported Content-Type), queue a task to fire an event named error at the link element. Non-network errors in processing the resource or its subresources (e.g. CSS parse errors, PNG decoding errors) are not failures for the purposes of this paragraph.

The task source for these tasks is the DOM manipulation task source.

Unless otherwise specified for a given rel keyword, the element must delay the load event of the element's node document until all the attempts to obtain the resource and its critical subresources are complete. (Resources that the user agent has not yet attempted to obtain, e.g. because it is waiting for the resource to be needed, do not delay the load event.)

4.2.4.4 Processing `Link` headers
HTTP `Link` headers, if supported, must be assumed to come before any links in the document, in the order that they were given in the HTTP message. These headers are to be processed according to the rules given in the relevant specifications. [HTTP] [WEBLINK]

Registration of relation types in HTTP `Link` headers is distinct from HTML link types, and thus their semantics can be different from same-named HTML types.

4.2.4.5 Providing users with a means to follow hyperlinks created using the link element
Interactive user agents may provide users with a means to follow the hyperlinks created using the link element, somewhere within their user interface. The exact interface is not defined by this specification, but it could include the following information (obtained from the element's attributes, again as defined below), in some form or another (possibly simplified), for each hyperlink created with each link element in the document:

The relationship between this document and the resource (given by the rel attribute)
The title of the resource (given by the title attribute).
The address of the resource (given by the href attribute).
The language of the resource (given by the hreflang attribute).
The optimum media for the resource (given by the media attribute).
User agents could also include other information, such as the type of the resource (as given by the type attribute).

The activation behavior of link elements that create hyperlinks is to follow the hyperlink created by the link element.

4.2.5 The meta element
Categories:
Metadata content.
If the itemprop attribute is present: flow content.
If the itemprop attribute is present: phrasing content.
Contexts in which this element can be used:
If the charset attribute is present, or if the element's http-equiv attribute is in the Encoding declaration state: in a head element.
If the http-equiv attribute is present but not in the Encoding declaration state: in a head element.
If the http-equiv attribute is present but not in the Encoding declaration state: in a noscript element that is a child of a head element.
If the name attribute is present: where metadata content is expected.
If the itemprop attribute is present: where metadata content is expected.
If the itemprop attribute is present: where phrasing content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
name — Metadata name
http-equiv — Pragma directive
content — Value of the element
charset — Character encoding declaration
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLMetaElement : HTMLElement {
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString httpEquiv;
  [CEReactions] attribute DOMString content;

  // also has obsolete members
};
The meta element represents various kinds of metadata that cannot be expressed using the title, base, link, style, and script elements.

The meta element can represent document-level metadata with the name attribute, pragma directives with the http-equiv attribute, and the file's character encoding declaration when an HTML document is serialized to string form (e.g. for transmission over the network or for disk storage) with the charset attribute.

Exactly one of the name, http-equiv, charset, and itemprop attributes must be specified.

If either name, http-equiv, or itemprop is specified, then the content attribute must also be specified. Otherwise, it must be omitted.

The charset attribute specifies the character encoding used by the document. This is a character encoding declaration. If the attribute is present, its value must be an ASCII case-insensitive match for the string "utf-8".

The charset attribute on the meta element has no effect in XML documents, but is allowed in XML documents in order to facilitate migration to and from XML.

There must not be more than one meta element with a charset attribute per document.

The content attribute gives the value of the document metadata or pragma directive when the element is used for those purposes. The allowed values depend on the exact context, as described in subsequent sections of this specification.

If a meta element has a name attribute, it sets document metadata. Document metadata is expressed in terms of name-value pairs, the name attribute on the meta element giving the name, and the content attribute on the same element giving the value. The name specifies what aspect of metadata is being set; valid names and the meaning of their values are described in the following sections. If a meta element has no content attribute, then the value part of the metadata name-value pair is the empty string.

The name and content IDL attributes must reflect the respective content attributes of the same name. The IDL attribute httpEquiv must reflect the content attribute http-equiv.

4.2.5.1 Standard metadata names
This specification defines a few names for the name attribute of the meta element.

Names are case-insensitive, and must be compared in an ASCII case-insensitive manner.

application-name
The value must be a short free-form string giving the name of the Web application that the page represents. If the page is not a Web application, the application-name metadata name must not be used. Translations of the Web application's name may be given, using the lang attribute to specify the language of each name.

There must not be more than one meta element with a given language and with its name attribute set to the value application-name per document.

User agents may use the application name in UI in preference to the page's title, since the title might include status messages and the like relevant to the status of the page at a particular moment in time instead of just being the name of the application.

To find the application name to use given an ordered list of languages (e.g. British English, American English, and English), user agents must run the following steps:

Let languages be the list of languages.

Let default language be the language of the Document's document element, if any, and if that language is not unknown.

If there is a default language, and if it is not the same language as any of the languages in languages, append it to languages.

Let winning language be the first language in languages for which there is a meta element in the Document that has its name attribute set to the value application-name and whose language is the language in question.

If none of the languages have such a meta element, then return; there's no given application name.

Return the value of the content attribute of the first meta element in the Document in tree order that has its name attribute set to the value application-name and whose language is winning language.

This algorithm would be used by a browser when it needs a name for the page, for instance, to label a bookmark. The languages it would provide to the algorithm would be the user's preferred languages.

author
The value must be a free-form string giving the name of one of the page's authors.

description
The value must be a free-form string that describes the page. The value must be appropriate for use in a directory of pages, e.g. in a search engine. There must not be more than one meta element with its name attribute set to the value description per document.

generator
The value must be a free-form string that identifies one of the software packages used to generate the document. This value must not be used on pages whose markup is not generated by software, e.g. pages whose markup was written by a user in a text editor.

Here is what a tool called "Frontweaver" could include in its output, in the page's head element, to identify itself as the tool used to generate the page:

<meta name=generator content="Frontweaver 8.2">
keywords
The value must be a set of comma-separated tokens, each of which is a keyword relevant to the page.

This page about typefaces on British motorways uses a meta element to specify some keywords that users might use to look for the page:

<!DOCTYPE HTML>
<html lang="en-GB">
 <head>
  <title>Typefaces on UK motorways</title>
  <meta name="keywords" content="british,type face,font,fonts,highway,highways">
 </head>
 <body>
  ...
Many search engines do not consider such keywords, because this feature has historically been used unreliably and even misleadingly as a way to spam search engine results in a way that is not helpful for users.

To obtain the list of keywords that the author has specified as applicable to the page, the user agent must run the following steps:

Let keywords be an empty list.

For each meta element with a name attribute and a content attribute and whose name attribute's value is keywords:

Split the value of the element's content attribute on commas.

Add the resulting tokens, if any, to keywords.

Remove any duplicates from keywords.

Return keywords. This is the list of keywords that the author has specified as applicable to the page.

User agents should not use this information when there is insufficient confidence in the reliability of the value.

For instance, it would be reasonable for a content management system to use the keyword information of pages within the system to populate the index of a site-specific search engine, but a large-scale content aggregator that used this information would likely find that certain users would try to game its ranking mechanism through the use of inappropriate keywords.

referrer
The value must be a referrer policy, which defines the default referrer policy for the Document. [REFERRERPOLICY]

If any meta elements are inserted into the document or removed from the document, or existing meta elements have their name or content attributes changed, user agents must run the following algorithm:

Let candidate elements be the list of all meta elements that meet the following criteria, in tree order:

The element is in a document tree
The element has a name attribute, whose value is referrer
The element has a content attribute, whose value is not the empty string
The element is a child of the head element of the document
For each element in candidate elements:

Let value be the value of element's content attribute, converted to ASCII lowercase.

If value is one of the values given in the first column of the following table, then set value to the value given in the second column:

Legacy value	Referrer policy
never	no-referrer
default	no-referrer-when-downgrade
always	unsafe-url
origin-when-crossorigin	origin-when-cross-origin
If value is a referrer policy, then set element's node document's referrer policy to policy.

The fact that these steps are applied for each element enables deployment of fallback values for older user agents. [REFERRERPOLICY]

theme-color
The value must be a string that matches the CSS <color> production, defining a suggested color that user agents should use to customize the display of the page or of the surrounding user interface. For example, a browser might color the page's title bar with the specified value, or use it as a color highlight in a tab bar or task switcher.

There must not be more than one meta element with its name attribute set to the value theme-color per document.

This standard itself uses "WHATWG green" as its theme color:

<!DOCTYPE HTML>
<title>HTML Standard</title>
<meta name="theme-color" content="#3c790a">
...
To obtain a page's theme color, user agents must run the following steps:

Let candidate elements be the list of all meta elements that meet the following criteria, in tree order:

The element is in a document tree
The element has a name attribute, whose value is theme-color
The element has a content attribute
For each element in candidate elements:

Let value be the result of stripping leading and trailing ASCII whitespace from the value of element's content attribute.

Let color be the result of parsing value.

If color is not failure, then return color.

Return nothing (the page has no theme color).

If any meta elements are inserted into the document or removed from the document, or existing meta elements have their name or content attributes changed, user agents must re-run the above algorithm and apply the result to any affected UI.

When using the theme color in UI, user agents may adjust it in implementation-specific ways to make it more suitable for the UI in question. For example, if a user agent intends to use the theme color as a background and display white text over it, it might use a darker variant of the theme color in that part of the UI, to ensure adequate contrast.

4.2.5.2 Other metadata names
Anyone can create and use their own extensions to the predefined set of metadata names. There is no requirement to register such extensions.

However, a new metadata name should not be created in any of the following cases:

If either the name is a URL, or the value of its accompanying content attribute is a URL; in those cases, registering it as an extension to the predefined set of link types is encouraged (rather than creating a new metadata name).

If the name is for something expected to have processing requirements in user agents; in that case it ought to be standardized.

Also, before creating and using a new metadata name, consulting the WHATWG Wiki MetaExtensions page is encouraged — to avoid choosing a metadata name that's already in use, and to avoid duplicating the purpose of any metadata names that are already in use, and to avoid new standardized names clashing with your chosen name. [WHATWGWIKI]

Anyone is free to edit the WHATWG Wiki MetaExtensions page at any time to add a metadata name. New metadata names can be specified with the following information:

Keyword
The actual name being defined. The name should not be confusingly similar to any other defined name (e.g. differing only in case).

Brief description
A short non-normative description of what the metadata name's meaning is, including the format the value is required to be in.

Specification
A link to a more detailed description of the metadata name's semantics and requirements. It could be another page on the Wiki, or a link to an external page.
Synonyms
A list of other names that have exactly the same processing requirements. Authors should not use the names defined to be synonyms (they are only intended to allow user agents to support legacy content). Anyone may remove synonyms that are not used in practice; only names that need to be processed as synonyms for compatibility with legacy content are to be registered in this way.

Status
One of the following:

Proposed
The name has not received wide peer review and approval. Someone has proposed it and is, or soon will be, using it.
Ratified
The name has received wide peer review and approval. It has a specification that unambiguously defines how to handle pages that use the name, including when they use it in incorrect ways.
Discontinued
The metadata name has received wide peer review and it has been found wanting. Existing pages are using this metadata name, but new pages should avoid it. The "brief description" and "specification" entries will give details of what authors should use instead, if anything.
If a metadata name is found to be redundant with existing values, it should be removed and listed as a synonym for the existing value.

If a metadata name is added in the "proposed" state for a period of a month or more without being used or specified, then it may be removed from the WHATWG Wiki MetaExtensions page.

If a metadata name is added with the "proposed" status and found to be redundant with existing values, it should be removed and listed as a synonym for the existing value. If a metadata name is added with the "proposed" status and found to be harmful, then it should be changed to "discontinued" status.

Anyone can change the status at any time, but should only do so in accordance with the definitions above.

4.2.5.3 Pragma directives
When the http-equiv attribute is specified on a meta element, the element is a pragma directive.

The http-equiv attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.

State	Keyword	Notes
Content Language	content-language	Non-conforming
Encoding declaration	content-type
Default style	default-style
Refresh	refresh
Cookie setter	set-cookie	Non-conforming
X-UA-Compatible	x-ua-compatible
Content security policy	Content-Security-Policy
When a meta element is inserted into the document, if its http-equiv attribute is present and represents one of the above states, then the user agent must run the algorithm appropriate for that state, as described in the following list:

Content language state (http-equiv="content-language")
This feature is non-conforming. Authors are encouraged to use the lang attribute instead.

This pragma sets the pragma-set default language. Until such a pragma is successfully processed, there is no pragma-set default language.

If the meta element has no content attribute, then return.

If the element's content attribute contains a U+002C COMMA character (,) then return.

Let input be the value of the element's content attribute.

Let position point at the first character of input.

Skip ASCII whitespace within input given position.

Collect a sequence of code points that are not ASCII whitespace from input given position.

Let candidate be the string that resulted from the previous step.

If candidate is the empty string, return.

Set the pragma-set default language to candidate.

If the value consists of multiple space-separated tokens, tokens after the first are ignored.

This pragma is almost, but not quite, entirely unlike the HTTP `Content-Language` header of the same name. [HTTP]

Encoding declaration state (http-equiv="content-type")
The Encoding declaration state is just an alternative form of setting the charset attribute: it is a character encoding declaration. This state's user agent requirements are all handled by the parsing section of the specification.

For meta elements with an http-equiv attribute in the Encoding declaration state, the content attribute must have a value that is an ASCII case-insensitive match for a string that consists of: the literal string "text/html;", optionally followed by any number of ASCII whitespace, followed by the literal string "charset=utf-8".

A document must not contain both a meta element with an http-equiv attribute in the Encoding declaration state and a meta element with the charset attribute present.

The Encoding declaration state may be used in HTML documents, but elements with an http-equiv attribute in that state must not be used in XML documents.

Default style state (http-equiv="default-style")
This pragma sets the name of the default CSS style sheet set.

If the meta element has no content attribute, or if that attribute's value is the empty string, then return.

Change the preferred CSS style sheet set name with the name being the value of the element's content attribute. [CSSOM]

Refresh state (http-equiv="refresh")
This pragma acts as timed redirect.

A Document object has an associated will declaratively refresh (a boolean). It is initially false.

If the meta element has no content attribute, or if that attribute's value is the empty string, then return.

Let input be the value of the element's content attribute.

Run the shared declarative refresh steps with the meta element's node document, input, and the meta element.

The shared declarative refresh steps, given a Document object document, string input, and optionally a meta element meta, are as follows:

If document's will declaratively refresh is true, then return.

Let position point at the first code point of input.

Skip ASCII whitespace within input given position.

Let time be 0.

Collect a sequence of code points that are ASCII digits from input given position, and let the result be timeString.

If timeString is the empty string, then:

If the code point in input pointed to by position is not U+002E (.), then return.

Otherwise, set time to the result of parsing timeString using the rules for parsing non-negative integers.

Collect a sequence of code points that are ASCII digits and U+002E FULL STOP characters (.) from input given position. Ignore any collected characters.

Let urlRecord be document's URL.

If position is not past the end of input, then:

If the code point in input pointed to by position is not U+003B (;), U+002C (,), or ASCII whitespace, then return.

Skip ASCII whitespace within input given position.

If the code point in input pointed to by position is U+003B (;) or U+002C (,), then advance position to the next code point.

Skip ASCII whitespace within input given position.

If position is not past the end of input, then:

Let urlString be the substring of input from the code point at position to the end of the string.

If the code point in input pointed to by position is U+0055 (U) or U+0075 (u), then advance position to the next code point. Otherwise, jump to the step labeled skip quotes.

If the code point in input pointed to by position is U+0052 (R) or U+0072 (r), then advance position to the next code point. Otherwise, jump to the step labeled parse.

If the code point in input pointed to by position is U+004C (L) or U+006C (l), then advance position to the next code point. Otherwise, jump to the step labeled parse.

Skip ASCII whitespace within input given position.

If the code point in input pointed to by position is U+003D (=), then advance position to the next code point. Otherwise, jump to the step labeled parse.

Skip ASCII whitespace within input given position.

Skip quotes: If the code point in input pointed to by position is U+0027 (') or U+0022 ("), then let quote be that code point, and advance position to the next code point. Otherwise, let quote be the empty string.

Set urlString to the substring of input from the code point at position to the end of the string.

If quote is not the empty string, and there is a code point in urlString equal to quote, then truncate urlString at that code point, so that it and all subsequent code points are removed.

Parse: Parse urlString relative to document. If that fails, return. Otherwise, set urlRecord to the resulting URL record.

Set document's will declaratively refresh to true.

Perform one or more of the following steps:

After the refresh has come due (as defined below), if the user has not canceled the redirect and, if meta is given, document's active sandboxing flag set does not have the sandboxed automatic features browsing context flag set, then navigate document's browsing context to urlRecord, with replacement enabled, and with document's browsing context as the source browsing context.

For the purposes of the previous paragraph, a refresh is said to have come due as soon as the later of the following two conditions occurs:

At least time seconds have elapsed since document has completely loaded, adjusted to take into account user or user agent preferences.
If meta is given, at least time seconds have elapsed since meta was inserted into the document document, adjusted to take into account user or user agent preferences.
It is important to use document here, and not meta's node document, as that might have changed between the initial set of steps and the refresh coming due and meta is not always given (in case of the HTTP `Refresh` header).

Provide the user with an interface that, when selected, navigates a browsing context to urlRecord, with document's browsing context as the source browsing context.

Do nothing.

In addition, the user agent may, as with anything, inform the user of any and all aspects of its operation, including the state of any timers, the destinations of any timed redirects, and so forth.

For meta elements with an http-equiv attribute in the Refresh state, the content attribute must have a value consisting either of:

just a valid non-negative integer, or
a valid non-negative integer, followed by a U+003B SEMICOLON character (;), followed by one or more ASCII whitespace, followed by a substring that is an ASCII case-insensitive match for the string "URL", followed by a U+003D EQUALS SIGN character (=), followed by a valid URL string that does not start with a literal U+0027 APOSTROPHE (') or U+0022 QUOTATION MARK (") character.
In the former case, the integer represents a number of seconds before the page is to be reloaded; in the latter case the integer represents a number of seconds before the page is to be replaced by the page at the given URL.

A news organization's front page could include the following markup in the page's head element, to ensure that the page automatically reloads from the server every five minutes:

<meta http-equiv="Refresh" content="300">
A sequence of pages could be used as an automated slide show by making each page refresh to the next page in the sequence, using markup such as the following:

<meta http-equiv="Refresh" content="20; URL=page4.html">
Cookie setter (http-equiv="set-cookie")
This pragma sets an HTTP cookie. [COOKIES]

It is non-conforming. Real HTTP headers should be used instead.

If the meta element has no content attribute, or if that attribute's value is the empty string, then return.

Act as if receiving a set-cookie-string for the document's URL via a "non-HTTP" API, consisting of the value of the element's content attribute encoded as UTF-8. [COOKIES] [ENCODING]

X-UA-Compatible state (http-equiv="x-ua-compatible")
In practice, this pragma encourages Internet Explorer to more closely follow the specifications.

For meta elements with an http-equiv attribute in the X-UA-Compatible state, the content attribute must have a value that is an ASCII case-insensitive match for the string "IE=edge".

User agents are required to ignore this pragma.

Content security policy state (http-equiv="Content-Security-Policy")
This pragma enforces a Content Security Policy on a Document. [CSP]

If the meta element is not a child of a head element, return.

If the meta element has no content attribute, or if that attribute's value is the empty string, then return.

Let policy be the result of executing Content Security Policy's parse a serialized Content Security Policy algorithm on the meta element's content attribute's value, with a source of "meta", and a disposition of "enforce".

Remove all occurrences of the report-uri, frame-ancestors, and sandbox directives from policy.

Enforce the policy policy.

For meta elements with an http-equiv attribute in the Content security policy state, the content attribute must have a value consisting of a valid Content Security Policy, but must not contain any report-uri, frame-ancestors, or sandbox directives. The Content Security Policy given in the content attribute will be enforced upon the current document. [CSP]

A page might choose to mitigate the risk of cross-site scripting attacks by preventing the execution of inline JavaScript, as well as blocking all plugin content, using a policy such as the following:

<meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'">
There must not be more than one meta element with any particular state in the document at a time.

4.2.5.4 Specifying the document's character encoding
A character encoding declaration is a mechanism by which the character encoding used to store or transmit a document is specified.

The Encoding standard requires use of the UTF-8 character encoding and requires use of the "utf-8" encoding label to identify it. Those requirements necessitate that the document's character encoding declaration, if it exists, specifies an encoding label using an ASCII case-insensitive match for "utf-8". Regardless of whether a character encoding declaration is present or not, the actual character encoding used to encode the document must be UTF-8. [ENCODING]

To enforce the above rules, authoring tools must default to using UTF-8 for newly-created documents.

The following restrictions also apply:

The character encoding declaration must be serialized without the use of character references or character escapes of any kind.
The element containing the character encoding declaration must be serialized completely within the first 1024 bytes of the document.
In addition, due to a number of restrictions on meta elements, there can only be one meta-based character encoding declaration per document.

If an HTML document does not start with a BOM, and its encoding is not explicitly given by Content-Type metadata, and the document is not an iframe srcdoc document, then the encoding must be specified using a meta element with a charset attribute or a meta element with an http-equiv attribute in the Encoding declaration state.

A character encoding declaration is required (either in the Content-Type metadata or explicitly in the file) even when all characters are in the ASCII range, because a character encoding is needed to process non-ASCII characters entered by the user in forms, in URLs generated by scripts, and so forth.

Using non-UTF-8 encodings can have unexpected results on form submission and URL encodings, which use the document's character encoding by default.

If the document is an iframe srcdoc document, the document must not have a character encoding declaration. (In this case, the source is already decoded, since it is part of the document that contained the iframe.)

In XML, the XML declaration should be used for inline character encoding information, if necessary.

In HTML, to declare that the character encoding is UTF-8, the author could include the following markup near the top of the document (in the head element):

<meta charset="utf-8">
In XML, the XML declaration would be used instead, at the very top of the markup:

<?xml version="1.0" encoding="utf-8"?>
4.2.6 The style element
Categories:
Metadata content.
Contexts in which this element can be used:
Where metadata content is expected.
In a noscript element that is a child of a head element.
Content model:
Text that gives a conformant style sheet.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
media — Applicable media
Also, the title attribute has special semantics on this element: CSS style sheet set name.
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLStyleElement : HTMLElement {
  [CEReactions] attribute DOMString media;

  // also has obsolete members
};
HTMLStyleElement includes LinkStyle;
The style element allows authors to embed CSS style sheets in their documents. The style element is one of several inputs to the styling processing model. The element does not represent content for the user.

The media attribute says which media the styles apply to. The value must be a valid media query list. The user agent must apply the styles when the media attribute's value matches the environment and the other relevant conditions apply, and must not apply them otherwise.

The styles might be further limited in scope, e.g. in CSS with the use of @media blocks. This specification does not override such further restrictions or requirements.

The default, if the media attribute is omitted, is "all", meaning that by default styles apply to all media.

The title attribute on style elements defines CSS style sheet sets. If the style element has no title attribute, then it has no title; the title attribute of ancestors does not apply to the style element. If the style element is not in a document tree, then the title attribute is ignored. [CSSOM]

The title attribute on style elements, like the title attribute on link elements, differs from the global title attribute in that a style block without a title does not inherit the title of the parent element: it merely has no title.

The child text content of a style element must be that of a conformant style sheet.

The user agent must run the update a style block algorithm whenever one of the following conditions occur:

The element is popped off the stack of open elements of an HTML parser or XML parser.

The element is not on the stack of open elements of an HTML parser or XML parser, and it becomes connected or disconnected.

The element's child text content change steps run.

The update a style block algorithm is as follows:

Let element be the style element.

If element has an associated CSS style sheet, remove the CSS style sheet in question.

If element's root is neither a shadow root nor a document, then return.

If element's type attribute is present and its value is neither the empty string nor an ASCII case-insensitive match for "text/css", then return.

In particular, a type value with parameters, such as "text/css; charset=utf-8", will cause this algorithm to return early.

If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the style element, "style", and the style element's child text content, then return. [CSP]

Create a CSS style sheet with the following properties:

type
text/css

owner node
element

media
The media attribute of element.

This is a reference to the (possibly absent at this time) attribute, rather than a copy of the attribute's current value. The CSSOM specification defines what happens when the attribute is dynamically set, changed, or removed.

title
The title attribute of element, if element is in a document tree, or the empty string otherwise.

Again, this is a reference to the attribute.

alternate flag
Unset.

origin-clean flag
Set.

location
parent CSS style sheet
owner CSS rule
null

disabled flag
Left at its default value.

CSS rules
Left uninitialized.

This doesn't seem right. Presumably we should be using the element's child text content? Tracked as issue #2997.

Once the attempts to obtain the style sheet's critical subresources, if any, are complete, or, if the style sheet has no critical subresources, once the style sheet has been parsed and processed, the user agent must, if the loads were successful or there were none, queue a task to fire an event named load at the style element, or, if one of the style sheet's critical subresources failed to completely load for any reason (e.g. DNS error, HTTP 404 response, a connection being prematurely closed, unsupported Content-Type), queue a task to fire an event named error at the style element. Non-network errors in processing the style sheet or its subresources (e.g. CSS parse errors, PNG decoding errors) are not failures for the purposes of this paragraph.

The task source for these tasks is the DOM manipulation task source.

The element must delay the load event of the element's node document until all the attempts to obtain the style sheet's critical subresources, if any, are complete.

This specification does not specify a style system, but CSS is expected to be supported by most Web browsers. [CSS]

The media IDL attribute must reflect the content attribute of the same name.

The LinkStyle interface is also implemented by this element. [CSSOM]

The following document has its stress emphasis styled as bright red text rather than italics text, while leaving titles of works and Latin words in their default italics. It shows how using appropriate elements enables easier restyling of documents.

<!DOCTYPE html>
<html lang="en-US">
 <head>
  <title>My favorite book</title>
  <style>
   body { color: black; background: white; }
   em { font-style: normal; color: red; }
  </style>
 </head>
 <body>
  <p>My <em>favorite</em> book of all time has <em>got</em> to be
  <cite>A Cat's Life</cite>. It is a book by P. Rahmel that talks
  about the <i lang="la">Felis Catus</i> in modern human society.</p>
 </body>
</html>
4.2.7 Interactions of styling and scripting
Style sheets, whether added by a link element, a style element, an <?xml-stylesheet?> PI, an HTTP `Link` header, or some other mechanism, have a style sheet ready flag, which is initially unset.

When a style sheet is ready to be applied, its style sheet ready flag must be set. If the style sheet referenced no other resources (e.g. it was an internal style sheet given by a style element with no @import rules), then the style rules must be immediately made available to script; otherwise, the style rules must only be made available to script once the event loop reaches its update the rendering step.

A style sheet in the context of the Document of an HTML parser or XML parser is said to be a style sheet that is blocking scripts if all of the following conditions occur:

The element was created by that Document's parser.

The element is either a style element or a link element that was an external resource link that contributes to the styling processing model when the element was created by the parser.

If the element is a link element, it's media attribute's value matches the environment.

The element's style sheet was enabled when the element was created by the parser.

The element's style sheet ready flag is not yet set.

The last time the event loop reached step 1, the element's root was that Document.

The user agent hasn't given up on that particular style sheet yet. A user agent may give up on a style sheet at any time.

Giving up on a style sheet before the style sheet loads, if the style sheet eventually does still load, means that the script might end up operating with incorrect information. For example, if a style sheet sets the color of an element to green, but a script that inspects the resulting style is executed before the sheet is loaded, the script will find that the element is black (or whatever the default color is), and might thus make poor choices (e.g. deciding to use black as the color elsewhere on the page, instead of green). Implementors have to balance the likelihood of a script using incorrect information with the performance impact of doing nothing while waiting for a slow network request to finish.

A Document has a style sheet that is blocking scripts if there is either a style sheet that is blocking scripts in the context of that Document, or if that Document has a browsing context that has a parent browsing context, and the active document of that parent browsing context itself has a style sheet that is blocking scripts.

A Document has no style sheet that is blocking scripts if it does not have a style sheet that is blocking scripts as defined in the previous paragraph.

4.3 Sections

Support: html5semantic
Chrome for Android	64+
Chrome	26+
iOS Safari	7.0+
UC Browser for Android	11.8+
Firefox	21+
Samsung Internet	4+
IE (limited)	9+
Opera Mini (limited)	all+
Safari	6.1+
Edge	12+
Android Browser	4.4+
Opera	15+

Source: caniuse.com

4.3.1 The body element
Categories:
Sectioning root.
Contexts in which this element can be used:
As the second element in an html element.
Content model:
Flow content.
Tag omission in text/html:
A body element's start tag can be omitted if the element is empty, or if the first thing inside the body element is not ASCII whitespace or a comment, except if the first thing inside the body element is a meta, link, script, style, or template element.
A body element's end tag can be omitted if the body element is not immediately followed by a comment.
Content attributes:
Global attributes
onafterprint
onbeforeprint
onbeforeunload
onhashchange
onlanguagechange
onmessage
onmessageerror
onoffline
ononline
onpagehide
onpageshow
onpopstate
onrejectionhandled
onstorage
onunhandledrejection
onunload
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLBodyElement : HTMLElement {
  // also has obsolete members
};

HTMLBodyElement includes WindowEventHandlers;
The body element represents the contents of the document.

In conforming documents, there is only one body element. The document.body IDL attribute provides scripts with easy access to a document's body element.

Some DOM operations (for example, parts of the drag and drop model) are defined in terms of "the body element". This refers to a particular element in the DOM, as per the definition of the term, and not any arbitrary body element.

The body element exposes as event handler content attributes a number of the event handlers of the Window object. It also mirrors their event handler IDL attributes.

The onblur, onerror, onfocus, onload, onresize, and onscroll event handlers of the Window object, exposed on the body element, replace the generic event handlers with the same names normally supported by HTML elements.

Thus, for example, a bubbling error event dispatched on a child of the body element of a Document would first trigger the onerror event handler content attributes of that element, then that of the root html element, and only then would it trigger the onerror event handler content attribute on the body element. This is because the event would bubble from the target, to the body, to the html, to the Document, to the Window, and the event handler on the body is watching the Window not the body. A regular event listener attached to the body using addEventListener(), however, would be run when the event bubbled through the body and not when it reaches the Window object.

This page updates an indicator to show whether or not the user is online:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Online or offline?</title>
  <script>
   function update(online) {
     document.getElementById('status').textContent =
       online ? 'Online' : 'Offline';
   }
  </script>
 </head>
 <body ononline="update(true)"
       onoffline="update(false)"
       onload="update(navigator.onLine)">
  <p>You are: <span id="status">(Unknown)</span></p>
 </body>
</html>
4.3.2 The article element
Categories:
Flow content.
Sectioning content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The article element represents a complete, or self-contained, composition in a document, page, application, or site and that is, in principle, independently distributable or reusable, e.g. in syndication. This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment, an interactive widget or gadget, or any other independent item of content.

When article elements are nested, the inner article elements represent articles that are in principle related to the contents of the outer article. For instance, a blog entry on a site that accepts user-submitted comments could represent the comments as article elements nested within the article element for the blog entry.

Author information associated with an article element (q.v. the address element) does not apply to nested article elements.

When used specifically with content to be redistributed in syndication, the article element is similar in purpose to the entry element in Atom. [ATOM]

The schema.org microdata vocabulary can be used to provide the publication date for an article element, using one of the CreativeWork subtypes.

When the main content of the page (i.e. excluding footers, headers, navigation blocks, and sidebars) is all one single self-contained composition, that content may be marked with an article, but it is technically redundant in that case (since it's self-evident that the page is a single composition, as it is a single document).

This example shows a blog post using the article element, with some schema.org annotations:

<article itemscope itemtype="http://schema.org/BlogPosting">
 <header>
  <h1 itemprop="headline">The Very First Rule of Life</h1>
  <p><time itemprop="datePublished" datetime="2009-10-09">3 days ago</time></p>
  <link itemprop="url" href="?comments=0">
 </header>
 <p>If there's a microphone anywhere near you, assume it's hot and
 sending whatever you're saying to the world. Seriously.</p>
 <p>...</p>
 <footer>
  <a itemprop="discussionUrl" href="?comments=1">Show comments...</a>
 </footer>
</article>
Here is that same blog post, but showing some of the comments:

<article itemscope itemtype="http://schema.org/BlogPosting">
 <header>
  <h1 itemprop="headline">The Very First Rule of Life</h1>
  <p><time itemprop="datePublished" datetime="2009-10-09">3 days ago</time></p>
  <link itemprop="url" href="?comments=0">
 </header>
 <p>If there's a microphone anywhere near you, assume it's hot and
 sending whatever you're saying to the world. Seriously.</p>
 <p>...</p>
 <section>
  <h1>Comments</h1>
  <article itemprop="comment" itemscope itemtype="http://schema.org/UserComments" id="c1">
   <link itemprop="url" href="#c1">
   <footer>
    <p>Posted by: <span itemprop="creator" itemscope itemtype="http://schema.org/Person">
     <span itemprop="name">George Washington</span>
    </span></p>
    <p><time itemprop="commentTime" datetime="2009-10-10">15 minutes ago</time></p>
   </footer>
   <p>Yeah! Especially when talking about your lobbyist friends!</p>
  </article>
  <article itemprop="comment" itemscope itemtype="http://schema.org/UserComments" id="c2">
   <link itemprop="url" href="#c2">
   <footer>
    <p>Posted by: <span itemprop="creator" itemscope itemtype="http://schema.org/Person">
     <span itemprop="name">George Hammond</span>
    </span></p>
    <p><time itemprop="commentTime" datetime="2009-10-10">5 minutes ago</time></p>
   </footer>
   <p>Hey, you have the same first name as me.</p>
  </article>
 </section>
</article>
Notice the use of footer to give the information for each comment (such as who wrote it and when): the footer element can appear at the start of its section when appropriate, such as in this case. (Using header in this case wouldn't be wrong either; it's mostly a matter of authoring preference.)

In this example, article elements are used to host widgets on a portal page. The widgets are implemented as customized built-in elements in order to get specific styling and scripted behavior.

<!DOCTYPE HTML>
<html lang=en>
<title>eHome Portal</title>
<script src="/scripts/widgets.js">
<link rel=stylesheet href="/styles/main.css">
<article is="stock-widget">
 <h1>Stocks</h1>
 <table>
  <thead> <tr> <th> Stock <th> Value <th> Delta
  <tbody> <template> <tr> <td> <td> <td> </template>
 </table>
 <p> <input type=button value="Refresh" onclick="this.parentElement.refresh()">
</article>
<article is="news-widget">
 <h1>News</h1>
 <ul>
  <template>
   <li>
    <p><img> <strong></strong>
    <p>
  </template>
 </ul>
 <p> <input type=button value="Refresh" onclick="this.parentElement.refresh()">
</article>
4.3.3 The section element
Categories:
Flow content.
Sectioning content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The section element represents a generic section of a document or application. A section, in this context, is a thematic grouping of content, typically with a heading.

Examples of sections would be chapters, the various tabbed pages in a tabbed dialog box, or the numbered sections of a thesis. A Web site's home page could be split into sections for an introduction, news items, and contact information.

Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate the contents of the element.

The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element's contents would be listed explicitly in the document's outline.

In the following example, we see an article (part of a larger Web page) about apples, containing two short sections.

<article>
 <hgroup>
  <h1>Apples</h1>
  <h2>Tasty, delicious fruit!</h2>
 </hgroup>
 <p>The apple is the pomaceous fruit of the apple tree.</p>
 <section>
  <h1>Red Delicious</h1>
  <p>These bright red apples are the most common found in many
  supermarkets.</p>
 </section>
 <section>
  <h1>Granny Smith</h1>
  <p>These juicy, green apples make a great filling for
  apple pies.</p>
 </section>
</article>
Notice how the use of section means that the author can use h1 elements throughout, without having to worry about whether a particular section is at the top level, the second level, the third level, and so on.

Here is a graduation programme with two sections, one for the list of people graduating, and one for the description of the ceremony. (The markup in this example features an uncommon style sometimes used to minimize the amount of inter-element whitespace.)

<!DOCTYPE Html>
<Html Lang=En
 ><Head
   ><Title
     >Graduation Ceremony Summer 2022</Title
   ></Head
 ><Body
   ><H1
     >Graduation</H1
   ><Section
     ><H1
       >Ceremony</H1
     ><P
       >Opening Procession</P
     ><P
       >Speech by Validactorian</P
     ><P
       >Speech by Class President</P
     ><P
       >Presentation of Diplomas</P
     ><P
       >Closing Speech by Headmaster</P
   ></Section
   ><Section
     ><H1
       >Graduates</H1
     ><Ul
       ><Li
         >Molly Carpenter</Li
       ><Li
         >Anastasia Luccio</Li
       ><Li
         >Ebenezar McCoy</Li
       ><Li
         >Karrin Murphy</Li
       ><Li
         >Thomas Raith</Li
       ><Li
         >Susan Rodriguez</Li
     ></Ul
   ></Section
 ></Body
></Html>
In this example, a book author has marked up some sections as chapters and some as appendices, and uses CSS to style the headers in these two classes of section differently.

<style>
 section { border: double medium; margin: 2em; }
 section.chapter h1 { font: 2em Roboto, Helvetica Neue, sans-serif; }
 section.appendix h1 { font: small-caps 2em Roboto, Helvetica Neue, sans-serif; }
</style>
<header>
 <hgroup>
  <h1>My Book</h1>
  <h2>A sample with not much content</h2>
 </hgroup>
 <p><small>Published by Dummy Publicorp Ltd.</small></p>
</header>
<section class="chapter">
 <h1>My First Chapter</h1>
 <p>This is the first of my chapters. It doesn't say much.</p>
 <p>But it has two paragraphs!</p>
</section>
<section class="chapter">
 <h1>It Continues: The Second Chapter</h1>
 <p>Bla dee bla, dee bla dee bla. Boom.</p>
</section>
<section class="chapter">
 <h1>Chapter Three: A Further Example</h1>
 <p>It's not like a battle between brightness and earthtones would go
 unnoticed.</p>
 <p>But it might ruin my story.</p>
</section>
<section class="appendix">
 <h1>Appendix A: Overview of Examples</h1>
 <p>These are demonstrations.</p>
</section>
<section class="appendix">
 <h1>Appendix B: Some Closing Remarks</h1>
 <p>Hopefully this long example shows that you <em>can</em> style
 sections, so long as they are used to indicate actual sections.</p>
</section>
4.3.4 The nav element
Categories:
Flow content.
Sectioning content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The nav element represents a section of a page that links to other pages or to parts within the page: a section with navigation links.

Not all groups of links on a page need to be in a nav element — the element is primarily intended for sections that consist of major navigation blocks. In particular, it is common for footers to have a short list of links to various pages of a site, such as the terms of service, the home page, and a copyright page. The footer element alone is sufficient for such cases; while a nav element can be used in such cases, it is usually unnecessary.

User agents (such as screen readers) that are targeted at users who can benefit from navigation information being omitted in the initial rendering, or who can benefit from navigation information being immediately available, can use this element as a way to determine what content on the page to initially skip or provide on request (or both).

In the following example, there are two nav elements, one for primary navigation around the site, and one for secondary navigation around the page itself.

<body>
 <h1>The Wiki Center Of Exampland</h1>
 <nav>
  <ul>
   <li><a href="/">Home</a></li>
   <li><a href="/events">Current Events</a></li>
   ...more...
  </ul>
 </nav>
 <article>
  <header>
   <h1>Demos in Exampland</h1>
   <p>Written by A. N. Other.</p>
  </header>
  <nav>
   <ul>
    <li><a href="#public">Public demonstrations</a></li>
    <li><a href="#destroy">Demolitions</a></li>
    ...more...
   </ul>
  </nav>
  <div>
   <section id="public">
    <h1>Public demonstrations</h1>
    <p>...more...</p>
   </section>
   <section id="destroy">
    <h1>Demolitions</h1>
    <p>...more...</p>
   </section>
   ...more...
  </div>
  <footer>
   <p><a href="?edit">Edit</a> | <a href="?delete">Delete</a> | <a href="?Rename">Rename</a></p>
  </footer>
 </article>
 <footer>
  <p><small>© copyright 1998 Exampland Emperor</small></p>
 </footer>
</body>
In the following example, the page has several places where links are present, but only one of those places is considered a navigation section.

<body itemscope itemtype="http://schema.org/Blog">
 <header>
  <h1>Wake up sheeple!</h1>
  <p><a href="news.html">News</a> -
     <a href="blog.html">Blog</a> -
     <a href="forums.html">Forums</a></p>
  <p>Last Modified: <span itemprop="dateModified">2009-04-01</span></p>
  <nav>
   <h1>Navigation</h1>
   <ul>
    <li><a href="articles.html">Index of all articles</a></li>
    <li><a href="today.html">Things sheeple need to wake up for today</a></li>
    <li><a href="successes.html">Sheeple we have managed to wake</a></li>
   </ul>
  </nav>
 </header>
 <main>
  <article itemprop="blogPosts" itemscope itemtype="http://schema.org/BlogPosting">
   <header>
    <h1 itemprop="headline">My Day at the Beach</h1>
   </header>
   <div itemprop="articleBody">
    <p>Today I went to the beach and had a lot of fun.</p>
    ...more content...
   </div>
   <footer>
    <p>Posted <time itemprop="datePublished" datetime="2009-10-10">Thursday</time>.</p>
   </footer>
  </article>
  ...more blog posts...
 </main>
 <footer>
  <p>Copyright ©
   <span itemprop="copyrightYear">2010</span>
   <span itemprop="copyrightHolder">The Example Company</span>
  </p>
  <p><a href="about.html">About</a> -
     <a href="policy.html">Privacy Policy</a> -
     <a href="contact.html">Contact Us</a></p>
 </footer>
</body>
You can also see microdata annotations in the above example that use the schema.org vocabulary to provide the publication date and other metadata about the blog post.

A nav element doesn't have to contain a list, it can contain other kinds of content as well. In this navigation block, links are provided in prose:

<nav>
 <h1>Navigation</h1>
 <p>You are on my home page. To the north lies <a href="/blog">my
 blog</a>, from whence the sounds of battle can be heard. To the east
 you can see a large mountain, upon which many <a
 href="/school">school papers</a> are littered. Far up thus mountain
 you can spy a little figure who appears to be me, desperately
 scribbling a <a href="/school/thesis">thesis</a>.</p>
 <p>To the west are several exits. One fun-looking exit is labeled <a
 href="https://games.example.com/">"games"</a>. Another more
 boring-looking exit is labeled <a
 href="https://isp.example.net/">ISP™</a>.</p>
 <p>To the south lies a dark and dank <a href="/about">contacts
 page</a>. Cobwebs cover its disused entrance, and at one point you
 see a rat run quickly out of the page.</p>
</nav>
In this example, nav is used in an e-mail application, to let the user switch folders:

<p><input type=button value="Compose" onclick="compose()"></p>
<nav>
 <h1>Folders</h1>
 <ul>
  <li> <a href="/inbox" onclick="return openFolder(this.href)">Inbox</a> <span class=count></span>
  <li> <a href="/sent" onclick="return openFolder(this.href)">Sent</a>
  <li> <a href="/drafts" onclick="return openFolder(this.href)">Drafts</a>
  <li> <a href="/trash" onclick="return openFolder(this.href)">Trash</a>
  <li> <a href="/customers" onclick="return openFolder(this.href)">Customers</a>
 </ul>
</nav>
4.3.5 The aside element
Categories:
Flow content.
Sectioning content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The aside element represents a section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.

The element can be used for typographical effects like pull quotes or sidebars, for advertising, for groups of nav elements, and for other content that is considered separate from the main content of the page.

It's not appropriate to use the aside element just for parentheticals, since those are part of the main flow of the document.

The following example shows how an aside is used to mark up background material on Switzerland in a much longer news story on Europe.

<aside>
 <h1>Switzerland</h1>
 <p>Switzerland, a land-locked country in the middle of geographic
 Europe, has not joined the geopolitical European Union, though it is
 a signatory to a number of European treaties.</p>
</aside>
The following example shows how an aside is used to mark up a pull quote in a longer article.

...

<p>He later joined a large company, continuing on the same work.
<q>I love my job. People ask me what I do for fun when I'm not at
work. But I'm paid to do my hobby, so I never know what to
answer. Some people wonder what they would do if they didn't have to
work... but I know what I would do, because I was unemployed for a
year, and I filled that time doing exactly what I do now.</q></p>

<aside>
 <q> People ask me what I do for fun when I'm not at work. But I'm
 paid to do my hobby, so I never know what to answer. </q>
</aside>

<p>Of course his work — or should that be hobby? —
isn't his only passion. He also enjoys other pleasures.</p>

...
The following extract shows how aside can be used for blogrolls and other side content on a blog:

<body>
 <header>
  <h1>My wonderful blog</h1>
  <p>My tagline</p>
 </header>
 <aside>
  <!-- this aside contains two sections that are tangentially related
  to the page, namely, links to other blogs, and links to blog posts
  from this blog -->
  <nav>
   <h1>My blogroll</h1>
   <ul>
    <li><a href="https://blog.example.com/">Example Blog</a>
   </ul>
  </nav>
  <nav>
   <h1>Archives</h1>
   <ol reversed>
    <li><a href="/last-post">My last post</a>
    <li><a href="/first-post">My first post</a>
   </ol>
  </nav>
 </aside>
 <aside>
  <!-- this aside is tangentially related to the page also, it
  contains twitter messages from the blog author -->
  <h1>Twitter Feed</h1>
  <blockquote cite="https://twitter.example.net/t31351234">
   I'm on vacation, writing my blog.
  </blockquote>
  <blockquote cite="https://twitter.example.net/t31219752">
   I'm going to go on vacation soon.
  </blockquote>
 </aside>
 <article>
  <!-- this is a blog post -->
  <h1>My last post</h1>
  <p>This is my last post.</p>
  <footer>
   <p><a href="/last-post" rel=bookmark>Permalink</a>
  </footer>
 </article>
 <article>
  <!-- this is also a blog post -->
  <h1>My first post</h1>
  <p>This is my first post.</p>
  <aside>
   <!-- this aside is about the blog post, since it's inside the
   <article> element; it would be wrong, for instance, to put the
   blogroll here, since the blogroll isn't really related to this post
   specifically, only to the page as a whole -->
   <h1>Posting</h1>
   <p>While I'm thinking about it, I wanted to say something about
   posting. Posting is fun!</p>
  </aside>
  <footer>
   <p><a href="/first-post" rel=bookmark>Permalink</a>
  </footer>
 </article>
 <footer>
  <nav>
   <a href="/archives">Archives</a> —
   <a href="/about">About me</a> —
   <a href="/copyright">Copyright</a>
  </nav>
 </footer>
</body>
4.3.6 The h1, h2, h3, h4, h5, and h6 elements
Categories:
Flow content.
Heading content.
Palpable content.
Contexts in which this element can be used:
As a child of an hgroup element.
Where flow content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLHeadingElement : HTMLElement {
  // also has obsolete members
};
These elements represent headings for their sections.

The semantics and meaning of these elements are defined in the section on headings and sections.

These elements have a rank given by the number in their name. The h1 element is said to have the highest rank, the h6 element has the lowest rank, and two elements with the same name have equal rank.

As far as their respective document outlines (their heading and section structures) are concerned, these two snippets are semantically equivalent:

<body>
<h1>Let's call it a draw(ing surface)</h1>
<h2>Diving in</h2>
<h2>Simple shapes</h2>
<h2>Canvas coordinates</h2>
<h3>Canvas coordinates diagram</h3>
<h2>Paths</h2>
</body>
<body>
 <h1>Let's call it a draw(ing surface)</h1>
 <section>
  <h1>Diving in</h1>
 </section>
 <section>
  <h1>Simple shapes</h1>
 </section>
 <section>
  <h1>Canvas coordinates</h1>
  <section>
   <h1>Canvas coordinates diagram</h1>
  </section>
 </section>
 <section>
  <h1>Paths</h1>
 </section>
</body>
Authors might prefer the former style for its terseness, or the latter style for its convenience in the face of heavy editing; which is best is purely an issue of preferred authoring style.

The two styles can be combined, for compatibility with legacy tools while still future-proofing for when that compatibility is no longer needed. This third snippet again has the same outline as the previous two:

<body>
 <h1>Let's call it a draw(ing surface)</h1>
 <section>
  <h2>Diving in</h2>
 </section>
 <section>
  <h2>Simple shapes</h2>
 </section>
 <section>
  <h2>Canvas coordinates</h2>
  <section>
   <h3>Canvas coordinates diagram</h3>
  </section>
 </section>
 <section>
  <h2>Paths</h2>
 </section>
</body>
4.3.7 The hgroup element
Categories:
Flow content.
Heading content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
One or more h1, h2, h3, h4, h5, h6, and template elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The hgroup element represents the heading of a section, which consists of all the h1–h6 element children of the hgroup element. The element is used to group a set of h1–h6 elements when the heading has multiple levels, such as subheadings, alternative titles, or taglines.

The rank of an hgroup element is the rank of the highest-ranked h1–h6 element descendant of the hgroup element, if there are any such elements, or otherwise the same as for an h1 element (the highest rank). Other h1–h6 elements of heading content in the hgroup element indicate subheadings or subtitles or (secondary) alternative titles.

The section on headings and sections defines how hgroup elements are assigned to individual sections.

Here are some examples of valid headings.

<hgroup>
 <h1>The reality dysfunction</h1>
 <h2>Space is not the only void</h2>
</hgroup>
<hgroup>
 <h1>Dr. Strangelove</h1>
 <h2>Or: How I Learned to Stop Worrying and Love the Bomb</h2>
</hgroup>
The point of using hgroup in these examples is to prevent the h2 element (which acts as a secondary title) from creating a separate section of its own in any outline and to instead cause the contents of the h2 to be shown in rendered output from the outline algorithm in some way to indicate that it is not the title of a separate section but instead just a secondary title in a group of titles.

How a user agent exposes such multi-level headings in user interfaces (e.g. in tables of contents or search results) is left open to implementers, as it is a user interface issue. The first example above could be rendered as:

The reality dysfunction: Space is not the only void
Alternatively, it could look like this:

The reality dysfunction (Space is not the only void)
In interfaces where a title can be rendered on multiple lines, it could be rendered as follows, maybe with the first line in a bigger font size:

The reality dysfunction
Space is not the only void
The following two examples show ways in which two h1 headings could be used within an hgroup element to group the US and UK names for the same movie.

<hgroup>
 <h1>The Avengers</h1>
 <h1>Avengers Assemble</h1>
</hgroup>

<hgroup>
 <h1>Avengers Assemble</h1>
 <h1>The Avengers</h1>
</hgroup>
The first example above shows how the movie names might be grouped in a publication in the US, with the US name The Avengers as the (primary) title, and the UK name Avengers Assemble as the (secondary) alternative title. The second example above shows how the movie names might be grouped in a publication in the UK, with the UK name as the (primary) title, and the US name as the (secondary) alternative title.

In both cases it is important to note the use of the hgroup element to group the two titles indicates that the titles are not equivalent; instead the first h1 gives the (primary) title while the second gives the (secondary) alternative title. Even though both the title and alternative title are marked up with h1 elements, in a rendered view of output from the outline algorithm, the second h1 in the hgroup will be shown in some way that clearly indicates it is secondary; for example:

In a US publication:

The Avengers (Avengers Assemble)
In a UK publication:

Avengers Assemble (The Avengers)
In the following example, an hgroup element is used to mark up a two-level heading in a wizard-style dialog box:

<dialog onclose="walletSetup.continue(this.returnValue)">
 <hgroup>
  <h1>Wallet Setup</h1>
  <h2>Configure your Wallet funding source</h2>
 </hgroup>
 <p>Your Wallet can be used to buy wands at the merchant in town, to buy potions from travelling
 salesmen you may find in the dungeons, and to pay for mercenaries.</p>
 <p>We support two payment sources:</p>
 <form method=dialog>
  <fieldset oninput="this.getElementsByTagName('input')[0].checked = true">
   <legend> <label> <input type=radio name=payment-type value=cc> Credit Card </label> </legend>
   <p><label>Name on card: <input name=cc1 autocomplete="section-cc cc-name" placeholder="Y. Name"></label>
   <p><label>Card number: <input name=cc2 inputmode=numeric autocomplete="section-cc cc-number" placeholder="6331 1019 9999 0016"></label>
   <p><label>Expiry Date: <input name=cc3 type=month autocomplete="section-cc cc-exp" placeholder="2020-02"></label>
   <p><label>Security Code: <input name=cc4 inputmode=numeric autocomplete="section-cc cc-csc" placeholder="246"></label>
  </fieldset>
  <fieldset oninput="this.getElementsByTagName('input')[0].checked = true">
   <legend> <label> <input type=radio name=payment-type value=bank> Checking Account </label> </legend>
   <p><label>Name on account: <input name=bank1 autocomplete="section-bank cc-name"></label>
   <p><label>Routing number: <input name=bank2 inputmode=numeric></label>
   <p><label>Account number: <input name=bank3 inputmode=numeric></label>
  </fieldset>
  <button type=submit value="back"> ← Back </button>
  <button type=submit value="next"> Next → </button>
 </form>
</dialog>
4.3.8 The header element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content, but with no header or footer element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The header element represents a group of introductory or navigational aids.

A header element is intended to usually contain the section's heading (an h1–h6 element or an hgroup element), but this is not required. The header element can also be used to wrap a section's table of contents, a search form, or any relevant logos.

Here are some sample headers. This first one is for a game:

<header>
 <p>Welcome to...</p>
 <h1>Voidwars!</h1>
</header>
The following snippet shows how the element can be used to mark up a specification's header:

<header>
 <hgroup>
  <h1>Fullscreen API</h1>
  <h2>Living Standard — Last Updated 19 October 2015</h2>
 </hgroup>
 <dl>
  <dt>Participate:</dt>
  <dd><a href="https://github.com/whatwg/fullscreen">GitHub whatwg/fullscreen</a></dd>
  <dt>Commits:</dt>
  <dd><a href="https://github.com/whatwg/fullscreen/commits">GitHub whatwg/fullscreen/commits</a></dd>
 </dl>
</header>
The header element is not sectioning content; it doesn't introduce a new section.

In this example, the page has a page heading given by the h1 element, and two subsections whose headings are given by h2 elements. The content after the header element is still part of the last subsection started in the header element, because the header element doesn't take part in the outline algorithm.

<body>
 <header>
  <h1>Little Green Guys With Guns</h1>
  <nav>
   <ul>
    <li><a href="/games">Games</a>
    <li><a href="/forum">Forum</a>
    <li><a href="/download">Download</a>
   </ul>
  </nav>
  <h2>Important News</h2> <!-- this starts a second subsection -->
  <!-- this is part of the subsection entitled "Important News" -->
  <p>To play today's games you will need to update your client.</p>
  <h2>Games</h2> <!-- this starts a third subsection -->
 </header>
 <p>You have three active games:</p>
 <!-- this is still part of the subsection entitled "Games" -->
 ...
4.3.9 The footer element

Spec bugs: 12990

Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content, but with no header or footer element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The footer element represents a footer for its nearest ancestor sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like.

When the footer element contains entire sections, they represent appendices, indexes, long colophons, verbose license agreements, and other such content.

Contact information for the author or editor of a section belongs in an address element, possibly itself inside a footer. Bylines and other information that could be suitable for both a header or a footer can be placed in either (or neither). The primary purpose of these elements is merely to help the author write self-explanatory markup that is easy to maintain and style; they are not intended to impose specific structures on authors.

Footers don't necessarily have to appear at the end of a section, though they usually do.

When the nearest ancestor sectioning content or sectioning root element is the body element, then it applies to the whole page.

The footer element is not sectioning content; it doesn't introduce a new section.

Here is a page with two footers, one at the top and one at the bottom, with the same content:

<body>
 <footer><a href="../">Back to index...</a></footer>
 <hgroup>
  <h1>Lorem ipsum</h1>
  <h2>The ipsum of all lorems</h2>
 </hgroup>
 <p>A dolor sit amet, consectetur adipisicing elit, sed do eiusmod
 tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
 veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex
 ea commodo consequat. Duis aute irure dolor in reprehenderit in
 voluptate velit esse cillum dolore eu fugiat nulla
 pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
 culpa qui officia deserunt mollit anim id est laborum.</p>
 <footer><a href="../">Back to index...</a></footer>
</body>
Here is an example which shows the footer element being used both for a site-wide footer and for a section footer.

<!DOCTYPE HTML>
<HTML LANG="en"><HEAD>
<TITLE>The Ramblings of a Scientist</TITLE>
<BODY>
<H1>The Ramblings of a Scientist</H1>
<ARTICLE>
 <H1>Episode 15</H1>
 <VIDEO SRC="/fm/015.ogv" CONTROLS PRELOAD>
  <P><A HREF="/fm/015.ogv">Download video</A>.</P>
 </VIDEO>
 <FOOTER> <!-- footer for article -->
  <P>Published <TIME DATETIME="2009-10-21T18:26-07:00">on 2009/10/21 at 6:26pm</TIME></P>
 </FOOTER>
</ARTICLE>
<ARTICLE>
 <H1>My Favorite Trains</H1>
 <P>I love my trains. My favorite train of all time is a Köf.</P>
 <P>It is fun to see them pull some coal cars because they look so
 dwarfed in comparison.</P>
 <FOOTER> <!-- footer for article -->
  <P>Published <TIME DATETIME="2009-09-15T14:54-07:00">on 2009/09/15 at 2:54pm</TIME></P>
 </FOOTER>
</ARTICLE>
<FOOTER> <!-- site wide footer -->
 <NAV>
  <P><A HREF="/credits.html">Credits</A> —
     <A HREF="/tos.html">Terms of Service</A> —
     <A HREF="/index.html">Blog Index</A></P>
 </NAV>
 <P>Copyright © 2009 Gordon Freeman</P>
</FOOTER>
</BODY>
</HTML>
Some site designs have what is sometimes referred to as "fat footers" — footers that contain a lot of material, including images, links to other articles, links to pages for sending feedback, special offers... in some ways, a whole "front page" in the footer.

This fragment shows the bottom of a page on a site with a "fat footer":

...
 <footer>
  <nav>
   <section>
    <h1>Articles</h1>
    <p><img src="images/somersaults.jpeg" alt=""> Go to the gym with
    our somersaults class! Our teacher Jim takes you through the paces
    in this two-part article. <a href="articles/somersaults/1">Part
    1</a> · <a href="articles/somersaults/2">Part 2</a></p>
    <p><img src="images/kindplus.jpeg"> Tired of walking on the edge of
    a clif<!-- sic -->? Our guest writer Lara shows you how to bumble
    your way through the bars. <a href="articles/kindplus/1">Read
    more...</a></p>
    <p><img src="images/crisps.jpeg"> The chips are down, now all
    that's left is a potato. What can you do with it? <a
    href="articles/crisps/1">Read more...</a></p>
   </section>
   <ul>
    <li> <a href="/about">About us...</a>
    <li> <a href="/feedback">Send feedback!</a>
    <li> <a href="/sitemap">Sitemap</a>
   </ul>
  </nav>
  <p><small>Copyright © 2015 The Snacker —
  <a href="/tos">Terms of Service</a></small></p>
 </footer>
</body>
4.3.10 The address element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content, but with no heading content descendants, no sectioning content descendants, and no header, footer, or address element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The address element represents the contact information for its nearest article or body element ancestor. If that is the body element, then the contact information applies to the document as a whole.

For example, a page at the W3C Web site related to HTML might include the following contact information:

<ADDRESS>
 <A href="../People/Raggett/">Dave Raggett</A>,
 <A href="../People/Arnaud/">Arnaud Le Hors</A>,
 contact persons for the <A href="Activity">W3C HTML Activity</A>
</ADDRESS>
The address element must not be used to represent arbitrary addresses (e.g. postal addresses), unless those addresses are in fact the relevant contact information. (The p element is the appropriate element for marking up postal addresses in general.)

The address element must not contain information other than contact information.

For example, the following is non-conforming use of the address element:

<ADDRESS>Last Modified: 1999/12/24 23:37:50</ADDRESS>
Typically, the address element would be included along with other information in a footer element.

The contact information for a node node is a collection of address elements defined by the first applicable entry from the following list:

If node is an article element
If node is a body element
The contact information consists of all the address elements that have node as an ancestor and do not have another body or article element ancestor that is a descendant of node.

If node has an ancestor element that is an article element
If node has an ancestor element that is a body element
The contact information of node is the same as the contact information of the nearest article or body element ancestor, whichever is nearest.

If node's node document has a body element
The contact information of node is the same as the contact information of the body element of the Document.

Otherwise
There is no contact information for node.

User agents may expose the contact information of a node to the user, or use it for other purposes, such as indexing sections based on the sections' contact information.

In this example the footer contains contact information and a copyright notice.

<footer>
 <address>
  For more details, contact
  <a href="mailto:js@example.com">John Smith</a>.
 </address>
 <p><small>© copyright 2038 Example Corp.</small></p>
</footer>
4.3.11 Headings and sections
The h1–h6 elements and the hgroup element are headings.

The first element of heading content in an element of sectioning content represents the heading for that section. Subsequent headings of equal or higher rank start new (implied) sections, headings of lower rank start implied subsections that are part of the previous one. In both cases, the element represents the heading of the implied section.

Certain elements are said to be sectioning roots, including blockquote and td elements. These elements can have their own outlines, but the sections and headings inside these elements do not contribute to the outlines of their ancestors.

blockquotebodydetailsdialogfieldsetfiguretd
Sectioning content elements are always considered subsections of their nearest ancestor sectioning root or their nearest ancestor element of sectioning content, whichever is nearest, regardless of what implied sections other headings may have created.

For the following fragment:

<body>
 <h1>Foo</h1>
 <h2>Bar</h2>
 <blockquote>
  <h3>Bla</h3>
 </blockquote>
 <p>Baz</p>
 <h2>Quux</h2>
 <section>
  <h3>Thud</h3>
 </section>
 <p>Grunt</p>
</body>
...the structure would be:

Foo (heading of explicit body section, containing the "Grunt" paragraph)
Bar (heading starting implied section, containing a block quote and the "Baz" paragraph)
Quux (heading starting implied section with no content other than the heading itself)
Thud (heading of explicit section section)
Notice how the section ends the earlier implicit section so that a later paragraph ("Grunt") is back at the top level.

Sections may contain headings of any rank, but authors are strongly encouraged to either use only h1 elements, or to use elements of the appropriate rank for the section's nesting level.

Authors are also encouraged to explicitly wrap sections in elements of sectioning content, instead of relying on the implicit sections generated by having multiple headings in one element of sectioning content.

For example, the following is correct:

<body>
 <h4>Apples</h4>
 <p>Apples are fruit.</p>
 <section>
  <h2>Taste</h2>
  <p>They taste lovely.</p>
  <h6>Sweet</h6>
  <p>Red apples are sweeter than green ones.</p>
  <h1>Color</h1>
  <p>Apples come in various colors.</p>
 </section>
</body>
However, the same document would be more clearly expressed as:

<body>
 <h1>Apples</h1>
 <p>Apples are fruit.</p>
 <section>
  <h2>Taste</h2>
  <p>They taste lovely.</p>
  <section>
   <h3>Sweet</h3>
   <p>Red apples are sweeter than green ones.</p>
  </section>
 </section>
 <section>
  <h2>Color</h2>
  <p>Apples come in various colors.</p>
 </section>
</body>
Both of the documents above are semantically identical and would produce the same outline in compliant user agents.

This third example is also semantically identical, and might be easier to maintain (e.g. if sections are often moved around in editing):

<body>
 <h1>Apples</h1>
 <p>Apples are fruit.</p>
 <section>
  <h1>Taste</h1>
  <p>They taste lovely.</p>
  <section>
   <h1>Sweet</h1>
   <p>Red apples are sweeter than green ones.</p>
  </section>
 </section>
 <section>
  <h1>Color</h1>
  <p>Apples come in various colors.</p>
 </section>
</body>
This final example would need explicit style rules to be rendered well in legacy browsers. Legacy browsers without CSS support would render all the headings as top-level headings.

4.3.11.1 Creating an outline
This section defines an algorithm for creating an outline for a sectioning content element or a sectioning root element. It is defined in terms of a walk over the nodes of a DOM tree, in tree order, with each node being visited when it is entered and when it is exited during the walk.

The outline for a sectioning content element or a sectioning root element consists of a list of one or more potentially nested sections. The element for which an outline is created is said to be the outline's owner.

A section is a container that corresponds to some nodes in the original DOM tree. Each section can have one heading associated with it, and can contain any number of further nested sections. The algorithm for the outline also associates each node in the DOM tree with a particular section and potentially a heading. (The sections in the outline aren't section elements, though some may correspond to such elements — they are merely conceptual sections.)

The following markup fragment:

<body>
  <hgroup id="document-title">
    <h1>HTML</h1>
    <h2>Living Standard — Last Updated 12 August 2016</h2>
  </hgroup>
  <p>Some intro to the document.</p>
  <h2>Table of contents</h2>
  <ol id=toc>...</ol>
  <h2>First section</h2>
  <p>Some intro to the first section.</p>
</body>
...results in the following outline being created for the body node (and thus the entire document):

Section created for body node.

Associated with heading <hgroup id="document-title">...</hgroup> consisting of primary heading <h1>HTML</h1> and secondary heading <h2>Living Standard — Last Updated 12 August 2016</h2>.

Also associated with the paragraph <p>Some intro to the document.</p> (though it likely would not be shown in a rendered view of the outline).

Nested sections:

Section implied for first h2 element.

Associated with heading <h2>Table of contents</h2>.

Also associated with the ordered list <ol id=toc>...</ol> (though it likely would not be shown in a rendered view of the outline).

No nested sections.

Section implied for second h2 element.

Associated with heading <h2>First section</h2>.

Also associated with the paragraph <p>Some intro to the first section.</p> (though it likely would not be shown in a rendered view of the outline).

No nested sections.

The following image shows what a rendered view of the outline might look like.



The algorithm that must be followed during a walk of a DOM subtree rooted at a sectioning content element or a sectioning root element to determine that element's outline is as follows:

Let current outline target be null. (It holds the element whose outline is being created.)

Let current section be null. (It holds a pointer to a section, so that elements in the DOM can all be associated with a section.)

Create a stack to hold elements, which is used to handle nesting. Initialize this stack to empty.

Walk over the DOM in tree order, starting with the sectioning content element or sectioning root element at the root of the subtree for which an outline is to be created, and trigger the first relevant step below for each element as the walk enters and exits it.

When exiting an element, if that element is the element at the top of the stack
The element being exited is a heading content element or an element with a hidden attribute.

Pop that element from the stack.

If the top of the stack is a heading content element or an element with a hidden attribute
Do nothing.

When entering an element with a hidden attribute
Push the element being entered onto the stack. (This causes the algorithm to skip that element and any descendants of the element.)

When entering a sectioning content element
Run these steps:

If current outline target is not null, then:

If the current section has no heading, create an implied heading and let that be the heading for the current section.

Push current outline target onto the stack.

Let current outline target be the element that is being entered.

Let current section be a newly created section for the current outline target element.

Associate current outline target with current section.

Let there be a new outline for the new current outline target, initialized with just the new current section as the only section in the outline.

When exiting a sectioning content element, if the stack is not empty
Run these steps:

If the current section has no heading, create an implied heading and let that be the heading for the current section.

Pop the top element from the stack, and let the current outline target be that element.

Let current section be the last section in the outline of the current outline target element.

Append the outline of the sectioning content element being exited to the current section. (This does not change which section is the last section in the outline.)

When entering a sectioning root element
Run these steps:

If current outline target is not null, push current outline target onto the stack.

Let current outline target be the element that is being entered.

Let current outline target's parent section be current section.

Let current section be a newly created section for the current outline target element.

Let there be a new outline for the new current outline target, initialized with just the new current section as the only section in the outline.

When exiting a sectioning root element, if the stack is not empty
Run these steps:

If the current section has no heading, create an implied heading and let that be the heading for the current section.

Let current section be current outline target's parent section.

Pop the top element from the stack, and let the current outline target be that element.

When exiting a sectioning content element or a sectioning root element (when the stack is empty)
The current outline target is the element being exited, and it is the sectioning content element or a sectioning root element at the root of the subtree for which an outline is being generated.

If the current section has no heading, create an implied heading and let that be the heading for the current section.

Skip to the next step in the overall set of steps. (The walk is over.)

When entering a heading content element
If the current section has no heading, let the element being entered be the heading for the current section.

If the element being entered is an hgroup element, that hgroup as a whole is a multi-level heading for the current section, with the highest-ranked h1–h6 descendant of the hgroup providing the primary heading for the current section, and with other h1–h6 descendants of the hgroup providing secondary headings for the current section.

Otherwise, if the element being entered has a rank equal to or higher than the heading of the last section of the outline of the current outline target, or if the heading of the last section of the outline of the current outline target is an implied heading, then create a new section and append it to the outline of the current outline target element, so that this new section is the new last section of that outline. Let current section be that new section. Let the element being entered be the new heading for the current section.

Otherwise, run these substeps:

Let candidate section be current section.

Heading loop: If the element being entered has a rank lower than the rank of the heading of the candidate section, then create a new section, and append it to candidate section. (This does not change which section is the last section in the outline.) Let current section be this new section. Let the element being entered be the new heading for the current section. Abort these substeps.

Let new candidate section be the section that contains candidate section in the outline of current outline target.

Let candidate section be new candidate section.

Return to the step labeled heading loop.

Push the element being entered onto the stack. (This causes the algorithm to skip any descendants of the element.)

Recall that h1 has the highest rank, and h6 has the lowest rank.

Otherwise
Do nothing.

In addition, whenever the walk exits a node, after doing the steps above, if the node is not associated with a section yet, associate the node with the section current section.

Associate all non-element nodes that are in the subtree for which an outline is being created with the section with which their parent element is associated.

Associate all nodes in the subtree with the heading of the section with which they are associated, if any.

The tree of sections created by the algorithm above, or a proper subset thereof, must be used when generating document outlines, for example when generating tables of contents.

The outline created for the body element of a Document is the outline of the entire document.

When creating an interactive table of contents, entries should jump the user to the relevant sectioning content element, if the section was created for a real element in the original document, or to the relevant heading content element, if the section in the tree was generated for a heading in the above process.

Selecting the first section of the document therefore always takes the user to the top of the document, regardless of where the first heading in the body is to be found.

The outline depth of a heading content element associated with a section section is the number of sections that are ancestors of section in the outermost outline that section finds itself in when the outlines of its Document's elements are created, plus 1. The outline depth of a heading content element not associated with a section is 1.

User agents should provide default headings for sections that do not have explicit section headings.

Consider the following snippet:

<body>
 <nav>
  <p><a href="/">Home</a></p>
 </nav>
 <p>Hello world.</p>
 <aside>
  <p>My cat is cute.</p>
 </aside>
</body>
Although it contains no headings, this snippet has three sections: a document (the body) with two subsections (a nav and an aside). A user agent could present the outline as follows:

Untitled document
Navigation
Sidebar
These default headings ("Untitled document", "Navigation", "Sidebar") are not specified by this specification, and might vary with the user's language, the page's language, the user's preferences, the user agent implementer's preferences, etc.

The following JavaScript function shows how the tree walk could be implemented. The root argument is the root of the tree to walk (either a sectioning content element or a sectioning root element), and the enter and exit arguments are callbacks that are called with the nodes as they are entered and exited. [JAVASCRIPT]

function (root, enter, exit) {
  var node = root;
  start: while (node) {
    enter(node);
    if (node.firstChild) {
      node = node.firstChild;
      continue start;
    }
    while (node) {
      exit(node);
      if (node == root) {
        node = null;
      } else if (node.nextSibling) {
        node = node.nextSibling;
        continue start;
      } else {
        node = node.parentNode;
      }
    }
  }
}
4.3.11.2 Sample outlines
This section is non-normative.

The following document shows a straight-forward application of the outline algorithm. First, here is the document, which is a book with very short chapters and subsections:

<!DOCTYPE HTML>
<html lang=en>
<title>The Tax Book (all in one page)</title>
<h1>The Tax Book</h1>
<h2>Earning money</h2>
<p>Earning money is good.</p>
<h3>Getting a job</h3>
<p>To earn money you typically need a job.</p>
<h2>Spending money</h2>
<p>Spending is what money is mainly used for.</p>
<h3>Cheap things</h3>
<p>Buying cheap things often not cost-effective.</p>
<h3>Expensive things</h3>
<p>The most expensive thing is often not the most cost-effective either.</p>
<h2>Investing money</h2>
<p>You can lend your money to other people.</p>
<h2>Losing money</h2>
<p>If you spend money or invest money, sooner or later you will lose money.
<h3>Poor judgement</h3>
<p>Usually if you lose money it's because you made a mistake.</p>
This book would form the following outline:

The Tax Book
Earning money
Getting a job
Spending money
Cheap things
Expensive things
Investing money
Losing money
Poor judgement
Notice that the title element does not participate in the outline.

Here is a similar document, but this time using section elements to get the same effect:

<!DOCTYPE HTML>
<html lang=en>
<title>The Tax Book (all in one page)</title>
<h1>The Tax Book</h1>
<section>
 <h1>Earning money</h1>
 <p>Earning money is good.</p>
 <section>
  <h1>Getting a job</h1>
  <p>To earn money you typically need a job.</p>
 </section>
</section>
<section>
 <h1>Spending money</h1>
 <p>Spending is what money is mainly used for.</p>
 <section>
  <h1>Cheap things</h1>
  <p>Buying cheap things often not cost-effective.</p>
 </section>
 <section>
  <h1>Expensive things</h1>
  <p>The most expensive thing is often not the most cost-effective either.</p>
 </section>
</section>
<section>
 <h1>Investing money</h1>
 <p>You can lend your money to other people.</p>
</section>
<section>
 <h1>Losing money</h1>
 <p>If you spend money or invest money, sooner or later you will lose money.
 <section>
  <h1>Poor judgement</h1>
  <p>Usually if you lose money it's because you made a mistake.</p>
 </section>
</section>
This book would form the same outline:

The Tax Book
Earning money
Getting a job
Spending money
Cheap things
Expensive things
Investing money
Losing money
Poor judgement
A document can contain multiple top-level headings:

<!DOCTYPE HTML>
<html lang=en>
<title>Alphabetic Fruit</title>
<h1>Apples</h1>
<p>Pomaceous.</p>
<h1>Bananas</h1>
<p>Edible.</p>
<h1>Carambola</h1>
<p>Star.</p>
This would form the following simple outline consisting of three top-level sections:

Apples
Bananas
Carambola
Effectively, the body element is split into three.

Mixing both the h1–h6 model and the section/h1 model can lead to some unintuitive results.

Consider for example the following, which is just the previous example but with the contents of the (implied) body wrapped in a section:

<!DOCTYPE HTML>
<html lang=en>
<title>Alphabetic Fruit</title>
<section>
 <h1>Apples</h1>
 <p>Pomaceous.</p>
 <h1>Bananas</h1>
 <p>Edible.</p>
 <h1>Carambola</h1>
 <p>Star.</p>
</section>
The resulting outline would be:

(untitled page)
Apples
Bananas
Carambola
This result is described as unintuitive because it results in three subsections even though there's only one section element. Effectively, the section is split into three, just like the implied body element in the previous example.

(In this example, "(untitled page)" is the implied heading for the body element, since it has no explicit heading.)

Headings never rise above other sections. Thus, in the following example, the first h1 does not actually describe the page header; it describes the header for the second half of the page:

<!DOCTYPE HTML>
<html lang=en>
<title>Feathers on The Site of Encyclopedic Knowledge</title>
<section>
 <h1>A plea from our caretakers</h1>
 <p>Please, we beg of you, send help! We're stuck in the server room!</p>
</section>
<h1>Feathers</h1>
<p>Epidermal growths.</p>
The resulting outline would be:

(untitled page)
A plea from our caretakers
Feathers
Thus, when an article element starts with a nav block and only later has its heading, the result is that the nav block is not part of the same section as the rest of the article in the outline. For instance, take this document:

<!DOCTYPE HTML>
<html lang="en">
<title>We're adopting a child! — Ray's blog</title>
<h1>Ray's blog</h1>
<article>
 <header>
  <nav>
   <a href="?t=-1d">Yesterday</a>;
   <a href="?t=-7d">Last week</a>;
   <a href="?t=-1m">Last month</a>
  </nav>
  <h1>We're adopting a child!</h1>
 </header>
 <p>As of today, Janine and I have signed the papers to become
 the proud parents of baby Diane! We've been looking forward to
 this day for weeks.</p>
</article>
</html>
The resulting outline would be:

Ray's blog
Untitled article
Untitled navigation section
We're adopting a child!
Also worthy of note in this example is that the header element has no effect whatsoever on the document outline.

The hgroup element can be used for subheadings. For example:

<!DOCTYPE HTML>
<html lang="en">
<title>Chronotype: CS Student</title>
<hgroup>
 <h1> The morning </h1>
 <h2> 06:00 to 12:00 </h2>
</hgroup>
<p>We sleep.</p>
<hgroup>
 <h1> The afternoon </h1>
 <h2> 12:00 to 18:00 </h2>
</hgroup>
<p>We study.</p>
<hgroup>
 <h2>Additional Commentary</h2>
 <h3>Because not all this is necessarily true</h3>
 <h6>Ok it's almost certainly not true</h6>
</hgroup>
<p>Yeah we probably play, rather than study.</p>
<hgroup>
 <h1> The evening </h1>
 <h2> 18:00 to 00:00 </h2>
</hgroup>
<p>We play.</p>
<hgroup>
 <h1> The night </h1>
 <h2> 00:00 to 06:00 </h2>
</hgroup>
<p>We play some more.</p>
</html>
The resulting outline would be:

The morning 06:00 to 12:00
The afternoon 12:00 to 18:00
Additional Commentary Because not all this is necessarily true Ok it's almost certainly not true
The evening 18:00 to 00:00
The night 00:00 to 06:00
Exactly how this is represented by user agents, as most interface issues, is left as a matter of implementation preference, but the key part is that the hgroup's descendant h1–h6 elements are what form the element's heading. Thus, the following would be equally valid:

The morning — 06:00 to 12:00
The afternoon — 12:00 to 18:00
Additional Commentary — Because not all this is necessarily true — Ok it's almost certainly not true
The evening — 18:00 to 00:00
The night — 00:00 to 06:00
But so would the following:

The morning
The afternoon
Additional Commentary
The evening
The night
The following would also be valid, though maybe less practical in most contexts:

The morning

06:00 to 12:00

The afternoon

12:00 to 18:00

Additional Commentary

Because not all this is necessarily true

Ok it's almost certainly not true

The evening

18:00 to 00:00

The night

00:00 to 06:00

4.3.11.3 Exposing outlines to users
User agents are encouraged to expose page outlines to users to aid in navigation. This is especially true for non-visual media, e.g. screen readers.

However, to mitigate the difficulties that arise from authors misusing sectioning content, user agents are also encouraged to offer a mode that navigates the page using heading content alone.

For instance, a user agent could map the arrow keys as follows:

Shift+← Left
Go to previous section, including subsections of previous sections
Shift+→ Right
Go to next section, including subsections of the current section
Shift+↑ Up
Go to parent section of the current section
Shift+↓ Down
Go to next section, skipping subsections of the current section
Plus in addition, the user agent could map the j and k keys to navigating to the previous or next element of heading content, regardless of the section's outline depth and ignoring sections with no headings.

4.3.12 Usage summary
This section is non-normative.

Element	Purpose
Example
body	The contents of the document.
<!DOCTYPE HTML>
<html lang="en">
 <head> <title>Steve Hill's Home Page</title> </head>
 <body> <p>Hard Trance is My Life.</p> </body>
</html>
article	A complete, or self-contained, composition in a document, page, application, or site and that is, in principle, independently distributable or reusable, e.g. in syndication. This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment, an interactive widget or gadget, or any other independent item of content.
<article>
 <img src="/tumblr_masqy2s5yn1rzfqbpo1_500.jpg" alt="Yellow smiley face with the caption 'masif'">
 <p>My fave Masif tee so far!</p>
 <footer>Posted 2 days ago</footer>
</article>
<article>
 <img src="/tumblr_m9tf6wSr6W1rzfqbpo1_500.jpg" alt="">
 <p>Happy 2nd birthday Masif Saturdays!!!</p>
 <footer>Posted 3 weeks ago</footer>
</article>
section	A generic section of a document or application. A section, in this context, is a thematic grouping of content, typically with a heading.
<h1>Biography</h1>
<section>
 <h1>The facts</h1>
 <p>1500+ shows, 14+ countries</p>
</section>
<section>
 <h1>2010/2011 figures per year</h1>
 <p>100+ shows, 8+ countries</p>
</section>
nav	A section of a page that links to other pages or to parts within the page: a section with navigation links.
<nav>
 <p><a href="/">Home</a>
 <p><a href="/biog.html">Bio</a>
 <p><a href="/discog.html">Discog</a>
</nav>
aside	A section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.
<h1>Music</h1>
<p>As any burner can tell you, the event has a lot of trance.</p>
<aside>You can buy the music we played at our <a href="buy.html">playlist page</a>.</aside>
<p>This year we played a kind of trance that originated in Belgium, Germany, and the Netherlands in the mid 90s.</p>
h1–h6	A section heading
<h1>The Guide To Music On The Playa</h1>
<h2>The Main Stage</h2>
<p>If you want to play on a stage, you should bring one.</p>
<h2>Amplified Music</h2>
<p>Amplifiers up to 300W or 90dB are welcome.</p>
hgroup	The heading of a section, which consists of all the h1–h6 element children of the hgroup element. The element is used to group a set of h1–h6 elements when the heading has multiple levels, such as subheadings, alternative titles, or taglines.
<hgroup>
 <h1>Burning Music</h1>
 <h2>The Guide To Music On The Playa</h2>
</hgroup>
<section>
 <hgroup>
  <h1>Main Stage</h1>
  <h2>The Fiction Of A Music Festival</h2>
 </hgroup>
 <p>If you want to play on a stage, you should bring one.</p>
</section>
<section>
 <hgroup>
  <h1>Loudness!</h1>
  <h2>Questions About Amplified Music</h2>
 </hgroup>
 <p>Amplifiers up to 300W or 90dB are welcome.</p>
</section>
header	A group of introductory or navigational aids.
<article>
 <header>
  <h1>Hard Trance is My Life</h1>
  <p>By DJ Steve Hill and Technikal</p>
 </header>
 <p>The album with the amusing punctuation has red artwork.</p>
</article>
footer	A footer for its nearest ancestor sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like.
<article>
 <h1>Hard Trance is My Life</h1>
 <p>The album with the amusing punctuation has red artwork.</p>
 <footer>
  <p>Artists: DJ Steve Hill and Technikal</p>
 </footer>
</article>
4.3.12.1 Article or section?
This section is non-normative.

A section forms part of something else. An article is its own thing. But how does one know which is which? Mostly the real answer is "it depends on author intent".

For example, one could imagine a book with a "Granny Smith" chapter that just said "These juicy, green apples make a great filling for apple pies."; that would be a section because there'd be lots of other chapters on (maybe) other kinds of apples.

On the other hand, one could imagine a tweet or reddit comment or tumblr post or newspaper classified ad that just said "Granny Smith. These juicy, green apples make a great filling for apple pies."; it would then be articles because that was the whole thing.

A comment on an article is not part of the article on which it is commenting, therefore it is its own article.

4.4 Grouping content
4.4.1 The p element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
A p element's end tag can be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hgroup, hr, main, menu, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLParagraphElement : HTMLElement {
  // also has obsolete members
};
The p element represents a paragraph.

While paragraphs are usually represented in visual media by blocks of text that are physically separated from adjacent blocks through blank lines, a style sheet or user agent would be equally justified in presenting paragraph breaks in a different manner, for instance using inline pilcrows (¶).

The following examples are conforming HTML fragments:

<p>The little kitten gently seated herself on a piece of
carpet. Later in her life, this would be referred to as the time the
cat sat on the mat.</p>
<fieldset>
 <legend>Personal information</legend>
 <p>
   <label>Name: <input name="n"></label>
   <label><input name="anon" type="checkbox"> Hide from other users</label>
 </p>
 <p><label>Address: <textarea name="a"></textarea></label></p>
</fieldset>
<p>There was once an example from Femley,<br>
Whose markup was of dubious quality.<br>
The validator complained,<br>
So the author was pained,<br>
To move the error from the markup to the rhyming.</p>
The p element should not be used when a more specific element is more appropriate.

The following example is technically correct:

<section>
 <!-- ... -->
 <p>Last modified: 2001-04-23</p>
 <p>Author: fred@example.com</p>
</section>
However, it would be better marked-up as:

<section>
 <!-- ... -->
 <footer>Last modified: 2001-04-23</footer>
 <address>Author: fred@example.com</address>
</section>
Or:

<section>
 <!-- ... -->
 <footer>
  <p>Last modified: 2001-04-23</p>
  <address>Author: fred@example.com</address>
 </footer>
</section>
List elements (in particular, ol and ul elements) cannot be children of p elements. When a sentence contains a bulleted list, therefore, one might wonder how it should be marked up.

For instance, this fantastic sentence has bullets relating to

wizards,
faster-than-light travel, and
telepathy,
and is further discussed below.

The solution is to realize that a paragraph, in HTML terms, is not a logical concept, but a structural one. In the fantastic example above, there are actually five paragraphs as defined by this specification: one before the list, one for each bullet, and one after the list.

The markup for the above example could therefore be:

<p>For instance, this fantastic sentence has bullets relating to</p>
<ul>
 <li>wizards,
 <li>faster-than-light travel, and
 <li>telepathy,
</ul>
<p>and is further discussed below.</p>
Authors wishing to conveniently style such "logical" paragraphs consisting of multiple "structural" paragraphs can use the div element instead of the p element.

Thus for instance the above example could become the following:

<div>For instance, this fantastic sentence has bullets relating to
<ul>
 <li>wizards,
 <li>faster-than-light travel, and
 <li>telepathy,
</ul>
and is further discussed below.</div>
This example still has five structural paragraphs, but now the author can style just the div instead of having to consider each part of the example separately.

4.4.2 The hr element
Categories:
Flow content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLHRElement : HTMLElement {
  // also has obsolete members
};
The hr element represents a paragraph-level thematic break, e.g. a scene change in a story, or a transition to another topic within a section of a reference book.

The following fictional extract from a project manual shows two sections that use the hr element to separate topics within the section.

<section>
 <h1>Communication</h1>
 <p>There are various methods of communication. This section
 covers a few of the important ones used by the project.</p>
 <hr>
 <p>Communication stones seem to come in pairs and have mysterious
 properties:</p>
 <ul>
  <li>They can transfer thoughts in two directions once activated
  if used alone.</li>
  <li>If used with another device, they can transfer one's
  consciousness to another body.</li>
  <li>If both stones are used with another device, the
  consciousnesses switch bodies.</li>
 </ul>
 <hr>
 <p>Radios use the electromagnetic spectrum in the meter range and
 longer.</p>
 <hr>
 <p>Signal flares use the electromagnetic spectrum in the
 nanometer range.</p>
</section>
<section>
 <h1>Food</h1>
 <p>All food at the project is rationed:</p>
 <dl>
  <dt>Potatoes</dt>
  <dd>Two per day</dd>
  <dt>Soup</dt>
  <dd>One bowl per day</dd>
 </dl>
 <hr>
 <p>Cooking is done by the chefs on a set rotation.</p>
</section>
There is no need for an hr element between the sections themselves, since the section elements and the h1 elements imply thematic changes themselves.

The following extract from Pandora's Star by Peter F. Hamilton shows two paragraphs that precede a scene change and the paragraph that follows it. The scene change, represented in the printed book by a gap containing a solitary centered star between the second and third paragraphs, is here represented using the hr element.

<p>Dudley was ninety-two, in his second life, and fast approaching
time for another rejuvenation. Despite his body having the physical
age of a standard fifty-year-old, the prospect of a long degrading
campaign within academia was one he regarded with dread. For a
supposedly advanced civilization, the Intersolar Commonwealth could be
appallingly backward at times, not to mention cruel.</p>
<p><i>Maybe it won't be that bad</i>, he told himself. The lie was
comforting enough to get him through the rest of the night's
shift.</p>
<hr>
<p>The Carlton AllLander drove Dudley home just after dawn. Like the
astronomer, the vehicle was old and worn, but perfectly capable of
doing its job. It had a cheap diesel engine, common enough on a
semi-frontier world like Gralmond, although its drive array was a
thoroughly modern photoneural processor. With its high suspension and
deep-tread tyres it could plough along the dirt track to the
observatory in all weather and seasons, including the metre-deep snow
of Gralmond's winters.</p>
The hr element does not affect the document's outline.

4.4.3 The pre element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLPreElement : HTMLElement {
  // also has obsolete members
};
The pre element represents a block of preformatted text, in which structure is represented by typographic conventions rather than by elements.

In the HTML syntax, a leading newline character immediately following the pre element start tag is stripped.

Some examples of cases where the pre element could be used:

Including an e-mail, with paragraphs indicated by blank lines, lists indicated by lines prefixed with a bullet, and so on.
Including fragments of computer code, with structure indicated according to the conventions of that language.
Displaying ASCII art.
Authors are encouraged to consider how preformatted text will be experienced when the formatting is lost, as will be the case for users of speech synthesizers, braille displays, and the like. For cases like ASCII art, it is likely that an alternative presentation, such as a textual description, would be more universally accessible to the readers of the document.

To represent a block of computer code, the pre element can be used with a code element; to represent a block of computer output the pre element can be used with a samp element. Similarly, the kbd element can be used within a pre element to indicate text that the user is to enter.

This element has rendering requirements involving the bidirectional algorithm.

In the following snippet, a sample of computer code is presented.

<p>This is the <code>Panel</code> constructor:</p>
<pre><code>function Panel(element, canClose, closeHandler) {
  this.element = element;
  this.canClose = canClose;
  this.closeHandler = function () { if (closeHandler) closeHandler() };
}</code></pre>
In the following snippet, samp and kbd elements are mixed in the contents of a pre element to show a session of Zork I.

<pre><samp>You are in an open field west of a big white house with a boarded
front door.
There is a small mailbox here.

></samp> <kbd>open mailbox</kbd>

<samp>Opening the mailbox reveals:
A leaflet.

></samp></pre>
The following shows a contemporary poem that uses the pre element to preserve its unusual formatting, which forms an intrinsic part of the poem itself.

<pre>                maxling

it is with a          heart
               heavy

that i admit loss of a feline
        so           loved

a friend lost to the
        unknown
                                (night)

~cdr 11dec07</pre>
4.4.4 The blockquote element
Categories:
Flow content.
Sectioning root.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
cite — Link to the source of the quotation or more information about the edit
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLQuoteElement : HTMLElement {
  [CEReactions] attribute USVString cite;
};
The HTMLQuoteElement interface is also used by the q element.

The blockquote element represents a section that is quoted from another source.

Content inside a blockquote must be quoted from another source, whose address, if it has one, may be cited in the cite attribute.

If the cite attribute is present, it must be a valid URL potentially surrounded by spaces. To obtain the corresponding citation link, the value of the attribute must be parsed relative to the element's node document. User agents may allow users to follow such citation links, but they are primarily intended for private use (e.g., by server-side scripts collecting statistics about a site's use of quotations), not for readers.

The content of a blockquote may be abbreviated or may have context added in the conventional manner for the text's language.

For example, in English this is traditionally done using square brackets. Consider a page with the sentence "Jane ate the cracker. She then said she liked apples and fish."; it could be quoted as follows:

<blockquote>
 <p>[Jane] then said she liked [...] fish.</p>
</blockquote>
Attribution for the quotation, if any, must be placed outside the blockquote element.

For example, here the attribution is given in a paragraph after the quote:

<blockquote>
 <p>I contend that we are both atheists. I just believe in one fewer
 god than you do. When you understand why you dismiss all the other
 possible gods, you will understand why I dismiss yours.</p>
</blockquote>
<p>— Stephen Roberts</p>
The other examples below show other ways of showing attribution.

The cite IDL attribute must reflect the element's cite content attribute.

Here a blockquote element is used in conjunction with a figure element and its figcaption to clearly relate a quote to its attribution (which is not part of the quote and therefore doesn't belong inside the blockquote itself):

<figure>
 <blockquote>
  <p>The truth may be puzzling. It may take some work to grapple with.
  It may be counterintuitive. It may contradict deeply held
  prejudices. It may not be consonant with what we desperately want to
  be true. But our preferences do not determine what's true. We have a
  method, and that method helps us to reach not absolute truth, only
  asymptotic approaches to the truth — never there, just closer
  and closer, always finding vast new oceans of undiscovered
  possibilities. Cleverly designed experiments are the key.</p>
 </blockquote>
 <figcaption>Carl Sagan, in "<cite>Wonder and Skepticism</cite>", from
 the <cite>Skeptical Inquirer</cite> Volume 19, Issue 1 (January-February
 1995)</figcaption>
</figure>
This next example shows the use of cite alongside blockquote:

<p>His next piece was the aptly named <cite>Sonnet 130</cite>:</p>
<blockquote cite="https://quotes.example.org/s/sonnet130.html">
  <p>My mistress' eyes are nothing like the sun,<br>
  Coral is far more red, than her lips red,<br>
  ...
This example shows how a forum post could use blockquote to show what post a user is replying to. The article element is used for each post, to mark up the threading.

<article>
 <h1><a href="https://bacon.example.com/?blog=109431">Bacon on a crowbar</a></h1>
 <article>
  <header><strong>t3yw</strong> 12 points 1 hour ago</header>
  <p>I bet a narwhal would love that.</p>
  <footer><a href="?pid=29578">permalink</a></footer>
  <article>
   <header><strong>greg</strong> 8 points 1 hour ago</header>
   <blockquote><p>I bet a narwhal would love that.</p></blockquote>
   <p>Dude narwhals don't eat bacon.</p>
   <footer><a href="?pid=29579">permalink</a></footer>
   <article>
    <header><strong>t3yw</strong> 15 points 1 hour ago</header>
    <blockquote>
     <blockquote><p>I bet a narwhal would love that.</p></blockquote>
     <p>Dude narwhals don't eat bacon.</p>
    </blockquote>
    <p>Next thing you'll be saying they don't get capes and wizard
    hats either!</p>
    <footer><a href="?pid=29580">permalink</a></footer>
    <article>
     <article>
      <header><strong>boing</strong> -5 points 1 hour ago</header>
      <p>narwhals are worse than ceiling cat</p>
      <footer><a href="?pid=29581">permalink</a></footer>
     </article>
    </article>
   </article>
  </article>
  <article>
   <header><strong>fred</strong> 1 points 23 minutes ago</header>
   <blockquote><p>I bet a narwhal would love that.</p></blockquote>
   <p>I bet they'd love to peel a banana too.</p>
   <footer><a href="?pid=29582">permalink</a></footer>
  </article>
 </article>
</article>
This example shows the use of a blockquote for short snippets, demonstrating that one does not have to use p elements inside blockquote elements:

<p>He began his list of "lessons" with the following:</p>
<blockquote>One should never assume that his side of
the issue will be recognized, let alone that it will
be conceded to have merits.</blockquote>
<p>He continued with a number of similar points, ending with:</p>
<blockquote>Finally, one should be prepared for the threat
of breakdown in negotiations at any given moment and not
be cowed by the possibility.</blockquote>
<p>We shall now discuss these points...
Examples of how to represent a conversation are shown in a later section; it is not appropriate to use the cite and blockquote elements for this purpose.

4.4.5 The ol element
Categories:
Flow content.
If the element's children include at least one li element: Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Zero or more li and script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
reversed — Number the list backwards
start — Starting value of the list
type — Kind of list marker
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLOListElement : HTMLElement {
  [CEReactions] attribute boolean reversed;
  [CEReactions] attribute long start;
  [CEReactions] attribute DOMString type;

  // also has obsolete members
};
The ol element represents a list of items, where the items have been intentionally ordered, such that changing the order would change the meaning of the document.

The items of the list are the li element child nodes of the ol element, in tree order.

The reversed attribute is a boolean attribute. If present, it indicates that the list is a descending list (..., 3, 2, 1). If the attribute is omitted, the list is an ascending list (1, 2, 3, ...).


Support: ol-reversed
Chrome for Android	64+
Chrome	20+
iOS Safari	6.0+
UC Browser for Android	11.8+
Firefox	18+
Samsung Internet	4+
IE	None
Opera Mini	all+
Safari	6.1+
Edge	None
Android Browser	4.4+
Opera	12.1+

Source: caniuse.com

The start attribute, if present, must be a valid integer. It is used to determine the starting value of the list.

An ol element has a starting value, which is an integer determined as follows:

If the ol element has a start attribute, then:

Let parsed be the result of parsing the value of the attribute as an integer.

If parsed is not an error, then return parsed.

If the ol element has a reversed attribute, then return the number of owned li elements.

Return 1.

The type attribute can be used to specify the kind of marker to use in the list, in the cases where that matters (e.g. because items are to be referenced by their number/letter). The attribute, if specified, must have a value that is a case-sensitive match for one of the characters given in the first cell of one of the rows of the following table. The type attribute represents the state given in the cell in the second column of the row whose first cell matches the attribute's value; if none of the cells match, or if the attribute is omitted, then the attribute represents the decimal state.

Keyword	State	Description	Examples for values 1-3 and 3999-4001
1 (U+0031)	decimal	Decimal numbers	1.	2.	3.	...	3999.	4000.	4001.	...
a (U+0061)	lower-alpha	Lowercase latin alphabet	a.	b.	c.	...	ewu.	ewv.	eww.	...
A (U+0041)	upper-alpha	Uppercase latin alphabet	A.	B.	C.	...	EWU.	EWV.	EWW.	...
i (U+0069)	lower-roman	Lowercase roman numerals	i.	ii.	iii.	...	mmmcmxcix.	i̅v̅.	i̅v̅i.	...
I (U+0049)	upper-roman	Uppercase roman numerals	I.	II.	III.	...	MMMCMXCIX.	I̅V̅.	I̅V̅I.	...
User agents should render the items of the list in a manner consistent with the state of the type attribute of the ol element. Numbers less than or equal to zero should always use the decimal system regardless of the type attribute.

For CSS user agents, a mapping for this attribute to the 'list-style-type' CSS property is given in the rendering section (the mapping is straightforward: the states above have the same names as their corresponding CSS values).

It is possible to redefine the default CSS list styles used to implement this attribute in CSS user agents; doing so will affect how list items are rendered.

The reversed and type IDL attributes must reflect the respective content attributes of the same name.

The start IDL attribute must reflect the content attribute of the same name, with a default value of 1.

This means that the start IDL attribute does not necessarily match the list's starting value, in cases where the start content attribute is omitted and the reversed content attribute is specified.

The following markup shows a list where the order matters, and where the ol element is therefore appropriate. Compare this list to the equivalent list in the ul section to see an example of the same items using the ul element.

<p>I have lived in the following countries (given in the order of when
I first lived there):</p>
<ol>
 <li>Switzerland
 <li>United Kingdom
 <li>United States
 <li>Norway
</ol>
Note how changing the order of the list changes the meaning of the document. In the following example, changing the relative order of the first two items has changed the birthplace of the author:

<p>I have lived in the following countries (given in the order of when
I first lived there):</p>
<ol>
 <li>United Kingdom
 <li>Switzerland
 <li>United States
 <li>Norway
</ol>
4.4.6 The ul element
Categories:
Flow content.
If the element's children include at least one li element: Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Zero or more li and script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLUListElement : HTMLElement {
  // also has obsolete members
};
The ul element represents a list of items, where the order of the items is not important — that is, where changing the order would not materially change the meaning of the document.

The items of the list are the li element child nodes of the ul element.

The following markup shows a list where the order does not matter, and where the ul element is therefore appropriate. Compare this list to the equivalent list in the ol section to see an example of the same items using the ol element.

<p>I have lived in the following countries:</p>
<ul>
 <li>Norway
 <li>Switzerland
 <li>United Kingdom
 <li>United States
</ul>
Note that changing the order of the list does not change the meaning of the document. The items in the snippet above are given in alphabetical order, but in the snippet below they are given in order of the size of their current account balance in 2007, without changing the meaning of the document whatsoever:

<p>I have lived in the following countries:</p>
<ul>
 <li>Switzerland
 <li>Norway
 <li>United Kingdom
 <li>United States
</ul>
4.4.7 The menu element
Categories:
Flow content.
If the element's children include at least one li element: Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Zero or more li and script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLMenuElement : HTMLElement {

  // also has obsolete members
};
The menu element represents a toolbar consisting of its contents, in the form of an unordered list of items (represented by li elements), each of which represents a command that the user can perform or activate.

The menu element is simply a semantic alternative to ul to express an unordered list of commands (a "toolbar").

In this example, a text-editing application uses a menu element to provide a series of editing commands:

<menu>
 <li><button onclick="copy()"><img src="copy.svg" alt="Copy"></button></li>
 <li><button onclick="cut()"><img src="cut.svg" alt="Cut"></button></li>
 <li><button onclick="paste()"><img src="paste.svg" alt="Paste"></button></li>
</menu>
Note that the styling to make this look like a conventional toolbar menu is up to the application.

4.4.8 The li element
Categories:
None.
Contexts in which this element can be used:
Inside ol elements.
Inside ul elements.
Inside menu elements.
Content model:
Flow content.
Tag omission in text/html:
An li element's end tag can be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
Content attributes:
Global attributes
If the element is not a child of an ul or menu element: value — Ordinal value of the list item
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLLIElement : HTMLElement {
  [CEReactions] attribute long value;

  // also has obsolete members
};
The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.

The value attribute, if present, must be a valid integer. It is used to determine the ordinal value of the list item, when the li's list owner is an ol element.

Any element whose computed value of 'display' is 'list-item' has a list owner, which is determined as follows:

If the element is not being rendered, return null; the element has no list owner.

Let ancestor be the element's parent.

If the element has an ol, ul, or menu ancestor, set ancestor to the closest such ancestor element.

Return the closest inclusive ancestor of ancestor that produces a CSS box.

Such an element will always exist, as at the very least the document element will always produce a CSS box.

To determine the ordinal value of each element owned by a given list owner owner, perform the following steps:

Let i be 1.

If owner is an ol element, let numbering be owner's starting value. Otherwise, let numbering be 1.

Loop: If i is greater than the number of list items that owner owns, then return; all of owner's owned list items have been assigned ordinal values.

Let item be the ith of owner's owned list items, in tree order.

If item is an li element that has a value attribute, then:

Let parsed be the result of parsing the value of the attribute as an integer.

If parsed is not an error, then set numbering to parsed.

The ordinal value of item is numbering.

If owner is an ol element, and owner has a reversed attribute, decrement numbering by 1; otherwise, increment numbering by 1.

Increment i by 1.

Go to the step labeled loop.

The value IDL attribute must reflect the value of the value content attribute.

The element's value IDL attribute does not directly correspond to its ordinal value; it simply reflects the content attribute. For example, given this list:

<ol>
 <li>Item 1
 <li value="3">Item 3
 <li>Item 4
</ol>
The ordinal values are 1, 3, and 4, whereas the value IDL attributes return 0, 3, 0 on getting.

The following example, the top ten movies are listed (in reverse order). Note the way the list is given a title by using a figure element and its figcaption element.

<figure>
 <figcaption>The top 10 movies of all time</figcaption>
 <ol>
  <li value="10"><cite>Josie and the Pussycats</cite>, 2001</li>
  <li value="9"><cite lang="sh">Црна мачка, бели мачор</cite>, 1998</li>
  <li value="8"><cite>A Bug's Life</cite>, 1998</li>
  <li value="7"><cite>Toy Story</cite>, 1995</li>
  <li value="6"><cite>Monsters, Inc</cite>, 2001</li>
  <li value="5"><cite>Cars</cite>, 2006</li>
  <li value="4"><cite>Toy Story 2</cite>, 1999</li>
  <li value="3"><cite>Finding Nemo</cite>, 2003</li>
  <li value="2"><cite>The Incredibles</cite>, 2004</li>
  <li value="1"><cite>Ratatouille</cite>, 2007</li>
 </ol>
</figure>
The markup could also be written as follows, using the reversed attribute on the ol element:

<figure>
 <figcaption>The top 10 movies of all time</figcaption>
 <ol reversed>
  <li><cite>Josie and the Pussycats</cite>, 2001</li>
  <li><cite lang="sh">Црна мачка, бели мачор</cite>, 1998</li>
  <li><cite>A Bug's Life</cite>, 1998</li>
  <li><cite>Toy Story</cite>, 1995</li>
  <li><cite>Monsters, Inc</cite>, 2001</li>
  <li><cite>Cars</cite>, 2006</li>
  <li><cite>Toy Story 2</cite>, 1999</li>
  <li><cite>Finding Nemo</cite>, 2003</li>
  <li><cite>The Incredibles</cite>, 2004</li>
  <li><cite>Ratatouille</cite>, 2007</li>
 </ol>
</figure>
While it is conforming to include heading elements (e.g. h1) inside li elements, it likely does not convey the semantics that the author intended. A heading starts a new section, so a heading in a list implicitly splits the list into spanning multiple sections.

4.4.9 The dl element
Categories:
Flow content.
If the element's children include at least one name-value group: Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.
Or: One or more div elements, optionally intermixed with script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDListElement : HTMLElement {
  // also has obsolete members
};
The dl element represents an association list consisting of zero or more name-value groups (a description list). A name-value group consists of one or more names (dt elements, possibly as children of a div element child) followed by one or more values (dd elements, possibly as children of a div element child), ignoring any nodes other than dt and dd element children, and dt and dd elements that are children of div element children. Within a single dl element, there should not be more than one dt element for each name.

Name-value groups may be terms and definitions, metadata topics and values, questions and answers, or any other groups of name-value data.

The values within a group are alternatives; multiple paragraphs forming part of the same value must all be given within the same dd element.

The order of the list of groups, and of the names and values within each group, may be significant.

In order to annotate groups with microdata attributes, or other global attributes that apply to whole groups, or just for styling purposes, each group in a dl element can be wrapped in a div element. This does not change the semantics of the dl element.

The name-value groups of a dl element dl are determined using the following algorithm. A name-value group has a name (a list of dt elements, initially empty) and a value (a list of dd elements, initially empty).

Let groups be an empty list of name-value groups.

Let current be a new name-value group.

Let seenDd be false.

Let child be dl's first child.

Let grandchild be null.

While child is not null:

If child is a div element, then:

Let grandchild be child's first child.

While grandchild is not null:

Process dt or dd for grandchild.

Set grandchild to grandchild's next sibling.

Otherwise, process dt or dd for child.

Set child to child's next sibling.

If current is not empty, then append current to groups.

Return groups.

To process dt or dd for a node node means to follow these steps:

Let groups, current, and seenDd be the same variables as those of the same name in the algorithm that invoked these steps.

If node is a dt element, then:

If seenDd is true, then append current to groups, set current to a new name-value group, and set seenDd to false.

Append node to current's name.

Otherwise, if node is a dd element, then append node to current's value and set seenDd to true.

When a name-value group has an empty list as name or value, it is often due to accidentally using dd elements in the place of dt elements and vice versa. Conformance checkers can spot such mistakes and might be able to advise authors how to correctly use the markup.

In the following example, one entry ("Authors") is linked to two values ("John" and "Luke").

<dl>
 <dt> Authors
 <dd> John
 <dd> Luke
 <dt> Editor
 <dd> Frank
</dl>
In the following example, one definition is linked to two terms.

<dl>
 <dt lang="en-US"> <dfn>color</dfn> </dt>
 <dt lang="en-GB"> <dfn>colour</dfn> </dt>
 <dd> A sensation which (in humans) derives from the ability of
 the fine structure of the eye to distinguish three differently
 filtered analyses of a view. </dd>
</dl>
The following example illustrates the use of the dl element to mark up metadata of sorts. At the end of the example, one group has two metadata labels ("Authors" and "Editors") and two values ("Robert Rothman" and "Daniel Jackson"). This example also uses the div element around the groups of dt and dd element, to aid with styling.

<dl>
 <div>
  <dt> Last modified time </dt>
  <dd> 2004-12-23T23:33Z </dd>
 </div>
 <div>
  <dt> Recommended update interval </dt>
  <dd> 60s </dd>
 </div>
 <div>
  <dt> Authors </dt>
  <dt> Editors </dt>
  <dd> Robert Rothman </dd>
  <dd> Daniel Jackson </dd>
 </div>
</dl>
The following example shows the dl element used to give a set of instructions. The order of the instructions here is important (in the other examples, the order of the blocks was not important).

<p>Determine the victory points as follows (use the
first matching case):</p>
<dl>
 <dt> If you have exactly five gold coins </dt>
 <dd> You get five victory points </dd>
 <dt> If you have one or more gold coins, and you have one or more silver coins </dt>
 <dd> You get two victory points </dd>
 <dt> If you have one or more silver coins </dt>
 <dd> You get one victory point </dd>
 <dt> Otherwise </dt>
 <dd> You get no victory points </dd>
</dl>
The following snippet shows a dl element being used as a glossary. Note the use of dfn to indicate the word being defined.

<dl>
 <dt><dfn>Apartment</dfn>, n.</dt>
 <dd>An execution context grouping one or more threads with one or
 more COM objects.</dd>
 <dt><dfn>Flat</dfn>, n.</dt>
 <dd>A deflated tire.</dd>
 <dt><dfn>Home</dfn>, n.</dt>
 <dd>The user's login directory.</dd>
</dl>
This example uses microdata attributes in a dl element, together with the div element, to annotate the ice cream desserts at a French restaurant.

<dl>
 <div itemscope itemtype="http://schema.org/Product">
  <dt itemprop="name">Café ou Chocolat Liégeois
  <dd itemprop="offers" itemscope itemtype="http://schema.org/Offer">
   <span itemprop="price">3.50</span>
   <data itemprop="priceCurrency" value="EUR">€</data>
  <dd itemprop="description">
   2 boules Café ou Chocolat, 1 boule Vanille, sause café ou chocolat, chantilly
 </div>

 <div itemscope itemtype="http://schema.org/Product">
  <dt itemprop="name">Américaine
  <dd itemprop="offers" itemscope itemtype="http://schema.org/Offer">
   <span itemprop="price">3.50</span>
   <data itemprop="priceCurrency" value="EUR">€</data>
  <dd itemprop="description">
   1 boule Crème brûlée, 1 boule Vanille, 1 boule Caramel, chantilly
 </div>
</dl>
Without the div element the markup would need to use the itemref attribute to link the data in the dd elements with the item, as follows.

<dl>
 <dt itemscope itemtype="http://schema.org/Product" itemref="1-offer 1-description">
  <span itemprop="name">Café ou Chocolat Liégeois</span>
 <dd id="1-offer" itemprop="offers" itemscope itemtype="http://schema.org/Offer">
  <span itemprop="price">3.50</span>
  <data itemprop="priceCurrency" value="EUR">€</data>
 <dd id="1-description" itemprop="description">
  2 boules Café ou Chocolat, 1 boule Vanille, sause café ou chocolat, chantilly

 <dt itemscope itemtype="http://schema.org/Product" itemref="2-offer 2-description">
  <span itemprop="name">Américaine</span>
 <dd id="2-offer" itemprop="offers" itemscope itemtype="http://schema.org/Offer">
  <span itemprop="price">3.50</span>
  <data itemprop="priceCurrency" value="EUR">€</data>
 <dd id="2-description" itemprop="description">
  1 boule Crème brûlée, 1 boule Vanille, 1 boule Caramel, chantilly
</dl>
The dl element is inappropriate for marking up dialogue. See some examples of how to mark up dialogue.

4.4.10 The dt element
Categories:
None.
Contexts in which this element can be used:
Before dd or dt elements inside dl elements.
Before dd or dt elements inside div elements that are children of a dl element.
Content model:
Flow content, but with no header, footer, sectioning content, or heading content descendants.
Tag omission in text/html:
A dt element's end tag can be omitted if the dt element is immediately followed by another dt element or a dd element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The dt element represents the term, or name, part of a term-description group in a description list (dl element).

The dt element itself, when used in a dl element, does not indicate that its contents are a term being defined, but this can be indicated using the dfn element.

This example shows a list of frequently asked questions (a FAQ) marked up using the dt element for questions and the dd element for answers.

<article>
 <h1>FAQ</h1>
 <dl>
  <dt>What do we want?</dt>
  <dd>Our data.</dd>
  <dt>When do we want it?</dt>
  <dd>Now.</dd>
  <dt>Where is it?</dt>
  <dd>We are not sure.</dd>
 </dl>
</article>
4.4.11 The dd element
Categories:
None.
Contexts in which this element can be used:
After dt or dd elements inside dl elements.
After dt or dd elements inside div elements that are children of a dl element.
Content model:
Flow content.
Tag omission in text/html:
A dd element's end tag can be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The dd element represents the description, definition, or value, part of a term-description group in a description list (dl element).

A dl can be used to define a vocabulary list, like in a dictionary. In the following example, each entry, given by a dt with a dfn, has several dds, showing the various parts of the definition.

<dl>
 <dt><dfn>happiness</dfn></dt>
 <dd class="pronunciation">/'hæ p. nes/</dd>
 <dd class="part-of-speech"><i><abbr>n.</abbr></i></dd>
 <dd>The state of being happy.</dd>
 <dd>Good fortune; success. <q>Oh <b>happiness</b>! It worked!</q></dd>
 <dt><dfn>rejoice</dfn></dt>
 <dd class="pronunciation">/ri jois'/</dd>
 <dd><i class="part-of-speech"><abbr>v.intr.</abbr></i> To be delighted oneself.</dd>
 <dd><i class="part-of-speech"><abbr>v.tr.</abbr></i> To cause one to be delighted.</dd>
</dl>
4.4.12 The figure element
Categories:
Flow content.
Sectioning root.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Either: one figcaption element followed by flow content.
Or: flow content followed by one figcaption element.
Or: flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The figure element represents some flow content, optionally with a caption, that is self-contained (like a complete sentence) and is typically referenced as a single unit from the main flow of the document.

"Self-contained" in this context does not necessarily mean independent. For example, each sentence in a paragraph is self-contained; an image that is part of a sentence would be inappropriate for figure, but an entire sentence made of images would be fitting.

The element can thus be used to annotate illustrations, diagrams, photos, code listings, etc.

When a figure is referred to from the main content of the document by identifying it by its caption (e.g., by figure number), it enables such content to be easily moved away from that primary content, e.g., to the side of the page, to dedicated pages, or to an appendix, without affecting the flow of the document.

If a figure element is referenced by its relative position, e.g., "in the photograph above" or "as the next figure shows", then moving the figure would disrupt the page's meaning. Authors are encouraged to consider using labels to refer to figures, rather than using such relative references, so that the page can easily be restyled without affecting the page's meaning.

The first figcaption element child of the element, if any, represents the caption of the figure element's contents. If there is no child figcaption element, then there is no caption.

A figure element's contents are part of the surrounding flow. If the purpose of the page is to display the figure, for example a photograph on an image sharing site, the figure and figcaption elements can be used to explicitly provide a caption for that figure. For content that is only tangentially related, or that serves a separate purpose than the surrounding flow, the aside element should be used (and can itself wrap a figure). For example, a pull quote that repeats content from an article would be more appropriate in an aside than in a figure, because it isn't part of the content, it's a repetition of the content for the purposes of enticing readers or highlighting key topics.

This example shows the figure element to mark up a code listing.

<p>In <a href="#l4">listing 4</a> we see the primary core interface
API declaration.</p>
<figure id="l4">
 <figcaption>Listing 4. The primary core interface API declaration.</figcaption>
 <pre><code>interface PrimaryCore {
 boolean verifyDataLine();
 void sendData(in sequence&lt;byte> data);
 void initSelfDestruct();
}</code></pre>
</figure>
<p>The API is designed to use UTF-8.</p>
Here we see a figure element to mark up a photo that is the main content of the page (as in a gallery).

<!DOCTYPE HTML>
<html lang="en">
<title>Bubbles at work — My Gallery™</title>
<figure>
 <img src="bubbles-work.jpeg"
      alt="Bubbles, sitting in his office chair, works on his
           latest project intently.">
 <figcaption>Bubbles at work</figcaption>
</figure>
<nav><a href="19414.html">Prev</a> — <a href="19416.html">Next</a></nav>
In this example, we see an image that is not a figure, as well as an image and a video that are. The first image is literally part of the example's second sentence, so it's not a self-contained unit, and thus figure would be inappropriate.

<h2>Malinko's comics</h2>

<p>This case centered on some sort of "intellectual property"
infringement related to a comic (see Exhibit A). The suit started
after a trailer ending with these words:

<blockquote>
 <img src="promblem-packed-action.png" alt="ROUGH COPY! Promblem-Packed Action!">
</blockquote>

<p>...was aired. A lawyer, armed with a Bigger Notebook, launched a
preemptive strike using snowballs. A complete copy of the trailer is
included with Exhibit B.

<figure>
 <img src="ex-a.png" alt="Two squiggles on a dirty piece of paper.">
 <figcaption>Exhibit A. The alleged <cite>rough copy</cite> comic.</figcaption>
</figure>

<figure>
 <video src="ex-b.mov"></video>
 <figcaption>Exhibit B. The <cite>Rough Copy</cite> trailer.</figcaption>
</figure>

<p>The case was resolved out of court.
Here, a part of a poem is marked up using figure.

<figure>
 <p>'Twas brillig, and the slithy toves<br>
 Did gyre and gimble in the wabe;<br>
 All mimsy were the borogoves,<br>
 And the mome raths outgrabe.</p>
 <figcaption><cite>Jabberwocky</cite> (first verse). Lewis Carroll, 1832-98</figcaption>
</figure>
In this example, which could be part of a much larger work discussing a castle, nested figure elements are used to provide both a group caption and individual captions for each figure in the group:

<figure>
 <figcaption>The castle through the ages: 1423, 1858, and 1999 respectively.</figcaption>
 <figure>
  <figcaption>Etching. Anonymous, ca. 1423.</figcaption>
  <img src="castle1423.jpeg" alt="The castle has one tower, and a tall wall around it.">
 </figure>
 <figure>
  <figcaption>Oil-based paint on canvas. Maria Towle, 1858.</figcaption>
  <img src="castle1858.jpeg" alt="The castle now has two towers and two walls.">
 </figure>
 <figure>
  <figcaption>Film photograph. Peter Jankle, 1999.</figcaption>
  <img src="castle1999.jpeg" alt="The castle lies in ruins, the original tower all that remains in one piece.">
 </figure>
</figure>
The previous example could also be more succinctly written as follows (using title attributes in place of the nested figure/figcaption pairs):

<figure>
 <img src="castle1423.jpeg" title="Etching. Anonymous, ca. 1423."
      alt="The castle has one tower, and a tall wall around it.">
 <img src="castle1858.jpeg" title="Oil-based paint on canvas. Maria Towle, 1858."
      alt="The castle now has two towers and two walls.">
 <img src="castle1999.jpeg" title="Film photograph. Peter Jankle, 1999."
      alt="The castle lies in ruins, the original tower all that remains in one piece.">
 <figcaption>The castle through the ages: 1423, 1858, and 1999 respectively.</figcaption>
</figure>
The figure is sometimes referenced only implicitly from the content:

<article>
 <h1>Fiscal negotiations stumble in Congress as deadline nears</h1>
 <figure>
  <img src="obama-reid.jpeg" alt="Obama and Reid sit together smiling in the Oval Office.">
  <figcaption>Barack Obama and Harry Reid. White House press photograph.</figcaption>
 </figure>
 <p>Negotiations in Congress to end the fiscal impasse sputtered on Tuesday, leaving both chambers
 grasping for a way to reopen the government and raise the country's borrowing authority with a
 Thursday deadline drawing near.</p>
 ...
</article>
4.4.13 The figcaption element
Categories:
None.
Contexts in which this element can be used:
As the first or last child of a figure element.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The figcaption element represents a caption or legend for the rest of the contents of the figcaption element's parent figure element, if any.

The element can contain additional information about the source:

<figcaption>
 <p>A duck.</p>
 <p><small>Photograph courtesy of 🌟 News.</small></p>
</figcaption>
<figcaption>
 <p>Average rent for 3-room apartments, excluding non-profit apartments</p>
 <p>Zürich’s Statistics Office — <time datetime=2017-11-14>14 November 2017</time></p>
</figcaption>
4.4.14 The main element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected, but only if it is a hierarchically correct main element.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The main element represents the dominant contents of the document.

A document must not have more than one main element that does not have the hidden attribute specified.

A hierarchically correct main element is one whose ancestor elements are limited to html, body, div, form without an accessible name, and autonomous custom elements. Each main element must be a hierarchically correct main element.

In this example, the author has used a presentation where each component of the page is rendered in a box. To wrap the main content of the page (as opposed to the header, the footer, the navigation bar, and a sidebar), the main element is used.

<!DOCTYPE html>
<html lang="en">
<title>RPG System 17</title>
<style>
 header, nav, aside, main, footer {
   margin: 0.5em; border: thin solid; padding: 0.5em;
   background: #EFF; color: black; box-shadow: 0 0 0.25em #033;
 }
 h1, h2, p { margin: 0; }
 nav, main { float: left; }
 aside { float: right; }
 footer { clear: both; }
</style>
<header>
 <h1>System Eighteen</h1>
</header>
<nav>
 <a href="../16/">← System 17</a>
 <a href="../18/">RPXIX →</a>
</nav>
<aside>
 <p>This system has no HP mechanic, so there's no healing.
</aside>
<main>
 <h2>Character creation</h2>
 <p>Attributes (magic, strength, agility) are purchased at the cost of one point per level.</p>
 <h2>Rolls</h2>
 <p>Each encounter, roll the dice for all your skills. If you roll more than the opponent, you win.</p>
</main>
<footer>
 <p>Copyright © 2013
</footer>
</html>
In the following example, multiple main elements are used and script is used to make navigation work without a server roundtrip and to set the hidden attribute on those that are not current:

<!doctype html>
<html lang=en-CA>
<meta charset=utf-8>
<title> … </title>
<link rel=stylesheet href=spa.css>
<script src=spa.js async></script>
<nav>
 <a href=/>Home</a>
 <a href=/about>About</a>
 <a href=/contact>Contact</a>
</nav>
<main>
 <h1>Home</h1>
 …
</main>
<main hidden>
 <h1>About</h1>
 …
</main>
<main hidden>
 <h1>Contact</h1>
 …
</main>
<footer>Made with ❤️ by <a href=https://example.com/>Example 👻</a>.</footer>
4.4.15 The div element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
As a child of a dl element.
Content model:
If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.
If the element is not a child of a dl element: flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDivElement : HTMLElement {
  // also has obsolete members
};
The div element has no special meaning at all. It represents its children. It can be used with the class, lang, and title attributes to mark up semantics common to a group of consecutive elements. It can also be used in a dl element, wrapping groups of dt and dd elements.

Authors are strongly encouraged to view the div element as an element of last resort, for when no other element is suitable. Use of more appropriate elements instead of the div element leads to better accessibility for readers and easier maintainability for authors.

For example, a blog post would be marked up using article, a chapter using section, a page's navigation aids using nav, and a group of form controls using fieldset.

On the other hand, div elements can be useful for stylistic purposes or to wrap multiple paragraphs within a section that are all to be annotated in a similar way. In the following example, we see div elements used as a way to set the language of two paragraphs at once, instead of setting the language on the two paragraph elements separately:

<article lang="en-US">
 <h1>My use of language and my cats</h1>
 <p>My cat's behavior hasn't changed much since her absence, except
 that she plays her new physique to the neighbors regularly, in an
 attempt to get pets.</p>
 <div lang="en-GB">
  <p>My other cat, coloured black and white, is a sweetie. He followed
  us to the pool today, walking down the pavement with us. Yesterday
  he apparently visited our neighbours. I wonder if he recognises that
  their flat is a mirror image of ours.</p>
  <p>Hm, I just noticed that in the last paragraph I used British
  English. But I'm supposed to write in American English. So I
  shouldn't say "pavement" or "flat" or "colour"...</p>
 </div>
 <p>I should say "sidewalk" and "apartment" and "color"!</p>
</article>
4.5 Text-level semantics
4.5.1 The a element
Categories:
Flow content.
Phrasing content.
If the element has an href attribute: Interactive content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent, but there must be no interactive content or a element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
href — Address of the hyperlink
target — Browsing context for hyperlink navigation
download — Whether to download the resource instead of navigating to it, and its file name if so
ping — URLs to ping
rel — Relationship between the location in the document containing the hyperlink and the destination resource
hreflang — Language of the linked resource
type — Hint for the type of the referenced resource
referrerpolicy — Referrer policy for fetches initiated by the element
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLAnchorElement : HTMLElement {
  [CEReactions] attribute DOMString target;
  [CEReactions] attribute DOMString download;
  [CEReactions] attribute USVString ping;
  [CEReactions] attribute DOMString rel;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList relList;
  [CEReactions] attribute DOMString hreflang;
  [CEReactions] attribute DOMString type;

  [CEReactions] attribute DOMString text;

  [CEReactions] attribute DOMString referrerPolicy;

  // also has obsolete members
};
HTMLAnchorElement includes HTMLHyperlinkElementUtils;
If the a element has an href attribute, then it represents a hyperlink (a hypertext anchor) labeled by its contents.

If the a element has no href attribute, then the element represents a placeholder for where a link might otherwise have been placed, if it had been relevant, consisting of just the element's contents.

The target, download, ping, rel, hreflang, type, and referrerpolicy attributes must be omitted if the href attribute is not present.

If the itemprop attribute is specified on an a element, then the href attribute must also be specified.

If a site uses a consistent navigation toolbar on every page, then the link that would normally link to the page itself could be marked up using an a element:

<nav>
 <ul>
  <li> <a href="/">Home</a> </li>
  <li> <a href="/news">News</a> </li>
  <li> <a>Examples</a> </li>
  <li> <a href="/legal">Legal</a> </li>
 </ul>
</nav>
The href, target, download, ping, and referrerpolicy attributes affect what happens when users follow hyperlinks or download hyperlinks created using the a element. The rel, hreflang, and type attributes may be used to indicate to the user the likely nature of the target resource before the user follows the link.

The activation behavior of a elements that create hyperlinks is to run the following steps:

If the target of the click event is an img element with an ismap attribute specified, then server-side image map processing must be performed, as follows:

Let x and y be zero.
If the click event was a real pointing-device-triggered click event on the img element, then set x to the distance in CSS pixels from the left edge of the image to the location of the click, and set y to the distance in CSS pixels from the top edge of the image to the location of the click.
If x is negative, set x to zero.
If y is negative, set y to zero.
Let hyperlink suffix be a U+003F QUESTION MARK character, the value of x expressed as a base-ten integer using ASCII digits, a U+002C COMMA character (,), and the value of y expressed as a base-ten integer using ASCII digits.
Follow the hyperlink or download the hyperlink created by the a element, as determined by the download attribute and any expressed user preference, passing hyperlink suffix, if the steps above defined it.

a . text
Same as textContent.

The IDL attributes download, ping, target, rel, hreflang, and type, must reflect the respective content attributes of the same name.

The IDL attribute relList must reflect the rel content attribute.


Support: rellist
Chrome for Android (limited)	64+
Chrome	65+
iOS Safari	9.0+
UC Browser for Android (limited)	11.8+
Firefox	30+
Samsung Internet (limited)	5+
IE	None
Opera Mini	None
Safari	9+
Edge (limited)	17+
Android Browser (limited)	62+
Opera	52+

Source: caniuse.com

The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.

The text IDL attribute, on getting, must return the same value as the textContent IDL attribute on the element, and on setting, must act as if the textContent IDL attribute on the element had been set to the new value.

The a element may be wrapped around entire paragraphs, lists, tables, and so forth, even entire sections, so long as there is no interactive content within (e.g. buttons or other links). This example shows how this can be used to make an entire advertising block into a link:

<aside class="advertising">
 <h1>Advertising</h1>
 <a href="https://ad.example.com/?adid=1929&amp;pubid=1422">
  <section>
   <h1>Mellblomatic 9000!</h1>
   <p>Turn all your widgets into mellbloms!</p>
   <p>Only $9.99 plus shipping and handling.</p>
  </section>
 </a>
 <a href="https://ad.example.com/?adid=375&amp;pubid=1422">
  <section>
   <h1>The Mellblom Browser</h1>
   <p>Web browsing at the speed of light.</p>
   <p>No other browser goes faster!</p>
  </section>
 </a>
</aside>
4.5.2 The em element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The em element represents stress emphasis of its contents.

The level of stress that a particular piece of content has is given by its number of ancestor em elements.

The placement of stress emphasis changes the meaning of the sentence. The element thus forms an integral part of the content. The precise way in which stress is used in this way depends on the language.

These examples show how changing the stress emphasis changes the meaning. First, a general statement of fact, with no stress:

<p>Cats are cute animals.</p>
By emphasizing the first word, the statement implies that the kind of animal under discussion is in question (maybe someone is asserting that dogs are cute):

<p><em>Cats</em> are cute animals.</p>
Moving the stress to the verb, one highlights that the truth of the entire sentence is in question (maybe someone is saying cats are not cute):

<p>Cats <em>are</em> cute animals.</p>
By moving it to the adjective, the exact nature of the cats is reasserted (maybe someone suggested cats were mean animals):

<p>Cats are <em>cute</em> animals.</p>
Similarly, if someone asserted that cats were vegetables, someone correcting this might emphasize the last word:

<p>Cats are cute <em>animals</em>.</p>
By emphasizing the entire sentence, it becomes clear that the speaker is fighting hard to get the point across. This kind of stress emphasis also typically affects the punctuation, hence the exclamation mark here.

<p><em>Cats are cute animals!</em></p>
Anger mixed with emphasizing the cuteness could lead to markup such as:

<p><em>Cats are <em>cute</em> animals!</em></p>
The em element isn't a generic "italics" element. Sometimes, text is intended to stand out from the rest of the paragraph, as if it was in a different mood or voice. For this, the i element is more appropriate.

The em element also isn't intended to convey importance; for that purpose, the strong element is more appropriate.

4.5.3 The strong element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The strong element represents strong importance, seriousness, or urgency for its contents.

Importance: the strong element can be used in a heading, caption, or paragraph to distinguish the part that really matters from other parts that might be more detailed, more jovial, or merely boilerplate. (This is distinct from marking up subheadings, for which the hgroup element is appropriate.)

For example, the first word of the previous paragraph is marked up with strong to distinguish it from the more detailed text in the rest of the paragraph.

Seriousness: the strong element can be used to mark up a warning or caution notice.

Urgency: the strong element can be used to denote contents that the user needs to see sooner than other parts of the document.

The relative level of importance of a piece of content is given by its number of ancestor strong elements; each strong element increases the importance of its contents.

Changing the importance of a piece of text with the strong element does not change the meaning of the sentence.

Here, the word "chapter" and the actual chapter number are mere boilerplate, and the actual name of the chapter is marked up with strong:

<h1>Chapter 1: <strong>The Praxis</strong></h1>
In the following example, the name of the diagram in the caption is marked up with strong, to distinguish it from boilerplate text (before) and the description (after):

<figcaption>Figure 1. <strong>Ant colony dynamics</strong>. The ants in this colony are
affected by the heat source (upper left) and the food source (lower right).</figcaption>
In this example, the heading is really "Flowers, Bees, and Honey", but the author has added a light-hearted addition to the heading. The strong element is thus used to mark up the first part to distinguish it from the latter part.

<h1><strong>Flowers, Bees, and Honey</strong> and other things I don't understand</h1>
Here is an example of a warning notice in a game, with the various parts marked up according to how important they are:

<p><strong>Warning.</strong> This dungeon is dangerous.
<strong>Avoid the ducks.</strong> Take any gold you find.
<strong><strong>Do not take any of the diamonds</strong>,
they are explosive and <strong>will destroy anything within
ten meters.</strong></strong> You have been warned.</p>
In this example, the strong element is used to denote the part of the text that the user is intended to read first.

<p>Welcome to Remy, the reminder system.</p>
<p>Your tasks for today:</p>
<ul>
 <li><p><strong>Turn off the oven.</strong></p></li>
 <li><p>Put out the trash.</p></li>
 <li><p>Do the laundry.</p></li>
</ul>
4.5.4 The small element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The small element represents side comments such as small print.

Small print typically features disclaimers, caveats, legal restrictions, or copyrights. Small print is also sometimes used for attribution, or for satisfying licensing requirements.

The small element does not "de-emphasize" or lower the importance of text emphasized by the em element or marked as important with the strong element. To mark text as not emphasized or important, simply do not mark it up with the em or strong elements respectively.

The small element should not be used for extended spans of text, such as multiple paragraphs, lists, or sections of text. It is only intended for short runs of text. The text of a page listing terms of use, for instance, would not be a suitable candidate for the small element: in such a case, the text is not a side comment, it is the main content of the page.

The small element must not be used for subheadings; for that purpose, use the hgroup element.

In this example, the small element is used to indicate that value-added tax is not included in a price of a hotel room:

<dl>
 <dt>Single room
 <dd>199 € <small>breakfast included, VAT not included</small>
 <dt>Double room
 <dd>239 € <small>breakfast included, VAT not included</small>
</dl>
In this second example, the small element is used for a side comment in an article.

<p>Example Corp today announced record profits for the
second quarter <small>(Full Disclosure: Foo News is a subsidiary of
Example Corp)</small>, leading to speculation about a third quarter
merger with Demo Group.</p>
This is distinct from a sidebar, which might be multiple paragraphs long and is removed from the main flow of text. In the following example, we see a sidebar from the same article. This sidebar also has small print, indicating the source of the information in the sidebar.

<aside>
 <h1>Example Corp</h1>
 <p>This company mostly creates small software and Web
 sites.</p>
 <p>The Example Corp company mission is "To provide entertainment
 and news on a sample basis".</p>
 <p><small>Information obtained from <a
 href="https://example.com/about.html">example.com</a> home
 page.</small></p>
</aside>
In this last example, the small element is marked as being important small print.

<p><strong><small>Continued use of this service will result in a kiss.</small></strong></p>
4.5.5 The s element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The s element represents contents that are no longer accurate or no longer relevant.

The s element is not appropriate when indicating document edits; to mark a span of text as having been removed from a document, use the del element.

In this example a recommended retail price has been marked as no longer relevant as the product in question has a new sale price.

<p>Buy our Iced Tea and Lemonade!</p>
<p><s>Recommended retail price: $3.99 per bottle</s></p>
<p><strong>Now selling for just $2.99 a bottle!</strong></p>
4.5.6 The cite element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The cite element represents the title of a work (e.g. a book, a paper, an essay, a poem, a score, a song, a script, a film, a TV show, a game, a sculpture, a painting, a theatre production, a play, an opera, a musical, an exhibition, a legal case report, a computer program, etc). This can be a work that is being quoted or referenced in detail (i.e. a citation), or it can just be a work that is mentioned in passing.

A person's name is not the title of a work — even if people call that person a piece of work — and the element must therefore not be used to mark up people's names. (In some cases, the b element might be appropriate for names; e.g. in a gossip article where the names of famous people are keywords rendered with a different style to draw attention to them. In other cases, if an element is really needed, the span element can be used.)

This next example shows a typical use of the cite element:

<p>My favorite book is <cite>The Reality Dysfunction</cite> by
Peter F. Hamilton. My favorite comic is <cite>Pearls Before
Swine</cite> by Stephan Pastis. My favorite track is <cite>Jive
Samba</cite> by the Cannonball Adderley Sextet.</p>
This is correct usage:

<p>According to the Wikipedia article <cite>HTML</cite>, as it
stood in mid-February 2008, leaving attribute values unquoted is
unsafe. This is obviously an over-simplification.</p>
The following, however, is incorrect usage, as the cite element here is containing far more than the title of the work:

<!-- do not copy this example, it is an example of bad usage! -->
<p>According to <cite>the Wikipedia article on HTML</cite>, as it
stood in mid-February 2008, leaving attribute values unquoted is
unsafe. This is obviously an over-simplification.</p>
The cite element is obviously a key part of any citation in a bibliography, but it is only used to mark the title:

<p><cite>Universal Declaration of Human Rights</cite>, United Nations,
December 1948. Adopted by General Assembly resolution 217 A (III).</p>
A citation is not a quote (for which the q element is appropriate).

This is incorrect usage, because cite is not for quotes:

<p><cite>This is wrong!</cite>, said Ian.</p>
This is also incorrect usage, because a person is not a work:

<p><q>This is still wrong!</q>, said <cite>Ian</cite>.</p>
The correct usage does not use a cite element:

<p><q>This is correct</q>, said Ian.</p>
As mentioned above, the b element might be relevant for marking names as being keywords in certain kinds of documents:

<p>And then <b>Ian</b> said <q>this might be right, in a
gossip column, maybe!</q>.</p>
4.5.7 The q element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
cite — Link to the source of the quotation or more information about the edit
DOM interface:
Uses HTMLQuoteElement.
The q element represents some phrasing content quoted from another source.

Quotation punctuation (such as quotation marks) that is quoting the contents of the element must not appear immediately before, after, or inside q elements; they will be inserted into the rendering by the user agent.

Content inside a q element must be quoted from another source, whose address, if it has one, may be cited in the cite attribute. The source may be fictional, as when quoting characters in a novel or screenplay.

If the cite attribute is present, it must be a valid URL potentially surrounded by spaces. To obtain the corresponding citation link, the value of the attribute must be parsed relative to the element's node document. User agents may allow users to follow such citation links, but they are primarily intended for private use (e.g., by server-side scripts collecting statistics about a site's use of quotations), not for readers.

The q element must not be used in place of quotation marks that do not represent quotes; for example, it is inappropriate to use the q element for marking up sarcastic statements.

The use of q elements to mark up quotations is entirely optional; using explicit quotation punctuation without q elements is just as correct.

Here is a simple example of the use of the q element:

<p>The man said <q>Things that are impossible just take
longer</q>. I disagreed with him.</p>
Here is an example with both an explicit citation link in the q element, and an explicit citation outside:

<p>The W3C page <cite>About W3C</cite> says the W3C's
mission is <q cite="https://www.w3.org/Consortium/">To lead the
World Wide Web to its full potential by developing protocols and
guidelines that ensure long-term growth for the Web</q>. I
disagree with this mission.</p>
In the following example, the quotation itself contains a quotation:

<p>In <cite>Example One</cite>, he writes <q>The man
said <q>Things that are impossible just take longer</q>. I
disagreed with him</q>. Well, I disagree even more!</p>
In the following example, quotation marks are used instead of the q element:

<p>His best argument was ❝I disagree❞, which
I thought was laughable.</p>
In the following example, there is no quote — the quotation marks are used to name a word. Use of the q element in this case would be inappropriate.

<p>The word "ineffable" could have been used to describe the disaster
resulting from the campaign's mismanagement.</p>
4.5.8 The dfn element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content, but there must be no dfn element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
Also, the title attribute has special semantics on this element: Full term or expansion of abbreviation.
DOM interface:
Uses HTMLElement.
The dfn element represents the defining instance of a term. The paragraph, description list group, or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element.

Defining term: if the dfn element has a title attribute, then the exact value of that attribute is the term being defined. Otherwise, if it contains exactly one element child node and no child Text nodes, and that child element is an abbr element with a title attribute, then the exact value of that attribute is the term being defined. Otherwise, it is the exact textContent of the dfn element that gives the term being defined.

If the title attribute of the dfn element is present, then it must contain only the term being defined.

The title attribute of ancestor elements does not affect dfn elements.

An a element that links to a dfn element represents an instance of the term defined by the dfn element.

In the following fragment, the term "Garage Door Opener" is first defined in the first paragraph, then used in the second. In both cases, its abbreviation is what is actually displayed.

<p>The <dfn><abbr title="Garage Door Opener">GDO</abbr></dfn>
is a device that allows off-world teams to open the iris.</p>
<!-- ... later in the document: -->
<p>Teal'c activated his <abbr title="Garage Door Opener">GDO</abbr>
and so Hammond ordered the iris to be opened.</p>
With the addition of an a element, the reference can be made explicit:

<p>The <dfn id=gdo><abbr title="Garage Door Opener">GDO</abbr></dfn>
is a device that allows off-world teams to open the iris.</p>
<!-- ... later in the document: -->
<p>Teal'c activated his <a href=#gdo><abbr title="Garage Door Opener">GDO</abbr></a>
and so Hammond ordered the iris to be opened.</p>
4.5.9 The abbr element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
Also, the title attribute has special semantics on this element: Full term or expansion of abbreviation.
DOM interface:
Uses HTMLElement.
The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else.

The paragraph below contains an abbreviation marked up with the abbr element. This paragraph defines the term "Web Hypertext Application Technology Working Group".

<p>The <dfn id=whatwg><abbr
title="Web Hypertext Application Technology Working Group">WHATWG</abbr></dfn>
is a loose unofficial collaboration of Web browser manufacturers and
interested parties who wish to develop new technologies designed to
allow authors to write and deploy Applications over the World Wide
Web.</p>
An alternative way to write this would be:

<p>The <dfn id=whatwg>Web Hypertext Application Technology
Working Group</dfn> (<abbr
title="Web Hypertext Application Technology Working Group">WHATWG</abbr>)
is a loose unofficial collaboration of Web browser manufacturers and
interested parties who wish to develop new technologies designed to
allow authors to write and deploy Applications over the World Wide
Web.</p>
This paragraph has two abbreviations. Notice how only one is defined; the other, with no expansion associated with it, does not use the abbr element.

<p>The
<abbr title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
started working on HTML5 in 2004.</p>
This paragraph links an abbreviation to its definition.

<p>The <a href="#whatwg"><abbr
title="Web Hypertext Application Technology Working Group">WHATWG</abbr></a>
community does not have much representation from Asia.</p>
This paragraph marks up an abbreviation without giving an expansion, possibly as a hook to apply styles for abbreviations (e.g. smallcaps).

<p>Philip` and Dashiva both denied that they were going to
get the issue counts from past revisions of the specification to
backfill the <abbr>WHATWG</abbr> issue graph.</p>
If an abbreviation is pluralized, the expansion's grammatical number (plural vs singular) must match the grammatical number of the contents of the element.

Here the plural is outside the element, so the expansion is in the singular:

<p>Two <abbr title="Working Group">WG</abbr>s worked on
this specification: the <abbr>WHATWG</abbr> and the
<abbr>HTMLWG</abbr>.</p>
Here the plural is inside the element, so the expansion is in the plural:

<p>Two <abbr title="Working Groups">WGs</abbr> worked on
this specification: the <abbr>WHATWG</abbr> and the
<abbr>HTMLWG</abbr>.</p>
Abbreviations do not have to be marked up using this element. It is expected to be useful in the following cases:

Abbreviations for which the author wants to give expansions, where using the abbr element with a title attribute is an alternative to including the expansion inline (e.g. in parentheses).
Abbreviations that are likely to be unfamiliar to the document's readers, for which authors are encouraged to either mark up the abbreviation using an abbr element with a title attribute or include the expansion inline in the text the first time the abbreviation is used.
Abbreviations whose presence needs to be semantically annotated, e.g. so that they can be identified from a style sheet and given specific styles, for which the abbr element can be used without a title attribute.
Providing an expansion in a title attribute once will not necessarily cause other abbr elements in the same document with the same contents but without a title attribute to behave as if they had the same expansion. Every abbr element is independent.

4.5.10 The ruby element

Support: ruby
Chrome for Android (limited)	64+
Chrome (limited)	5+
iOS Safari (limited)	5.0+
UC Browser for Android (limited)	11.8+
Firefox	38+
Samsung Internet (limited)	4+
IE (limited)	5.5+
Safari (limited)	5+
Edge (limited)	12+
Android Browser (limited)	3+
Opera (limited)	15+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
See prose.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.

The content model of ruby elements consists of one or more of the following sequences:

One or the other of the following:
Phrasing content, but with no ruby elements and with no ruby element descendants
A single ruby element that itself has no ruby element descendants
One or the other of the following:
One or more rt elements
An rp element followed by one or more rt elements, each of which is itself followed by an rp element
The ruby and rt elements can be used for a variety of kinds of annotations, including in particular (though by no means limited to) those described below. For more details on Japanese Ruby in particular, and how to render Ruby for Japanese, see Requirements for Japanese Text Layout. [JLREQ]

At the time of writing, CSS does not yet provide a way to fully control the rendering of the HTML ruby element. It is hoped that CSS will be extended to support the styles described below in due course.

Mono-ruby for individual base characters in Japanese
One or more hiragana or katakana characters (the ruby annotation) are placed with each ideographic character (the base text). This is used to provide readings of kanji characters.

<ruby>B<rt>annotation</ruby>
In this example, notice how each annotation corresponds to a single base character.

<ruby>君<rt>くん</ruby><ruby>子<rt>し</ruby>は<ruby>和<rt>わ</ruby>して<ruby>同<rt>どう</ruby>ぜず。
君くん子しは和わして同どうぜず。

This example can also be written as follows, using one ruby element with two segments of base text and two annotations (one for each) rather than two back-to-back ruby elements each with one base text segment and annotation (as in the markup above):

<ruby>君<rt>くん</rt>子<rt>し</ruby>は<ruby>和<rt>わ</ruby>して<ruby>同<rt>どう</ruby>ぜず。
Mono-ruby for compound words (jukugo)
This is similar to the previous case: each ideographic character in the compound word (the base text) has its reading given in hiragana or katakana characters (the ruby annotation). The difference is that the base text segments form a compound word rather than being separate from each other.

<ruby>B<rt>annotation</rt>B<rt>annotation</ruby>
In this example, notice again how each annotation corresponds to a single base character. In this example, each compound word (jukugo) corresponds to a single ruby element.

The rendering here is expected to be that each annotation be placed over (or next to, in vertical text) the corresponding base character, with the annotations not overhanging any of the adjacent characters.

<ruby>鬼<rt>き</rt>門<rt>もん</rt></ruby>の<ruby>方<rt>ほう</rt>角<rt>がく</rt></ruby>を<ruby>凝<rt>ぎょう</rt>視<rt>し</rt></ruby>する
鬼き門もんの方ほう角がくを凝ぎょう視しする

Jukugo-ruby
This is semantically identical to the previous case (each individual ideographic character in the base compound word has its reading given in an annotation in hiragana or katakana characters), but the rendering is the more complicated Jukugo Ruby rendering.

This is the same example as above for mono-ruby for compound words. The different rendering is expected to be achieved using different styling (e.g. in CSS), and is not shown here.

<ruby>鬼<rt>き</rt>門<rt>もん</rt></ruby>の<ruby>方<rt>ほう</rt>角<rt>がく</rt></ruby>を<ruby>凝<rt>ぎょう</rt>視<rt>し</rt></ruby>する
For more details on Jukugo Ruby rendering, see Appendix F in the Requirements for Japanese Text Layout. [JLREQ]

Group ruby for describing meanings
The annotation describes the meaning of the base text, rather than (or in addition to) the pronunciation. As such, both the base text and the annotation can be multiple characters long.

<ruby>BASE<rt>annotation</ruby>
Here a compound ideographic word has its corresponding katakana given as an annotation.

<ruby>境界面<rt>インターフェース</ruby>
境界面インターフェース

Here a compound ideographic word has its translation in English provided as an annotation.

<ruby lang="ja">編集者<rt lang="en">editor</ruby>
編集者editor

Group ruby for Jukuji readings
A phonetic reading that corresponds to multiple base characters, because a one-to-one mapping would be difficult. (In English, the words "Colonel" and "Lieutenant" are examples of words where a direct mapping of pronunciation to individual letters is, in some dialects, rather unclear.)

In this example, the name of a species of flowers has a phonetic reading provided using group ruby:

<ruby>紫陽花<rt>あじさい</ruby>
紫陽花あじさい

Text with both phonetic and semantic annotations (double-sided ruby)
Sometimes, ruby styles described above are combined.

If this results in two annotations covering the same single base segment, then the annotations can just be placed back to back.

<ruby>BASE<rt>annotation 1<rt>annotation 2</ruby>
<ruby>B<rt>a<rt>a</ruby><ruby>A<rt>a<rt>a</ruby><ruby>S<rt>a<rt>a</ruby><ruby>E<rt>a<rt>a</ruby>
In this contrived example, some symbols are given names in English and French.

<ruby>
 ♥ <rt> Heart <rt lang=fr> Cœur </rt>
 ☘ <rt> Shamrock <rt lang=fr> Trèfle </rt>
 ✶ <rt> Star <rt lang=fr> Étoile </rt>
</ruby>
In more complication situations such as following examples, a nested ruby element is used to give the inner annotations, and then that whole ruby is then given an annotation at the "outer" level.

<ruby><ruby>B<rt>a</rt>A<rt>n</rt>S<rt>t</rt>E<rt>n</rt></ruby><rt>annotation</ruby>
Here both a phonetic reading and the meaning are given in ruby annotations. The annotation on the nested ruby element gives a mono-ruby phonetic annotation for each base character, while the annotation in the rt element that is a child of the outer ruby element gives the meaning using hiragana.

<ruby><ruby>東<rt>とう</rt>南<rt>なん</rt></ruby><rt>たつみ</rt></ruby>の方角
東とう南なんたつみの方角

This is the same example, but the meaning is given in English instead of Japanese:

<ruby><ruby>東<rt>とう</rt>南<rt>なん</rt></ruby><rt lang=en>Southeast</rt></ruby>の方角
東とう南なんSoutheastの方角

Within a ruby element that does not have a ruby element ancestor, content is segmented and segments are placed into three categories: base text segments, annotation segments, and ignored segments. Ignored segments do not form part of the document's semantics (they consist of some inter-element whitespace and rp elements, the latter of which are used for legacy user agents that do not support ruby at all). Base text segments can overlap (with a limit of two segments overlapping any one position in the DOM, and with any segment having an earlier start point than an overlapping segment also having an equal or later end point, and any segment have a later end point than an overlapping segment also having an equal or earlier start point). Annotation segments correspond to rt elements. Each annotation segment can be associated with a base text segment, and each base text segment can have annotation segments associated with it. (In a conforming document, each base text segment is associated with at least one annotation segment, and each annotation segment is associated with one base text segment.) A ruby element represents the union of the segments of base text it contains, along with the mapping from those base text segments to annotation segments. Segments are described in terms of DOM ranges; annotation segment ranges always consist of exactly one element. [DOM]

At any particular time, the segmentation and categorization of content of a ruby element is the result that would be obtained from running the following algorithm:

Let base text segments be an empty list of base text segments, each potentially with a list of base text subsegments.

Let annotation segments be an empty list of annotation segments, each potentially being associated with a base text segment or subsegment.

Let root be the ruby element for which the algorithm is being run.

If root has a ruby element ancestor, then jump to the step labeled end.

Let current parent be root.

Let index be 0.

Let start index be null.

Let parent start index be null.

Let current base text be null.

Start mode: If index is equal to or greater than the number of child nodes in current parent, then jump to the step labeled end mode.

If the indexth node in current parent is an rt or rp element, jump to the step labeled annotation mode.

Set start index to the value of index.

Base mode: If the indexth node in current parent is a ruby element, and if current parent is the same element as root, then push a ruby level and then jump to the step labeled start mode.

If the indexth node in current parent is an rt or rp element, then set the current base text and then jump to the step labeled annotation mode.

Increment index by one.

Base mode post-increment: If index is equal to or greater than the number of child nodes in current parent, then jump to the step labeled end mode.

Jump back to the step labeled base mode.

Annotation mode: If the indexth node in current parent is an rt element, then push a ruby annotation and jump to the step labeled annotation mode increment.

If the indexth node in current parent is an rp element, jump to the step labeled annotation mode increment.

If the indexth node in current parent is not a Text node, or is a Text node that is not inter-element whitespace, then jump to the step labeled base mode.

Annotation mode increment: Let lookahead index be index plus one.

Annotation mode white-space skipper: If lookahead index is equal to the number of child nodes in current parent then jump to the step labeled end mode.

If the lookahead indexth node in current parent is an rt element or an rp element, then set index to lookahead index and jump to the step labeled annotation mode.

If the lookahead indexth node in current parent is not a Text node, or is a Text node that is not inter-element whitespace, then jump to the step labeled base mode (without further incrementing index, so the inter-element whitespace seen so far becomes part of the next base text segment).

Increment lookahead index by one.

Jump to the step labeled annotation mode white-space skipper.

End mode: If current parent is not the same element as root, then pop a ruby level and jump to the step labeled base mode post-increment.

End: Return base text segments and annotation segments. Any content of the ruby element not described by segments in either of those lists is implicitly in an ignored segment.

When the steps above say to set the current base text, it means to run the following steps at that point in the algorithm:

Let text range be a DOM range whose start is the boundary point (current parent, start index) and whose end is the boundary point (current parent, index).

Let new text segment be a base text segment described by the range annotation range.

Add new text segment to base text segments.

Let current base text be new text segment.

Let start index be null.

When the steps above say to push a ruby level, it means to run the following steps at that point in the algorithm:

Let current parent be the indexth node in current parent.

Let index be 0.

Set saved start index to the value of start index.

Let start index be null.

When the steps above say to pop a ruby level, it means to run the following steps at that point in the algorithm:

Let index be the position of current parent in root.

Let current parent be root.

Increment index by one.

Set start index to the value of saved start index.

Let saved start index be null.

When the steps above say to push a ruby annotation, it means to run the following steps at that point in the algorithm:

Let rt be the rt element that is the indexth node of current parent.

Let annotation range be a DOM range whose start is the boundary point (current parent, index) and whose end is the boundary point (current parent, index plus one) (i.e. that contains only rt).

Let new annotation segment be an annotation segment described by the range annotation range.

If current base text is not null, associate new annotation segment with current base text.

Add new annotation segment to annotation segments.

In this example, each ideograph in the Japanese text 漢字 is annotated with its reading in hiragana.

...
<ruby>漢<rt>かん</rt>字<rt>じ</rt></ruby>
...
This might be rendered as:



In this example, each ideograph in the traditional Chinese text 漢字 is annotated with its bopomofo reading.

<ruby>漢<rt>ㄏㄢˋ</rt>字<rt>ㄗˋ</rt></ruby>
This might be rendered as:



In this example, each ideograph in the simplified Chinese text 汉字 is annotated with its pinyin reading.

...<ruby>汉<rt>hàn</rt>字<rt>zì</rt></ruby>...
This might be rendered as:



In this more contrived example, the acronym "HTML" has four annotations: one for the whole acronym, briefly describing what it is, one for the letters "HT" expanding them to "Hypertext", one for the letter "M" expanding it to "Markup", and one for the letter "L" expanding it to "Language".

<ruby>
 <ruby>HT<rt>Hypertext</rt>M<rt>Markup</rt>L<rt>Language</rt></ruby>
 <rt>An abstract language for describing documents and applications
</ruby>
4.5.11 The rt element
Categories:
None.
Contexts in which this element can be used:
As a child of a ruby element.
Content model:
Phrasing content.
Tag omission in text/html:
An rt element's end tag can be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The rt element marks the ruby text component of a ruby annotation. When it is the child of a ruby element, it doesn't represent anything itself, but the ruby element uses it as part of determining what it represents.

An rt element that is not a child of a ruby element represents the same thing as its children.

4.5.12 The rp element
Categories:
None.
Contexts in which this element can be used:
As a child of a ruby element, either immediately before or immediately after an rt element.
Content model:
Text.
Tag omission in text/html:
An rp element's end tag can be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The rp element can be used to provide parentheses or other content around a ruby text component of a ruby annotation, to be shown by user agents that don't support ruby annotations.

An rp element that is a child of a ruby element represents nothing. An rp element whose parent element is not a ruby element represents its children.

The example above, in which each ideograph in the text 漢字 is annotated with its phonetic reading, could be expanded to use rp so that in legacy user agents the readings are in parentheses:

...
<ruby>漢<rp>（</rp><rt>かん</rt><rp>）</rp>字<rp>（</rp><rt>じ</rt><rp>）</rp></ruby>
...
In conforming user agents the rendering would be as above, but in user agents that do not support ruby, the rendering would be:

... 漢（かん）字（じ）...
When there are multiple annotations for a segment, rp elements can also be placed between the annotations. Here is another copy of an earlier contrived example showing some symbols with names given in English and French, but this time with rp elements as well:

<ruby>
♥<rp>: </rp><rt>Heart</rt><rp>, </rp><rt lang=fr>Cœur</rt><rp>.</rp>
☘<rp>: </rp><rt>Shamrock</rt><rp>, </rp><rt lang=fr>Trèfle</rt><rp>.</rp>
✶<rp>: </rp><rt>Star</rt><rp>, </rp><rt lang=fr>Étoile</rt><rp>.</rp>
</ruby>
This would make the example render as follows in non-ruby-capable user agents:

♥: Heart, Cœur. ☘: Shamrock, Trèfle. ✶: Star, Étoile.
4.5.13 The data element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
value — Machine-readable value
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDataElement : HTMLElement {
  [CEReactions] attribute DOMString value;
};
The data element represents its contents, along with a machine-readable form of those contents in the value attribute.

The value attribute must be present. Its value must be a representation of the element's contents in a machine-readable format.

When the value is date- or time-related, the more specific time element can be used instead.

The element can be used for several purposes.

When combined with microformats or the microdata attributes defined in this specification, the element serves to provide both a machine-readable value for the purposes of data processors, and a human-readable value for the purposes of rendering in a Web browser. In this case, the format to be used in the value attribute is determined by the microformats or microdata vocabulary in use.

The element can also, however, be used in conjunction with scripts in the page, for when a script has a literal value to store alongside a human-readable value. In such cases, the format to be used depends only on the needs of the script. (The data-* attributes can also be useful in such situations.)

The value IDL attribute must reflect the content attribute of the same name.

Here, a short table has its numeric values encoded using the data element so that the table sorting JavaScript library can provide a sorting mechanism on each column despite the numbers being presented in textual form in one column and in a decomposed form in another.

<script src="sortable.js"></script>
<table class="sortable">
 <thead> <tr> <th> Game <th> Corporations <th> Map Size
 <tbody>
  <tr> <td> 1830 <td> <data value="8">Eight</data> <td> <data value="93">19+74 hexes (93 total)</data>
  <tr> <td> 1856 <td> <data value="11">Eleven</data> <td> <data value="99">12+87 hexes (99 total)</data>
  <tr> <td> 1870 <td> <data value="10">Ten</data> <td> <data value="149">4+145 hexes (149 total)</data>
</table>
4.5.14 The time element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
If the element has a datetime attribute: Phrasing content.
Otherwise: Text, but must match requirements described in prose below.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
datetime — Machine-readable value
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTimeElement : HTMLElement {
  [CEReactions] attribute DOMString dateTime;
};
The time element represents its contents, along with a machine-readable form of those contents in the datetime attribute. The kind of content is limited to various kinds of dates, times, time-zone offsets, and durations, as described below.

The datetime attribute may be present. If present, its value must be a representation of the element's contents in a machine-readable format.

A time element that does not have a datetime content attribute must not have any element descendants.

The datetime value of a time element is the value of the element's datetime content attribute, if it has one, otherwise the child text content of the time element.

The datetime value of a time element must match one of the following syntaxes.

A valid month string
<time>2011-11</time>
A valid date string
<time>2011-11-18</time>
A valid yearless date string
<time>11-18</time>
A valid time string
<time>14:54</time>
<time>14:54:39</time>
<time>14:54:39.929</time>
A valid local date and time string
<time>2011-11-18T14:54</time>
<time>2011-11-18T14:54:39</time>
<time>2011-11-18T14:54:39.929</time>
<time>2011-11-18 14:54</time>
<time>2011-11-18 14:54:39</time>
<time>2011-11-18 14:54:39.929</time>
Times with dates but without a time zone offset are useful for specifying events that are observed at the same specific time in each time zone, throughout a day. For example, the 2020 new year is celebrated at 2020-01-01 00:00 in each time zone, not at the same precise moment across all time zones. For events that occur at the same time across all time zones, for example a videoconference meeting, a valid global date and time string is likely more useful.

A valid time-zone offset string
<time>Z</time>
<time>+0000</time>
<time>+00:00</time>
<time>-0800</time>
<time>-08:00</time>
For times without dates (or times referring to events that recur on multiple dates), specifying the geographic location that controls the time is usually more useful than specifying a time zone offset, because geographic locations change time zone offsets with daylight saving time. In some cases, geographic locations even change time zone, e.g. when the boundaries of those time zones are redrawn, as happened with Samoa at the end of 2011. There exists a time zone database that describes the boundaries of time zones and what rules apply within each such zone, known as the time zone database. [TZDATABASE]

A valid global date and time string
<time>2011-11-18T14:54Z</time>
<time>2011-11-18T14:54:39Z</time>
<time>2011-11-18T14:54:39.929Z</time>
<time>2011-11-18T14:54+0000</time>
<time>2011-11-18T14:54:39+0000</time>
<time>2011-11-18T14:54:39.929+0000</time>
<time>2011-11-18T14:54+00:00</time>
<time>2011-11-18T14:54:39+00:00</time>
<time>2011-11-18T14:54:39.929+00:00</time>
<time>2011-11-18T06:54-0800</time>
<time>2011-11-18T06:54:39-0800</time>
<time>2011-11-18T06:54:39.929-0800</time>
<time>2011-11-18T06:54-08:00</time>
<time>2011-11-18T06:54:39-08:00</time>
<time>2011-11-18T06:54:39.929-08:00</time>
<time>2011-11-18 14:54Z</time>
<time>2011-11-18 14:54:39Z</time>
<time>2011-11-18 14:54:39.929Z</time>
<time>2011-11-18 14:54+0000</time>
<time>2011-11-18 14:54:39+0000</time>
<time>2011-11-18 14:54:39.929+0000</time>
<time>2011-11-18 14:54+00:00</time>
<time>2011-11-18 14:54:39+00:00</time>
<time>2011-11-18 14:54:39.929+00:00</time>
<time>2011-11-18 06:54-0800</time>
<time>2011-11-18 06:54:39-0800</time>
<time>2011-11-18 06:54:39.929-0800</time>
<time>2011-11-18 06:54-08:00</time>
<time>2011-11-18 06:54:39-08:00</time>
<time>2011-11-18 06:54:39.929-08:00</time>
Times with dates and a time zone offset are useful for specifying specific events, or recurring virtual events where the time is not anchored to a specific geographic location. For example, the precise time of an asteroid impact, or a particular meeting in a series of meetings held at 1400 UTC every day, regardless of whether any particular part of the world is observing daylight saving time or not. For events where the precise time varies by the local time zone offset of a specific geographic location, a valid local date and time string combined with that geographic location is likely more useful.

A valid week string
<time>2011-W47</time>
Four or more ASCII digits, at least one of which is not U+0030 DIGIT ZERO (0)
<time>2011</time>
<time>0001</time>
A valid duration string
<time>PT4H18M3S</time>
<time>4h 18m 3s</time>
The machine-readable equivalent of the element's contents must be obtained from the element's datetime value by using the following algorithm:

If parsing a month string from the element's datetime value returns a month, that is the machine-readable equivalent; return.

If parsing a date string from the element's datetime value returns a date, that is the machine-readable equivalent; return.

If parsing a yearless date string from the element's datetime value returns a yearless date, that is the machine-readable equivalent; return.

If parsing a time string from the element's datetime value returns a time, that is the machine-readable equivalent; return.

If parsing a local date and time string from the element's datetime value returns a local date and time, that is the machine-readable equivalent; return.

If parsing a time-zone offset string from the element's datetime value returns a time-zone offset, that is the machine-readable equivalent; return.

If parsing a global date and time string from the element's datetime value returns a global date and time, that is the machine-readable equivalent; return.

If parsing a week string from the element's datetime value returns a week, that is the machine-readable equivalent; return.

If the element's datetime value consists of only ASCII digits, at least one of which is not U+0030 DIGIT ZERO (0), then the machine-readable equivalent is the base-ten interpretation of those digits, representing a year; return.

If parsing a duration string from the element's datetime value returns a duration, that is the machine-readable equivalent; return.

There is no machine-readable equivalent.

The algorithms referenced above are intended to be designed such that for any arbitrary string s, only one of the algorithms returns a value. A more efficient approach might be to create a single algorithm that parses all these data types in one pass; developing such an algorithm is left as an exercise to the reader.

The dateTime IDL attribute must reflect the element's datetime content attribute.

The time element can be used to encode dates, for example in microformats. The following shows a hypothetical way of encoding an event using a variant on hCalendar that uses the time element:

<div class="vevent">
 <a class="url" href="http://www.web2con.com/">http://www.web2con.com/</a>
 <span class="summary">Web 2.0 Conference</span>:
 <time class="dtstart" datetime="2005-10-05">October 5</time> -
 <time class="dtend" datetime="2005-10-07">7</time>,
 at the <span class="location">Argent Hotel, San Francisco, CA</span>
</div>
Here, a fictional microdata vocabulary based on the Atom vocabulary is used with the time element to mark up a blog post's publication date.

<article itemscope itemtype="https://n.example.org/rfc4287">
 <h1 itemprop="title">Big tasks</h1>
 <footer>Published <time itemprop="published" datetime="2009-08-29">two days ago</time>.</footer>
 <p itemprop="content">Today, I went out and bought a bike for my kid.</p>
</article>
In this example, another article's publication date is marked up using time, this time using the schema.org microdata vocabulary:

<article itemscope itemtype="http://schema.org/BlogPosting">
 <h1 itemprop="headline">Small tasks</h1>
 <footer>Published <time itemprop="datePublished" datetime="2009-08-30">yesterday</time>.</footer>
 <p itemprop="articleBody">I put a bike bell on her bike.</p>
</article>
In the following snippet, the time element is used to encode a date in the ISO8601 format, for later processing by a script:

<p>Our first date was <time datetime="2006-09-23">a Saturday</time>.</p>
In this second snippet, the value includes a time:

<p>We stopped talking at <time datetime="2006-09-24T05:00-07:00">5am the next morning</time>.</p>
A script loaded by the page (and thus privy to the page's internal convention of marking up dates and times using the time element) could scan through the page and look at all the time elements therein to create an index of dates and times.

For example, this element conveys the string "Friday" with the additional semantic that the 18th of November 2011 is the meaning that corresponds to "Friday":

Today is <time datetime="2011-11-18">Friday</time>.
In this example, a specific time in the Pacific Standard Time timezone is specified:

Your next meeting is at <time datetime="2011-11-18T15:00-08:00">3pm</time>.
4.5.15 The code element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The code element represents a fragment of computer code. This could be an XML element name, a file name, a computer program, or any other string that a computer would recognize.

There is no formal way to indicate the language of computer code being marked up. Authors who wish to mark code elements with the language used, e.g. so that syntax highlighting scripts can use the right rules, can use the class attribute, e.g. by adding a class prefixed with "language-" to the element.

The following example shows how the element can be used in a paragraph to mark up element names and computer code, including punctuation.

<p>The <code>code</code> element represents a fragment of computer
code.</p>

<p>When you call the <code>activate()</code> method on the
<code>robotSnowman</code> object, the eyes glow.</p>

<p>The example below uses the <code>begin</code> keyword to indicate
the start of a statement block. It is paired with an <code>end</code>
keyword, which is followed by the <code>.</code> punctuation character
(full stop) to indicate the end of the program.</p>
The following example shows how a block of code could be marked up using the pre and code elements.

<pre><code class="language-pascal">var i: Integer;
begin
   i := 1;
end.</code></pre>
A class is used in that example to indicate the language used.

See the pre element for more details.

4.5.16 The var element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The var element represents a variable. This could be an actual variable in a mathematical expression or programming context, an identifier representing a constant, a symbol identifying a physical quantity, a function parameter, or just be a term used as a placeholder in prose.

In the paragraph below, the letter "n" is being used as a variable in prose:

<p>If there are <var>n</var> pipes leading to the ice
cream factory then I expect at <em>least</em> <var>n</var>
flavors of ice cream to be available for purchase!</p>
For mathematics, in particular for anything beyond the simplest of expressions, MathML is more appropriate. However, the var element can still be used to refer to specific variables that are then mentioned in MathML expressions.

In this example, an equation is shown, with a legend that references the variables in the equation. The expression itself is marked up with MathML, but the variables are mentioned in the figure's legend using var.

<figure>
 <math>
  <mi>a</mi>
  <mo>=</mo>
  <msqrt>
   <msup><mi>b</mi><mn>2</mn></msup>
   <mi>+</mi>
   <msup><mi>c</mi><mn>2</mn></msup>
  </msqrt>
 </math>
 <figcaption>
  Using Pythagoras' theorem to solve for the hypotenuse <var>a</var> of
  a triangle with sides <var>b</var> and <var>c</var>
 </figcaption>
</figure>
Here, the equation describing mass-energy equivalence is used in a sentence, and the var element is used to mark the variables and constants in that equation:

<p>Then she turned to the blackboard and picked up the chalk. After a few moment's
thought, she wrote <var>E</var> = <var>m</var> <var>c</var><sup>2</sup>. The teacher
looked pleased.</p>
4.5.17 The samp element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The samp element represents sample or quoted output from another program or computing system.

See the pre and kbd elements for more details.

This element can be contrasted with the output element, which can be used to provide immediate output in a Web application.

This example shows the samp element being used inline:

<p>The computer said <samp>Too much cheese in tray
two</samp> but I didn't know what that meant.</p>
This second example shows a block of sample output from a console program. Nested samp and kbd elements allow for the styling of specific elements of the sample output using a style sheet. There's also a few parts of the samp that are annotated with even more detailed markup, to enable very precise styling. To achieve this, span elements are used.

<pre><samp><span class="prompt">jdoe@mowmow:~$</span> <kbd>ssh demo.example.com</kbd>
Last login: Tue Apr 12 09:10:17 2005 from mowmow.example.com on pts/1
Linux demo 2.6.10-grsec+gg3+e+fhs6b+nfs+gr0501+++p3+c4a+gr2b-reslog-v6.189 #1 SMP Tue Feb 1 11:22:36 PST 2005 i686 unknown

<span class="prompt">jdoe@demo:~$</span> <span class="cursor">_</span></samp></pre>
This third example shows a block of input and its respective output. The example uses both code and samp elements.

<pre>
<code class="language-javascript">console.log(2.3 + 2.4)</code>
<samp>4.699999999999999</samp>
</pre>
4.5.18 The kbd element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The kbd element represents user input (typically keyboard input, although it may also be used to represent other input, such as voice commands).

When the kbd element is nested inside a samp element, it represents the input as it was echoed by the system.

When the kbd element contains a samp element, it represents input based on system output, for example invoking a menu item.

When the kbd element is nested inside another kbd element, it represents an actual key or other single unit of input as appropriate for the input mechanism.

Here the kbd element is used to indicate keys to press:

<p>To make George eat an apple, press <kbd><kbd>Shift</kbd>+<kbd>F3</kbd></kbd></p>
In this second example, the user is told to pick a particular menu item. The outer kbd element marks up a block of input, with the inner kbd elements representing each individual step of the input, and the samp elements inside them indicating that the steps are input based on something being displayed by the system, in this case menu labels:

<p>To make George eat an apple, select
    <kbd><kbd><samp>File</samp></kbd>|<kbd><samp>Eat Apple...</samp></kbd></kbd>
</p>
Such precision isn't necessary; the following is equally fine:

<p>To make George eat an apple, select <kbd>File | Eat Apple...</kbd></p>
4.5.19 The sub and sup elements
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Use HTMLElement.
The sup element represents a superscript and the sub element represents a subscript.

These elements must be used only to mark up typographical conventions with specific meanings, not for typographical presentation for presentation's sake. For example, it would be inappropriate for the sub and sup elements to be used in the name of the LaTeX document preparation system. In general, authors should use these elements only if the absence of those elements would change the meaning of the content.

In certain languages, superscripts are part of the typographical conventions for some abbreviations.

<p>Their names are
<span lang="fr"><abbr>M<sup>lle</sup></abbr> Gwendoline</span> and
<span lang="fr"><abbr>M<sup>me</sup></abbr> Denise</span>.</p>
The sub element can be used inside a var element, for variables that have subscripts.

Here, the sub element is used to represent the subscript that identifies the variable in a family of variables:

<p>The coordinate of the <var>i</var>th point is
(<var>x<sub><var>i</var></sub></var>, <var>y<sub><var>i</var></sub></var>).
For example, the 10th point has coordinate
(<var>x<sub>10</sub></var>, <var>y<sub>10</sub></var>).</p>
Mathematical expressions often use subscripts and superscripts. Authors are encouraged to use MathML for marking up mathematics, but authors may opt to use sub and sup if detailed mathematical markup is not desired. [MATHML]

<var>E</var>=<var>m</var><var>c</var><sup>2</sup>
f(<var>x</var>, <var>n</var>) = log<sub>4</sub><var>x</var><sup><var>n</var></sup>
4.5.20 The i element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The i element represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose in a manner indicating a different quality of text, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, transliteration, a thought, or a ship name in Western texts.

Terms in languages different from the main text should be annotated with lang attributes (or, in XML, lang attributes in the XML namespace).

The examples below show uses of the i element:

<p>The <i class="taxonomy">Felis silvestris catus</i> is cute.</p>
<p>The term <i>prose content</i> is defined above.</p>
<p>There is a certain <i lang="fr">je ne sais quoi</i> in the air.</p>
In the following example, a dream sequence is marked up using i elements.

<p>Raymond tried to sleep.</p>
<p><i>The ship sailed away on Thursday</i>, he
dreamt. <i>The ship had many people aboard, including a beautiful
princess called Carey. He watched her, day-in, day-out, hoping she
would notice him, but she never did.</i></p>
<p><i>Finally one night he picked up the courage to speak with
her—</i></p>
<p>Raymond woke with a start as the fire alarm rang out.</p>
Authors can use the class attribute on the i element to identify why the element is being used, so that if the style of a particular use (e.g. dream sequences as opposed to taxonomic terms) is to be changed at a later date, the author doesn't have to go through the entire document (or series of related documents) annotating each use.

Authors are encouraged to consider whether other elements might be more applicable than the i element, for instance the em element for marking up stress emphasis, or the dfn element to mark up the defining instance of a term.

Style sheets can be used to format i elements, just like any other element can be restyled. Thus, it is not the case that content in i elements will necessarily be italicized.

4.5.21 The b element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.

The following example shows a use of the b element to highlight key words without marking them up as important:

<p>The <b>frobonitor</b> and <b>barbinator</b> components are fried.</p>
In the following example, objects in a text adventure are highlighted as being special by use of the b element.

<p>You enter a small room. Your <b>sword</b> glows
brighter. A <b>rat</b> scurries past the corner wall.</p>
Another case where the b element is appropriate is in marking up the lede (or lead) sentence or paragraph. The following example shows how a BBC article about kittens adopting a rabbit as their own could be marked up:

<article>
 <h2>Kittens 'adopted' by pet rabbit</h2>
 <p><b class="lede">Six abandoned kittens have found an
 unexpected new mother figure — a pet rabbit.</b></p>
 <p>Veterinary nurse Melanie Humble took the three-week-old
 kittens to her Aberdeen home.</p>
[...]
As with the i element, authors can use the class attribute on the b element to identify why the element is being used, so that if the style of a particular use is to be changed at a later date, the author doesn't have to go through annotating each use.

The b element should be used as a last resort when no other element is more appropriate. In particular, headings should use the h1 to h6 elements, stress emphasis should use the em element, importance should be denoted with the strong element, and text marked or highlighted should use the mark element.

The following would be incorrect usage:

<p><b>WARNING!</b> Do not frob the barbinator!</p>
In the previous example, the correct element to use would have been strong, not b.

Style sheets can be used to format b elements, just like any other element can be restyled. Thus, it is not the case that content in b elements will necessarily be boldened.

4.5.22 The u element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The u element represents a span of text with an unarticulated, though explicitly rendered, non-textual annotation, such as labeling the text as being a proper name in Chinese text (a Chinese proper name mark), or labeling the text as being misspelt.

In most cases, another element is likely to be more appropriate: for marking stress emphasis, the em element should be used; for marking key words or phrases either the b element or the mark element should be used, depending on the context; for marking book titles, the cite element should be used; for labeling text with explicit textual annotations, the ruby element should be used; for technical terms, taxonomic designation, transliteration, a thought, or for labeling ship names in Western texts, the i element should be used.

The default rendering of the u element in visual presentations clashes with the conventional rendering of hyperlinks (underlining). Authors are encouraged to avoid using the u element where it could be confused for a hyperlink.

In this example, a u element is used to mark a word as misspelt:

<p>The <u>see</u> is full of fish.</p>
4.5.23 The mark element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity.

This example shows how the mark element can be used to bring attention to a particular part of a quotation:

<p lang="en-US">Consider the following quote:</p>
<blockquote lang="en-GB">
 <p>Look around and you will find, no-one's really
 <mark>colour</mark> blind.</p>
</blockquote>
<p lang="en-US">As we can tell from the <em>spelling</em> of the word,
the person writing this quote is clearly not American.</p>
(If the goal was to mark the element as misspelt, however, the u element, possibly with a class, would be more appropriate.)

Another example of the mark element is highlighting parts of a document that are matching some search string. If someone looked at a document, and the server knew that the user was searching for the word "kitten", then the server might return the document with one paragraph modified as follows:

<p>I also have some <mark>kitten</mark>s who are visiting me
these days. They're really cute. I think they like my garden! Maybe I
should adopt a <mark>kitten</mark>.</p>
In the following snippet, a paragraph of text refers to a specific part of a code fragment.

<p>The highlighted part below is where the error lies:</p>
<pre><code>var i: Integer;
begin
   i := <mark>1.1</mark>;
end.</code></pre>
This is separate from syntax highlighting, for which span is more appropriate. Combining both, one would get:

<p>The highlighted part below is where the error lies:</p>
<pre><code><span class=keyword>var</span> <span class=ident>i</span>: <span class=type>Integer</span>;
<span class=keyword>begin</span>
   <span class=ident>i</span> := <span class=literal><mark>1.1</mark></span>;
<span class=keyword>end</span>.</code></pre>
This is another example showing the use of mark to highlight a part of quoted text that was originally not emphasized. In this example, common typographic conventions have led the author to explicitly style mark elements in quotes to render in italics.

<style>
 blockquote mark, q mark {
   font: inherit; font-style: italic;
   text-decoration: none;
   background: transparent; color: inherit;
 }
 .bubble em {
   font: inherit; font-size: larger;
   text-decoration: underline;
 }
</style>
<article>
 <h1>She knew</h1>
 <p>Did you notice the subtle joke in the joke on panel 4?</p>
 <blockquote>
  <p class="bubble">I didn't <em>want</em> to believe. <mark>Of course
  on some level I realized it was a known-plaintext attack.</mark> But I
  couldn't admit it until I saw for myself.</p>
 </blockquote>
 <p>(Emphasis mine.) I thought that was great. It's so pedantic, yet it
 explains everything neatly.</p>
</article>
Note, incidentally, the distinction between the em element in this example, which is part of the original text being quoted, and the mark element, which is highlighting a part for comment.

The following example shows the difference between denoting the importance of a span of text (strong) as opposed to denoting the relevance of a span of text (mark). It is an extract from a textbook, where the extract has had the parts relevant to the exam highlighted. The safety warnings, important though they may be, are apparently not relevant to the exam.

<h3>Wormhole Physics Introduction</h3>

<p><mark>A wormhole in normal conditions can be held open for a
maximum of just under 39 minutes.</mark> Conditions that can increase
the time include a powerful energy source coupled to one or both of
the gates connecting the wormhole, and a large gravity well (such as a
black hole).</p>

<p><mark>Momentum is preserved across the wormhole. Electromagnetic
radiation can travel in both directions through a wormhole,
but matter cannot.</mark></p>

<p>When a wormhole is created, a vortex normally forms.
<strong>Warning: The vortex caused by the wormhole opening will
annihilate anything in its path.</strong> Vortexes can be avoided when
using sufficiently advanced dialing technology.</p>

<p><mark>An obstruction in a gate will prevent it from accepting a
wormhole connection.</mark></p>
4.5.24 The bdi element

Spec bugs: 27475

Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
Also, the dir global attribute has special semantics on this element.
DOM interface:
Uses HTMLElement.
The bdi element represents a span of text that is to be isolated from its surroundings for the purposes of bidirectional text formatting. [BIDI]

The dir global attribute defaults to auto on this element (it never inherits from the parent element like with other elements).

This element has rendering requirements involving the bidirectional algorithm.

This element is especially useful when embedding user-generated content with an unknown directionality.

In this example, usernames are shown along with the number of posts that the user has submitted. If the bdi element were not used, the username of the Arabic user would end up confusing the text (the bidirectional algorithm would put the colon and the number "3" next to the word "User" rather than next to the word "posts").

<ul>
 <li>User <bdi>jcranmer</bdi>: 12 posts.
 <li>User <bdi>hober</bdi>: 5 posts.
 <li>User <bdi>إيان</bdi>: 3 posts.
</ul>

When using the bdi element, the username acts as expected.

If the bdi element were to be replaced by a b element, the username would confuse the bidirectional algorithm and the third bullet would end up saying "User 3 :", followed by the Arabic name (right-to-left), followed by "posts" and a period.
4.5.25 The bdo element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
Also, the dir global attribute has special semantics on this element.
DOM interface:
Uses HTMLElement.
The bdo element represents explicit text directionality formatting control for its children. It allows authors to override the Unicode bidirectional algorithm by explicitly specifying a direction override. [BIDI]

Authors must specify the dir attribute on this element, with the value ltr to specify a left-to-right override and with the value rtl to specify a right-to-left override. The auto value must not be specified.

This element has rendering requirements involving the bidirectional algorithm.

4.5.26 The span element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLSpanElement : HTMLElement {};
The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g. class, lang, or dir. It represents its children.

In this example, a code fragment is marked up using span elements and class attributes so that its keywords and identifiers can be color-coded from CSS:

<pre><code class="lang-c"><span class="keyword">for</span> (<span class="ident">j</span> = 0; <span class="ident">j</span> &lt; 256; <span class="ident">j</span>++) {
  <span class="ident">i_t3</span> = (<span class="ident">i_t3</span> & 0x1ffff) | (<span class="ident">j</span> &lt;&lt; 17);
  <span class="ident">i_t6</span> = (((((((<span class="ident">i_t3</span> >> 3) ^ <span class="ident">i_t3</span>) >> 1) ^ <span class="ident">i_t3</span>) >> 8) ^ <span class="ident">i_t3</span>) >> 5) & 0xff;
  <span class="keyword">if</span> (<span class="ident">i_t6</span> == <span class="ident">i_t1</span>)
    <span class="keyword">break</span>;
}</code></pre>
4.5.27 The br element
Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLBRElement : HTMLElement {
  // also has obsolete members
};
The br element represents a line break.

While line breaks are usually represented in visual media by physically moving subsequent text to a new line, a style sheet or user agent would be equally justified in causing line breaks to be rendered in a different manner, for instance as green dots, or as extra spacing.

br elements must be used only for line breaks that are actually part of the content, as in poems or addresses.

The following example is correct usage of the br element:

<p>P. Sherman<br>
42 Wallaby Way<br>
Sydney</p>
br elements must not be used for separating thematic groups in a paragraph.

The following examples are non-conforming, as they abuse the br element:

<p><a ...>34 comments.</a><br>
<a ...>Add a comment.</a></p>
<p><label>Name: <input name="name"></label><br>
<label>Address: <input name="address"></label></p>
Here are alternatives to the above, which are correct:

<p><a ...>34 comments.</a></p>
<p><a ...>Add a comment.</a></p>
<p><label>Name: <input name="name"></label></p>
<p><label>Address: <input name="address"></label></p>
If a paragraph consists of nothing but a single br element, it represents a placeholder blank line (e.g. as in a template). Such blank lines must not be used for presentation purposes.

Any content inside br elements must not be considered part of the surrounding text.

This element has rendering requirements involving the bidirectional algorithm.

4.5.28 The wbr element

Support: wbr-element
Chrome for Android	64+
Chrome	4+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	None
Opera Mini	all+
Safari	3.2+
Edge	12+
Android Browser	2.3+
Opera	9.5+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The wbr element represents a line break opportunity.

In the following example, someone is quoted as saying something which, for effect, is written as one long word. However, to ensure that the text can be wrapped in a readable fashion, the individual words in the quote are separated using a wbr element.

<p>So then she pointed at the tiger and screamed
"there<wbr>is<wbr>no<wbr>way<wbr>you<wbr>are<wbr>ever<wbr>going<wbr>to<wbr>catch<wbr>me"!</p>
Any content inside wbr elements must not be considered part of the surrounding text.

var wbr = document.createElement("wbr");
wbr.textContent = "This is wrong";
document.body.appendChild(wbr);
This element has rendering requirements involving the bidirectional algorithm.

4.5.29 Usage summary
This section is non-normative.

Element	Purpose	Example
a	Hyperlinks
Visit my <a href="drinks.html">drinks</a> page.
em	Stress emphasis
I must say I <em>adore</em> lemonade.
strong	Importance
This tea is <strong>very hot</strong>.
small	Side comments
These grapes are made into wine. <small>Alcohol is addictive.</small>
s	Inaccurate text
Price: <s>£4.50</s> £2.00!
cite	Titles of works
The case <cite>Hugo v. Danielle</cite> is relevant here.
q	Quotations
The judge said <q>You can drink water from the fish tank</q> but advised against it.
dfn	Defining instance
The term <dfn>organic food</dfn> refers to food produced without synthetic chemicals.
abbr	Abbreviations
Organic food in Ireland is certified by the <abbr title="Irish Organic Farmers and Growers Association">IOFGA</abbr>.
ruby, rt, rp	Ruby annotations
<ruby> OJ <rp>(<rt>Orange Juice<rp>)</ruby>
data	Machine-readable equivalent
Available starting today! <data value="UPC:022014640201">North Coast Organic Apple Cider</data>
time	Machine-readable equivalent of date- or time-related data
Available starting on <time datetime="2011-11-18">November 18th</time>!
code	Computer code
The <code>fruitdb</code> program can be used for tracking fruit production.
var	Variables
If there are <var>n</var> fruit in the bowl, at least <var>n</var>÷2 will be ripe.
samp	Computer output
The computer said <samp>Unknown error -3</samp>.
kbd	User input
Hit <kbd>F1</kbd> to continue.
sub	Subscripts
Water is H<sub>2</sub>O.
sup	Superscripts
The Hydrogen in heavy water is usually <sup>2</sup>H.
i	Alternative voice
Lemonade consists primarily of <i>Citrus limon</i>.
b	Keywords
Take a <b>lemon</b> and squeeze it with a <b>juicer</b>.
u	Annotations
The mixture of apple juice and <u class="spelling">eldeflower</u> juice is very pleasant.
mark	Highlight
Elderflower cordial, with one <mark>part</mark> cordial to ten <mark>part</mark>s water, stands a<mark>part</mark> from the rest.
bdi	Text directionality isolation
The recommended restaurant is <bdi lang="">My Juice Café (At The Beach)</bdi>.
bdo	Text directionality formatting
The proposal is to write English, but in reverse order. "Juice" would become "<bdo dir=rtl>Juice</bdo>"
span	Other
In French we call it <span lang="fr">sirop de sureau</span>.
br	Line break
Simply Orange Juice Company<br>Apopka, FL 32703<br>U.S.A.
wbr	Line breaking opportunity
www.simply<wbr>orange<wbr>juice.com
4.6 Links
4.6.1 Introduction
Links are a conceptual construct, created by a, area, and link elements, that represent a connection between two resources, one of which is the current Document. There are two kinds of links in HTML:

Links to external resources
These are links to resources that are to be used to augment the current document, generally automatically processed by the user agent.

Hyperlinks
These are links to other resources that are generally exposed to the user by the user agent so that the user can cause the user agent to navigate to those resources, e.g. to visit them in a browser or download them.

For link elements with an href attribute and a rel attribute, links must be created for the keywords of the rel attribute, as defined for those keywords in the link types section.

Similarly, for a and area elements with an href attribute and a rel attribute, links must be created for the keywords of the rel attribute as defined for those keywords in the link types section. Unlike link elements, however, a and area elements with an href attribute that either do not have a rel attribute, or whose rel attribute has no keywords that are defined as specifying hyperlinks, must also create a hyperlink. This implied hyperlink has no special meaning (it has no link type) beyond linking the element's node document to the resource given by the element's href attribute.

A hyperlink can have one or more hyperlink annotations that modify the processing semantics of that hyperlink.

4.6.2 Links created by a and area elements
The href attribute on a and area elements must have a value that is a valid URL potentially surrounded by spaces.

The href attribute on a and area elements is not required; when those elements do not have href attributes they do not create hyperlinks.

The target attribute, if present, must be a valid browsing context name or keyword. It gives the name of the browsing context that will be used. User agents use this name when following hyperlinks.

When an a or area element's activation behavior is invoked, the user agent may allow the user to indicate a preference regarding whether the hyperlink is to be used for navigation or whether the resource it specifies is to be downloaded.

In the absence of a user preference, the default should be navigation if the element has no download attribute, and should be to download the specified resource if it does.

Whether determined by the user's preferences or via the presence or absence of the attribute, if the decision is to use the hyperlink for navigation then the user agent must follow the hyperlink, and if the decision is to use the hyperlink to download a resource, the user agent must download the hyperlink. These terms are defined in subsequent sections below.

The download attribute, if present, indicates that the author intends the hyperlink to be used for downloading a resource. The attribute may have a value; the value, if any, specifies the default file name that the author recommends for use in labeling the resource in a local file system. There are no restrictions on allowed values, but authors are cautioned that most file systems have limitations with regard to what punctuation is supported in file names, and user agents are likely to adjust file names accordingly.

The ping attribute, if present, gives the URLs of the resources that are interested in being notified if the user follows the hyperlink. The value must be a set of space-separated tokens, each of which must be a valid non-empty URL whose scheme is an HTTP(S) scheme. The value is used by the user agent for hyperlink auditing.


Support: ping
Chrome for Android	64+
Chrome	15+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	None
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	6+
Edge	17+
Android Browser	4.4+
Opera	15+

Source: caniuse.com

The rel attribute on a and area elements controls what kinds of links the elements create. The attribute's value must be a set of space-separated tokens. The allowed keywords and their meanings are defined below.

rel's supported tokens are the keywords defined in HTML link types which are allowed on a and area elements, impact the processing model, and are supported by the user agent. The possible supported tokens are noreferrer and noopener. rel's supported tokens must only include the tokens from this list that the user agent implements the processing model for.

Other specifications may add HTML link types as defined in Other link types, with the following additional requirements:

Such specifications may require that their link types be included in rel's supported tokens.
Such specifications may specify that their link types are body-ok.
The rel attribute has no default value. If the attribute is omitted or if none of the values in the attribute are recognized by the user agent, then the document has no particular relationship with the destination resource other than there being a hyperlink between the two.

The hreflang attribute on a elements that create hyperlinks, if present, gives the language of the linked resource. It is purely advisory. The value must be a valid BCP 47 language tag. [BCP47] User agents must not consider this attribute authoritative — upon fetching the resource, user agents must use only language information associated with the resource to determine its language, not metadata included in the link to the resource.

The type attribute, if present, gives the MIME type of the linked resource. It is purely advisory. The value must be a valid MIME type string. User agents must not consider the type attribute authoritative — upon fetching the resource, user agents must not use metadata included in the link to the resource to determine its type.

The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when following hyperlinks. [REFERRERPOLICY]

4.6.3 API for a and area elements
interface mixin HTMLHyperlinkElementUtils {
  [CEReactions] stringifier attribute USVString href;
  readonly attribute USVString origin;
  [CEReactions] attribute USVString protocol;
  [CEReactions] attribute USVString username;
  [CEReactions] attribute USVString password;
  [CEReactions] attribute USVString host;
  [CEReactions] attribute USVString hostname;
  [CEReactions] attribute USVString port;
  [CEReactions] attribute USVString pathname;
  [CEReactions] attribute USVString search;
  [CEReactions] attribute USVString hash;
};
hyperlink . toString()
hyperlink . href
Returns the hyperlink's URL.

Can be set, to change the URL.

hyperlink . origin
Returns the hyperlink's URL's origin.

hyperlink . protocol
Returns the hyperlink's URL's scheme.

Can be set, to change the URL's scheme.

hyperlink . username
Returns the hyperlink's URL's username.

Can be set, to change the URL's username.

hyperlink . password
Returns the hyperlink's URL's password.

Can be set, to change the URL's password.

hyperlink . host
Returns the hyperlink's URL's host and port (if different from the default port for the scheme).

Can be set, to change the URL's host and port.

hyperlink . hostname
Returns the hyperlink's URL's host.

Can be set, to change the URL's host.

hyperlink . port
Returns the hyperlink's URL's port.

Can be set, to change the URL's port.

hyperlink . pathname
Returns the hyperlink's URL's path.

Can be set, to change the URL's path.

hyperlink . search
Returns the hyperlink's URL's query (includes leading "?" if non-empty).

Can be set, to change the URL's query (ignores leading "?").

hyperlink . hash
Returns the hyperlink's URL's fragment (includes leading "#" if non-empty).

Can be set, to change the URL's fragment (ignores leading "#").

An element implementing the HTMLHyperlinkElementUtils mixin has an associated url (null or a URL). It is initially null.

An element implementing the HTMLHyperlinkElementUtils mixin has an associated set the url algorithm, which runs these steps:

If this element's href content attribute is absent, set this element's url to null.

Otherwise, parse this element's href content attribute value relative to this element's node document. If parsing is successful, set this element's url to the result; otherwise, set this element's url to null.

When elements implementing the HTMLHyperlinkElementUtils mixin are created, and whenever those elements have their href content attribute set, changed, or removed, the user agent must set the url.

This is only observable for blob: URLs as parsing them involves a Blob URL Store lookup.

An element implementing the HTMLHyperlinkElementUtils mixin has an associated reinitialize url algorithm, which runs these steps:

If element's url is non-null, its scheme is "blob", and its cannot-be-a-base-URL flag is set, terminate these steps.

Set the url.

To update href, set the element's href content attribute's value to the element's url, serialized.

The href attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null and this element has no href content attribute, return the empty string.

Otherwise, if url is null, return this element's href content attribute's value.

Return url, serialized.

The href attribute's setter must set this element's href content attribute's value to the given value.

The origin attribute's getter must run these steps:

Reinitialize url.

If this element's url is null, return the empty string.

Return the serialization of this element's url's origin.

The protocol attribute's getter must run these steps:

Reinitialize url.

If this element's url is null, return ":".

Return this element's url's scheme, followed by ":".

The protocol attribute's setter must run these steps:

Reinitialize url.

If this element's url is null, terminate these steps.

Basic URL parse the given value, followed by ":", with this element's url as url and scheme start state as state override.

Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".

Update href.

The username attribute's getter must run these steps:

Reinitialize url.

If this element's url is null, return the empty string.

Return this element's url's username.

The username attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url cannot have a username/password/port, then return.

Set the username, given url and the given value.

Update href.

The password attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, then return the empty string.

Return url's password.

The password attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url cannot have a username/password/port, then return.

Set the password, given url and the given value.

Update href.

The host attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url or url's host is null, return the empty string.

If url's port is null, return url's host, serialized.

Return url's host, serialized, followed by ":" and url's port, serialized.

The host attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

Basic URL parse the given value, with url as url and host state as state override.

Update href.

The hostname attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url or url's host is null, return the empty string.

Return url's host, serialized.

The hostname attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

Basic URL parse the given value, with url as url and hostname state as state override.

Update href.

The port attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url or url's port is null, return the empty string.

Return url's port, serialized.

The port attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url cannot have a username/password/port, then return.

If the given value is the empty string, then set url's port to null.

Otherwise, basic URL parse the given value, with url as url and port state as state override.

Update href.

The pathname attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, return the empty string.

If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

If url's path is empty, then return the empty string.

Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The pathname attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

Set url's path to the empty list.

Basic URL parse the given value, with url as url and path start state as state override.

Update href.

The search attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, or url's query is either null or the empty string, return the empty string.

Return "?", followed by url's query.

The search attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, terminate these steps.

If the given value is the empty string, set url's query to null.

Otherwise:

Let input be the given value with a single leading "?" removed, if any.

Set url's query to the empty string.

Basic URL parse input, with url as url and query state as state override, and this element's node document's document's character encoding as encoding override.

Update href.

The hash attribute's getter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, or url's fragment is either null or the empty string, return the empty string.

Return "#", followed by url's fragment.

The hash attribute's setter must run these steps:

Reinitialize url.

Let url be this element's url.

If url is null, then return.

If the given value is the empty string, set url's fragment to null.

Otherwise:

Let input be the given value with a single leading "#" removed, if any.

Set url's fragment to the empty string.

Basic URL parse input, with url as url and fragment state as state override.

Update href.

4.6.4 Following hyperlinks

Spec bugs: 28925

An element element cannot navigate if one of the following is true:

element's node document is not fully active
element is not an a element and is not connected.
This is also used by form submission for the form element. The exception for a elements is for compatibility with web content.

When a user follows a hyperlink created by an element subject, optionally with a hyperlink suffix, the user agent must run the following steps:

If subject cannot navigate, then return.

Let replace be false.

Let source be subject's node document's browsing context.

Let targetAttributeValue be the empty string.

If subject is an a or area element, then set targetAttributeValue to the result of getting an element's target given subject.

Let noopener be true if subject's link types include the noreferrer or noopener keyword

Let target and replace be the result of applying the rules for choosing a browsing context given targetAttributeValue, source, and noopener.

If target is null, then return.

If noopener and replace are true, then disown target.

Parse the URL given by subject's href attribute, relative to subject's node document.

If that is successful, let URL be the resulting URL string.

Otherwise, if parsing the URL failed, the user agent may report the error to the user in a user-agent-specific manner, may queue a task to navigate the target browsing context to an error page to report the error, or may ignore the error and do nothing. In any case, the user agent must then return.

If there is a hyperlink suffix, append it to URL.

Let resource be a new request whose url is URL and whose referrer policy is the current state of subject's referrerpolicy content attribute.

Queue a task to navigate the target browsing context to resource. If replace is true, the navigation must be performed with replacement enabled. The source browsing context must be source.

The task source for the tasks mentioned above is the DOM manipulation task source.

4.6.5 Downloading resources

Support: download
Chrome for Android	64+
Chrome	14+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	20+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	10.1+
Edge	13+
Android Browser	4.4+
Opera	15+

Source: caniuse.com

In some cases, resources are intended for later use rather than immediate viewing. To indicate that a resource is intended to be downloaded for use later, rather than immediately used, the download attribute can be specified on the a or area element that creates the hyperlink to that resource.

The attribute can furthermore be given a value, to specify the file name that user agents are to use when storing the resource in a file system. This value can be overridden by the `Content-Disposition` HTTP header's filename parameters. [RFC6266]

In cross-origin situations, the download attribute has to be combined with the `Content-Disposition` HTTP header, specifically with the attachment disposition type, to avoid the user being warned of possibly nefarious activity. (This is to protect users from being made to download sensitive personal or confidential information without their full understanding.)

When a user downloads a hyperlink created by an element subject, optionally with a hyperlink suffix, the user agent must run the following steps:

If subject cannot navigate, then return.

Parse the URL given by subject's href attribute, relative to subject's node document.

If parsing the URL fails, the user agent may report the error to the user in a user-agent-specific manner, may navigate to an error page to report the error, or may ignore the error and do nothing. In either case, the user agent must return.

Otherwise, let URL be the resulting URL string.

If there is a hyperlink suffix, append it to URL.

Run these steps in parallel:

Let request be a new request whose url is URL, client is entry settings object, initiator is "download", destination is the empty string, and whose synchronous flag and use-URL-credentials flag are set.

Handle the result of fetching request as a download.

When a user agent is to handle a resource obtained from a fetch as a download, it should provide the user with a way to save the resource for later use, if a resource is successfully obtained; or otherwise should report any problems downloading the file to the user.

If the user agent needs a file name for a resource being handled as a download, it should select one using the following algorithm.

This algorithm is intended to mitigate security dangers involved in downloading files from untrusted sites, and user agents are strongly urged to follow it.

Let filename be the void value.

If the resource has a `Content-Disposition` header, that header specifies the attachment disposition type, and the header includes file name information, then let filename have the value specified by the header, and jump to the step labeled sanitize below. [RFC6266]

Let interface origin be the origin of the Document in which the download or navigate action resulting in the download was initiated, if any.

Let resource origin be the origin of the URL of the resource being downloaded, unless that URL's scheme component is data, in which case let resource origin be the same as the interface origin, if any.

If there is no interface origin, then let trusted operation be true. Otherwise, let trusted operation be true if resource origin is the same origin as interface origin, and false otherwise.

If trusted operation is true and the resource has a `Content-Disposition` header and that header includes file name information, then let filename have the value specified by the header, and jump to the step labeled sanitize below. [RFC6266]

If the download was not initiated from a hyperlink created by an a or area element, or if the element of the hyperlink from which it was initiated did not have a download attribute when the download was initiated, or if there was such an attribute but its value when the download was initiated was the empty string, then jump to the step labeled no proposed file name.

Let proposed filename have the value of the download attribute of the element of the hyperlink that initiated the download at the time the download was initiated.

If trusted operation is true, let filename have the value of proposed filename, and jump to the step labeled sanitize below.

If the resource has a `Content-Disposition` header and that header specifies the attachment disposition type, let filename have the value of proposed filename, and jump to the step labeled sanitize below. [RFC6266]

No proposed file name: If trusted operation is true, or if the user indicated a preference for having the resource in question downloaded, let filename have a value derived from the URL of the resource in a user-agent-defined manner, and jump to the step labeled sanitize below.

Act in a user-agent-defined manner to safeguard the user from a potentially hostile cross-origin download. If the download is not to be aborted, then let filename be set to the user's preferred file name or to a file name selected by the user agent, and jump to the step labeled sanitize below.

If the algorithm reaches this step, then a download was begun from a different origin than the resource being downloaded, and the origin did not mark the file as suitable for downloading, and the download was not initiated by the user. This could be because a download attribute was used to trigger the download, or because the resource in question is not of a type that the user agent supports.

This could be dangerous, because, for instance, a hostile server could be trying to get a user to unknowingly download private information and then re-upload it to the hostile server, by tricking the user into thinking the data is from the hostile server.

Thus, it is in the user's interests that the user be somehow notified that the resource in question comes from quite a different source, and to prevent confusion, any suggested file name from the potentially hostile interface origin should be ignored.

Sanitize: Optionally, allow the user to influence filename. For example, a user agent could prompt the user for a file name, potentially providing the value of filename as determined above as a default value.

Adjust filename to be suitable for the local file system.

For example, this could involve removing characters that are not legal in file names, or trimming leading and trailing whitespace.

If the platform conventions do not in any way use extensions to determine the types of file on the file system, then return filename as the file name.

Let claimed type be the type given by the resource's Content-Type metadata, if any is known. Let named type be the type given by filename's extension, if any is known. For the purposes of this step, a type is a mapping of a MIME type to an extension.

If named type is consistent with the user's preferences (e.g. because the value of filename was determined by prompting the user), then return filename as the file name.

If claimed type and named type are the same type (i.e. the type given by the resource's Content-Type metadata is consistent with the type given by filename's extension), then return filename as the file name.

If the claimed type is known, then alter filename to add an extension corresponding to claimed type.

Otherwise, if named type is known to be potentially dangerous (e.g. it will be treated by the platform conventions as a native executable, shell script, HTML application, or executable-macro-capable document) then optionally alter filename to add a known-safe extension (e.g. ".txt").

This last step would make it impossible to download executables, which might not be desirable. As always, implementers are forced to balance security and usability in this matter.

Return filename as the file name.

For the purposes of this algorithm, a file extension consists of any part of the file name that platform conventions dictate will be used for identifying the type of the file. For example, many operating systems use the part of the file name following the last dot (".") in the file name to determine the type of the file, and from that the manner in which the file is to be opened or executed.

User agents should ignore any directory or path information provided by the resource itself, its URL, and any download attribute, in deciding where to store the resulting file in the user's file system.

4.6.5.1 Hyperlink auditing

Spec bugs: 24137

If a hyperlink created by an a or area element has a ping attribute, and the user follows the hyperlink, and the value of the element's href attribute can be parsed, relative to the element's node document, without failure, then the user agent must take the ping attribute's value, split that string on ASCII whitespace, parse each resulting token relative to the element's node document, and then run these steps for each resulting URL record ping URL, ignoring tokens that fail to parse:

If ping URL's scheme is not an HTTP(S) scheme, then return.

Optionally, return. (For example, the user agent might wish to ignore any or all ping URLs in accordance with the user's expressed preferences.)

Let request be a new request whose url is ping URL, method is `POST`, body is `PING`, client is the environment settings object of the Document containing the hyperlink, destination is the empty string, credentials mode is "include", referrer is "no-referrer", and whose use-URL-credentials flag is set.

Let target URL be the resulting URL string obtained from parsing the value of the element's href attribute and then:

If the URL of the Document object containing the hyperlink being audited and ping URL have the same origin
If the origins are different, but the HTTPS state of the Document containing the hyperlink being audited is "none"
request must include a `Ping-From` header with, as its value, the URL of the document containing the hyperlink, and a `Ping-To` HTTP header with, as its value, the target URL.
Otherwise
request must include a `Ping-To` HTTP header with, as its value, target URL. request does not include a `Ping-From` header.
Fetch request.

This may be done in parallel with the primary fetch, and is independent of the result of that fetch.

User agents should allow the user to adjust this behavior, for example in conjunction with a setting that disables the sending of HTTP `Referer` (sic) headers. Based on the user's preferences, UAs may either ignore the ping attribute altogether, or selectively ignore URLs in the list (e.g. ignoring any third-party URLs); this is explicitly accounted for in the steps above.

User agents must ignore any entity bodies returned in the responses. User agents may close the connection prematurely once they start receiving a response body.

When the ping attribute is present, user agents should clearly indicate to the user that following the hyperlink will also cause secondary requests to be sent in the background, possibly including listing the actual target URLs.

For example, a visual user agent could include the hostnames of the target ping URLs along with the hyperlink's actual URL in a status bar or tooltip.

The ping attribute is redundant with pre-existing technologies like HTTP redirects and JavaScript in allowing Web pages to track which off-site links are most popular or allowing advertisers to track click-through rates.

However, the ping attribute provides these advantages to the user over those alternatives:

It allows the user to see the final target URL unobscured.
It allows the UA to inform the user about the out-of-band notifications.
It allows the user to disable the notifications without losing the underlying link functionality.
It allows the UA to optimize the use of available network bandwidth so that the target page loads faster.
Thus, while it is possible to track users without this feature, authors are encouraged to use the ping attribute so that the user agent can make the user experience more transparent.

4.6.6 Link types
The following table summarizes the link types that are defined by this specification, by their corresponding keywords. This table is non-normative; the actual definitions for the link types are given in the next few sections.

In this section, the term referenced document refers to the resource identified by the element representing the link, and the term current document refers to the resource within which the element representing the link finds itself.

To determine which link types apply to a link, a, or area element, the element's rel attribute must be split on ASCII whitespace. The resulting tokens are the keywords for the link types that apply to that element.

Except where otherwise specified, a keyword must not be specified more than once per rel attribute.

Some of the sections that follow the table below list synonyms for certain keywords. The indicated synonyms are to be handled as specified by user agents, but must not be used in documents (for example, the keyword "copyright").

Keywords are always ASCII case-insensitive, and must be compared as such.

Thus, rel="next" is the same as rel="NEXT".

Keywords that are body-ok affect whether link elements are allowed in the body. The body-ok keywords defined by this specification are dns-prefetch, modulepreload, pingback, preconnect, prefetch, preload, prerender, and stylesheet. Other specifications can also define body-ok keywords.

Link type	Effect on...	body-ok	Brief description
link	a and area
alternate	Hyperlink	Hyperlink	·	Gives alternate representations of the current document.
canonical	Hyperlink	not allowed	·	Gives the preferred URL for the current document.
author	Hyperlink	Hyperlink	·	Gives a link to the author of the current document or article.
bookmark	not allowed	Hyperlink	·	Gives the permalink for the nearest ancestor section.
dns-prefetch	External Resource	not allowed	Yes	Specifies that the user agent should preemptively perform DNS resolution for the target resource's origin.
external	not allowed	Annotation	·	Indicates that the referenced document is not part of the same site as the current document.
help	Hyperlink	Hyperlink	·	Provides a link to context-sensitive help.
icon	External Resource	not allowed	·	Imports an icon to represent the current document.
modulepreload	External Resource	not allowed	Yes	Specifies that the user agent must preemptively fetch the module script and store it in the document's module map for later evaluation. Optionally, the module's dependencies can be fetched as well.
license	Hyperlink	Hyperlink	·	Indicates that the main content of the current document is covered by the copyright license described by the referenced document.
next	Hyperlink	Hyperlink	·	Indicates that the current document is a part of a series, and that the next document in the series is the referenced document.
nofollow	not allowed	Annotation	·	Indicates that the current document's original author or publisher does not endorse the referenced document.
noopener	not allowed	Annotation	·	Indicates that any browsing context created by following the hyperlink is disowned.
noreferrer	not allowed	Annotation	·	Indicates that any browsing context created by following the hyperlink is disowned and will not get a `Referer` (sic) header.
pingback	External Resource	not allowed	Yes	Gives the address of the pingback server that handles pingbacks to the current document.
preconnect	External Resource	not allowed	Yes	Specifies that the user agent should preemptively connect to the target resource's origin.
prefetch	External Resource	not allowed	Yes	Specifies that the user agent should preemptively fetch and cache the target resource as it is likely to be required for a followup navigation.
preload	External Resource	not allowed	Yes	Specifies that the user agent must preemptively fetch and cache the target resource for current navigation according to the potential destination given by the as attribute (and the priority associated with the corresponding destination).
prerender	External Resource	not allowed	Yes	Specifies that the user agent should preemptively fetch the target resource and process it in a way that helps deliver a faster response in the future.
prev	Hyperlink	Hyperlink	·	Indicates that the current document is a part of a series, and that the previous document in the series is the referenced document.
search	Hyperlink	Hyperlink	·	Gives a link to a resource that can be used to search through the current document and its related pages.
stylesheet	External Resource	not allowed	Yes	Imports a stylesheet.
tag	not allowed	Hyperlink	·	Gives a tag (identified by the given address) that applies to the current document.
4.6.6.1 Link type "alternate"
The alternate keyword may be used with link, a, and area elements.

The meaning of this keyword depends on the values of the other attributes.

If the element is a link element and the rel attribute also contains the keyword stylesheet
The alternate keyword modifies the meaning of the stylesheet keyword in the way described for that keyword. The alternate keyword does not create a link of its own.

Here, a set of link elements provide some style sheets:

<!-- a persistent style sheet -->
<link rel="stylesheet" href="default.css">

<!-- the preferred alternate style sheet -->
<link rel="stylesheet" href="green.css" title="Green styles">

<!-- some alternate style sheets -->
<link rel="alternate stylesheet" href="contrast.css" title="High contrast">
<link rel="alternate stylesheet" href="big.css" title="Big fonts">
<link rel="alternate stylesheet" href="wide.css" title="Wide screen">
If the alternate keyword is used with the type attribute set to the value application/rss+xml or the value application/atom+xml
The keyword creates a hyperlink referencing a syndication feed (though not necessarily syndicating exactly the same content as the current page).

For the purposes of feed autodiscovery, user agents should consider all link elements in the document with the alternate keyword used and with their type attribute set to the value application/rss+xml or the value application/atom+xml. If the user agent has the concept of a default syndication feed, the first such element (in tree order) should be used as the default.

The following link elements give syndication feeds for a blog:

<link rel="alternate" type="application/atom+xml" href="posts.xml" title="Cool Stuff Blog">
<link rel="alternate" type="application/atom+xml" href="posts.xml?category=robots" title="Cool Stuff Blog: robots category">
<link rel="alternate" type="application/atom+xml" href="comments.xml" title="Cool Stuff Blog: Comments">
Such link elements would be used by user agents engaged in feed autodiscovery, with the first being the default (where applicable).

The following example offers various different syndication feeds to the user, using a elements:

<p>You can access the planets database using Atom feeds:</p>
<ul>
 <li><a href="recently-visited-planets.xml" rel="alternate" type="application/atom+xml">Recently Visited Planets</a></li>
 <li><a href="known-bad-planets.xml" rel="alternate" type="application/atom+xml">Known Bad Planets</a></li>
 <li><a href="unexplored-planets.xml" rel="alternate" type="application/atom+xml">Unexplored Planets</a></li>
</ul>
These links would not be used in feed autodiscovery.

Otherwise
The keyword creates a hyperlink referencing an alternate representation of the current document.

The nature of the referenced document is given by the hreflang, and type attributes.

If the alternate keyword is used with the hreflang attribute, and that attribute's value differs from the document element's language, it indicates that the referenced document is a translation.

If the alternate keyword is used with the type attribute, it indicates that the referenced document is a reformulation of the current document in the specified format.

The hreflang and type attributes can be combined when specified with the alternate keyword.

The following example shows how you can specify versions of the page that use alternative formats, are aimed at other languages, and that are intended for other media:

<link rel=alternate href="/en/html" hreflang=en type=text/html title="English HTML">
<link rel=alternate href="/fr/html" hreflang=fr type=text/html title="French HTML">
<link rel=alternate href="/en/html/print" hreflang=en type=text/html media=print title="English HTML (for printing)">
<link rel=alternate href="/fr/html/print" hreflang=fr type=text/html media=print title="French HTML (for printing)">
<link rel=alternate href="/en/pdf" hreflang=en type=application/pdf title="English PDF">
<link rel=alternate href="/fr/pdf" hreflang=fr type=application/pdf title="French PDF">
This relationship is transitive — that is, if a document links to two other documents with the link type "alternate", then, in addition to implying that those documents are alternative representations of the first document, it is also implying that those two documents are alternative representations of each other.

4.6.6.2 Link type "author"
The author keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

For a and area elements, the author keyword indicates that the referenced document provides further information about the author of the nearest article element ancestor of the element defining the hyperlink, if there is one, or of the page as a whole, otherwise.

For link elements, the author keyword indicates that the referenced document provides further information about the author for the page as a whole.

The "referenced document" can be, and often is, a mailto: URL giving the e-mail address of the author. [MAILTO]

Synonyms: For historical reasons, user agents must also treat link, a, and area elements that have a rev attribute with the value "made" as having the author keyword specified as a link relationship.

4.6.6.3 Link type "bookmark"
The bookmark keyword may be used with a and area elements. This keyword creates a hyperlink.

The bookmark keyword gives a permalink for the nearest ancestor article element of the linking element in question, or of the section the linking element is most closely associated with, if there are no ancestor article elements.

The following snippet has three permalinks. A user agent could determine which permalink applies to which part of the spec by looking at where the permalinks are given.

 ...
 <body>
  <h1>Example of permalinks</h1>
  <div id="a">
   <h2>First example</h2>
   <p><a href="a.html" rel="bookmark">This permalink applies to
   only the content from the first H2 to the second H2</a>. The DIV isn't
   exactly that section, but it roughly corresponds to it.</p>
  </div>
  <h2>Second example</h2>
  <article id="b">
   <p><a href="b.html" rel="bookmark">This permalink applies to
   the outer ARTICLE element</a> (which could be, e.g., a blog post).</p>
   <article id="c">
    <p><a href="c.html" rel="bookmark">This permalink applies to
    the inner ARTICLE element</a> (which could be, e.g., a blog comment).</p>
   </article>
  </article>
 </body>
 ...
4.6.6.4 Link type "canonical"
The canonical keyword may be used with link element. This keyword creates a hyperlink.

The canonical keyword indicates that URL given by the href attribute is the preferred URL for the current document. That helps search engines reduce duplicate content, as described in more detail in The Canonical Link Relation specification. [RFC6596]

4.6.6.5 Link type "dns-prefetch"
The dns-prefetch keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The dns-prefetch keyword indicates that preemptively performing DNS resolution for the origin of the specified resource is likely to be beneficial, as it is highly likely that the user will require resources located at that origin, and the user experience would be improved by preempting the latency costs associated with DNS resolution. User agents must implement the processing model of the dns-prefetch keyword described in the Resource Hints specification. [RESOURCEHINTS]

There is no default type for resources given by the dns-prefetch keyword.

4.6.6.6 Link type "external"
The external keyword may be used with a and area elements. This keyword does not create a hyperlink, but annotates any other hyperlinks created by the element (the implied hyperlink, if no other keywords create one).

The external keyword indicates that the link is leading to a document that is not part of the site that the current document forms a part of.

4.6.6.7 Link type "help"
The help keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

For a and area elements, the help keyword indicates that the referenced document provides further help information for the parent of the element defining the hyperlink, and its children.

In the following example, the form control has associated context-sensitive help. The user agent could use this information, for example, displaying the referenced document if the user presses the "Help" or "F1" key.

 <p><label> Topic: <input name=topic> <a href="help/topic.html" rel="help">(Help)</a></label></p>
For link elements, the help keyword indicates that the referenced document provides help for the page as a whole.

For a and area elements, on some browsers, the help keyword causes the link to use a different cursor.

4.6.6.8 Link type "icon"

Support: link-icon-png
Chrome for Android	64+
Chrome	4+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	11+
Opera Mini	None
Safari	3.1+
Edge	12+
Android Browser	2.1+
Opera	9+

Source: caniuse.com

The icon keyword may be used with link elements. This keyword creates an external resource link.

The specified resource is an icon representing the page or site, and should be used by the user agent when representing the page in the user interface.

Icons could be auditory icons, visual icons, or other kinds of icons. If multiple icons are provided, the user agent must select the most appropriate icon according to the type, media, and sizes attributes. If there are multiple equally appropriate icons, user agents must use the last one declared in tree order at the time that the user agent collected the list of icons. If the user agent tries to use an icon but that icon is determined, upon closer examination, to in fact be inappropriate (e.g. because it uses an unsupported format), then the user agent must try the next-most-appropriate icon as determined by the attributes.

User agents are not required to update icons when the list of icons changes, but are encouraged to do so.

There is no default type for resources given by the icon keyword. However, for the purposes of determining the type of the resource, user agents must expect the resource to be an image.

The sizes keywords represent icon sizes in raw pixels (as opposed to CSS pixels).

An icon that is 50 CSS pixels wide intended for displays with a device pixel density of two device pixels per CSS pixel (2x, 192dpi) would have a width of 100 raw pixels. This feature does not support indicating that a different resource is to be used for small high-resolution icons vs large low-resolution icons (e.g. 50×50 2x vs 100×100 1x).

To parse and process the attribute's value, the user agent must first split the attribute's value on ASCII whitespace, and must then parse each resulting keyword to determine what it represents.

The any keyword represents that the resource contains a scalable icon, e.g. as provided by an SVG image.

Other keywords must be further parsed as follows to determine what they represent:

If the keyword doesn't contain exactly one U+0078 LATIN SMALL LETTER X or U+0058 LATIN CAPITAL LETTER X character, then this keyword doesn't represent anything. Return for that keyword.

Let width string be the string before the "x" or "X".

Let height string be the string after the "x" or "X".

If either width string or height string start with a U+0030 DIGIT ZERO (0) character or contain any characters other than ASCII digits, then this keyword doesn't represent anything. Return for that keyword.

Apply the rules for parsing non-negative integers to width string to obtain width.

Apply the rules for parsing non-negative integers to height string to obtain height.

The keyword represents that the resource contains a bitmap icon with a width of width device pixels and a height of height device pixels.

The keywords specified on the sizes attribute must not represent icon sizes that are not actually available in the linked resource.

In the absence of a link with the icon keyword, for Document objects whose URL's scheme is an HTTP(S) scheme, user agents may instead run these steps in parallel:

Let request be a new request whose url is the URL record obtained by resolving the URL "/favicon.ico" against the Document object's URL, client is the Document object's relevant settings object, destination is "image", synchronous flag is set, credentials mode is "include", and whose use-URL-credentials flag is set.

Let response be the result of fetching request.

Use response's unsafe response as an icon as if it had been declared using the icon keyword.

The following snippet shows the top part of an application with several icons.

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>lsForums — Inbox</title>
  <link rel=icon href=favicon.png sizes="16x16" type="image/png">
  <link rel=icon href=windows.ico sizes="32x32 48x48" type="image/vnd.microsoft.icon">
  <link rel=icon href=mac.icns sizes="128x128 512x512 8192x8192 32768x32768">
  <link rel=icon href=iphone.png sizes="57x57" type="image/png">
  <link rel=icon href=gnome.svg sizes="any" type="image/svg+xml">
  <link rel=stylesheet href=lsforums.css>
  <script src=lsforums.js></script>
  <meta name=application-name content="lsForums">
 </head>
 <body>
  ...
For historical reasons, the icon keyword may be preceded by the keyword "shortcut". If the "shortcut" keyword is present, the rel attribute's entire value must be an ASCII case-insensitive match for the string "shortcut icon" (with a single U+0020 SPACE character between the tokens and no other ASCII whitespace).

4.6.6.9 Link type "license"
The license keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

The license keyword indicates that the referenced document provides the copyright license terms under which the main content of the current document is provided.

This specification does not specify how to distinguish between the main content of a document and content that is not deemed to be part of that main content. The distinction should be made clear to the user.

Consider a photo sharing site. A page on that site might describe and show a photograph, and the page might be marked up as follows:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Exampl Pictures: Kissat</title>
  <link rel="stylesheet" href="/style/default">
 </head>
 <body>
  <h1>Kissat</h1>
  <nav>
   <a href="../">Return to photo index</a>
  </nav>
  <figure>
   <img src="/pix/39627052_fd8dcd98b5.jpg">
   <figcaption>Kissat</figcaption>
  </figure>
  <p>One of them has six toes!</p>
  <p><small><a rel="license" href="http://www.opensource.org/licenses/mit-license.php">MIT Licensed</a></small></p>
  <footer>
   <a href="/">Home</a> | <a href="../">Photo index</a>
   <p><small>© copyright 2009 Exampl Pictures. All Rights Reserved.</small></p>
  </footer>
 </body>
</html>
In this case the license applies to just the photo (the main content of the document), not the whole document. In particular not the design of the page itself, which is covered by the copyright given at the bottom of the document. This could be made clearer in the styling (e.g. making the license link prominently positioned near the photograph, while having the page copyright in light small text at the foot of the page).

Synonyms: For historical reasons, user agents must also treat the keyword "copyright" like the license keyword.

4.6.6.10 Link type "modulepreload"
The modulepreload keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The modulepreload keyword is a specialized alternative to the preload keyword, with a processing model geared toward preloading module scripts. In particular, it uses the specific fetch behavior for module scripts (including, e.g., a different interpretation of the crossorigin attribute), and places the result into the appropriate module map for later evaluation. In contrast, a similar external resource link using the preload keyword would place the result in the preload cache, without affecting the document's module map.

Additionally, implementations can take advantage of the fact that module scripts declare their dependencies in order to fetch the specified module's dependency as well. This is intended as an optimization opportunity, since the user agent knows that, in all likelihood, those dependencies will also be needed later. It will not generally be observable without using technology such as service workers, or monitoring on the server side. Notably, the appropriate load or error events will occur after the specified module is fetched, and will not wait for any dependencies.

The appropriate times to fetch the resource for such a link are:

When the external resource link is created on a link element that is already browsing-context connected.

When the external resource link's link element becomes browsing-context connected.

When the href attribute of the link element of an external resource link that is already browsing-context connected is changed.

Unlike some other link relations, changing the relevant attributes (such as as, crossorigin, and referrerpolicy) of such a link attribute does not trigger a new fetch. This is because the document's module map has already been populated by a previous fetch, and so re-fetching would be pointless.

To obtain the resource for such a link:

If the href attribute's value is the empty string, then return.

Let destination be the current state of the as attribute (a destination), or "script" if it is in no state.

If destination is not script-like, then queue a task on the networking task source to fire an event named error at the link element, and return.

Parse the URL given by the href attribute, relative to the element's node document. If that fails, then return. Otherwise, let url be the resulting URL record.

Let settings object be the link element's node document's relevant settings object.

Let credentials mode be the module script credentials mode for the crossorigin attribute.

Let cryptographic nonce be the current value of the element's [[CryptographicNonce]] internal slot.

Let integrity metadata be the value of the integrity attribute, if it is specified, or the empty string otherwise.

Let referrer policy be the current state of the element's referrerpolicy attribute.

Let options be a script fetch options whose cryptographic nonce is cryptographic nonce, integrity metadata is integrity metadata, parser metadata is "not-parser-inserted", credentials mode is credentials mode, and referrer policy is referrer policy.

Fetch a single module script given url, settings object, destination, options, settings object, "client", and with the top-level module fetch flag set. Wait until algorithm asynchronously completes with result.

If result is null, fire an event named error at the link element, and return.

Fire an event named load at the link element.

Optionally, perform the following steps:

Let visited set be « url ».

Fetch the descendants of and instantiate result given destination and visited set.

Generally, performing these steps will be beneficial for performance, as it allows pre-loading the modules that will invariably be requested later, when fetch a module script graph is called. However, user agents might wish to skip them in bandwidth-constrained situations, or situations where the relevant fetches are already in flight.

The following snippet shows the top part of an application with several modules preloaded:

<!DOCTYPE html>
<html lang="en">
<title>IRCFog</title>

<link rel="modulepreload" href="app.mjs">
<link rel="modulepreload" href="helpers.mjs">
<link rel="modulepreload" href="irc.mjs">
<link rel="modulepreload" href="fog-machine.mjs">

<script type="module" src="app.mjs">
...
Assume that the module graph for the application is as follows:


Here we see the application developer has used modulepreload all of the modules in their module graph, ensuring that the user agent initiates fetches for them all. Without such preloading, the user agent might need to go through multiple network roundtrips before discovering helpers.mjs, if technologies such as HTTP/2 Server Push are not in play. In this way, modulepreload link elements can be used as a sort of "manifest" of the application's modules.

The following code shows how modulepreload links can be used in conjunction with import() to ensure network fetching is done ahead of time, so that when import() is called, the module is already ready (but not evaluated) in the module map:

<link rel="modulepreload" href="awesome-viewer.js">

<button onclick="import('./awesome-viewer.js').then(m => m.view())">
  View awesome thing
</button>
4.6.6.11 Link type "nofollow"
The nofollow keyword may be used with a and area elements. This keyword does not create a hyperlink, but annotates any other hyperlinks created by the element (the implied hyperlink, if no other keywords create one).

The nofollow keyword indicates that the link is not endorsed by the original author or publisher of the page, or that the link to the referenced document was included primarily because of a commercial relationship between people affiliated with the two pages.

4.6.6.12 Link type "noopener"

Support: rel-noopener
Chrome for Android	64+
Chrome	49+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	52+
Samsung Internet	5+
IE	None
Opera Mini	None
Safari	10.1+
Edge	None
Android Browser	62+
Opera	36+

Source: caniuse.com

The noopener keyword may be used with a and area elements. This keyword does not create a hyperlink, but annotates any other hyperlinks created by the element (the implied hyperlink, if no other keywords create one).

The keyword indicates that any newly created browsing context which results from following the hyperlink will be disowned, which means that its window.opener attribute will be null.

4.6.6.13 Link type "noreferrer"

Support: rel-noreferrer
Chrome for Android	64+
Chrome	16+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	33+
Samsung Internet	4+
IE (limited)	11+
Opera Mini	None
Safari	5+
Edge	13+
Android Browser	2.3+
Opera	15+

Source: caniuse.com

The noreferrer keyword may be used with a and area elements. This keyword does not create a hyperlink, but annotates any other hyperlinks created by the element (the implied hyperlink, if no other keywords create one).

It indicates that no referrer information is to be leaked when following the link.

If a user agent follows a link defined by an a or area element that has the noreferrer keyword, the user agent must set their request's referrer to "no-referrer".

For historical reasons, the noreferrer keyword implies the behavior associated with the noopener keyword when present on a hyperlink that creates a new browsing context. That is, <a href="..." rel="noreferrer" target="_blank"> has the same behavior as <a href="..." rel="noreferrer noopener" target="_blank">.

4.6.6.14 Link type "pingback"
The pingback keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

For the semantics of the pingback keyword, see the Pingback 1.0 specification. [PINGBACK]

4.6.6.15 Link type "preconnect"
The preconnect keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The preconnect keyword indicates that preemptively initiating a connection to the origin of the specified resource is likely to be beneficial, as it is highly likely that the user will require resources located at that origin, and the user experience would be improved by preempting the latency costs associated with establishing the connection. User agents must implement the processing model of the preconnect keyword described in Resource Hints. [RESOURCEHINTS]

There is no default type for resources given by the preconnect keyword.

4.6.6.16 Link type "prefetch"
The prefetch keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The prefetch keyword indicates that preemptively fetching and caching the specified resource is likely to be beneficial, as it is highly likely that the user will require this resource for future navigations. User agents must implement the processing model of the prefetch keyword described in Resource Hints. [RESOURCEHINTS]

There is no default type for resources given by the prefetch keyword.

4.6.6.17 Link type "preload"
The preload keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The preload keyword indicates that the user agent must preemptively fetch and cache the specified resource according to the potential destination given by the as attribute (and the priority associated with the corresponding destination), as it is highly likely that the user will require this resource for the current navigation. User agents must implement the processing model of the preload keyword described in Preload, as well as in this specification's obtain the resource algorithm. [PRELOAD]

There is no default type for resources given by the preload keyword.

4.6.6.18 Link type "prerender"
The prerender keyword may be used with link elements. This keyword creates an external resource link. This keyword is body-ok.

The prerender keyword indicates that the specified resource might be required by the next navigation, and so it may be beneficial to not only preemptively fetch the resource, but also to process it, e.g. by fetching its subresources or performing some rendering. User agents must implement the processing model of the prerender keyword described in Resource Hints. [RESOURCEHINTS]

There is no default type for resources given by the prerender keyword.

4.6.6.19 Link type "search"
The search keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

The search keyword indicates that the referenced document provides an interface specifically for searching the document and its related resources.

OpenSearch description documents can be used with link elements and the search link type to enable user agents to autodiscover search interfaces. [OPENSEARCH]

4.6.6.20 Link type "stylesheet"
The stylesheet keyword may be used with link elements. This keyword creates an external resource link that contributes to the styling processing model. This keyword is body-ok.

The specified resource is a CSS style sheet that describes how to present the document.

If the alternate keyword is also specified on the link element, then the link is an alternative stylesheet; in this case, the title attribute must be specified on the link element, with a non-empty value.

The default type for resources given by the stylesheet keyword is text/css.

The appropriate times to obtain the resource are:

When the external resource link is created on a link element that is already browsing-context connected.

When the external resource link's link element becomes browsing-context connected.

When the href attribute of the link element of an external resource link that is already browsing-context connected is changed.

When the crossorigin attribute of the link element of an external resource link that is already browsing-context connected is set, changed, or removed.

When the type attribute of the link element of an external resource link that is already browsing-context connected is set or changed to a value that does not or no longer matches the Content-Type metadata of the previous obtained external resource, if any.

When the type attribute of the link element of an external resource link that is already browsing-context connected, but was previously not obtained due to the type attribute specifying an unsupported type, is set, removed, or changed.

When the external resource link that is already browsing-context connected changes from being an alternative stylesheet to not being one, or vice versa.

Quirk: If the document has been set to quirks mode, has the same origin as the URL of the external resource, and the Content-Type metadata of the external resource is not a supported style sheet type, the user agent must instead assume it to be text/css.

Once a resource has been obtained, if its Content-Type metadata is text/css, then run these steps:

Let element be the link element that created the external resource link.

If element has an associated CSS style sheet, remove the CSS style sheet in question.

If element no longer creates an external resource link that contributes to the styling processing model, or if, since the resource in question was obtained, it has become appropriate to obtain it again (meaning this algorithm is about to be invoked again for a newly obtained resource), then return.

Create a CSS style sheet with the following properties:

type
text/css

location
The resulting URL string determined during the obtain algorithm.

This is before any redirects get applied.

owner node
element

media
The media attribute of element.

This is a reference to the (possibly absent at this time) attribute, rather than a copy of the attribute's current value. The CSSOM specification defines what happens when the attribute is dynamically set, changed, or removed.

title
The title attribute of element, if element is in a document tree, or the empty string otherwise.

This is similarly a reference to the attribute, rather than a copy of the attribute's current value.

alternate flag
Set if the link is an alternative stylesheet; unset otherwise.

origin-clean flag
Set if the resource is CORS-same-origin; unset otherwise.

parent CSS style sheet
owner CSS rule
null

disabled flag
Left at its default value.

CSS rules
Left uninitialized.

This doesn't seem right. Presumably we should be using the response body? Tracked as issue #2997.

The CSS environment encoding is the result of running the following steps: [CSSSYNTAX]

If the element has a charset attribute, get an encoding from that attribute's value. If that succeeds, return the resulting encoding. [ENCODING]

Otherwise, return the document's character encoding. [DOM]

4.6.6.21 Link type "tag"
The tag keyword may be used with a and area elements. This keyword creates a hyperlink.

The tag keyword indicates that the tag that the referenced document represents applies to the current document.

Since it indicates that the tag applies to the current document, it would be inappropriate to use this keyword in the markup of a tag cloud, which lists the popular tags across a set of pages.

This document is about some gems, and so it is tagged with "https://en.wikipedia.org/wiki/Gemstone" to unambiguously categorize it as applying to the "jewel" kind of gems, and not to, say, the towns in the US, the Ruby package format, or the Swiss locomotive class:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>My Precious</title>
 </head>
 <body>
  <header><h1>My precious</h1> <p>Summer 2012</p></header>
  <p>Recently I managed to dispose of a red gem that had been
  bothering me. I now have a much nicer blue sapphire.</p>
  <p>The red gem had been found in a bauxite stone while I was digging
  out the office level, but nobody was willing to haul it away. The
  same red gem stayed there for literally years.</p>
  <footer>
   Tags: <a rel=tag href="https://en.wikipedia.org/wiki/Gemstone">Gemstone</a>
  </footer>
 </body>
</html>
In this document, there are two articles. The "tag" link, however, applies to the whole page (and would do so wherever it was placed, including if it was within the article elements).

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Gem 4/4</title>
 </head>
 <body>
  <article>
   <h1>801: Steinbock</h1>
   <p>The number 801 Gem 4/4 electro-diesel has an ibex and was rebuilt in 2002.</p>
  </article>
  <article>
   <h1>802: Murmeltier</h1>
   <figure>
    <img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Trains_de_la_Bernina_en_hiver_2.jpg"
         alt="The 802 was red with pantographs and tall vents on the side.">
    <figcaption>The 802 in the 1980s, above Lago Bianco.</figcaption>
   </figure>
   <p>The number 802 Gem 4/4 electro-diesel has a marmot and was rebuilt in 2003.</p>
  </article>
  <p class="topic"><a rel=tag href="https://en.wikipedia.org/wiki/Rhaetian_Railway_Gem_4/4">Gem 4/4</a></p>
 </body>
</html>
4.6.6.22 Sequential link types
Some documents form part of a sequence of documents.

A sequence of documents is one where each document can have a previous sibling and a next sibling. A document with no previous sibling is the start of its sequence, a document with no next sibling is the end of its sequence.

A document may be part of multiple sequences.

4.6.6.22.1 Link type "next"
The next keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

The next keyword indicates that the document is part of a sequence, and that the link is leading to the document that is the next logical document in the sequence.

When the next keyword is used with a link element, user agents should implement one of the processing models described in Resource Hints, i.e. should process such links as if they were using one of the dns-prefetch, preconnect, prefetch, or prerender keywords. Which resource hint the user agent wishes to use is implementation-dependent; for example, a user agent may wish to use the less-costly preconnect hint when trying to conserve data, battery power, or processing power, or may wish to pick a resource hint depending on heuristic analysis of past user behavior in similar scenarios. [RESOURCEHINTS]

4.6.6.22.2 Link type "prev"
The prev keyword may be used with link, a, and area elements. This keyword creates a hyperlink.

The prev keyword indicates that the document is part of a sequence, and that the link is leading to the document that is the previous logical document in the sequence.

Synonyms: For historical reasons, user agents must also treat the keyword "previous" like the prev keyword.

4.6.6.23 Other link types
Extensions to the predefined set of link types may be registered in the microformats wiki existing-rel-values page. [MFREL]

Anyone is free to edit the microformats wiki existing-rel-values page at any time to add a type. Extension types must be specified with the following information:

Keyword
The actual value being defined. The value should not be confusingly similar to any other defined value (e.g. differing only in case).

If the value contains a U+003A COLON character (:), it must also be an absolute URL.

Effect on... link
One of the following:

Not allowed
The keyword must not be specified on link elements.
Hyperlink
The keyword may be specified on a link element; it creates a hyperlink.
External Resource
The keyword may be specified on a link element; it creates an external resource link.
Effect on... a and area
One of the following:

Not allowed
The keyword must not be specified on a and area elements.
Hyperlink
The keyword may be specified on a and area elements; it creates a hyperlink.
External Resource
The keyword may be specified on a and area elements; it creates an external resource link.
Hyperlink Annotation
The keyword may be specified on a and area elements; it annotates other hyperlinks created by the element.
Brief description
A short non-normative description of what the keyword's meaning is.

Specification
A link to a more detailed description of the keyword's semantics and requirements. It could be another page on the Wiki, or a link to an external page.

Synonyms
A list of other keyword values that have exactly the same processing requirements. Authors should not use the values defined to be synonyms, they are only intended to allow user agents to support legacy content. Anyone may remove synonyms that are not used in practice; only names that need to be processed as synonyms for compatibility with legacy content are to be registered in this way.

Status
One of the following:

Proposed
The keyword has not received wide peer review and approval. Someone has proposed it and is, or soon will be, using it.
Ratified
The keyword has received wide peer review and approval. It has a specification that unambiguously defines how to handle pages that use the keyword, including when they use it in incorrect ways.
Discontinued
The keyword has received wide peer review and it has been found wanting. Existing pages are using this keyword, but new pages should avoid it. The "brief description" and "specification" entries will give details of what authors should use instead, if anything.
If a keyword is found to be redundant with existing values, it should be removed and listed as a synonym for the existing value.

If a keyword is registered in the "proposed" state for a period of a month or more without being used or specified, then it may be removed from the registry.

If a keyword is added with the "proposed" status and found to be redundant with existing values, it should be removed and listed as a synonym for the existing value. If a keyword is added with the "proposed" status and found to be harmful, then it should be changed to "discontinued" status.

Anyone can change the status at any time, but should only do so in accordance with the definitions above.

Conformance checkers must use the information given on the microformats wiki existing-rel-values page to establish if a value is allowed or not: values defined in this specification or marked as "proposed" or "ratified" must be accepted when used on the elements for which they apply as described in the "Effect on..." field, whereas values marked as "discontinued" or not listed in either this specification or on the aforementioned page must be rejected as invalid. Conformance checkers may cache this information (e.g. for performance reasons or to avoid the use of unreliable network connectivity).

When an author uses a new type not defined by either this specification or the Wiki page, conformance checkers should offer to add the value to the Wiki, with the details described above, with the "proposed" status.

Types defined as extensions in the microformats wiki existing-rel-values page with the status "proposed" or "ratified" may be used with the rel attribute on link, a, and area elements in accordance to the "Effect on..." field. [MFREL]

4.7 Edits
The ins and del elements represent edits to the document.

4.7.1 The ins element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
cite — Link to the source of the quotation or more information about the edit
datetime — Date and (optionally) time of the change
DOM interface:
Uses HTMLModElement.
The ins element represents an addition to the document.

The following represents the addition of a single paragraph:

<aside>
 <ins>
  <p> I like fruit. </p>
 </ins>
</aside>
As does the following, because everything in the aside element here counts as phrasing content and therefore there is just one paragraph:

<aside>
 <ins>
  Apples are <em>tasty</em>.
 </ins>
 <ins>
  So are pears.
 </ins>
</aside>
ins elements should not cross implied paragraph boundaries.

The following example represents the addition of two paragraphs, the second of which was inserted in two parts. The first ins element in this example thus crosses a paragraph boundary, which is considered poor form.

<aside>
 <!-- don't do this -->
 <ins datetime="2005-03-16 00:00Z">
  <p> I like fruit. </p>
  Apples are <em>tasty</em>.
 </ins>
 <ins datetime="2007-12-19 00:00Z">
  So are pears.
 </ins>
</aside>
Here is a better way of marking this up. It uses more elements, but none of the elements cross implied paragraph boundaries.

<aside>
 <ins datetime="2005-03-16 00:00Z">
  <p> I like fruit. </p>
 </ins>
 <ins datetime="2005-03-16 00:00Z">
  Apples are <em>tasty</em>.
 </ins>
 <ins datetime="2007-12-19 00:00Z">
  So are pears.
 </ins>
</aside>
4.7.2 The del element
Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
cite — Link to the source of the quotation or more information about the edit
datetime — Date and (optionally) time of the change
DOM interface:
Uses HTMLModElement.
The del element represents a removal from the document.

del elements should not cross implied paragraph boundaries.

The following shows a "to do" list where items that have been done are crossed-off with the date and time of their completion.

<h1>To Do</h1>
<ul>
 <li>Empty the dishwasher</li>
 <li><del datetime="2009-10-11T01:25-07:00">Watch Walter Lewin's lectures</del></li>
 <li><del datetime="2009-10-10T23:38-07:00">Download more tracks</del></li>
 <li>Buy a printer</li>
</ul>
4.7.3 Attributes common to ins and del elements
The cite attribute may be used to specify the URL of a document that explains the change. When that document is long, for instance the minutes of a meeting, authors are encouraged to include a fragment pointing to the specific part of that document that discusses the change.

If the cite attribute is present, it must be a valid URL potentially surrounded by spaces that explains the change. To obtain the corresponding citation link, the value of the attribute must be parsed relative to the element's node document. User agents may allow users to follow such citation links, but they are primarily intended for private use (e.g., by server-side scripts collecting statistics about a site's edits), not for readers.

The datetime attribute may be used to specify the time and date of the change.

If present, the datetime attribute's value must be a valid date string with optional time.

User agents must parse the datetime attribute according to the parse a date or time string algorithm. If that doesn't return a date or a global date and time, then the modification has no associated timestamp (the value is non-conforming; it is not a valid date string with optional time). Otherwise, the modification is marked as having been made at the given date or global date and time. If the given value is a global date and time then user agents should use the associated time-zone offset information to determine which time zone to present the given datetime in.

This value may be shown to the user, but it is primarily intended for private use.

The ins and del elements must implement the HTMLModElement interface:

[Exposed=Window,
 HTMLConstructor]
interface HTMLModElement : HTMLElement {
  [CEReactions] attribute USVString cite;
  [CEReactions] attribute DOMString dateTime;
};
The cite IDL attribute must reflect the element's cite content attribute. The dateTime IDL attribute must reflect the element's datetime content attribute.

4.7.4 Edits and paragraphs
This section is non-normative.

Since the ins and del elements do not affect paragraphing, it is possible, in some cases where paragraphs are implied (without explicit p elements), for an ins or del element to span both an entire paragraph or other non-phrasing content elements and part of another paragraph. For example:

<section>
 <ins>
  <p>
   This is a paragraph that was inserted.
  </p>
  This is another paragraph whose first sentence was inserted
  at the same time as the paragraph above.
 </ins>
 This is a second sentence, which was there all along.
</section>
By only wrapping some paragraphs in p elements, one can even get the end of one paragraph, a whole second paragraph, and the start of a third paragraph to be covered by the same ins or del element (though this is very confusing, and not considered good practice):

<section>
 This is the first paragraph. <ins>This sentence was
 inserted.
 <p>This second paragraph was inserted.</p>
 This sentence was inserted too.</ins> This is the
 third paragraph in this example.
 <!-- (don't do this) -->
</section>
However, due to the way implied paragraphs are defined, it is not possible to mark up the end of one paragraph and the start of the very next one using the same ins or del element. You instead have to use one (or two) p element(s) and two ins or del elements, as for example:

<section>
 <p>This is the first paragraph. <del>This sentence was
 deleted.</del></p>
 <p><del>This sentence was deleted too.</del> That
 sentence needed a separate &lt;del&gt; element.</p>
</section>
Partly because of the confusion described above, authors are strongly encouraged to always mark up all paragraphs with the p element, instead of having ins or del elements that cross implied paragraphs boundaries.

4.7.5 Edits and lists
This section is non-normative.

The content models of the ol and ul elements do not allow ins and del elements as children. Lists always represent all their items, including items that would otherwise have been marked as deleted.

To indicate that an item is inserted or deleted, an ins or del element can be wrapped around the contents of the li element. To indicate that an item has been replaced by another, a single li element can have one or more del elements followed by one or more ins elements.

In the following example, a list that started empty had items added and removed from it over time. The bits in the example that have been emphasized show the parts that are the "current" state of the list. The list item numbers don't take into account the edits, though.

<h1>Stop-ship bugs</h1>
<ol>
 <li><ins datetime="2008-02-12T15:20Z">Bug 225:
 Rain detector doesn't work in snow</ins></li>
 <li><del datetime="2008-03-01T20:22Z"><ins datetime="2008-02-14T12:02Z">Bug 228:
 Water buffer overflows in April</ins></del></li>
 <li><ins datetime="2008-02-16T13:50Z">Bug 230:
 Water heater doesn't use renewable fuels</ins></li>
 <li><del datetime="2008-02-20T21:15Z"><ins datetime="2008-02-16T14:25Z">Bug 232:
 Carbon dioxide emissions detected after startup</ins></del></li>
</ol>
In the following example, a list that started with just fruit was replaced by a list with just colors.

<h1>List of <del>fruits</del><ins>colors</ins></h1>
<ul>
 <li><del>Lime</del><ins>Green</ins></li>
 <li><del>Apple</del></li>
 <li>Orange</li>
 <li><del>Pear</del></li>
 <li><ins>Teal</ins></li>
 <li><del>Lemon</del><ins>Yellow</ins></li>
 <li>Olive</li>
 <li><ins>Purple</ins></li>
</ul>
4.7.6 Edits and tables
This section is non-normative.

The elements that form part of the table model have complicated content model requirements that do not allow for the ins and del elements, so indicating edits to a table can be difficult.

To indicate that an entire row or an entire column has been added or removed, the entire contents of each cell in that row or column can be wrapped in ins or del elements (respectively).

Here, a table's row has been added:

<table>
 <thead>
  <tr> <th> Game name           <th> Game publisher   <th> Verdict
 <tbody>
  <tr> <td> Diablo 2            <td> Blizzard         <td> 8/10
  <tr> <td> Portal              <td> Valve            <td> 10/10
  <tr> <td> <ins>Portal 2</ins> <td> <ins>Valve</ins> <td> <ins>10/10</ins>
</table>
Here, a column has been removed (the time at which it was removed is given also, as is a link to the page explaining why):

<table>
 <thead>
  <tr> <th> Game name           <th> Game publisher   <th> <del cite="/edits/r192" datetime="2011-05-02 14:23Z">Verdict</del>
 <tbody>
  <tr> <td> Diablo 2            <td> Blizzard         <td> <del cite="/edits/r192" datetime="2011-05-02 14:23Z">8/10</del>
  <tr> <td> Portal              <td> Valve            <td> <del cite="/edits/r192" datetime="2011-05-02 14:23Z">10/10</del>
  <tr> <td> Portal 2            <td> Valve            <td> <del cite="/edits/r192" datetime="2011-05-02 14:23Z">10/10</del>
</table>
Generally speaking, there is no good way to indicate more complicated edits (e.g. that a cell was removed, moving all subsequent cells up or to the left).

4.8 Embedded content
4.8.1 The picture element

Support: picture
Chrome for Android	64+
Chrome	38+
iOS Safari	9.3+
UC Browser for Android	11.8+
Firefox	38+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	9.1+
Edge	13+
Android Browser	62+
Opera	25+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Embedded content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLPictureElement : HTMLElement {};
The picture element is a container which provides multiple sources to its contained img element to allow authors to declaratively control or give hints to the user agent about which image resource to use, based on the screen pixel density, viewport size, image format, and other factors. It represents its children.

The picture element is somewhat different from the similar-looking video and audio elements. While all of them contain source elements, the source element's src attribute has no meaning when the element is nested within a picture element, and the resource selection algorithm is different. Also, the picture element itself does not display anything; it merely provides a context for its contained img element that enables it to choose from multiple URLs.

4.8.2 The source element
Categories:
None.
Contexts in which this element can be used:
As a child of a picture element, before the img element.
As a child of a media element, before any flow content or track elements.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
src — Address of the resource
type — Type of embedded resource
srcset — Images to use in different situations (e.g. high-resolution displays, small monitors, etc)
sizes — Image sizes for different page layouts
media — Applicable media
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLSourceElement : HTMLElement {
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute USVString srcset;
  [CEReactions] attribute DOMString sizes;
  [CEReactions] attribute DOMString media;
};
The source element allows authors to specify multiple alternative source sets for img elements or multiple alternative media resources for media elements. It does not represent anything on its own.

The type attribute may be present. If present, the value must be a valid MIME type string.

The remainder of the requirements depend on whether the parent is a picture element or a media element:

source element's parent is a picture element
The srcset attribute must be present, and is a srcset attribute.

The srcset attribute contributes the image sources to the source set, if the source element is selected.

If the srcset attribute has any image candidate strings using a width descriptor, the sizes attribute must also be present, and is a sizes attribute. The sizes attribute contributes the source size to the source set, if the source element is selected.

The media attributes may also be present. If present, the value must contain a valid media query list. The user agent will skip to the next source element if the value does not match the environment.

The type attribute gives the type of the images in the source set, to allow the user agent to skip to the next source element if it does not support the given type.

If the type attribute is not specified, the user agent will not select a different source element if it finds that it does not support the image format after fetching it.

When a source element has a following sibling source element or img element with a srcset attribute specified, it must have at least one of the following:

A media attribute specified with a value that, after stripping leading and trailing ASCII whitespace, is not the empty string and is not an ASCII case-insensitive match for the string "all".

A type attribute specified.

The src attribute must not be present.

source element's parent is a media element
The src attribute gives the URL of the media resource. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.

Dynamically modifying a source element and its attribute when the element is already inserted in a video or audio element will have no effect. To change what is playing, just use the src attribute on the media element directly, possibly making use of the canPlayType() method to pick from amongst available resources. Generally, manipulating source elements manually after the document has been parsed is an unnecessarily complicated approach.

The type attribute gives the type of the media resource, to help the user agent determine if it can play this media resource before fetching it. The codecs parameter, which certain MIME types define, might be necessary to specify exactly how the resource is encoded. [RFC6381]

The following list shows some examples of how to use the codecs= MIME parameter in the type attribute.

H.264 Constrained baseline profile video (main and extended video compatible) level 3 and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
H.264 Extended profile video (baseline-compatible) level 3 and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="avc1.58A01E, mp4a.40.2"'>
H.264 Main profile video level 3 and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="avc1.4D401E, mp4a.40.2"'>
H.264 'High' profile video (incompatible with main, baseline, or extended profiles) level 3 and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="avc1.64001E, mp4a.40.2"'>
MPEG-4 Visual Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="mp4v.20.8, mp4a.40.2"'>
MPEG-4 Advanced Simple Profile Level 0 video and Low-Complexity AAC audio in MP4 container
<source src='video.mp4' type='video/mp4; codecs="mp4v.20.240, mp4a.40.2"'>
MPEG-4 Visual Simple Profile Level 0 video and AMR audio in 3GPP container
<source src='video.3gp' type='video/3gpp; codecs="mp4v.20.8, samr"'>
Theora video and Vorbis audio in Ogg container
<source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'>
Theora video and Speex audio in Ogg container
<source src='video.ogv' type='video/ogg; codecs="theora, speex"'>
Vorbis audio alone in Ogg container
<source src='audio.ogg' type='audio/ogg; codecs=vorbis'>
Speex audio alone in Ogg container
<source src='audio.spx' type='audio/ogg; codecs=speex'>
FLAC audio alone in Ogg container
<source src='audio.oga' type='audio/ogg; codecs=flac'>
Dirac video and Vorbis audio in Ogg container
<source src='video.ogv' type='video/ogg; codecs="dirac, vorbis"'>
The srcset, sizes, and media attributes must not be present.

If a source element is inserted as a child of a media element that has no src attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke the media element's resource selection algorithm.

The IDL attributes src, type, srcset, sizes and media must reflect the respective content attributes of the same name.

If the author isn't sure if user agents will all be able to render the media resources provided, the author can listen to the error event on the last source element and trigger fallback behavior:

<script>
 function fallback(video) {
   // replace <video> with its contents
   while (video.hasChildNodes()) {
     if (video.firstChild instanceof HTMLSourceElement)
       video.removeChild(video.firstChild);
     else
       video.parentNode.insertBefore(video.firstChild, video);
   }
   video.parentNode.removeChild(video);
 }
</script>
<video controls autoplay>
 <source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
 <source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'
         onerror="fallback(parentNode)">
 ...
</video>
4.8.3 The img element

Spec bugs: 24055, 26068, 28096

Categories:
Flow content.
Phrasing content.
Embedded content.
Form-associated element.
If the element has a usemap attribute: Interactive content.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
alt — Replacement text for use when images are not available
src — Address of the resource
srcset — Images to use in different situations (e.g. high-resolution displays, small monitors, etc)
sizes — Image sizes for different page layouts
crossorigin — How the element handles crossorigin requests
usemap — Name of image map to use
ismap — Whether the image is a server-side image map
width — Horizontal dimension
height — Vertical dimension
referrerpolicy — Referrer policy for fetches initiated by the element
decoding — Decoding hint to use when processing this image for presentation
DOM interface:
[Exposed=Window,
 HTMLConstructor,
 NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : HTMLElement {
  [CEReactions] attribute DOMString alt;
  [CEReactions] attribute USVString src;
  [CEReactions] attribute USVString srcset;
  [CEReactions] attribute DOMString sizes;
  [CEReactions] attribute DOMString? crossOrigin;
  [CEReactions] attribute DOMString useMap;
  [CEReactions] attribute boolean isMap;
  [CEReactions] attribute unsigned long width;
  [CEReactions] attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
  readonly attribute USVString currentSrc;
  [CEReactions] attribute DOMString referrerPolicy;
  [CEReactions] attribute DOMString decoding;

  Promise<void> decode();

  // also has obsolete members
};
An img element represents an image.

The image given by the src and srcset attributes, and any previous sibling source elements' srcset attributes if the parent is a picture element, is the embedded content; the value of the alt attribute provides equivalent content for those who cannot process images or who have image loading disabled (i.e. it is the img element's fallback content).


Support: srcset
Chrome for Android	64+
Chrome	38+
iOS Safari	9.0+
UC Browser for Android	11.8+
Firefox	38+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	9+
Edge	16+
Android Browser	62+
Opera	25+

Source: caniuse.com

The requirements on the alt attribute's value are described in a separate section.

The src attribute must be present, and must contain a valid non-empty URL potentially surrounded by spaces referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.

The requirements above imply that images can be static bitmaps (e.g. PNGs, GIFs, JPEGs), single-page vector documents (single-page PDFs, XML files with an SVG document element), animated bitmaps (APNGs, animated GIFs), animated vector graphics (XML files with an SVG document element that use declarative SMIL animation), and so forth. However, these definitions preclude SVG files with script, multipage PDF files, interactive MNG files, HTML documents, plain text documents, and so forth. [PNG] [GIF] [JPEG] [PDF] [XML] [APNG] [SVG] [MNG]

The srcset attribute may also be present, and is a srcset attribute.

The srcset attribute and the src attribute (if width descriptors are not used) contribute the image sources to the source set (if no source element was selected).

If the srcset attribute is present and has any image candidate strings using a width descriptor, the sizes attribute must also be present, and is a sizes attribute. The sizes attribute contributes the source size to the source set (if no source element was selected).

The crossorigin attribute is a CORS settings attribute. Its purpose is to allow images from third-party sites that allow cross-origin access to be used with canvas.

The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the image. [REFERRERPOLICY]

The decoding attribute indicates the preferred method to decode this image. The attribute, if present, must be an image decoding hint. This attribute's missing value default and invalid value default are both the auto state.

The img element must not be used as a layout tool. In particular, img elements should not be used to display transparent images, as such images rarely convey meaning and rarely add anything useful to the document.

What an img element represents depends on the src attribute and the alt attribute.

If the src attribute is set and the alt attribute is set to the empty string
The image is either decorative or supplemental to the rest of the content, redundant with some other information in the document.

If the image is available and the user agent is configured to display that image, then the element represents the element's image data.

Otherwise, the element represents nothing, and may be omitted completely from the rendering. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.

If the src attribute is set and the alt attribute is set to a value that isn't empty
The image is a key part of the content; the alt attribute gives a textual equivalent or replacement for the image.

If the image is available and the user agent is configured to display that image, then the element represents the element's image data.

Otherwise, the element represents the text given by the alt attribute. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.

If the src attribute is set and the alt attribute is not
The image might be a key part of the content, and there is no textual equivalent of the image available.

In a conforming document, the absence of the alt attribute indicates that the image is a key part of the content but that a textual replacement for the image was not available when the image was generated.

If the image is available and the user agent is configured to display that image, then the element represents the element's image data.

If the image has a src attribute whose value is the empty string, then the element represents nothing.

Otherwise, the user agent should display some sort of indicator that there is an image that is not being rendered, and may, if requested by the user, or if so configured, or when required to provide contextual information in response to navigation, provide caption information for the image, derived as follows:

If the image has a title attribute whose value is not the empty string, then return the value of that attribute.

If the image is a descendant of a figure element that has a child figcaption element, and, ignoring the figcaption element and its descendants, the figure element has no flow content descendants other than inter-element whitespace and the img element, then return the contents of the first such figcaption element.

Return nothing. (There is no caption information.)

If the src attribute is not set and either the alt attribute is set to the empty string or the alt attribute is not set at all
The element represents nothing.

Otherwise
The element represents the text given by the alt attribute.

The alt attribute does not represent advisory information. User agents must not present the contents of the alt attribute in the same way as content of the title attribute.

User agents may always provide the user with the option to display any image, or to prevent any image from being displayed. User agents may also apply heuristics to help the user make use of the image when the user is unable to see it, e.g. due to a visual disability or because they are using a text terminal with no graphics capabilities. Such heuristics could include, for instance, optical character recognition (OCR) of text found within the image.

While user agents are encouraged to repair cases of missing alt attributes, authors must not rely on such behavior. Requirements for providing text to act as an alternative for images are described in detail below.

The contents of img elements, if any, are ignored for the purposes of rendering.

The usemap attribute, if present, can indicate that the image has an associated image map.

The ismap attribute, when used on an element that is a descendant of an a element with an href attribute, indicates by its presence that the element provides access to a server-side image map. This affects how events are handled on the corresponding a element.

The ismap attribute is a boolean attribute. The attribute must not be specified on an element that does not have an ancestor a element with an href attribute.

The usemap and ismap attributes can result in confusing behavior when used together with source elements with the media attribute specified in a picture element.

The img element supports dimension attributes.

The alt, src, srcset and sizes IDL attributes must reflect the respective content attributes of the same name.

The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

The useMap IDL attribute must reflect the usemap content attribute.

The isMap IDL attribute must reflect the ismap content attribute.

The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The decoding IDL attribute must reflect the decoding content attribute, limited to only known values.

image . width [ = value ]
image . height [ = value ]
These attributes return the actual rendered dimensions of the image, or zero if the dimensions are not known.

They can be set, to change the corresponding content attributes.

image . naturalWidth
image . naturalHeight
These attributes return the intrinsic dimensions of the image, or zero if the dimensions are not known.

image . complete
Returns true if the image has been completely downloaded or if no image is specified; otherwise, returns false.

image . currentSrc
Returns the image's absolute URL.

image . decoding
Returns the image decoding hint set for this image.

image . decode()
This method causes the user agent to decode the image in parallel, returning a promise that fulfills when decoding is complete.

The promise will be rejected with an "EncodingError" DOMException if the image cannot be decoded.

image = new Image( [ width [, height ] ] )
Returns a new img element, with the width and height attributes set to the values passed in the relevant arguments, if applicable.

The IDL attributes width and height must return the rendered width and height of the image, in CSS pixels, if the image is being rendered, and is being rendered to a visual medium; or else the density-corrected intrinsic width and height of the image, in CSS pixels, if the image has intrinsic dimensions and is available but not being rendered to a visual medium; or else 0, if the image is not available or does not have intrinsic dimensions. [CSS]

On setting, they must act as if they reflected the respective content attributes of the same name.

The IDL attributes naturalWidth and naturalHeight must return the density-corrected intrinsic width and height of the image, in CSS pixels, if the image has intrinsic dimensions and is available, or else 0. [CSS]


Spec bugs: 23581

Support: img-naturalwidth-naturalheight
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	9+
Opera Mini	all+
Safari	3.1+
Edge	12+
Android Browser	2.1+
Opera	9+

Source: caniuse.com

The IDL attribute complete must return true if any of the following conditions is true:


Spec bugs: 18742, 26113

Both the src attribute and the srcset attribute are omitted.
The srcset attribute is omitted and the src attribute's value is the empty string.
The final task that is queued by the networking task source once the resource has been fetched has been queued.
The img element's current request's state is completely available.
The img element's current request's state is broken.
Otherwise, the attribute must return false.

The value of complete can thus change while a script is executing.

The currentSrc IDL attribute must return the img element's current request's current URL.

The decode() method, when invoked, must perform the following steps:

Let promise be a new promise.

Queue a microtask to perform the following steps:

This is done because updating the image data takes place in a microtask as well. Thus, to make code such as

img.src = "stars.jpg";
img.decode();
properly decode stars.jpg, we need to delay any processing by one microtask.

If any of the following conditions are true about this img element:

its node document is not an active document;

its current request's state is broken,

then reject promise with an "EncodingError" DOMException.

Otherwise, in parallel, wait for one of the following cases to occur, and perform the corresponding actions:

This img element's node document stops being an active document
This img element's current request changes or is mutated
This img element's current request's state becomes broken
Reject promise with an "EncodingError" DOMException.

This img element's current request's state becomes completely available
Decode the image.

If decoding does not need to be performed for this image (for example because it is a vector graphic), resolve promise with undefined.

If decoding fails (for example due to invalid image data), reject promise with an "EncodingError" DOMException.

If the decoding process completes successfully, resolve promise with undefined.

User agents should ensure that the decoded media data stays readily available until at least the end of the next successful update the rendering step in the event loop. This is an important part of the API contract, and should not be broken if at all possible. (Typically, this would only be violated in low-memory situations that require evicting decoded image data, or when the image is too large to keep in decoded form for this period of time.)

Animated images will become completely available only after all their frames are loaded. Thus, even though an implementation could decode the first frame before that point, the above steps will not do so, instead waiting until all frames are available.

Return promise.

Without the decode() method, the process of loading an img element and then displaying it might look like the following:

const img = new Image();
img.src = "nebula.jpg";
img.onload = () => {
    document.body.appendChild(img);
};
img.onerror = () => {
    document.body.appendChild(new Text("Could not load the nebula :("));
};
However, this can cause notable dropped frames, as the paint that occurs after inserting the image into the DOM causes a synchronous decode on the main thread.

This can instead be rewritten using the decode() method:

const img = new Image();
img.src = "nebula.jpg";
img.decode().then(() => {
    document.body.appendChild(img);
}).catch(() => {
    document.body.appendChild(new Text("Could not load the nebula :("));
});
This latter form avoids the dropped frames of the original, by allowing the user agent to decode the image in parallel, and only inserting it into the DOM (and thus causing it to be painted) once the decoding process is complete.

Because the decode() method attempts to ensure that the decoded image data is available for at least one frame, it can be combined with the requestAnimationFrame() API. This means it can be used with coding styles or frameworks that ensure that all DOM modifications are batched together as animation frame callbacks:

const container = document.querySelector("#container");

const { containerWidth, containerHeight } = computeDesiredSize();
requestAnimationFrame(() => {
 container.style.width = containerWidth;
 container.style.height = containerHeight;
});

// ...

const img = new Image();
img.src = "supernova.jpg";
img.decode().then(() => {
    requestAnimationFrame(() => container.appendChild(img));
});
A constructor is provided for creating HTMLImageElement objects (in addition to the factory methods from DOM such as createElement()): Image(width, height). When invoked, the constructor must perform the following steps:

Let document be the current global object's associated Document.

Let img be the result of creating an element given document, img, and the HTML namespace.

If width is given, then set an attribute value for img using "width" and width.

If height is given, then set an attribute value for img using "height" and height.

Return img.

A single image can have different appropriate alternative text depending on the context.

In each of the following cases, the same image is used, yet the alt text is different each time. The image is the coat of arms of the Carouge municipality in the canton Geneva in Switzerland.

Here it is used as a supplementary icon:

<p>I lived in <img src="carouge.svg" alt=""> Carouge.</p>
Here it is used as an icon representing the town:

<p>Home town: <img src="carouge.svg" alt="Carouge"></p>
Here it is used as part of a text on the town:

<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt="The coat of arms depicts a lion, sitting in front of a tree."></p>
<p>It is used as decoration all over the town.</p>
Here it is used as a way to support a similar text where the description is given as well as, instead of as an alternative to, the image:

<p>Carouge has a coat of arms.</p>
<p><img src="carouge.svg" alt=""></p>
<p>The coat of arms depicts a lion, sitting in front of a tree.
It is used as decoration all over the town.</p>
Here it is used as part of a story:

<p>She picked up the folder and a piece of paper fell out.</p>
<p><img src="carouge.svg" alt="Shaped like a shield, the paper had a
red background, a green tree, and a yellow lion with its tongue
hanging out and whose tail was shaped like an S."></p>
<p>She stared at the folder. S! The answer she had been looking for all
this time was simply the letter S! How had she not seen that before? It all
came together now. The phone call where Hector had referred to a lion's tail,
the time Maria had stuck her tongue out...</p>
Here it is not known at the time of publication what the image will be, only that it will be a coat of arms of some kind, and thus no replacement text can be provided, and instead only a brief caption for the image is provided, in the title attribute:

<p>The last user to have uploaded a coat of arms uploaded this one:</p>
<p><img src="last-uploaded-coat-of-arms.cgi" title="User-uploaded coat of arms."></p>
Ideally, the author would find a way to provide real replacement text even in this case, e.g. by asking the previous user. Not providing replacement text makes the document more difficult to use for people who are unable to view images, e.g. blind users, or users or very low-bandwidth connections or who pay by the byte, or users who are forced to use a text-only Web browser.

Here are some more examples showing the same picture used in different contexts, with different appropriate alternate texts each time.

<article>
 <h1>My cats</h1>
 <h2>Fluffy</h2>
 <p>Fluffy is my favorite.</p>
 <img src="fluffy.jpg" alt="She likes playing with a ball of yarn.">
 <p>She's just too cute.</p>
 <h2>Miles</h2>
 <p>My other cat, Miles just eats and sleeps.</p>
</article>
<article>
 <h1>Photography</h1>
 <h2>Shooting moving targets indoors</h2>
 <p>The trick here is to know how to anticipate; to know at what speed and
 what distance the subject will pass by.</p>
 <img src="fluffy.jpg" alt="A cat flying by, chasing a ball of yarn, can be
 photographed quite nicely using this technique.">
 <h2>Nature by night</h2>
 <p>To achieve this, you'll need either an extremely sensitive film, or
 immense flash lights.</p>
</article>
<article>
 <h1>About me</h1>
 <h2>My pets</h2>
 <p>I've got a cat named Fluffy and a dog named Miles.</p>
 <img src="fluffy.jpg" alt="Fluffy, my cat, tends to keep itself busy.">
 <p>My dog Miles and I like go on long walks together.</p>
 <h2>music</h2>
 <p>After our walks, having emptied my mind, I like listening to Bach.</p>
</article>
<article>
 <h1>Fluffy and the Yarn</h1>
 <p>Fluffy was a cat who liked to play with yarn. She also liked to jump.</p>
 <aside><img src="fluffy.jpg" alt="" title="Fluffy"></aside>
 <p>She would play in the morning, she would play in the evening.</p>
</article>
4.8.4 Images
4.8.4.1 Introduction
This section is non-normative.

To embed an image in HTML, when there is only a single image resource, use the img element and its src attribute.

<h2>From today's featured article</h2>
<img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...
However, there are a number of situations for which the author might wish to use multiple image resources that the user agent can choose from:

Different users might have different environmental characteristics:

The users' physical screen size might be different from one another.

A mobile phone's screen might be 4 inches diagonally, while a laptop's screen might be 14 inches diagonally.

4″
14″
This is only relevant when an image's rendered size depends on the viewport size.

The users' screen pixel density might be different from one another.

A mobile phone's screen might have three times as many physical pixels per inch compared to another mobile phone's screen, regardless of their physical screen size.

1x
3x
The users' zoom level might be different from one another, or might change for a single user over time.

A user might zoom in to a particular image to be able to get a more detailed look.

The zoom level and the screen pixel density (the previous point) can both affect the number of physical screen pixels per CSS pixel. This ratio is usually referred to as device-pixel-ratio.

The users' screen orientation might be different from one another, or might change for a single user over time.

A tablet can be held upright or rotated 90 degrees, so that the screen is either "portrait" or "landscape".

Portrait
Landscape
The users' network speed, network latency and bandwidth cost might be different from one another, or might change for a single user over time.

A user might be on a fast, low-latency and constant-cost connection while at work, on a slow, low-latency and constant-cost connection while at home, and on a variable-speed, high-latency and variable-cost connection anywhere else.

Authors might want to show the same image content but with different rendered size depending on, usually, the width of the viewport. This is usually referred to as viewport-based selection.

A Web page might have a banner at the top that always spans the entire viewport width. In this case, the rendered size of the image depends on the physical size of the screen (assuming a maximised browser window).

Another Web page might have images in columns, with a single column for screens with a small physical size, two columns for screens with medium physical size, and three columns for screens with big physical size, with the images varying in rendered size in each case to fill up the viewport. In this case, the rendered size of an image might be bigger in the one-column layout compared to the two-column layout, despite the screen being smaller.

Narrow, 1 column
Medium, 2 columns
Wide, 3 columns
Authors might want to show different image content depending on the rendered size of the image. This is usually referred to as art direction.

When a Web page is viewed on a screen with a large physical size (assuming a maximised browser window), the author might wish to include some less relevant parts surrounding the critical part of the image. When the same Web page is viewed on a screen with a small physical size, the author might wish to show only the critical part of the image.

Authors might want to show the same image content but using different image formats, depending on which image formats the user agent supports. This is usually referred to as image format-based selection.

A Web page might have some images in the JPEG, WebP and JPEG XR image formats, with the latter two having better compression abilities compared to JPEG. Since different user agents can support different image formats, with some formats offering better compression ratios, the author would like to serve the better formats to user agents that support them, while providing JPEG fallback for user agents that don't.

The above situations are not mutually exclusive. For example, it is reasonable to combine different resources for different device-pixel-ratio with different resources for art direction.

While it is possible to solve these problems using scripting, doing so introduces some other problems:

Some user agents aggressively download images specified in the HTML markup, before scripts have had a chance to run, so that Web pages complete loading sooner. If a script changes which image to download, the user agent will potentially start two separate downloads, which can instead cause worse page loading performance.

If the author avoids specifying any image in the HTML markup and instead instantiates a single download from script, that avoids the double download problem above but then no image will be downloaded at all for users with scripting disabled and the aggressive image downloading optimization will also be disabled.

With this in mind, this specification introduces a number of features to address the above problems in a declarative manner.

Device-pixel-ratio-based selection when the rendered size of the image is fixed
The src and srcset attributes on the img element can be used, using the x descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).

The x descriptor is not appropriate when the rendered size of the image depends on the viewport width (viewport-based selection), but can be used together with art direction.

<h2>From today's featured article</h2>
<img src="/uploads/100-marie-lloyd.jpg"
     srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"
     alt="" width="100" height="150">
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...
The user agent can choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.

For backwards compatibility with older user agents that don't yet understand the srcset attribute, one of the URLs is specified in the img element's src attribute. This will result in something useful (though perhaps lower-resolution than the user would like) being displayed even in older user agents. For new user agents, the src attribute participates in the resource selection, as if it was specified in srcset with a 1x descriptor.

The image's rendered size is given in the width and height attributes, which allows the user agent to allocate space for the image before it is downloaded.

Viewport-based selection
The srcset and sizes attributes can be used, using the w descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).

In this example, a banner image takes up the entire viewport width (using appropriate CSS).

<h1><img sizes="100vw" srcset="wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w"
     src="wolf-400.jpg" alt="The rad wolf"></h1>
The user agent will calculate the effective pixel density of each image from the specified w descriptors and the specified rendered size in the sizes attribute. It can then choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.

If the user's screen is 320 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x. On the other hand, if the user's screen is 1200 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x. By using the w descriptors and the sizes attribute, the user agent can choose the correct image source to download regardless of how large the user's device is.

For backwards compatibility, one of the URLs is specified in the img element's src attribute. In new user agents, the src attribute is ignored when the srcset attribute uses w descriptors.

In this example, the Web page has three layouts depending on the width of the viewport. The narrow layout has one column of images (the width of each image is about 100%), the middle layout has two columns of images (the width of each image is about 50%), and the widest layout has three columns of images, and some page margin (the width of each image is about 33%). It breaks between these layouts when the viewport is 30em wide and 50em wide, respectively.

<img sizes="(max-width: 30em) 100vw, (max-width: 50em) 50vw, calc(33vw - 100px)"
     srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"
     src="swing-400.jpg" alt="Kettlebell Swing">
The sizes attribute sets up the layout breakpoints at 30em and 50em, and declares the image sizes between these breakpoints to be 100vw, 50vw, or calc(33vw - 100px). These sizes do not necessarily have to match up exactly with the actual image width as specified in the CSS.

The user agent will pick a width from the sizes attribute, using the first item with a <media-condition> (the part in parentheses) that evaluates to true, or using the last item (calc(33vw - 100px)) if they all evaluate to false.

For example, if the viewport width is 29em, then (max-width: 30em) evaluates to true and 100vw is used, so the image size, for the purpose of resource selection, is 29em. If the viewport width is instead 32em, then (max-width: 30em) evaluates to false, but (max-width: 50em) evaluates to true and 50vw is used, so the image size, for the purpose of resource selection, is 16em (half the viewport width). Notice that the slightly wider viewport results in a smaller image because of the different layout.

The user agent can then calculate the effective pixel density and choose an appropriate resource similarly to the previous example.

Art direction-based selection
The picture element and the source element, together with the media attribute, can be used, to provide multiple images that vary the image content (for instance the smaller image might be a cropped version of the bigger image).

<picture>
  <source media="(min-width: 45em)" srcset="large.jpg">
  <source media="(min-width: 32em)" srcset="med.jpg">
  <img src="small.jpg" alt="The wolf runs through the snow.">
</picture>
The user agent will choose the first source element for which the media query in the media attribute matches, and then choose an appropriate URL from its srcset attribute.

The rendered size of the image varies depending on which resource is chosen. To specify dimensions that the user agent can use before having downloaded the image, CSS can be used.

img { width: 300px; height: 300px }
@media (min-width: 32em) { img { width: 500px; height:300px } }
@media (min-width: 45em) { img { width: 700px; height:400px } }
This example combines art direction- and device-pixel-ratio-based selection. A banner that takes half the viewport is provided in two versions, one for wide screens and one for narrow screens.

<h1>
 <picture>
  <source media="(max-width: 500px)" srcset="banner-phone.jpeg, banner-phone-HD.jpeg 2x">
  <img src="banner.jpeg" srcset="banner-HD.jpeg 2x" alt="The Breakfast Combo">
 </picture>
</h1>
Image format-based selection
The type attribute on the source element can be used, to provide multiple images in different formats.

<h2>From today's featured article</h2>
<picture>
 <source srcset="/uploads/100-marie-lloyd.webp" type="image/webp">
 <source srcset="/uploads/100-marie-lloyd.jxr" type="image/vnd.ms-photo">
 <img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150">
</picture>
<p><b><a href="/wiki/Marie_Lloyd">Marie Lloyd</a></b> (1870–1922)
was an English <a href="/wiki/Music_hall">music hall</a> singer, ...
In this example, the user agent will choose the first source that has a type attribute with a supported MIME type. If the user agent supports WebP images, the first source element will be chosen. If not, but the user agent does support JPEG XR images, the second source element will be chosen. If neither of those formats are supported, the img element will be chosen.

4.8.4.1.1 Adaptive images
This section is non-normative.

CSS and media queries can be used to construct graphical page layouts that adapt dynamically to the user's environment, in particular to different viewport dimensions and pixel densities. For content, however, CSS does not help; instead, we have the img element's srcset attribute and the picture element. This section walks through a sample case showing how to use these features.

Consider a situation where on wide screens (wider than 600 CSS pixels) a 300×150 image named a-rectangle.png is to be used, but on smaller screens (600 CSS pixels and less), a smaller 100×100 image called a-square.png is to be used. The markup for this would look like this:

<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="Barney Frank wears a suit and glasses.">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>
For details on what to put in the alt attribute, see the Requirements for providing text to act as an alternative for images section.

The problem with this is that the user agent does not necessarily know what dimensions to use for the image when the image is loading. To avoid the layout having to be reflowed multiple times as the page is loading, CSS and CSS media queries can be used to provide the dimensions:

<style>
 #a { width: 300px; height: 150px; }
 @media (max-width: 600px) { #a { width: 100px; height: 100px; } }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" alt="Barney Frank wears a suit and glasses." id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>
Alternatively, the width and height attributes can be used to provide the width for legacy user agents, using CSS just for the user agents that support picture:

<style media="(max-width: 600px)">
 #a { width: 100px; height: 100px; }
</style>
<figure>
 <picture>
  <source srcset="a-square.png" media="(max-width: 600px)">
  <img src="a-rectangle.png" width="300" height="150"
  alt="Barney Frank wears a suit and glasses." id="a">
 </picture>
 <figcaption>Barney Frank, 2011</figcaption>
</figure>
The img element is used with the src attribute, which gives the URL of the image to use for legacy user agents that do not support the picture element. This leads to a question of which image to provide in the src attribute.

If the author wants the biggest image in legacy user agents, the markup could be as follows:

<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <img src="pear-desktop.jpeg" alt="The pear is juicy.">
</picture>
However, if legacy mobile user agents are more important, one can list all three images in the source elements, overriding the src attribute entirely.

<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>
Since at this point the src attribute is actually being ignored entirely by picture-supporting user agents, the src attribute can default to any image, including one that is neither the smallest nor biggest:

<picture>
 <source srcset="pear-mobile.jpeg" media="(max-width: 720px)">
 <source srcset="pear-tablet.jpeg" media="(max-width: 1280px)">
 <source srcset="pear-desktop.jpeg">
 <img src="pear-tablet.jpeg" alt="The pear is juicy.">
</picture>
Above the max-width media feature is used, giving the maximum (viewport) dimensions that an image is intended for. It is also possible to use min-width instead.

<picture>
 <source srcset="pear-desktop.jpeg" media="(min-width: 1281px)">
 <source srcset="pear-tablet.jpeg" media="(min-width: 721px)">
 <img src="pear-mobile.jpeg" alt="The pear is juicy.">
</picture>
4.8.4.2 Attributes common to source and img elements
4.8.4.2.1 Srcset attributes
A srcset attribute is an attribute with requirements defined in this section.

If present, its value must consist of one or more image candidate strings, each separated from the next by a U+002C COMMA character (,). If an image candidate string contains no descriptors and no ASCII whitespace after the URL, the following image candidate string, if there is one, must begin with one or more ASCII whitespace.

An image candidate string consists of the following components, in order, with the further restrictions described below this list:

Zero or more ASCII whitespace.

A valid non-empty URL that does not start or end with a U+002C COMMA character (,), referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.

Zero or more ASCII whitespace.

Zero or one of the following:

A width descriptor, consisting of: ASCII whitespace, a valid non-negative integer giving a number greater than zero representing the width descriptor value, and a U+0077 LATIN SMALL LETTER W character.

A pixel density descriptor, consisting of: ASCII whitespace, a valid floating-point number giving a number greater than zero representing the pixel density descriptor value, and a U+0078 LATIN SMALL LETTER X character.

Zero or more ASCII whitespace.

There must not be an image candidate string for an element that has the same width descriptor value as another image candidate string's width descriptor value for the same element.

There must not be an image candidate string for an element that has the same pixel density descriptor value as another image candidate string's pixel density descriptor value for the same element. For the purpose of this requirement, an image candidate string with no descriptors is equivalent to an image candidate string with a 1x descriptor.

If an image candidate string for an element has the width descriptor specified, all other image candidate strings for that element must also have the width descriptor specified.

The specified width in an image candidate string's width descriptor must match the intrinsic width in the resource given by the image candidate string's URL, if it has an intrinsic width.

If an element has a srcset attribute present, all image candidate strings for that element must have the width descriptor specified.

4.8.4.2.2 Sizes attributes
A sizes attribute is an attribute with requirements defined in this section.

If present, the value must be a valid source size list.

A valid source size list is a string that matches the following grammar: [CSSVALUES] [MQ]

<source-size-list> = [ <source-size># , ]? <source-size-value>
<source-size> = <media-condition> <source-size-value>
<source-size-value> = <length>
A <source-size-value> must not be negative, and must not use CSS functions other than the 'calc()' function.

The <source-size-value> gives the intended layout width of the image. The author can specify different widths for different environments with <media-condition>s.

Percentages are not allowed in a <source-size-value>, to avoid confusion about what it would be relative to. The 'vw' unit can be used for sizes relative to the viewport width.

4.8.4.3 Processing model
The task source for the tasks queued by algorithms in this section is the DOM manipulation task source.

An img element has a current request and a pending request. The current request is initially set to a new image request. The pending request is initially set to null.


Spec bugs: 27484

An image request has a state, current URL, and image data.

An image request's state is one of the following:

Unavailable
The user agent hasn't obtained any image data, or has obtained some or all of the image data but hasn't yet decoded enough of the image to get the image dimensions.
Partially available
The user agent has obtained some of the image data and at least the image dimensions are available.
Completely available
The user agent has obtained all of the image data and at least the image dimensions are available.
Broken
The user agent has obtained all of the image data that it can, but it cannot even decode the image enough to get the image dimensions (e.g. the image is corrupted, or the format is not supported, or no data could be obtained).
An image request's current URL is initially the empty string.

An image request's image data is the decoded image data.

When an image request's state is either partially available or completely available, the image request is said to be available.

When an img element's current request's state is completely available and the user agent can decode the media data without errors, then the img element is said to be fully decodable.

An image request's state is initially unavailable.

When an img element's current request is available, the img element provides a paint source whose width is the image's density-corrected intrinsic width (if any), whose height is the image's density-corrected intrinsic height (if any), and whose appearance is the intrinsic appearance of the image.

An img element is said to use srcset or picture if it has a srcset attribute specified or if it has a parent that is a picture element.

Each img element has a last selected source, which must initially be null.

Each image request has a current pixel density, which must initially be undefined.

When an img element has a current pixel density that is not 1.0, the element's image data must be treated as if its resolution, in device pixels per CSS pixels, was the current pixel density. The image's density-corrected intrinsic width and height are the intrinsic width and height after taking into account the current pixel density.

For example, if the current pixel density is 3.125, that means that there are 300 device pixels per CSS inch, and thus if the image data is 300x600, it has intrinsic dimensions of 96 CSS pixels by 192 CSS pixels.

An img element is associated with a source set.

A source set is an ordered set of zero or more image sources and a source size.

An image source is a URL, and optionally either a pixel density descriptor, or a width descriptor.

A source size is a <source-size-value>. When a source size has a unit relative to the viewport, it must be interpreted relative to the img element's node document's viewport. Other units must be interpreted the same as in Media Queries. [MQ]

A parse error for algorithms in this section indicates a non-fatal mismatch between input and requirements. User agents are encouraged to expose parse errors somehow.

Whether the image is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the image's type and whether it is a valid image.

This allows servers to return images with error responses, and have them displayed.

The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type headers giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's associated Content-Type headers.


Spec bugs: 25889, 26702

User agents must not support non-image resources with the img element (e.g. XML files whose document element is an HTML element). User agents must not run executable code (e.g. scripts) embedded in the image resource. User agents must only display the first page of a multipage resource (e.g. a PDF file). User agents must not allow the resource to act in an interactive fashion, but should honour any animation in the resource.

This specification does not specify which image types are to be supported.

4.8.4.3.1 When to obtain images
In a browsing context where scripting is disabled, user agents may obtain images immediately or on demand. In a browsing context where scripting is enabled, user agents must obtain images immediately.

A user agent that obtains images immediately must synchronously update the image data of an img element, with the restart animation flag set if so stated, whenever that element is created or has experienced relevant mutations.

A user agent that obtains images on demand must update the image data of an img element whenever it needs the image data (i.e., on demand), but only if the img element's current request's state is unavailable. When an img element has experienced relevant mutations, if the user agent only obtains images on demand, the img element's current request's state must return to unavailable.

4.8.4.3.2 Reacting to DOM mutations
The relevant mutations for an img element are as follows:

The element's src, srcset, width, or sizes attributes are set, changed, or removed.

The element's src attribute is set to the same value as the previous value. This must set the restart animation flag for the update the image data algorithm.

The element's crossorigin attribute's state is changed.

The element is inserted into or removed from a picture parent element.

The element's parent is a picture element and a source element is inserted as a previous sibling.

The element's parent is a picture element and a source element that was a previous sibling is removed.

The element's parent is a picture element and a source element that is a previous sibling has its srcset, sizes, media, or type attributes set, changed, or removed.

The element's adopting steps are run.

4.8.4.3.3 The list of available images
Each Document object must have a list of available images. Each image in this list is identified by a tuple consisting of an absolute URL, a CORS settings attribute mode, and, if the mode is not No CORS, an origin. Each image furthermore has an ignore higher-layer caching flag. User agents may copy entries from one Document object's list of available images to another at any time (e.g. when the Document is created, user agents can add to it all the images that are loaded in other Documents), but must not change the keys of entries copied in this way when doing so, and must unset the ignore higher-layer caching flag for the copied entry. User agents may also remove images from such lists at any time (e.g. to save memory). User agents must remove entries in the list of available images as appropriate given higher-layer caching semantics for the resource (e.g. the HTTP `Cache-Control` response header) when the ignore higher-layer caching flag is unset.

The list of available images is intended to enable synchronous switching when changing the src attribute to a URL that has previously been loaded, and to avoid re-downloading images in the same document even when they don't allow caching per HTTP. It is not used to avoid re-downloading the same image while the previous image is still loading.

The user agent can also store the image data separately from the list of available images.

For example, if a resource has the HTTP response header `Cache-Control: must-revalidate`, and its ignore higher-layer caching flag is unset, the user agent would remove it from the list of available images but could keep the image data separately, and use that if the server responds with a 304 Not Modified status.

4.8.4.3.4 Decoding images
Image data is usually encoded in order to reduce file size. This means that in order for the user agent to present the image to the screen, the data needs to be decoded. Decoding is the process which converts an image's media data into a bitmap form, suitable for presentation to the screen. Note that this process can be slow relative to other processes involved in presenting content. Thus, the user agent can choose when to perform decoding, in order to create the best user experience.

Image decoding is said to be synchronous if it prevents presentation of other content until it is finished. Typically, this has an effect of atomically presenting the image and any other content at the same time. However, this presentation is delayed by the amount of time it takes to perform the decode.

Image decoding is said to be asynchronous if it does not prevent presentation of other content. This has an effect of presenting non-image content faster. However, the image content is missing on screen until the decode finishes. Once the decode is finished, the screen is updated with the image.

In both synchronous and asynchronous decoding modes, the final content is presented to screen after the same amount of time has elapsed. The main difference is whether the user agent presents non-image content ahead of presenting the final content.

In order to aid the user agent in deciding whether to perform synchronous or asynchronous decode, the decoding attribute can be set on img elements. The possible values of of the decoding attribute are the following image decoding hint keywords:

Keyword	State	Description
sync	Sync	Indicates a preference to decode this image synchronously for atomic presentation with other content.
async	Async	Indicates a preference to decode this image asynchronously to avoid delaying presentation of other content.
auto	Auto	Indicates no preference in decoding mode (the default).
When decoding an image, the user agent should respect the preference indicated by the decoding attribute's state. If the state indicated is auto, then the user agent is free to choose any decoding behavior.

It is also possible to control the decoding behavior using the decode() method. Since the decode() method performs decoding independently from the process responsible for presenting content to screen, it is unaffected by the decoding attribute.

4.8.4.3.5 Updating the image data
When the user agent is to update the image data of an img element, optionally with the restart animations flag set, it must run the following steps:


Spec bugs: 24597, 24712

If the element's node document is not the active document, then:

Continue running this algorithm in parallel.

Wait until the element's node document is the active document.

If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.

Queue a microtask to continue this algorithm.

If the user agent cannot support images, or its support for images has been disabled, then abort the image request for the current request and the pending request, set current request's state to unavailable, set pending request to null, and return.

Let selected source be null and selected pixel density be undefined.

If the element does not use srcset or picture and it has a src attribute specified whose value is not the empty string, then set selected source to the value of the element's src attribute and set selected pixel density to 1.0.

Set the element's last selected source to selected source.

If selected source is not null, then:

Parse selected source, relative to the element's node document. If that is not successful, then abort this inner set of steps. Otherwise, let urlString be the resulting URL string.

Let key be a tuple consisting of urlString, the img element's crossorigin attribute's mode, and, if that mode is not No CORS, the node document's origin.

If the list of available images contains an entry for key, then:

Set the ignore higher-layer caching flag for that entry.

Abort the image request for the current request and the pending request.

Set pending request to null.

Let current request be a new image request whose image data is that of the entry and whose state is completely available.

Update the presentation of the image appropriately.

Set current request's current pixel density to selected pixel density.

Queue a task to:

If restart animation is set, then restart the animation.

Set current request's current URL to urlString.

Fire an event named load at the img element.

Abort the update the image data algorithm.

Await a stable state, allowing the task that invoked this algorithm to continue. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

⌛ If another instance of this algorithm for this img element was started after this instance (even if it aborted and is no longer running), then return.

Only the last instance takes effect, to avoid multiple requests when, for example, the src, srcset, and crossorigin attributes are all set in succession.

⌛ Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.

⌛ If selected source is null, then:

⌛ Set the current request's state to broken, abort the image request for the current request and the pending request, and set pending request to null.

⌛ Queue a task to change the current request's current URL to the empty string, and then, if the element has a src attribute or it uses srcset or picture, fire an event named error at the img element.

⌛ Return.

⌛ Queue a task to fire a progress event named loadstart at the img element.

⌛ Parse selected source, relative to the element's node document, and let urlString be the resulting URL string. If that is not successful, then:

⌛ Abort the image request for the current request and the pending request.

⌛ Set the current request's state to broken.

⌛ Set pending request to null.

⌛ Queue a task to change the current request's current URL to selected source, fire an event named error at the img element and then fire an event named loadend at the img element.

⌛ Return.

⌛ If the pending request is not null and urlString is the same as the pending request's current URL, then return.

⌛ If urlString is the same as the current request's current URL and current request's state is partially available, then abort the image request for the pending request, queue a task to restart the animation if restart animation is set, and return.

⌛ If the pending request is not null, then abort the image request for the pending request.

⌛ Set image request to a new image request whose current URL is urlString.

⌛ If current request's state is unavailable or broken, then set the current request to image request. Otherwise, set the pending request to image request.

⌛ Let request be the result of creating a potential-CORS request given urlString, "image", and the current state of the element's crossorigin content attribute.

⌛ Set request's client to the element's node document's Window object's environment settings object.

⌛ If the element uses srcset or picture, set request's initiator to "imageset".

⌛ Set request's referrer policy to the current state of the element's referrerpolicy attribute.

⌛ Fetch request. Let this instance of the fetching algorithm be associated with image request.

The resource obtained in this fashion, if any, is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the origin of the image itself (e.g. when used on a canvas).

Fetching the image must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined below) has been run.

This, unfortunately, can be used to perform a rudimentary port scan of the user's local network (especially in conjunction with scripting, though scripting isn't actually necessary to carry out such an attack). User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing Web content.

If the resource is CORS-same-origin, each task that is queued by the networking task source while the image is being fetched, if image request is the current request, must fire a progress event named progress at the img element.

End the synchronous section, continuing the remaining steps in parallel, but without missing any data from fetching.

As soon as possible, jump to the first applicable entry from the following list:

If the resource type is multipart/x-mixed-replace
The next task that is queued by the networking task source while the image is being fetched must run the following steps:

If image request is the pending request and at least one body part has been completely decoded, abort the image request for the current request, upgrade the pending request to the current request.

Otherwise, if image request is the pending request and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, abort the image request for the current request, upgrade the pending request to the current request, and set the current request's state to broken.

Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine image request's image's width and height, set the current request's state to partially available.

Otherwise, if image request is the current request, its state is unavailable, and the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, set the current request's state to broken.

Each task that is queued by the networking task source while the image is being fetched must update the presentation of the image, but as each new body part comes in, it must replace the previous image. Once one body part has been completely decoded, the user agent must set the img element's current request's state to completely available and queue a task to fire an event named load at the img element.

The progress and loadend events are not fired for multipart/x-mixed-replace image streams.

If the resource type and data corresponds to a supported image format, as described below
The next task that is queued by the networking task source while the image is being fetched must run the following steps:

If the user agent is able to determine image request's image's width and height, and image request is pending request, set image request's state to partially available.

Otherwise, if the user agent is able to determine image request's image's width and height, and image request is current request, update the img element's presentation appropriately and set image request's state to partially available.

Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is pending request, abort the image request for the current request and the pending request, upgrade the pending request to the current request, set current request's state to broken, fire an event named error at the img element, fire an event named loadend at the img element.

Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, and image request is current request, abort the image request for image request, fire an event named error at the img element, fire an event named loadend at the img element.

That task, and each subsequent task, that is queued by the networking task source while the image is being fetched, if image request is the current request, must update the presentation of the image appropriately (e.g., if the image is a progressive JPEG, each packet can improve the resolution of the image).


Spec bugs: 25797, 25798

Furthermore, the last task that is queued by the networking task source once the resource has been fetched must additionally run these steps:

If image request is the pending request, abort the image request for the current request, upgrade the pending request to the current request and update the img element's presentation appropriately.

Set image request to the completely available state.

Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.

Fire a progress event or event named load at the img element, depending on the resource in image request.

Fire a progress event or event named loadend at the img element, depending on the resource in image request.

Otherwise
The image data is not in a supported file format; the user agent must set image request's state to broken, abort the image request for the current request and the pending request, upgrade the pending request to the current request if image request is the pending request, and then queue a task to first fire an event named error at the img element and then fire an event named loadend at the img element.

While a user agent is running the above algorithm for an element x, there must be a strong reference from the element's node document to the element x, even if that element is not connected.

To abort the image request for an image request image request means to run the following steps:

Forget image request's image data, if any.

Abort any instance of the fetching algorithm for image request, discarding any pending tasks generated by that algorithm.

To upgrade the pending request to the current request for an img element means to run the following steps:

Let the img element's current request be the pending request.

Let the img element's pending request be null.

To fire a progress event or event named type at an element e, depending on resource r, means to fire a progress event named type at e if r is CORS-same-origin, and otherwise fire an event named type at e.

4.8.4.3.6 Selecting an image source
When asked to select an image source for a given img element el, user agents must do the following:

Update the source set for el.

If el's source set is empty, return null as the URL and undefined as the pixel density.

Otherwise, take el's source set and let it be source set.

If an entry b in source set has the same associated pixel density descriptor as an earlier entry a in source set, then remove entry b. Repeat this step until none of the entries in source set have the same associated pixel density descriptor as an earlier entry.

In a user agent-specific manner, choose one image source from source set. Let this be selected source.

Return selected source and its associated pixel density.

4.8.4.3.7 Updating the source set
When asked to update the source set for a given img element el, user agents must do the following:

Set el's source set to an empty source set.

If el has a parent node and that is a picture element, let elements be an array containing el's parent node's child elements, retaining relative order. Otherwise, let elements be array containing only el.

If el has a width attribute, and parsing that attribute's value using the rules for parsing dimension values doesn't generate an error or a percentage value, then let width be the returned integer value. Otherwise, let width be null.

Iterate through elements, doing the following for each item child:

If child is el:

If child has a srcset attribute, parse child's srcset attribute and let the returned source set be source set. Otherwise, let source set be an empty source set.

Parse child's sizes attribute with the fallback width width, and let source set's source size be the returned value.

If child has a src attribute whose value is not the empty string and source set does not contain an image source with a pixel density descriptor value of 1, and no image source with a width descriptor, append child's src attribute value to source set.

Normalize the source densities of source set.

Let el's source set be source set.

Return.

If child is not a source element, continue to the next child. Otherwise, child is a source element.

If child does not have a srcset attribute, continue to the next child.

Parse child's srcset attribute and let the returned source set be source set.

If source set has zero image sources, continue to the next child.

If child has a media attribute, and its value does not match the environment, continue to the next child.

Parse child's sizes attribute with the fallback width width, and let source set's source size be the returned value.

If child has a type attribute, and its value is an unknown or unsupported MIME type, continue to the next child.

Normalize the source densities of source set.

Let el's source set be source set.

Return.

Each img element independently considers its previous sibling source elements plus the img element itself for selecting an image source, ignoring any other (invalid) elements, including other img elements in the same picture element, or source elements that are following siblings of the relevant img element.

4.8.4.3.8 Parsing a srcset attribute
When asked to parse a srcset attribute from an element, parse the value of the element's srcset attribute as follows:

Let input be the value passed to this algorithm.

Let position be a pointer into input, initially pointing at the start of the string.

Let candidates be an initially empty source set.

Splitting loop: Collect a sequence of code points that are ASCII whitespace or U+002C COMMA characters from input given position. If any U+002C COMMA characters were collected, that is a parse error.

If position is past the end of input, return candidates.

Collect a sequence of code points that are not ASCII whitespace from input given position, and let that be url.

Let descriptors be a new empty list.

If url ends with U+002C (,), then:

Remove all trailing U+002C COMMA characters from url. If this removed more than one character, that is a parse error.

Otherwise:

Descriptor tokenizer: Skip ASCII whitespace within input given position.

Let current descriptor be the empty string.

Let state be in descriptor.

Let c be the character at position. Do the following depending on the value of state. For the purpose of this step, "EOF" is a special character representing that position is past the end of input.

In descriptor
Do the following, depending on the value of c:

ASCII whitespace
If current descriptor is not empty, append current descriptor to descriptors and let current descriptor be the empty string. Set state to after descriptor.

U+002C COMMA (,)
Advance position to the next character in input. If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

U+0028 LEFT PARENTHESIS (()
Append c to current descriptor. Set state to in parens.

EOF
If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

Anything else
Append c to current descriptor.

In parens
Do the following, depending on the value of c:

U+0029 RIGHT PARENTHESIS ())
Append c to current descriptor. Set state to in descriptor.

EOF
Append current descriptor to descriptors. Jump to the step labeled descriptor parser.

Anything else
Append c to current descriptor.

After descriptor
Do the following, depending on the value of c:

ASCII whitespace
Stay in this state.

EOF
Jump to the step labeled descriptor parser.

Anything else
Set state to in descriptor. Set position to the previous character in input.

Advance position to the next character in input. Repeat this step.

In order to be compatible with future additions, this algorithm supports multiple descriptors and descriptors with parens.

Descriptor parser: Let error be no.

Let width be absent.

Let density be absent.

Let future-compat-h be absent.

For each descriptor in descriptors, run the appropriate set of steps from the following list:

If the descriptor consists of a valid non-negative integer followed by a U+0077 LATIN SMALL LETTER W character
If the user agent does not support the sizes attribute, let error be yes.

A conforming user agent will support the sizes attribute. However, user agents typically implement and ship features in an incremental manner in practice.

If width and density are not both absent, then let error be yes.

Apply the rules for parsing non-negative integers to the descriptor. If the result is zero, let error be yes. Otherwise, let width be the result.

If the descriptor consists of a valid floating-point number followed by a U+0078 LATIN SMALL LETTER X character
If width, density and future-compat-h are not all absent, then let error be yes.

Apply the rules for parsing floating-point number values to the descriptor. If the result is less than zero, let error be yes. Otherwise, let density be the result.

If density is zero, the intrinsic dimensions will be infinite. User agents are expected to have limits in how big images can be rendered, which is allowed by the hardware limitations clause.

If the descriptor consists of a valid non-negative integer followed by a U+0068 LATIN SMALL LETTER H character
This is a parse error.

If future-compat-h and density are not both absent, then let error be yes.

Apply the rules for parsing non-negative integers to the descriptor. If the result is zero, let error be yes. Otherwise, let future-compat-h be the result.

Anything else
Let error be yes.

If future-compat-h is not absent and width is absent, let error be yes.

If error is still no, then append a new image source to candidates whose URL is url, associated with a width width if not absent and a pixel density density if not absent. Otherwise, there is a parse error.

Return to the step labeled splitting loop.

4.8.4.3.9 Parsing a sizes attribute
When asked to parse a sizes attribute from an element, with a fallback width width, parse a comma-separated list of component values from the value of the element's sizes attribute (or the empty string, if the attribute is absent), and let unparsed sizes list be the result. [CSSSYNTAX]

For each unparsed size in unparsed sizes list:

Remove all consecutive <whitespace-token>s from the end of unparsed size. If unparsed size is now empty, that is a parse error; continue to the next iteration of this algorithm.

If the last component value in unparsed size is a valid non-negative <source-size-value>, let size be its value and remove the component value from unparsed size. Any CSS function other than the 'calc()' function is invalid. Otherwise, there is a parse error; continue to the next iteration of this algorithm.

Remove all consecutive <whitespace-token>s from the end of unparsed size. If unparsed size is now empty, return size and exit this algorithm. If this was not the last item in unparsed sizes list, that is a parse error.

Parse the remaining component values in unparsed size as a <media-condition>. If it does not parse correctly, or it does parse correctly but the <media-condition> evaluates to false, continue to the next iteration of this algorithm. [MQ]

Return size and exit this algorithm.

If the above algorithm exhausts unparsed sizes list without returning a size value, follow these steps:

If width is not null, return a <length> with the value width and the unit 'px'.

Return 100vw.

While a valid source size list only contains a bare <source-size-value> (without an accompanying <media-condition>) as the last entry in the <source-size-list>, the parsing algorithm technically allows such at any point in the list, and will accept it immediately as the size if the preceding entries in the list weren't used. This is to enable future extensions, and protect against simple author errors such as a final trailing comma.

4.8.4.3.10 Normalizing the source densities
An image source can have a pixel density descriptor, a width descriptor, or no descriptor at all accompanying its URL. Normalizing a source set gives every image source a pixel density descriptor.

When asked to normalize the source densities of a source set source set, the user agent must do the following:

Let source size be source set's source size.

For each image source in source set:

If the image source has a pixel density descriptor, continue to the next image source.

Otherwise, if the image source has a width descriptor, replace the width descriptor with a pixel density descriptor with a value of the width descriptor value divided by the source size and a unit of x.

If the source size is zero, the density would be infinity, which results in the intrinsic dimensions being zero by zero.

Otherwise, give the image source a pixel density descriptor of 1x.

4.8.4.3.11 Reacting to environment changes
The user agent may at any time run the following algorithm to update an img element's image in order to react to changes in the environment. (User agents are not required to ever run this algorithm; for example, if the user is not looking at the page any more, the user agent might want to wait until the user has returned to the page before determining which image to use, in case the environment changes again in the meantime.)

User agents are encouraged to run this algorithm in particular when the user changes the viewport's size (e.g. by resizing the window or changing the page zoom), and when an img element is inserted into a document, so that the density-corrected intrinsic width and height match the new viewport, and so that the correct image is chosen when art direction is involved.

Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

⌛ If the img element does not use srcset or picture, its node document is not the active document, has image data whose resource type is multipart/x-mixed-replace, or the pending request is not null, then return.

⌛ Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source, respectively.

⌛ If selected source is null, then return.

⌛ If selected source and selected pixel density are the same as the element's last selected source and current pixel density, then return.

⌛ Parse selected source, relative to the element's node document, and let urlString be the resulting URL string. If that is not successful, then return.

⌛ Let corsAttributeState be the state of the element's crossorigin content attribute.

⌛ Let origin be the origin of the img element's node document.

⌛ Let client be the img element's node document's Window object's environment settings object.

⌛ Let key be a tuple consisting of urlString, corsAttributeState, and, if corsAttributeState is not No CORS, origin.

⌛ Let image request be a new image request whose current URL is urlString

⌛ Let the element's pending request be image request.

End the synchronous section, continuing the remaining steps in parallel.

If the list of available images contains an entry for key, then set image request's image data to that of the entry. Continue to the next step.

Otherwise:

Let request be the result of creating a potential-CORS request given urlString, "image", and corsAttributeState.

Set request's client to client, initiator to "imageset", and set request's synchronous flag.

Set request's referrer policy to the current state of the element's referrerpolicy attribute.

Let response be the result of fetching request.

If response's unsafe response is a network error or if the image format is unsupported (as determined by applying the image sniffing rules, again as mentioned earlier), or if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, or if the resource type is multipart/x-mixed-replace, then let pending request be null and abort these steps.

Otherwise, response's unsafe response is image request's image data. It can be either CORS-same-origin or CORS-cross-origin; this affects the origin of the image itself (e.g., when used on a canvas).

Queue a task to run these steps:

If the img element has experienced relevant mutations since this algorithm started, then let pending request be null and abort these steps.

Let the img element's last selected source be selected source and the img element's current pixel density be selected pixel density.

Set the image request's state to completely available.

Add the image to the list of available images using the key key, with the ignore higher-layer caching flag set.

Upgrade the pending request to the current request.

Update the img element's presentation appropriately.

Fire an event named load at the img element.

4.8.4.4 Requirements for providing text to act as an alternative for images
4.8.4.4.1 General guidelines
Except where otherwise specified, the alt attribute must be specified and its value must not be empty; the value must be an appropriate replacement for the image. The specific requirements for the alt attribute depend on what the image is intended to represent, as described in the following sections.

The most general rule to consider when writing alternative text is the following: the intent is that replacing every image with the text of its alt attribute not change the meaning of the page.

So, in general, alternative text can be written by considering what one would have written had one not been able to include the image.

A corollary to this is that the alt attribute's value should never contain text that could be considered the image's caption, title, or legend. It is supposed to contain replacement text that could be used by users instead of the image; it is not meant to supplement the image. The title attribute can be used for supplemental information.

Another corollary is that the alt attribute's value should not repeat information that is already provided in the prose next to the image.

One way to think of alternative text is to think about how you would read the page containing the image to someone over the phone, without mentioning that there is an image present. Whatever you say instead of the image is typically a good start for writing the alternative text.

4.8.4.4.2 A link or button containing nothing but the image
When an a element that creates a hyperlink, or a button element, has no textual content but contains one or more images, the alt attributes must contain text that together convey the purpose of the link or button.

In this example, a user is asked to pick their preferred color from a list of three. Each color is given by an image, but for users who have configured their user agent not to display images, the color names are used instead:

<h1>Pick your color</h1>
<ul>
 <li><a href="green.html"><img src="green.jpeg" alt="Green"></a></li>
 <li><a href="blue.html"><img src="blue.jpeg" alt="Blue"></a></li>
 <li><a href="red.html"><img src="red.jpeg" alt="Red"></a></li>
</ul>
In this example, each button has a set of images to indicate the kind of color output desired by the user. The first image is used in each case to give the alternative text.

<button name="rgb"><img src="red" alt="RGB"><img src="green" alt=""><img src="blue" alt=""></button>
<button name="cmyk"><img src="cyan" alt="CMYK"><img src="magenta" alt=""><img src="yellow" alt=""><img src="black" alt=""></button>
Since each image represents one part of the text, it could also be written like this:

<button name="rgb"><img src="red" alt="R"><img src="green" alt="G"><img src="blue" alt="B"></button>
<button name="cmyk"><img src="cyan" alt="C"><img src="magenta" alt="M"><img src="yellow" alt="Y"><img src="black" alt="K"></button>
However, with other alternative text, this might not work, and putting all the alternative text into one image in each case might make more sense:

<button name="rgb"><img src="red" alt="sRGB profile"><img src="green" alt=""><img src="blue" alt=""></button>
<button name="cmyk"><img src="cyan" alt="CMYK profile"><img src="magenta" alt=""><img src="yellow" alt=""><img src="black" alt=""></button>
4.8.4.4.3 A phrase or paragraph with an alternative graphical representation: charts, diagrams, graphs, maps, illustrations
Sometimes something can be more clearly stated in graphical form, for example as a flowchart, a diagram, a graph, or a simple map showing directions. In such cases, an image can be given using the img element, but the lesser textual version must still be given, so that users who are unable to view the image (e.g. because they have a very slow connection, or because they are using a text-only browser, or because they are listening to the page being read out by a hands-free automobile voice Web browser, or simply because they are blind) are still able to understand the message being conveyed.

The text must be given in the alt attribute, and must convey the same message as the image specified in the src attribute.

It is important to realize that the alternative text is a replacement for the image, not a description of the image.

In the following example we have a flowchart in image form, with text in the alt attribute rephrasing the flowchart in prose form:

<p>In the common case, the data handled by the tokenization stage
comes from the network, but it can also come from script.</p>
<p><img src="images/parsing-model-overview.svg" alt="The Network
passes data to the Input Stream Preprocessor, which passes it to the
Tokenizer, which passes it to the Tree Construction stage. From there,
data goes to both the DOM and to Script Execution. Script Execution is
linked to the DOM, and, using document.write(), passes data to the
Tokenizer."></p>
Here's another example, showing a good solution and a bad solution to the problem of including an image in a description.

First, here's the good solution. This sample shows how the alternative text should just be what you would have put in the prose if the image had never existed.

<!-- This is the correct way to do things. -->
<p>
 You are standing in an open field west of a house.
 <img src="house.jpeg" alt="The house is white, with a boarded front door.">
 There is a small mailbox here.
</p>
Second, here's the bad solution. In this incorrect way of doing things, the alternative text is simply a description of the image, instead of a textual replacement for the image. It's bad because when the image isn't shown, the text doesn't flow as well as in the first example.

<!-- This is the wrong way to do things. -->
<p>
 You are standing in an open field west of a house.
 <img src="house.jpeg" alt="A white house, with a boarded front door.">
 There is a small mailbox here.
</p>
Text such as "Photo of white house with boarded door" would be equally bad alternative text (though it could be suitable for the title attribute or in the figcaption element of a figure with this image).

4.8.4.4.4 A short phrase or label with an alternative graphical representation: icons, logos
A document can contain information in iconic form. The icon is intended to help users of visual browsers to recognize features at a glance.

In some cases, the icon is supplemental to a text label conveying the same meaning. In those cases, the alt attribute must be present but must be empty.

Here the icons are next to text that conveys the same meaning, so they have an empty alt attribute:

<nav>
 <p><a href="/help/"><img src="/icons/help.png" alt=""> Help</a></p>
 <p><a href="/configure/"><img src="/icons/configuration.png" alt="">
 Configuration Tools</a></p>
</nav>
In other cases, the icon has no text next to it describing what it means; the icon is supposed to be self-explanatory. In those cases, an equivalent textual label must be given in the alt attribute.

Here, posts on a news site are labeled with an icon indicating their topic.

<body>
 <article>
  <header>
   <h1>Ratatouille wins <i>Best Movie of the Year</i> award</h1>
   <p><img src="movies.png" alt="Movies"></p>
  </header>
  <p>Pixar has won yet another <i>Best Movie of the Year</i> award,
  making this its 8th win in the last 12 years.</p>
 </article>
 <article>
  <header>
   <h1>Latest TWiT episode is online</h1>
   <p><img src="podcasts.png" alt="Podcasts"></p>
  </header>
  <p>The latest TWiT episode has been posted, in which we hear
  several tech news stories as well as learning much more about the
  iPhone. This week, the panelists compare how reflective their
  iPhones' Apple logos are.</p>
 </article>
</body>
Many pages include logos, insignia, flags, or emblems, which stand for a particular entity such as a company, organization, project, band, software package, country, or some such.

If the logo is being used to represent the entity, e.g. as a page heading, the alt attribute must contain the name of the entity being represented by the logo. The alt attribute must not contain text like the word "logo", as it is not the fact that it is a logo that is being conveyed, it's the entity itself.

If the logo is being used next to the name of the entity that it represents, then the logo is supplemental, and its alt attribute must instead be empty.

If the logo is merely used as decorative material (as branding, or, for example, as a side image in an article that mentions the entity to which the logo belongs), then the entry below on purely decorative images applies. If the logo is actually being discussed, then it is being used as a phrase or paragraph (the description of the logo) with an alternative graphical representation (the logo itself), and the first entry above applies.

In the following snippets, all four of the above cases are present. First, we see a logo used to represent a company:

<h1><img src="XYZ.gif" alt="The XYZ company"></h1>
Next, we see a paragraph which uses a logo right next to the company name, and so doesn't have any alternative text:

<article>
 <h2>News</h2>
 <p>We have recently been looking at buying the <img src="alpha.gif"
 alt=""> ΑΒΓ company, a small Greek company
 specializing in our type of product.</p>
In this third snippet, we have a logo being used in an aside, as part of the larger article discussing the acquisition:

 <aside><p><img src="alpha-large.gif" alt=""></p></aside>
 <p>The ΑΒΓ company has had a good quarter, and our
 pie chart studies of their accounts suggest a much bigger blue slice
 than its green and orange slices, which is always a good sign.</p>
</article>
Finally, we have an opinion piece talking about a logo, and the logo is therefore described in detail in the alternative text.

<p>Consider for a moment their logo:</p>

<p><img src="/images/logo" alt="It consists of a green circle with a
green question mark centered inside it."></p>

<p>How unoriginal can you get? I mean, oooooh, a question mark, how
<em>revolutionary</em>, how utterly <em>ground-breaking</em>, I'm
sure everyone will rush to adopt those specifications now! They could
at least have tried for some sort of, I don't know, sequence of
rounded squares with varying shades of green and bold white outlines,
at least that would look good on the cover of a blue book.</p>
This example shows how the alternative text should be written such that if the image isn't available, and the text is used instead, the text flows seamlessly into the surrounding text, as if the image had never been there in the first place.

4.8.4.4.5 Text that has been rendered to a graphic for typographical effect
Sometimes, an image just consists of text, and the purpose of the image is not to highlight the actual typographic effects used to render the text, but just to convey the text itself.

In such cases, the alt attribute must be present but must consist of the same text as written in the image itself.

Consider a graphic containing the text "Earth Day", but with the letters all decorated with flowers and plants. If the text is merely being used as a heading, to spice up the page for graphical users, then the correct alternative text is just the same text "Earth Day", and no mention need be made of the decorations:

<h1><img src="earthdayheading.png" alt="Earth Day"></h1>
An illuminated manuscript might use graphics for some of its images. The alternative text in such a situation is just the character that the image represents.

<p><img src="initials/o.svg" alt="O">nce upon a time and a long long time ago, late at
night, when it was dark, over the hills, through the woods, across a great ocean, in a land far
away, in a small house, on a hill, under a full moon...
When an image is used to represent a character that cannot otherwise be represented in Unicode, for example gaiji, itaiji, or new characters such as novel currency symbols, the alternative text should be a more conventional way of writing the same thing, e.g. using the phonetic hiragana or katakana to give the character's pronunciation.

In this example from 1997, a new-fangled currency symbol that looks like a curly E with two bars in the middle instead of one is represented using an image. The alternative text gives the character's pronunciation.

<p>Only <img src="euro.png" alt="euro ">5.99!
An image should not be used if characters would serve an identical purpose. Only when the text cannot be directly represented using text, e.g., because of decorations or because there is no appropriate character (as in the case of gaiji), would an image be appropriate.

If an author is tempted to use an image because their default system font does not support a given character, then Web Fonts are a better solution than images.

4.8.4.4.6 A graphical representation of some of the surrounding text
In many cases, the image is actually just supplementary, and its presence merely reinforces the surrounding text. In these cases, the alt attribute must be present but its value must be the empty string.

In general, an image falls into this category if removing the image doesn't make the page any less useful, but including the image makes it a lot easier for users of visual browsers to understand the concept.

A flowchart that repeats the previous paragraph in graphical form:

<p>The Network passes data to the Input Stream Preprocessor, which
passes it to the Tokenizer, which passes it to the Tree Construction
stage. From there, data goes to both the DOM and to Script Execution.
Script Execution is linked to the DOM, and, using document.write(),
passes data to the Tokenizer.</p>
<p><img src="images/parsing-model-overview.svg" alt=""></p>
In these cases, it would be wrong to include alternative text that consists of just a caption. If a caption is to be included, then either the title attribute can be used, or the figure and figcaption elements can be used. In the latter case, the image would in fact be a phrase or paragraph with an alternative graphical representation, and would thus require alternative text.

<!-- Using the title="" attribute -->
<p>The Network passes data to the Input Stream Preprocessor, which
passes it to the Tokenizer, which passes it to the Tree Construction
stage. From there, data goes to both the DOM and to Script Execution.
Script Execution is linked to the DOM, and, using document.write(),
passes data to the Tokenizer.</p>
<p><img src="images/parsing-model-overview.svg" alt=""
        title="Flowchart representation of the parsing model."></p>
<!-- Using <figure> and <figcaption> -->
<p>The Network passes data to the Input Stream Preprocessor, which
passes it to the Tokenizer, which passes it to the Tree Construction
stage. From there, data goes to both the DOM and to Script Execution.
Script Execution is linked to the DOM, and, using document.write(),
passes data to the Tokenizer.</p>
<figure>
 <img src="images/parsing-model-overview.svg" alt="The Network leads to
 the Input Stream Preprocessor, which leads to the Tokenizer, which
 leads to the Tree Construction stage. The Tree Construction stage
 leads to two items. The first is Script Execution, which leads via
 document.write() back to the Tokenizer. The second item from which
 Tree Construction leads is the DOM. The DOM is related to the Script
 Execution.">
 <figcaption>Flowchart representation of the parsing model.</figcaption>
</figure>
<!-- This is WRONG. Do not do this. Instead, do what the above examples do. -->
<p>The Network passes data to the Input Stream Preprocessor, which
passes it to the Tokenizer, which passes it to the Tree Construction
stage. From there, data goes to both the DOM and to Script Execution.
Script Execution is linked to the DOM, and, using document.write(),
passes data to the Tokenizer.</p>
<p><img src="images/parsing-model-overview.svg"
        alt="Flowchart representation of the parsing model."></p>
<!-- Never put the image's caption in the alt="" attribute! -->
A graph that repeats the previous paragraph in graphical form:

<p>According to a study covering several billion pages,
about 62% of documents on the Web in 2007 triggered the Quirks
rendering mode of Web browsers, about 30% triggered the Almost
Standards mode, and about 9% triggered the Standards mode.</p>
<p><img src="rendering-mode-pie-chart.png" alt=""></p>
4.8.4.4.7 Ancillary images
Sometimes, an image is not critical to the content, but is nonetheless neither purely decorative nor entirely redundant with the text. In these cases, the alt attribute must be present, and its value should either be the empty string, or a textual representation of the information that the image conveys. If the image has a caption giving the image's title, then the alt attribute's value must not be empty (as that would be quite confusing for non-visual readers).

Consider a news article about a political figure, in which the individual's face was shown in an image that, through a style sheet, is floated to the right. The image is not purely decorative, as it is relevant to the story. The image is not entirely redundant with the story either, as it shows what the politician looks like. Whether any alternative text need be provided is an authoring decision, in part influenced by whether the image colors the interpretation of the prose.

In this first variant, the image is shown without context, and no alternative text is provided:

<p><img src="alexsalmond.jpeg" alt=""> Ahead of today's referendum,
the First Minister of Scotland, Alex Salmond, wrote an open letter to all
registered voters. In it, he admitted that all countries make mistakes.</p>
If the picture is just a face, there might be no value in describing it. It's of no interest to the reader whether the individual has red hair or blond hair, whether the individual has white skin or black skin, whether the individual has one eye or two eyes.

However, if the picture is more dynamic, for instance showing the politician as angry, or particularly happy, or devastated, some alternative text would be useful in setting the tone of the article, a tone that might otherwise be missed:

<p><img src="alexsalmond.jpeg" alt="Alex Salmond is sad.">
Ahead of today's referendum, the First Minister of Scotland, Alex Salmond,
wrote an open letter to all registered voters. In it, he admitted that all
countries make mistakes.</p>
<p><img src="alexsalmond.jpeg" alt="Alex Salmond is ecstatic!">
Ahead of today's referendum, the First Minister of Scotland, Alex Salmond,
wrote an open letter to all registered voters. In it, he admitted that all
countries make mistakes.</p>
Whether the individual was "sad" or "ecstatic" makes a difference to how the rest of the paragraph is to be interpreted: is he likely saying that he is resigned to the populace making a bad choice in the upcoming referendum, or is he saying that the election was a mistake but the likely turnout will make it irrelevant? The interpretation varies based on the image.

If the image has a caption, then including alternative text avoids leaving the non-visual user confused as to what the caption refers to.

<p>Ahead of today's referendum, the First Minister of Scotland, Alex Salmond,
wrote an open letter to all registered voters. In it, he admitted that all
countries make mistakes.</p>
<figure>
 <img src="alexsalmond.jpeg"
      alt="A high forehead, cheerful disposition, and dark hair round out Alex Salmond's face.">
 <figcaption> Alex Salmond, SNP. Photo © 2014 PolitiPhoto. </figcaption>
</figure>
4.8.4.4.8 A purely decorative image that doesn't add any information
If an image is decorative but isn't especially page-specific — for example an image that forms part of a site-wide design scheme — the image should be specified in the site's CSS, not in the markup of the document.

However, a decorative image that isn't discussed by the surrounding text but still has some relevance can be included in a page using the img element. Such images are decorative, but still form part of the content. In these cases, the alt attribute must be present but its value must be the empty string.

Examples where the image is purely decorative despite being relevant would include things like a photo of the Black Rock City landscape in a blog post about an event at Burning Man, or an image of a painting inspired by a poem, on a page reciting that poem. The following snippet shows an example of the latter case (only the first verse is included in this snippet):

<h1>The Lady of Shalott</h1>
<p><img src="shalott.jpeg" alt=""></p>
<p>On either side the river lie<br>
Long fields of barley and of rye,<br>
That clothe the wold and meet the sky;<br>
And through the field the road run by<br>
To many-tower'd Camelot;<br>
And up and down the people go,<br>
Gazing where the lilies blow<br>
Round an island there below,<br>
The island of Shalott.</p>
4.8.4.4.9 A group of images that form a single larger picture with no links
When a picture has been sliced into smaller image files that are then displayed together to form the complete picture again, one of the images must have its alt attribute set as per the relevant rules that would be appropriate for the picture as a whole, and then all the remaining images must have their alt attribute set to the empty string.

In the following example, a picture representing a company logo for XYZ Corp has been split into two pieces, the first containing the letters "XYZ" and the second with the word "Corp". The alternative text ("XYZ Corp") is all in the first image.

<h1><img src="logo1.png" alt="XYZ Corp"><img src="logo2.png" alt=""></h1>
In the following example, a rating is shown as three filled stars and two empty stars. While the alternative text could have been "★★★☆☆", the author has instead decided to more helpfully give the rating in the form "3 out of 5". That is the alternative text of the first image, and the rest have blank alternative text.

<p>Rating: <meter max=5 value=3><img src="1" alt="3 out of 5"
  ><img src="1" alt=""><img src="1" alt=""><img src="0" alt=""
  ><img src="0" alt=""></meter></p>
4.8.4.4.10 A group of images that form a single larger picture with links
Generally, image maps should be used instead of slicing an image for links.

However, if an image is indeed sliced and any of the components of the sliced picture are the sole contents of links, then one image per link must have alternative text in its alt attribute representing the purpose of the link.

In the following example, a picture representing the flying spaghetti monster emblem, with each of the left noodly appendages and the right noodly appendages in different images, so that the user can pick the left side or the right side in an adventure.

<h1>The Church</h1>
<p>You come across a flying spaghetti monster. Which side of His
Noodliness do you wish to reach out for?</p>
<p><a href="?go=left" ><img src="fsm-left.png"  alt="Left side. "></a
  ><img src="fsm-middle.png" alt=""
  ><a href="?go=right"><img src="fsm-right.png" alt="Right side."></a></p>
4.8.4.4.11 A key part of the content
In some cases, the image is a critical part of the content. This could be the case, for instance, on a page that is part of a photo gallery. The image is the whole point of the page containing it.

How to provide alternative text for an image that is a key part of the content depends on the image's provenance.

The general case
When it is possible for detailed alternative text to be provided, for example if the image is part of a series of screenshots in a magazine review, or part of a comic strip, or is a photograph in a blog entry about that photograph, text that can serve as a substitute for the image must be given as the contents of the alt attribute.

A screenshot in a gallery of screenshots for a new OS, with some alternative text:

<figure>
 <img src="KDE%20Light%20desktop.png"
      alt="The desktop is blue, with icons along the left hand side in
           two columns, reading System, Home, K-Mail, etc. A window is
           open showing that menus wrap to a second line if they
           cannot fit in the window. The window has a list of icons
           along the top, with an address bar below it, a list of
           icons for tabs along the left edge, a status bar on the
           bottom, and two panes in the middle. The desktop has a bar
           at the bottom of the screen with a few buttons, a pager, a
           list of open applications, and a clock.">
 <figcaption>Screenshot of a KDE desktop.</figcaption>
</figure>
A graph in a financial report:

<img src="sales.gif"
     title="Sales graph"
     alt="From 1998 to 2005, sales increased by the following percentages
     with each year: 624%, 75%, 138%, 40%, 35%, 9%, 21%">
Note that "sales graph" would be inadequate alternative text for a sales graph. Text that would be a good caption is not generally suitable as replacement text.

Images that defy a complete description
In certain cases, the nature of the image might be such that providing thorough alternative text is impractical. For example, the image could be indistinct, or could be a complex fractal, or could be a detailed topographical map.

In these cases, the alt attribute must contain some suitable alternative text, but it may be somewhat brief.

Sometimes there simply is no text that can do justice to an image. For example, there is little that can be said to usefully describe a Rorschach inkblot test. However, a description, even if brief, is still better than nothing:

<figure>
 <img src="/commons/a/a7/Rorschach1.jpg" alt="A shape with left-right
 symmetry with indistinct edges, with a small gap in the center, two
 larger gaps offset slightly from the center, with two similar gaps
 under them. The outline is wider in the top half than the bottom
 half, with the sides extending upwards higher than the center, and
 the center extending below the sides.">
 <figcaption>A black outline of the first of the ten cards
 in the Rorschach inkblot test.</figcaption>
</figure>
Note that the following would be a very bad use of alternative text:

<!-- This example is wrong. Do not copy it. -->
<figure>
 <img src="/commons/a/a7/Rorschach1.jpg" alt="A black outline
 of the first of the ten cards in the Rorschach inkblot test.">
 <figcaption>A black outline of the first of the ten cards
 in the Rorschach inkblot test.</figcaption>
</figure>
Including the caption in the alternative text like this isn't useful because it effectively duplicates the caption for users who don't have images, taunting them twice yet not helping them any more than if they had only read or heard the caption once.

Another example of an image that defies full description is a fractal, which, by definition, is infinite in detail.

The following example shows one possible way of providing alternative text for the full view of an image of the Mandelbrot set.

<img src="ms1.jpeg" alt="The Mandelbrot set appears as a cardioid with
its cusp on the real axis in the positive direction, with a smaller
bulb aligned along the same center line, touching it in the negative
direction, and with these two shapes being surrounded by smaller bulbs
of various sizes.">
Similarly, a photograph of a person's face, for example in a biography, can be considered quite relevant and key to the content, but it can be hard to fully substitute text for:

<section class="bio">
 <h1>A Biography of Isaac Asimov</h1>
 <p>Born <b>Isaak Yudovich Ozimov</b> in 1920, Isaac was a prolific author.</p>
 <p><img src="headpics/asimov.jpeg" alt="Isaac Asimov had dark hair, a tall forehead, and wore glasses.
 Later in life, he wore long white sideburns.">
 <p>Asimov was born in Russia, and moved to the US when he was three years old.</p>
 <p>...
</section>
In such cases it is unnecessary (and indeed discouraged) to include a reference to the presence of the image itself in the alternative text, since such text would be redundant with the browser itself reporting the presence of the image. For example, if the alternative text was "A photo of Isaac Asimov", then a conforming user agent might read that out as "(Image) A photo of Isaac Asimov" rather than the more useful "(Image) Isaac Asimov had dark hair, a tall forehead, and wore glasses...".

Images whose contents are not known
In some unfortunate cases, there might be no alternative text available at all, either because the image is obtained in some automated fashion without any associated alternative text (e.g. a Webcam), or because the page is being generated by a script using user-provided images where the user did not provide suitable or usable alternative text (e.g. photograph sharing sites), or because the author does not themself know what the images represent (e.g. a blind photographer sharing an image on their blog).

In such cases, the alt attribute may be omitted, but one of the following conditions must be met as well:

The img element is in a figure element that contains a figcaption element that contains content other than inter-element whitespace, and, ignoring the figcaption element and its descendants, the figure element has no flow content descendants other than inter-element whitespace and the img element.

The title attribute is present and has a non-empty value.

Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g. requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).

Such cases are to be kept to an absolute minimum. If there is even the slightest possibility of the author having the ability to provide real alternative text, then it would not be acceptable to omit the alt attribute.

A photo on a photo-sharing site, if the site received the image with no metadata other than the caption, could be marked up as follows:

<figure>
 <img src="1100670787_6a7c664aef.jpg">
 <figcaption>Bubbles traveled everywhere with us.</figcaption>
</figure>
It would be better, however, if a detailed description of the important parts of the image obtained from the user and included on the page.

A blind user's blog in which a photo taken by the user is shown. Initially, the user might not have any idea what the photo they took shows:

<article>
 <h1>I took a photo</h1>
 <p>I went out today and took a photo!</p>
 <figure>
  <img src="photo2.jpeg">
  <figcaption>A photograph taken blindly from my front porch.</figcaption>
 </figure>
</article>
Eventually though, the user might obtain a description of the image from their friends and could then include alternative text:

<article>
 <h1>I took a photo</h1>
 <p>I went out today and took a photo!</p>
 <figure>
  <img src="photo2.jpeg" alt="The photograph shows my squirrel
  feeder hanging from the edge of my roof. It is half full, but there
  are no squirrels around. In the background, out-of-focus trees fill the
  shot. The feeder is made of wood with a metal grate, and it contains
  peanuts. The edge of the roof is wooden too, and is painted white
  with light blue streaks.">
  <figcaption>A photograph taken blindly from my front porch.</figcaption>
 </figure>
</article>
Sometimes the entire point of the image is that a textual description is not available, and the user is to provide the description. For instance, the point of a CAPTCHA image is to see if the user can literally read the graphic. Here is one way to mark up a CAPTCHA (note the title attribute):

<p><label>What does this image say?
<img src="captcha.cgi?id=8934" title="CAPTCHA">
<input type=text name=captcha></label>
(If you cannot see the image, you can use an <a
href="?audio">audio</a> test instead.)</p>
Another example would be software that displays images and asks for alternative text precisely for the purpose of then writing a page with correct alternative text. Such a page could have a table of images, like this:

<table>
 <thead>
  <tr> <th> Image <th> Description
 <tbody>
  <tr>
   <td> <img src="2421.png" title="Image 640 by 100, filename 'banner.gif'">
   <td> <input name="alt2421">
  <tr>
   <td> <img src="2422.png" title="Image 200 by 480, filename 'ad3.gif'">
   <td> <input name="alt2422">
</table>
Notice that even in this example, as much useful information as possible is still included in the title attribute.

Since some users cannot use images at all (e.g. because they have a very slow connection, or because they are using a text-only browser, or because they are listening to the page being read out by a hands-free automobile voice Web browser, or simply because they are blind), the alt attribute is only allowed to be omitted rather than being provided with replacement text when no alternative text is available and none can be made available, as in the above examples. Lack of effort from the part of the author is not an acceptable reason for omitting the alt attribute.

4.8.4.4.12 An image not intended for the user
Generally authors should avoid using img elements for purposes other than showing images.

If an img element is being used for purposes other than showing an image, e.g. as part of a service to count page views, then the alt attribute must be the empty string.

In such cases, the width and height attributes should both be set to zero.

4.8.4.4.13 An image in an e-mail or private document intended for a specific person who is known to be able to view images
This section does not apply to documents that are publicly accessible, or whose target audience is not necessarily personally known to the author, such as documents on a Web site, e-mails sent to public mailing lists, or software documentation.

When an image is included in a private communication (such as an HTML e-mail) aimed at a specific person who is known to be able to view images, the alt attribute may be omitted. However, even in such cases authors are strongly urged to include alternative text (as appropriate according to the kind of image involved, as described in the above entries), so that the e-mail is still usable should the user use a mail client that does not support images, or should the document be forwarded on to other users whose abilities might not include easily seeing images.

4.8.4.4.14 Guidance for markup generators
Markup generators (such as WYSIWYG authoring tools) should, wherever possible, obtain alternative text from their users. However, it is recognized that in many cases, this will not be possible.

For images that are the sole contents of links, markup generators should examine the link target to determine the title of the target, or the URL of the target, and use information obtained in this manner as the alternative text.

For images that have captions, markup generators should use the figure and figcaption elements, or the title attribute, to provide the image's caption.

As a last resort, implementers should either set the alt attribute to the empty string, under the assumption that the image is a purely decorative image that doesn't add any information but is still specific to the surrounding content, or omit the alt attribute altogether, under the assumption that the image is a key part of the content.

Markup generators may specify a generator-unable-to-provide-required-alt attribute on img elements for which they have been unable to obtain alternative text and for which they have therefore omitted the alt attribute. The value of this attribute must be the empty string. Documents containing such attributes are not conforming, but conformance checkers will silently ignore this error.

This is intended to avoid markup generators from being pressured into replacing the error of omitting the alt attribute with the even more egregious error of providing phony alternative text, because state-of-the-art automated conformance checkers cannot distinguish phony alternative text from correct alternative text.

Markup generators should generally avoid using the image's own file name as the alternative text. Similarly, markup generators should avoid generating alternative text from any content that will be equally available to presentation user agents (e.g. Web browsers).

This is because once a page is generated, it will typically not be updated, whereas the browsers that later read the page can be updated by the user, therefore the browser is likely to have more up-to-date and finely-tuned heuristics than the markup generator did when generating the page.

4.8.4.4.15 Guidance for conformance checkers
A conformance checker must report the lack of an alt attribute as an error unless one of the conditions listed below applies:

The img element is in a figure element that satisfies the conditions described above.

The img element has a title attribute with a value that is not the empty string (also as described above).

The conformance checker has been configured to assume that the document is an e-mail or document intended for a specific person who is known to be able to view images.

The img element has a (non-conforming) generator-unable-to-provide-required-alt attribute whose value is the empty string. A conformance checker that is not reporting the lack of an alt attribute as an error must also not report the presence of the empty generator-unable-to-provide-required-alt attribute as an error. (This case does not represent a case where the document is conforming, only that the generator could not determine appropriate alternative text — validators are not required to show an error in this case, because such an error might encourage markup generators to include bogus alternative text purely in an attempt to silence validators. Naturally, conformance checkers may report the lack of an alt attribute as an error even in the presence of the generator-unable-to-provide-required-alt attribute; for example, there could be a user option to report all conformance errors even those that might be the more or less inevitable result of using a markup generator.)

4.8.5 The iframe element

Spec bugs: 28773

Categories:
Flow content.
Phrasing content.
Embedded content.
Interactive content.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Nothing.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
src — Address of the resource
srcdoc — A document to render in the iframe
name — Name of nested browsing context
sandbox — Security rules for nested content
allowfullscreen — Whether to allow the iframe's contents to use requestFullscreen()
allowpaymentrequest — Whether the iframe's contents are allowed to use the PaymentRequest interface to make payment requests
allowusermedia — Whether to allow the iframe's contents to use getUserMedia()
width — Horizontal dimension
height — Vertical dimension
referrerpolicy — Referrer policy for fetches initiated by the element
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLIFrameElement : HTMLElement {
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString srcdoc;
  [CEReactions] attribute DOMString name;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList sandbox;
  [CEReactions] attribute boolean allowFullscreen;
  [CEReactions] attribute boolean allowPaymentRequest;
  [CEReactions] attribute boolean allowUserMedia;
  [CEReactions] attribute DOMString width;
  [CEReactions] attribute DOMString height;
  [CEReactions] attribute DOMString referrerPolicy;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;
  Document? getSVGDocument();

  // also has obsolete members
};
The iframe element represents a nested browsing context.

The src attribute gives the URL of a page that the nested browsing context is to contain. The attribute, if present, must be a valid non-empty URL potentially surrounded by spaces. If the itemprop attribute is specified on an iframe element, then the src attribute must also be specified.

The srcdoc attribute gives the content of the page that the nested browsing context is to contain. The value of the attribute is the source of an iframe srcdoc document.


Support: iframe-srcdoc
Chrome for Android	64+
Chrome	20+
iOS Safari	6.0+
UC Browser for Android	11.8+
Firefox	25+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	6+
Android Browser	4.4+
Opera	15+

Source: caniuse.com

The srcdoc attribute, if present, must have a value using the HTML syntax that consists of the following syntactic components, in the given order:

Any number of comments and ASCII whitespace.
Optionally, a DOCTYPE.
Any number of comments and ASCII whitespace.
The document element, in the form of an html element.
Any number of comments and ASCII whitespace.
The above requirements apply in XML documents as well.

Here a blog uses the srcdoc attribute in conjunction with the sandbox attribute described below to provide users of user agents that support this feature with an extra layer of protection from script injection in the blog post comments:

<article>
 <h1>I got my own magazine!</h1>
 <p>After much effort, I've finally found a publisher, and so now I
 have my own magazine! Isn't that awesome?! The first issue will come
 out in September, and we have articles about getting food, and about
 getting in boxes, it's going to be great!</p>
 <footer>
  <p>Written by <a href="/users/cap">cap</a>, 1 hour ago.
 </footer>
 <article>
  <footer> Thirteen minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>did you get a cover picture yet?"></iframe>
 </article>
 <article>
  <footer> Nine minutes ago, <a href="/users/cap">cap</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>Yeah, you can see it <a href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>in my gallery</a>."></iframe>
 </article>
 <article>
  <footer> Five minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>hey that's earl's table.
<p>you should get earl&amp;amp;me on the next cover."></iframe>
 </article>
Notice the way that quotes have to be escaped (otherwise the srcdoc attribute would end prematurely), and the way raw ampersands (e.g. in URLs or in prose) mentioned in the sandboxed content have to be doubly escaped — once so that the ampersand is preserved when originally parsing the srcdoc attribute, and once more to prevent the ampersand from being misinterpreted when parsing the sandboxed content.

Furthermore, notice that since the DOCTYPE is optional in iframe srcdoc documents, and the html, head, and body elements have optional start and end tags, and the title element is also optional in iframe srcdoc documents, the markup in a srcdoc attribute can be relatively succinct despite representing an entire document, since only the contents of the body element need appear literally in the syntax. The other elements are still present, but only by implication.

In the HTML syntax, authors need only remember to use U+0022 QUOTATION MARK characters (") to wrap the attribute contents and then to escape all U+0022 QUOTATION MARK (") and U+0026 AMPERSAND (&) characters, and to specify the sandbox attribute, to ensure safe embedding of content.

In XML the U+003C LESS-THAN SIGN character (<) needs to be escaped as well. In order to prevent attribute-value normalization, some of XML's whitespace characters — specifically U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), and U+000D CARRIAGE RETURN (CR) — also need to be escaped. [XML]

If the src attribute and the srcdoc attribute are both specified together, the srcdoc attribute takes priority. This allows authors to provide a fallback URL for legacy user agents that do not support the srcdoc attribute.

When an iframe element is inserted into a document that has a browsing context, the user agent must create a new browsing context, set the element's nested browsing context to the newly-created browsing context, and then process the iframe attributes for the "first time".

When an iframe element is removed from a document, the user agent must discard the element's nested browsing context, if it is not null, and then set the element's nested browsing context to null.

This happens without any unload events firing (the nested browsing context and its Document are discarded, not unloaded).

Whenever an iframe element with a non-null nested browsing context has its srcdoc attribute set, changed, or removed, the user agent must process the iframe attributes.

Similarly, whenever an iframe element with a non-null nested browsing context but with no srcdoc attribute specified has its src attribute set, changed, or removed, the user agent must process the iframe attributes.

When the user agent is to process the iframe attributes, it must run the first appropriate steps from the following list:

If the srcdoc attribute is specified
Navigate the element's nested browsing context to a new response whose url list consists of about:srcdoc, header list consists of `Content-Type`/`text/html, body is the value of the attribute, CSP list is the CSP list of the iframe element's node document, HTTPS state is the HTTPS state of the iframe element's node document.

The resulting Document must be considered an iframe srcdoc document.

Otherwise, if the element has no src attribute specified, and the user agent is processing the iframe's attributes for the "first time"
Queue a task to run the iframe load event steps.

The task source for this task is the DOM manipulation task source.

Otherwise
Run the otherwise steps for iframe or frame elements.

The otherwise steps for iframe or frame elements are as follows:

If the element has no src attribute specified, or its value is the empty string, let url be the URL "about:blank".

Otherwise, parse the value of the src attribute, relative to the element's node document.

If that is not successful, then let url be the URL "about:blank". Otherwise, let url be the resulting URL record.

If there exists an ancestor browsing context whose active document's URL, ignoring fragments, is equal to url, then return.

Let resource be a new request whose url is url and whose referrer policy is the current state of the element's referrerpolicy content attribute.

Navigate the element's nested browsing context to resource.

Any navigation required of the user agent in the process the iframe attributes algorithm must use the iframe element's node document's browsing context as the source browsing context.

Furthermore, if the active document of the element's nested browsing context before such a navigation was not completely loaded at the time of the new navigation, then the navigation must be completed with replacement enabled.

Similarly, if the nested browsing context's session history contained only one Document when the process the iframe attributes algorithm was invoked, and that was the about:blank Document created when the nested browsing context was created, then any navigation required of the user agent in that algorithm must be completed with replacement enabled.

When a Document in an iframe is marked as completely loaded, the user agent must run the iframe load event steps.

A load event is also fired at the iframe element when it is created if no other data is loaded in it.

Each Document has an iframe load in progress flag and a mute iframe load flag. When a Document is created, these flags must be unset for that Document.

The iframe load event steps are as follows:

Let child document be the active document of the iframe element's nested browsing context (which cannot be null at this point).

If child document has its mute iframe load flag set, return.

Set child document's iframe load in progress flag.

Fire an event named load at the iframe element.

Unset child document's iframe load in progress flag.

This, in conjunction with scripting, can be used to probe the URL space of the local network's HTTP servers. User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing Web content.

When the iframe's browsing context's active document is not ready for post-load tasks, and when anything in the iframe is delaying the load event of the iframe's browsing context's active document, and when the iframe's browsing context is in the delaying load events mode, the iframe must delay the load event of its document.

If, during the handling of the load event, the browsing context in the iframe is again navigated, that will further delay the load event.

If, when the element is created, the srcdoc attribute is not set, and the src attribute is either also not set or set but its value cannot be parsed, the browsing context will remain at the initial about:blank page.

If the user navigates away from this page, the iframe's corresponding WindowProxy object will proxy new Window objects for new Document objects, but the src attribute will not change.

The name attribute, if present, must be a valid browsing context name. The given value is used to name the nested browsing context. When the browsing context is created, if the attribute is present, the browsing context name must be set to the value of this attribute; otherwise, the browsing context name must be set to the empty string.

Whenever the name attribute is set, the nested browsing context's name must be changed to the new value. If the attribute is removed, the browsing context name must be set to the empty string.

The sandbox attribute, when specified, enables a set of extra restrictions on any content hosted by the iframe. Its value must be an unordered set of unique space-separated tokens that are ASCII case-insensitive. The allowed values are allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-popups-to-escape-sandbox, allow-presentation, allow-same-origin, allow-scripts, allow-top-navigation, and allow-top-navigation-by-user-activation.


Support: iframe-sandbox
Chrome for Android	64+
Chrome	4+
iOS Safari	4.2+
UC Browser for Android	11.8+
Firefox	28+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	2.2+
Opera	15+

Source: caniuse.com

When the attribute is set, the content is treated as being from a unique origin, forms, scripts, and various potentially annoying APIs are disabled, links are prevented from targeting other browsing contexts, and plugins are secured. The allow-same-origin keyword causes the content to be treated as being from its real origin instead of forcing it into a unique origin; the allow-top-navigation keyword allows the content to navigate its top-level browsing context; the allow-top-navigation-by-user-activation keyword behaves similarly but only allows such navigation when triggered by user activation; and the allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-presentation, allow-scripts, and allow-popups-to-escape-sandbox keywords re-enable forms, modal dialogs, screen orientation lock, the pointer lock API, popups, the presentation API, scripts, and the creation of unsandboxed auxiliary browsing contexts respectively. [POINTERLOCK] [SCREENORIENTATION] [PRESENTATION]

The allow-top-navigation and allow-top-navigation-by-user-activation keywords must not both be specified, as doing so is redundant; only allow-top-navigation will have an effect in such non-conformant markup.

Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the same origin as the page containing the iframe allows the embedded page to simply remove the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.

These flags only take effect when the nested browsing context of the iframe is navigated. Removing them, or removing the entire sandbox attribute, has no effect on an already-loaded page.

Potentially hostile files should not be served from the same server as the file containing the iframe element. Sandboxing hostile content is of minimal help if an attacker can convince the user to just visit the hostile content directly, rather than in the iframe. To limit the damage that can be caused by hostile HTML content, it should be served from a separate dedicated domain. Using a different domain ensures that scripts in the files are unable to attack the site, even if the user is tricked into visiting those pages directly, without the protection of the sandbox attribute.

When an iframe element with a sandbox attribute has its nested browsing context created (before the initial about:blank Document is created), and when an iframe element's sandbox attribute is set or changed while it has a nested browsing context, the user agent must parse the sandboxing directive using the attribute's value as the input and the iframe element's nested browsing context's iframe sandboxing flag set as the output.

When an iframe element's sandbox attribute is removed while it has a non-null nested browsing context, the user agent must empty the iframe element's nested browsing context's iframe sandboxing flag set as the output.

In this example, some completely-unknown, potentially hostile, user-provided HTML content is embedded in a page. Because it is served from a separate domain, it is affected by all the normal cross-site restrictions. In addition, the embedded page has scripting disabled, plugins disabled, forms disabled, and it cannot navigate any frames or windows other than itself (or any frames or windows it itself embeds).

<p>We're not scared of you! Here is your content, unedited:</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>
It is important to use a separate domain so that if the attacker convinces the user to visit that page directly, the page doesn't run in the context of the site's origin, which would make the user vulnerable to any attack found in the page.

In this example, a gadget from another site is embedded. The gadget has scripting and forms enabled, and the origin sandbox restrictions are lifted, allowing the gadget to communicate with its originating server. The sandbox is still useful, however, as it disables plugins and popups, thus reducing the risk of the user being exposed to malware and other annoyances.

<iframe sandbox="allow-same-origin allow-forms allow-scripts"
        src="https://maps.example.com/embedded.html"></iframe>
Suppose a file A contained the following fragment:

<iframe sandbox="allow-same-origin allow-forms" src=B></iframe>
Suppose that file B contained an iframe also:

<iframe sandbox="allow-scripts" src=C></iframe>
Further, suppose that file C contained a link:

<a href=D>Link</a>
For this example, suppose all the files were served as text/html.

Page C in this scenario has all the sandboxing flags set. Scripts are disabled, because the iframe in A has scripts disabled, and this overrides the allow-scripts keyword set on the iframe in B. Forms are also disabled, because the inner iframe (in B) does not have the allow-forms keyword set.

Suppose now that a script in A removes all the sandbox attributes in A and B. This would change nothing immediately. If the user clicked the link in C, loading page D into the iframe in B, page D would now act as if the iframe in B had the allow-same-origin and allow-forms keywords set, because that was the state of the nested browsing context in the iframe in A when page B was loaded.

Generally speaking, dynamically removing or changing the sandbox attribute is ill-advised, because it can make it quite hard to reason about what will be allowed and what will not.

The allowfullscreen attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context are to be allowed to use requestFullscreen() (if it's not blocked for other reasons, e.g. there is another ancestor iframe without this attribute set).

Here, an iframe is used to embed a player from a video site. The allowfullscreen attribute is needed to enable the player to show its video fullscreen.

<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">Private Post</a></p>
 </header>
 <p>Check out my new ride!</p>
 <iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>
</article>
The allowpaymentrequest attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context are to be allowed to use the PaymentRequest interface to make payment requests.

The allowusermedia attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context are to be allowed to use getUserMedia() (if it's not blocked for other reasons, e.g. there is another ancestor iframe without this attribute set).

To determine whether a Document object document is allowed to use the feature indicated by attribute name allowattribute, run these steps:

If document has no browsing context, then return false.

If document's browsing context's active document is not document, then return false.

If document's browsing context is a top-level browsing context, then return true.

If allowattribute is allowfullscreen, then:

If document's browsing context has a browsing context container that is an iframe element with an allowattribute attribute specified, and whose node document is allowed to use the feature indicated by allowattribute, then return true.

This step is legacy behavior for the allowfullscreen attribute that should not be used for new features. If possible this will be removed, see issue 2143.

Otherwise:

If document has the allowattribute flag set, and document's browsing context has a browsing context container that is an iframe element whose node document is allowed to use the feature indicated by allowattribute, then return true.

Return false.

To set the allow* flags for a Document document means to run these steps:

If document's browsing context has a browsing context container whose node document's origin is same origin-domain with document's origin, then set the allowpaymentrequest flag and the allowusermedia flag on document, and return.

If document.domain has been used for the browsing context container's node document, then its origin cannot be same origin-domain with document's origin, because these steps run when document is initialized so it cannot itself yet have used document.domain. Note that this is less permissive compared to doing a same origin check instead.

In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.

<!-- https://foo.example.com/a.html -->
<!doctype html>
<script>
 document.domain = 'example.com';
</script>
<iframe src=b.html></iframe>
<!-- https://bar.example.com/b.html -->
<!doctype html>
<script>
 document.domain = 'example.com'; // This happens after the document is initialized
 new PaymentRequest(…); // Not allowed to use
</script>
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.

<!-- https://example.com/a.html -->
<!doctype html>
<iframe src=b.html></iframe>
<!-- The child document is now initialized, before the script below is run. -->
<script>
 document.domain = 'example.com';
</script>
<!-- https://example.com/b.html -->
<!doctype html>
<script>
 new PaymentRequest(…); // Allowed to use
</script>
If document's browsing context has a browsing context container that is an iframe element, let iframe be that element. Otherwise, return.

If iframe has an allowpaymentrequest attribute specified, then set the allowpaymentrequest flag on document.

If iframe has an allowusermedia attribute specified, then set the allowusermedia flag on document.

The iframe element supports dimension attributes for cases where the embedded content has specific dimensions (e.g. ad units have well-defined dimensions).

An iframe element never has fallback content, as it will always create a nested browsing context, regardless of whether the specified initial contents are successfully used.

The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when processing the iframe attributes. [REFERRERPOLICY]

Descendants of iframe elements represent nothing. (In legacy user agents that do not support iframe elements, the contents would be parsed as markup that could act as fallback content.)

The HTML parser treats markup inside iframe elements as text.

The IDL attributes src, srcdoc, name,and sandbox must reflect the respective content attributes of the same name.

The supported tokens for sandbox's DOMTokenList are the allowed values defined in the sandbox attribute and supported by the user agent.

The allowFullscreen IDL attribute must reflect the allowfullscreen content attribute.

The allowPaymentRequest IDL attribute must reflect the allowpaymentrequest content attribute.

The allowUserMedia IDL attribute must reflect the allowusermedia content attribute.

The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The contentDocument IDL attribute, on getting, must return the iframe element's content document.

The contentWindow IDL attribute must return the WindowProxy object of the iframe element's nested browsing context, if its nested browsing context is non-null, or null otherwise.

Here is an example of a page using an iframe to include advertising from an advertising broker:

<iframe src="https://ads.example.com/?customerid=923513721&amp;format=banner"
        width="468" height="60"></iframe>
4.8.6 The embed element
Categories:
Flow content.
Phrasing content.
Embedded content.
Interactive content.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
src — Address of the resource
type — Type of embedded resource
width — Horizontal dimension
height — Vertical dimension
Any other attribute that has no namespace (see prose).
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLEmbedElement : HTMLElement {
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute DOMString width;
  [CEReactions] attribute DOMString height;
  Document? getSVGDocument();

  // also has obsolete members
};
Depending on the type of content instantiated by the embed element, the node may also support other interfaces.

The embed element provides an integration point for an external (typically non-HTML) application or interactive content.

The src attribute gives the URL of the resource being embedded. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.

If the itemprop attribute is specified on an embed element, then the src attribute must also be specified.

The type attribute, if present, gives the MIME type by which the plugin to instantiate is selected. The value must be a valid MIME type string. If both the type attribute and the src attribute are present, then the type attribute must specify the same type as the explicit Content-Type metadata of the resource given by the src attribute.

While any of the following conditions are occurring, any plugin instantiated for the element must be removed, and the embed element represents nothing:

The element has neither a src attribute nor a type attribute.

The element has a media element ancestor.

The element has an ancestor object element that is not showing its fallback content.

An embed element is said to be potentially active when the following conditions are all met simultaneously:

The element is in a document or was in a document the last time the event loop reached step 1.
The element's node document is fully active.
The element has either a src attribute set or a type attribute set (or both).
The element's src attribute is either absent or its value is not the empty string.
The element is not a descendant of a media element.
The element is not a descendant of an object element that is not showing its fallback content.
The element is being rendered, or was being rendered the last time the event loop reached step 1.
Whenever an embed element that was not potentially active becomes potentially active, and whenever a potentially active embed element that is remaining potentially active and has its src attribute set, changed, or removed or its type attribute set, changed, or removed, the user agent must queue a task using the embed task source to run the embed element setup steps.

The embed element setup steps are as follows:

If another task has since been queued to run the embed element setup steps for this element, then return.

If the Should element be blocked a priori by Content Security Policy? algorithm returns "Blocked" when executed on the element, then return. [CSP]

If the element has a src attribute set
The user agent must parse the value of the element's src attribute, relative to the element's node document. If that is successful, the user agent should run these steps:

Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, destination is "embed", credentials mode is "include", and whose use-URL-credentials flag is set.

Fetch request.

The task that is queued by the networking task source once the resource has been fetched must run the following steps:

If another task has since been queued to run the embed element setup steps for this element, then return.

Determine the type of the content being embedded, as follows (stopping at the first substep that determines the type):

If the element has a type attribute, and that attribute's value is a type that a plugin supports, then the value of the type attribute is the content's type.

Otherwise, if applying the URL parser algorithm to the URL of the specified resource (after any redirects) results in a URL record whose path component matches a pattern that a plugin supports, then the content's type is the type that that plugin can handle.

For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".

Otherwise, if the specified resource has explicit Content-Type metadata, then that is the content's type.

Otherwise, the content has no type and there can be no appropriate plugin for it.

If the previous step determined that the content's type is image/svg+xml, then run the following substeps:

If the embed element's nested browsing context is null, set the element's nested browsing context to a newly-created browsing context, and, if the element has a name attribute, set the browsing context name of the element's new nested browsing context to the value of this attribute.

Navigate the nested browsing context to the fetched resource, with replacement enabled, and with the embed element's node document's browsing context as the source browsing context. (The src attribute of the embed element doesn't get updated if the browsing context gets further navigated to other locations.)

The embed element now represents its nested browsing context.

Otherwise, find and instantiate an appropriate plugin based on the content's type, and hand that plugin the content of the resource, replacing any previously instantiated plugin for the element. The embed element now represents this plugin instance.

Once the resource or plugin has completely loaded, queue a task to fire an event named load at the element.

Whether the resource is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the content's type and when handing the resource to the plugin.

This allows servers to return data for plugins even with error responses (e.g. HTTP 500 Internal Server Error codes can still contain plugin data).

Fetching the resource must delay the load event of the element's node document.

If the element has no src attribute set
The user agent should find and instantiate an appropriate plugin based on the value of the type attribute. The embed element now represents this plugin instance.

Once the plugin is completely loaded, queue a task to fire an event named load at the element.

The embed element has no fallback content. If the user agent can't find a suitable plugin when attempting to find and instantiate one for the algorithm above, then the user agent must use a default plugin. This default could be as simple as saying "Unsupported Format".

Whenever an embed element that was potentially active stops being potentially active, any plugin that had been instantiated for that element must be unloaded.

When a plugin is to be instantiated but it cannot be secured and the sandboxed plugins browsing context flag is set on the embed element's node document's active sandboxing flag set, then the user agent must not instantiate the plugin, and must instead render the embed element in a manner that conveys that the plugin was disabled. The user agent may offer the user the option to override the sandbox and instantiate the plugin anyway; if the user invokes such an option, the user agent must act as if the conditions above did not apply for the purposes of this element.

Plugins that cannot be secured are disabled in sandboxed browsing contexts because they might not honor the restrictions imposed by the sandbox (e.g. they might allow scripting even when scripting in the sandbox is disabled). User agents should convey the danger of overriding the sandbox to the user if an option to do so is provided.

When an embed element has a non-null nested browsing context: if the embed element's nested browsing context's active document is not ready for post-load tasks, and when anything is delaying the load event of the embed element's browsing context's active document, and when the embed element's browsing context is in the delaying load events mode, the embed must delay the load event of its document.

The task source for the tasks mentioned in this section is the DOM manipulation task source.

Any namespace-less attribute other than name, align, hspace, and vspace may be specified on the embed element, so long as its name is XML-compatible and contains no ASCII upper alphas. These attributes are then passed as parameters to the plugin.

All attributes in HTML documents get lowercased automatically, so the restriction on uppercase letters doesn't affect such documents.

The four exceptions are to exclude legacy attributes that have side-effects beyond just sending parameters to the plugin.

The user agent should pass the names and values of all the attributes of the embed element that have no namespace to the plugin used, when one is instantiated.

The HTMLEmbedElement object representing the element must expose the scriptable interface of the plugin instantiated for the embed element, if any.

The embed element supports dimension attributes.

The IDL attributes src and type each must reflect the respective content attributes of the same name.

Here's a way to embed a resource that requires a proprietary plugin, like Flash:

<embed src="catgame.swf">
If the user does not have the plugin (for example if the plugin vendor doesn't support the user's platform), then the user will be unable to use the resource.

To pass the plugin a parameter "quality" with the value "high", an attribute can be specified:

<embed src="catgame.swf" quality="high">
This would be equivalent to the following, when using an object element instead:

<object data="catgame.swf">
 <param name="quality" value="high">
</object>
4.8.7 The object element

Spec bugs: 24852

Categories:
Flow content.
Phrasing content.
Embedded content.
If the element has a usemap attribute: Interactive content.
Listed and submittable form-associated element.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Zero or more param elements, then, transparent.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
data — Address of the resource
type — Type of embedded resource
typemustmatch — Whether the type attribute and the Content-Type value need to match for the resource to be used
name — Name of nested browsing context
usemap — Name of image map to use
form — Associates the control with a form element
width — Horizontal dimension
height — Vertical dimension
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLObjectElement : HTMLElement {
  [CEReactions] attribute USVString data;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute boolean typeMustMatch;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString useMap;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute DOMString width;
  [CEReactions] attribute DOMString height;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;
  Document? getSVGDocument();

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  // also has obsolete members
};
Depending on the type of content instantiated by the object element, the node also supports other interfaces.

The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image, as a nested browsing context, or as an external resource to be processed by a plugin.

The data attribute, if present, specifies the URL of the resource. If present, the attribute must be a valid non-empty URL potentially surrounded by spaces.

Authors who reference resources from other origins that they do not trust are urged to use the typemustmatch attribute defined below. Without that attribute, it is possible in certain cases for an attacker on the remote host to use the plugin mechanism to run arbitrary scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.

The type attribute, if present, specifies the type of the resource. If present, the attribute must be a valid MIME type string.

At least one of either the data attribute or the type attribute must be present.

If the itemprop attribute is specified on an object element, then the data attribute must also be specified.

The typemustmatch attribute is a boolean attribute whose presence indicates that the resource specified by the data attribute is only to be used if the value of the type attribute and the Content-Type of the aforementioned resource match.

The typemustmatch attribute must not be specified unless both the data attribute and the type attribute are present.

The name attribute, if present, must be a valid browsing context name. The given value is used to name the nested browsing context, if applicable.

Whenever one of the following conditions occur:

the element is created,
the element is popped off the stack of open elements of an HTML parser or XML parser,
the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into a document or removed from a document,
the element's node document changes whether it is fully active,
one of the element's ancestor object elements changes to or from showing its fallback content,
the element's classid attribute is set, changed, or removed,
the element's classid attribute is not present, and its data attribute is set, changed, or removed,
neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed, or removed,
the element changes from being rendered to not being rendered, or vice versa,
...the user agent must queue a task to run the following steps to (re)determine what the object element represents. This task being queued or actively running must delay the load event of the element's node document.

If the user has indicated a preference that this object element's fallback content be shown instead of the element's usual behavior, then jump to the step below labeled fallback.

For example, a user could ask for the element's fallback content to be shown because that content uses a format that the user finds more accessible.

If the element has an ancestor media element, or has an ancestor object element that is not showing its fallback content, or if the element is not in a document that has a browsing context, or if the element's node document is not fully active, or if the element is still in the stack of open elements of an HTML parser or XML parser, or if the element is not being rendered, or if the Should element be blocked a priori by Content Security Policy? algorithm returns "Blocked" when executed on the element, then jump to the step below labeled fallback. [CSP]

If the classid attribute is present, and has a value that isn't the empty string, then: if the user agent can find a plugin suitable according to the value of the classid attribute, and either plugins aren't being sandboxed or that plugin can be secured, then that plugin should be used, and the value of the data attribute, if any, should be passed to the plugin. If no suitable plugin can be found, or if the plugin reports an error, jump to the step below labeled fallback.

If the data attribute is present and its value is not the empty string, then:

If the type attribute is present and its value is not a type that the user agent supports, and is not a type that the user agent can find a plugin for, then the user agent may jump to the step below labeled fallback without fetching the content to examine its real type.

Parse the URL specified by the data attribute, relative to the element's node document.

If that failed, fire an event named error at the element, then jump to the step below labeled fallback.

Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, destination is "object", credentials mode is "include", and whose use-URL-credentials flag is set.

Fetch request.

Fetching the resource must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined next) has been run.

For the purposes of the application cache networking model, this fetch operation is not for a child browsing context (though it might end up being used for one after all, as defined below).

If the resource is not yet available (e.g. because the resource was not available in the cache, so that loading the resource required making a request over the network), then jump to the step below labeled fallback. The task that is queued by the networking task source once the resource is available must restart this algorithm from this step. Resources can load incrementally; user agents may opt to consider a resource "available" whenever enough data has been obtained to begin processing the resource.

If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), fire an event named error at the element, then jump to the step below labeled fallback.

Determine the resource type, as follows:

Let the resource type be unknown.

If the object element has a type attribute and a typemustmatch attribute, and the resource has associated Content-Type metadata, and the type specified in the resource's Content-Type metadata is an ASCII case-insensitive match for the value of the element's type attribute, then let resource type be that type and jump to the step below labeled handler.

If the object element has a typemustmatch attribute, jump to the step below labeled handler.

If the user agent is configured to strictly obey Content-Type headers for this resource, and the resource has associated Content-Type metadata, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.

This can introduce a vulnerability, wherein a site is trying to embed a resource that uses a particular plugin, but the remote site overrides that and instead furnishes the user agent with a resource that triggers a different plugin with different security characteristics.

If there is a type attribute present on the object element, and that attribute's value is not a type that the user agent supports, but it is a type that a plugin supports, then let the resource type be the type specified in that type attribute, and jump to the step below labeled handler.

Run the appropriate set of steps from the following list:

If the resource has associated Content-Type metadata
Let binary be false.

If the type specified in the resource's Content-Type metadata is "text/plain", and the result of applying the rules for distinguishing if a resource is text or binary to the resource is that the resource is not text/plain, then set binary to true.

If the type specified in the resource's Content-Type metadata is "application/octet-stream", then set binary to true.

If binary is false, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.

If there is a type attribute present on the object element, and its value is not application/octet-stream, then run the following steps:

If the attribute's value is a type that a plugin supports, or the attribute's value is a type that starts with "image/" that is not also an XML MIME type, then let the resource type be the type specified in that type attribute.

Jump to the step below labeled handler.

Otherwise, if the resource does not have associated Content-Type metadata
If there is a type attribute present on the object element, then let the tentative type be the type specified in that type attribute.

Otherwise, let tentative type be the computed type of the resource.

If tentative type is not application/octet-stream, then let resource type be tentative type and jump to the step below labeled handler.

If applying the URL parser algorithm to the URL of the specified resource (after any redirects) results in a URL record whose path component matches a pattern that a plugin supports, then let resource type be the type that that plugin can handle.

For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".

It is possible for this step to finish, or for one of the substeps above to jump straight to the next step, with resource type still being unknown. In both cases, the next step will trigger fallback.

Handler: Handle the content as given by the first of the following cases that matches:

If the resource type is not a type that the user agent supports, but it is a type that a plugin supports
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.

If plugins are being sandboxed and the plugin that supports resource type cannot be secured, jump to the step below labeled fallback.

Otherwise, the user agent should use the plugin that supports resource type and pass the content of the resource to that plugin. If the plugin reports an error, then jump to the step below labeled fallback.

If the resource type is an XML MIME type, or if the resource type does not start with "image/"
If the object element's nested browsing context is null, set the element's nested browsing context to a newly-created browsing context.

The object element must be associated with a newly created nested browsing context, if it does not already have one.

If the URL of the given resource is not about:blank, the element's nested browsing context must then be navigated to that resource, with replacement enabled, and with the object element's node document's browsing context as the source browsing context. (The data attribute of the object element doesn't get updated if the browsing context gets further navigated to other locations.)

If the URL of the given resource is about:blank, then, instead, the user agent must queue a task to fire an event named load at the object element. No load event is fired at the about:blank document itself.

The object element represents the nested browsing context.

If the name attribute is present, the object element's nested browsing context's browsing context name must be set to the value of this attribute; otherwise, the browsing context name must be set to the empty string.

In certain situations, e.g., if the resource was fetched from an application cache but it is an HTML file with a manifest attribute that points to a different application cache manifest, the navigation of the browsing context will be restarted so as to load the resource afresh from the network or a different application cache. Even if the resource is then found to have a different type, it is still used as part of a nested browsing context: only the navigate algorithm is restarted, not this object algorithm.

If the resource type starts with "image/", and support for images has not been disabled
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.

Apply the image sniffing rules to determine the type of the image.

The object element represents the specified image.

If the image cannot be rendered, e.g. because it is malformed or in an unsupported format, jump to the step below labeled fallback.

Otherwise
The given resource type is not supported. Jump to the step below labeled fallback.

If the previous step ended with the resource type being unknown, this is the case that is triggered.

The element's contents are not part of what the object element represents.

Return. Once the resource is completely loaded, queue a task to fire an event named load at the element.

If the data attribute is absent but the type attribute is present, and the user agent can find a plugin suitable according to the value of the type attribute, and either plugins aren't being sandboxed or the plugin can be secured, then that plugin should be used. If these conditions cannot be met, or if the plugin reports an error, jump to the step below labeled fallback. Otherwise return; once the plugin is completely loaded, queue a task to fire an event named load at the element.

Fallback: The object element represents the element's children, ignoring any leading param element children. This is the element's fallback content. If the element has an instantiated plugin, then unload it. If the element's nested browsing context is non-null, then it must be discarded and then set to null.

When the algorithm above instantiates a plugin, the user agent should pass to the plugin used the names and values of all the attributes on the element, in the order they were added to the element, with the attributes added by the parser being ordered in source order, followed by a parameter named "PARAM" whose value is null, followed by all the names and values of parameters given by param elements that are children of the object element, in tree order. If the plugin supports a scriptable interface, the HTMLObjectElement object representing the element should expose that interface. The object element represents the plugin. The plugin is not a nested browsing context.

Plugins are considered sandboxed for the purpose of an object element if the sandboxed plugins browsing context flag is set on the object element's node document's active sandboxing flag set.

Due to the algorithm above, the contents of object elements act as fallback content, used only when referenced resources can't be shown (e.g. because it returned a 404 error). This allows multiple object elements to be nested inside each other, targeting multiple user agents with different capabilities, with the user agent picking the first one it supports.

When an object element's nested browsing context is non-null: if the object element's nested browsing context's active document is not ready for post-load tasks, and when anything is delaying the load event of the object element's browsing context's active document, and when the object element's browsing context is in the delaying load events mode, the object must delay the load event of its document.

The task source for the tasks mentioned in this section is the DOM manipulation task source.

The usemap attribute, if present while the object element represents an image, can indicate that the object has an associated image map. The attribute must be ignored if the object element doesn't represent an image.

The form attribute is used to explicitly associate the object element with its form owner.

Constraint validation: object elements are always barred from constraint validation.

The object element supports dimension attributes.

The IDL attributes data, type and name each must reflect the respective content attributes of the same name. The typeMustMatch IDL attribute must reflect the typemustmatch content attribute. The useMap IDL attribute must reflect the usemap content attribute.

The contentDocument IDL attribute, on getting, must return the object element's content document.

The contentWindow IDL attribute must return the WindowProxy object of the object element's nested browsing context, if its nested browsing context is non-null; otherwise, it must return null.

The willValidate, validity, and validationMessage attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The form IDL attribute is part of the element's forms API.

In this example, an HTML page is embedded in another using the object element.

<figure>
 <object data="clock.html"></object>
 <figcaption>My HTML Clock</figcaption>
</figure>
The following example shows how a plugin can be used in HTML (in this case the Flash plugin, to show a video file). Fallback is provided for users who do not have Flash enabled, in this case using the video element to show the video for those using user agents that support video, and finally providing a link to the video for those who have neither Flash nor a video-capable browser.

<p>Look at my video:
 <object type="application/x-shockwave-flash">
  <param name=movie value="https://video.example.com/library/watch.swf">
  <param name=allowfullscreen value=true>
  <param name=flashvars value="https://video.example.com/vids/315981">
  <video controls src="https://video.example.com/vids/315981">
   <a href="https://video.example.com/vids/315981">View video</a>.
  </video>
 </object>
</p>
4.8.8 The param element
Categories:
None.
Contexts in which this element can be used:
As a child of an object element, before any flow content.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
name — Name of parameter
value — Value of parameter
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLParamElement : HTMLElement {
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString value;

  // also has obsolete members
};
The param element defines parameters for plugins invoked by object elements. It does not represent anything on its own.

The name attribute gives the name of the parameter.

The value attribute gives the value of the parameter.

Both attributes must be present. They may have any value.

If both attributes are present, and if the parent element of the param is an object element, then the element defines a parameter with the given name-value pair.

If either the name or value of a parameter defined by a param element that is the child of an object element that represents an instantiated plugin changes, and if that plugin is communicating with the user agent using an API that features the ability to update the plugin when the name or value of a parameter so changes, then the user agent must appropriately exercise that ability to notify the plugin of the change.

The IDL attributes name and value must both reflect the respective content attributes of the same name.

The following example shows how the param element can be used to pass a parameter to a plugin, in this case the O3D plugin.

<!DOCTYPE HTML>
<html lang="en">
  <head>
   <title>O3D Utah Teapot</title>
  </head>
  <body>
   <p>
    <object type="application/vnd.o3d.auto">
     <param name="o3d_features" value="FloatingPointTextures">
     <img src="o3d-teapot.png"
          title="3D Utah Teapot illustration rendered using O3D."
          alt="When O3D renders the Utah Teapot, it appears as a squat
          teapot with a shiny metallic finish on which the
          surroundings are reflected, with a faint shadow caused by
          the lighting.">
     <p>To see the teapot actually rendered by O3D on your
     computer, please download and install the <a
     href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D plugin</a>.</p>
    </object>
    <script src="o3d-teapot.js"></script>
   </p>
  </body>
</html>
4.8.9 The video element

Support: video
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	20+
Samsung Internet	4+
IE	9+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.3+
Opera	10.5+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Embedded content.
If the element has a controls attribute: Interactive content.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
src — Address of the resource
crossorigin — How the element handles crossorigin requests
poster — Poster frame to show prior to video playback
preload — Hints how much buffering the media resource will likely need
autoplay — Hint that the media resource can be started automatically when the page is loaded
playsinline — Encourage the user agent to display video content within the element's playback area
loop — Whether to loop the media resource
muted — Whether to mute the media resource by default
controls — Show user agent controls
width — Horizontal dimension
height — Vertical dimension
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLVideoElement : HTMLMediaElement {
  [CEReactions] attribute unsigned long width;
  [CEReactions] attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
  [CEReactions] attribute USVString poster;
  [CEReactions] attribute boolean playsInline;
};
A video element is used for playing videos or movies, and audio files with captions.

Content may be provided inside the video element. User agents should not show this content to the user; it is intended for older Web browsers which do not support video, so that legacy video plugins can be tried, or to show text to the users of these older browsers informing them of how to access the video contents.

In particular, this content is not intended to address accessibility concerns. To make video content accessible to the partially sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities, a variety of features are available. Captions can be provided, either embedded in the video stream or as external files using the track element. Sign-language tracks can be embedded in the video stream. Audio descriptions can be embedded in the video stream or in text form using a WebVTT file referenced using the track element and synthesized into speech by the user agent. WebVTT can also be used to provide chapter titles. For users who would rather not use a media element at all, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the video element. [WEBVTT]

The video element is a media element whose media data is ostensibly video data, possibly with associated audio data.

The src, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.

The poster attribute gives the URL of an image file that the user agent can show while no video data is available. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.

If the specified resource is to be used, then, when the element is created or when the poster attribute is set, changed, or removed, the user agent must run the following steps to determine the element's poster frame (regardless of the value of the element's show poster flag):

If there is an existing instance of this algorithm running for this video element, abort that instance of this algorithm without changing the poster frame.

If the poster attribute's value is the empty string or if the attribute is absent, then there is no poster frame; return.

Parse the poster attribute's value relative to the element's node document. If this fails, then there is no poster frame; return.

Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.

Fetch request. This must delay the load event of the element's node document.

If an image is thus obtained, the poster frame is that image. Otherwise, there is no poster frame.

The image given by the poster attribute, the poster frame, is intended to be a representative frame of the video (typically one of the first non-blank frames) that gives the user an idea of what the video is like.

The playsinline attribute is a boolean attribute. If present, it serves as a hint to the user agent that the video ought to be displayed "inline" in the document by default, constrained to the element's playback area, instead of being displayed fullscreen or in an independent resizable window.

The absence of the playsinline attributes does not imply that the video will display fullscreen by default. Indeed, most user agents have chosen to play all videos inline by default, and in such user agents the playsinline attribute has no effect.

A video element represents what is given for the first matching condition in the list below:

When no video data is available (the element's readyState attribute is either HAVE_NOTHING, or HAVE_METADATA but no video data has yet been obtained at all, or the element's readyState attribute is any subsequent value but the media resource does not have a video channel)
The video element represents its poster frame, if any, or else transparent black with no intrinsic dimensions.
When the video element is paused, the current playback position is the first frame of video, and the element's show poster flag is set
The video element represents its poster frame, if any, or else the first frame of the video.
When the video element is paused, and the frame of video corresponding to the current playback position is not available (e.g. because the video is seeking or buffering)
When the video element is neither potentially playing nor paused (e.g. when seeking or stalled)
The video element represents the last frame of the video to have been rendered.
When the video element is paused
The video element represents the frame of video corresponding to the current playback position.
Otherwise (the video element has a video channel and is potentially playing)
The video element represents the frame of video at the continuously increasing "current" position. When the current playback position changes such that the last frame rendered is no longer the frame corresponding to the current playback position in the video, the new frame must be rendered.
Frames of video must be obtained from the video track that was selected when the event loop last reached step 1.

Which frame in a video stream corresponds to a particular playback position is defined by the video stream's format.

The video element also represents any text track cues whose text track cue active flag is set and whose text track is in the showing mode, and any audio from the media resource, at the current playback position.

Any audio associated with the media resource must, if played, be played synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.

In addition to the above, the user agent may provide messages to the user (such as "buffering", "no video loaded", "error", or more detailed information) by overlaying text or icons on the video or other areas of the element's playback area, or in another appropriate manner.

User agents that cannot render the video may instead make the element represent a link to an external video playback utility or to the video data itself.

When a video element's media resource has a video channel, the element provides a paint source whose width is the media resource's intrinsic width, whose height is the media resource's intrinsic height, and whose appearance is the frame of video corresponding to the current playback position, if that is available, or else (e.g. when the video is seeking or buffering) its previous appearance, if any, or else (e.g. because the video is still loading the first frame) blackness.

video . videoWidth
video . videoHeight
These attributes return the intrinsic dimensions of the video, or zero if the dimensions are not known.

The intrinsic width and intrinsic height of the media resource are the dimensions of the resource in CSS pixels after taking into account the resource's dimensions, aspect ratio, clean aperture, resolution, and so forth, as defined for the format used by the resource. If an anamorphic format does not define how to apply the aspect ratio to the video data's dimensions to obtain the "correct" dimensions, then the user agent must apply the ratio by increasing one dimension and leaving the other unchanged.

The videoWidth IDL attribute must return the intrinsic width of the video in CSS pixels. The videoHeight IDL attribute must return the intrinsic height of the video in CSS pixels. If the element's readyState attribute is HAVE_NOTHING, then the attributes must return 0.

Whenever the intrinsic width or intrinsic height of the video changes (including, for example, because the selected video track was changed), if the element's readyState attribute is not HAVE_NOTHING, the user agent must queue a task to fire an event named resize at the media element.

The video element supports dimension attributes.

In the absence of style rules to the contrary, video content should be rendered inside the element's playback area such that the video content is shown centered in the playback area at the largest possible size that fits completely within it, with the video content's aspect ratio being preserved. Thus, if the aspect ratio of the playback area does not match the aspect ratio of the video, the video will be shown letterboxed or pillarboxed. Areas of the element's playback area that do not contain the video represent nothing.

In user agents that implement CSS, the above requirement can be implemented by using the style rule suggested in the rendering section.

The intrinsic width of a video element's playback area is the intrinsic width of the poster frame, if that is available and the element currently represents its poster frame; otherwise, it is the intrinsic width of the video resource, if that is available; otherwise the intrinsic width is missing.

The intrinsic height of a video element's playback area is the intrinsic height of the poster frame, if that is available and the element currently represents its poster frame; otherwise it is the intrinsic height of the video resource, if that is available; otherwise the intrinsic height is missing.

The default object size is a width of 300 CSS pixels and a height of 150 CSS pixels. [CSSIMAGES]

A video element is said to intersect the viewport when it is being rendered and its associated CSS layout box intersects the viewport.

User agents should provide controls to enable or disable the display of closed captions, audio description tracks, and other additional data associated with the video stream, though such features should, again, not interfere with the page's normal rendering.

User agents may allow users to view the video content in manners more suitable to the user, such as fullscreen or in an independent resizable window. User agents may even trigger such a viewing mode by default upon playing a video, although they should not do so when the playsinline attribute is specified. As with the other user interface features, controls to enable this should not interfere with the page's normal rendering unless the user agent is exposing a user interface. In such an independent viewing mode, however, user agents may make full user interfaces visible, even if the controls attribute is absent.

User agents may allow video playback to affect system features that could interfere with the user's experience; for example, user agents could disable screensavers while video playback is in progress.

The poster IDL attribute must reflect the poster content attribute.

The playsInline IDL attribute must reflect the playsinline content attribute.

This example shows how to detect when a video has failed to play correctly:

<script>
 function failed(e) {
   // video playback failed - show a message saying why
   switch (e.target.error.code) {
     case e.target.error.MEDIA_ERR_ABORTED:
       alert('You aborted the video playback.');
       break;
     case e.target.error.MEDIA_ERR_NETWORK:
       alert('A network error caused the video download to fail part-way.');
       break;
     case e.target.error.MEDIA_ERR_DECODE:
       alert('The video playback was aborted due to a corruption problem or because the video used features your browser did not support.');
       break;
     case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('The video could not be loaded, either because the server or network failed or because the format is not supported.');
       break;
     default:
       alert('An unknown error occurred.');
       break;
   }
 }
</script>
<p><video src="tgif.vid" autoplay controls onerror="failed(event)"></video></p>
<p><a href="tgif.vid">Download the video file</a>.</p>
4.8.10 The audio element

Support: audio
Chrome for Android	64+
Chrome	4+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	20+
Samsung Internet	4+
IE	9+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.3+
Opera	10.5+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Embedded content.
If the element has a controls attribute: Interactive content.
If the element has a controls attribute: Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
src — Address of the resource
crossorigin — How the element handles crossorigin requests
preload — Hints how much buffering the media resource will likely need
autoplay — Hint that the media resource can be started automatically when the page is loaded
loop — Whether to loop the media resource
muted — Whether to mute the media resource by default
controls — Show user agent controls
DOM interface:
[Exposed=Window,
 HTMLConstructor,
 NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : HTMLMediaElement {};
An audio element represents a sound or audio stream.

Content may be provided inside the audio element. User agents should not show this content to the user; it is intended for older Web browsers which do not support audio, so that legacy audio plugins can be tried, or to show text to the users of these older browsers informing them of how to access the audio contents.

In particular, this content is not intended to address accessibility concerns. To make audio content accessible to the deaf or to those with other physical or cognitive disabilities, a variety of features are available. If captions or a sign language video are available, the video element can be used instead of the audio element to play the audio, allowing users to enable the visual alternatives. Chapter titles can be provided to aid navigation, using the track element and a WebVTT file. And, naturally, transcripts or other textual alternatives can be provided by simply linking to them in the prose near the audio element. [WEBVTT]

The audio element is a media element whose media data is ostensibly audio data.

The src, preload, autoplay, loop, muted, and controls attributes are the attributes common to all media elements.

audio = new Audio( [ url ] )
Returns a new audio element, with the src attribute set to the value passed in the argument, if applicable.

A constructor is provided for creating HTMLAudioElement objects (in addition to the factory methods from DOM such as createElement()): Audio(src). When invoked, the constructor must perform the following steps:

Let document be the current global object's associated Document.

Let audio be the result of creating an element given document, audio, and the HTML namespace.

Set an attribute value for audio using "preload" and "auto".

If src is given, then set an attribute value for audio using "src" and src. (This will cause the user agent to invoke the object's resource selection algorithm before returning.)

Return audio.

4.8.11 The track element
Categories:
None.
Contexts in which this element can be used:
As a child of a media element, before any flow content.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
kind — The type of text track
src — Address of the resource
srclang — Language of the text track
label — User-visible label
default — Enable the track if no other text track is more suitable
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTrackElement : HTMLElement {
  [CEReactions] attribute DOMString kind;
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString srclang;
  [CEReactions] attribute DOMString label;
  [CEReactions] attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute TextTrack track;
};
The track element allows authors to specify explicit external timed text tracks for media elements. It does not represent anything on its own.

The kind attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The keyword given in the first cell of each row maps to the state given in the second cell.

Keyword	State	Brief description
subtitles	Subtitles	Transcription or translation of the dialogue, suitable for when the sound is available but not understood (e.g. because the user does not understand the language of the media resource's audio track). Overlaid on the video.
captions	Captions	Transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information, suitable for when sound is unavailable or not clearly audible (e.g. because it is muted, drowned-out by ambient noise, or because the user is deaf). Overlaid on the video; labeled as appropriate for the hard-of-hearing.
descriptions	Descriptions	Textual descriptions of the video component of the media resource, intended for audio synthesis when the visual component is obscured, unavailable, or not usable (e.g. because the user is interacting with the application without a screen while driving, or because the user is blind). Synthesized as audio.
chapters	Chapters metadata	Tracks intended for use from script. Not displayed by the user agent.
metadata	Metadata
The attribute may be omitted. The missing value default is the subtitles state. The invalid value default is the metadata state.

The src attribute gives the URL of the text track data. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.

If the element has a src attribute whose value is not the empty string and whose value, when the attribute was set, could be successfully parsed relative to the element's node document, then the element's track URL is the resulting URL string. Otherwise, the element's track URL is the empty string.

If the element's track URL identifies a WebVTT resource, and the element's kind attribute is not in the chapters metadata or metadata state, then the WebVTT file must be a WebVTT file using cue text. [WEBVTT]

The srclang attribute gives the language of the text track data. The value must be a valid BCP 47 language tag. This attribute must be present if the element's kind attribute is in the subtitles state. [BCP47]

If the element has a srclang attribute whose value is not the empty string, then the element's track language is the value of the attribute. Otherwise, the element has no track language.

The label attribute gives a user-readable title for the track. This title is used by user agents when listing subtitle, caption, and audio description tracks in their user interface.

The value of the label attribute, if the attribute is present, must not be the empty string. Furthermore, there must not be two track element children of the same media element whose kind attributes are in the same state, whose srclang attributes are both missing or have values that represent the same language, and whose label attributes are again both missing or both have the same value.

If the element has a label attribute whose value is not the empty string, then the element's track label is the value of the attribute. Otherwise, the element's track label is an empty string.

The default attribute is a boolean attribute, which, if specified, indicates that the track is to be enabled if the user's preferences do not indicate that another track would be more appropriate.

Each media element must have no more than one track element child whose kind attribute is in the subtitles or captions state and whose default attribute is specified.

Each media element must have no more than one track element child whose kind attribute is in the description state and whose default attribute is specified.

Each media element must have no more than one track element child whose kind attribute is in the chapters metadata state and whose default attribute is specified.

There is no limit on the number of track elements whose kind attribute is in the metadata state and whose default attribute is specified.

track . readyState
Returns the text track readiness state, represented by a number from the following list:

track . NONE (0)
The text track not loaded state.

track . LOADING (1)
The text track loading state.

track . LOADED (2)
The text track loaded state.

track . ERROR (3)
The text track failed to load state.

track . track
Returns the TextTrack object corresponding to the text track of the track element.

The readyState attribute must return the numeric value corresponding to the text track readiness state of the track element's text track, as defined by the following list:

NONE (numeric value 0)
The text track not loaded state.
LOADING (numeric value 1)
The text track loading state.
LOADED (numeric value 2)
The text track loaded state.
ERROR (numeric value 3)
The text track failed to load state.
The track IDL attribute must, on getting, return the track element's text track's corresponding TextTrack object.

The src, srclang, label, and default IDL attributes must reflect the respective content attributes of the same name. The kind IDL attribute must reflect the content attribute of the same name, limited to only known values.

This video has subtitles in several languages:

<video src="brave.webm">
 <track kind=subtitles src=brave.en.vtt srclang=en label="English">
 <track kind=captions src=brave.en.hoh.vtt srclang=en label="English for the Hard of Hearing">
 <track kind=subtitles src=brave.fr.vtt srclang=fr lang=fr label="Français">
 <track kind=subtitles src=brave.de.vtt srclang=de lang=de label="Deutsch">
</video>
(The lang attributes on the last two describe the language of the label attribute, not the language of the subtitles themselves. The language of the subtitles is given by the srclang attribute.)

4.8.12 Media elements

Spec bugs: 28625

HTMLMediaElement objects (audio and video, in this specification) are simply known as media elements.

enum CanPlayTypeResult { "" /* empty string */, "maybe", "probably" };
typedef (MediaStream or MediaSource or Blob) MediaProvider;

[Exposed=Window]
interface HTMLMediaElement : HTMLElement {

  // error state
  readonly attribute MediaError? error;

  // network state
  [CEReactions] attribute USVString src;
  attribute MediaProvider? srcObject;
  readonly attribute USVString currentSrc;
  [CEReactions] attribute DOMString? crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
  [CEReactions] attribute DOMString preload;
  readonly attribute TimeRanges buffered;
  void load();
  CanPlayTypeResult canPlayType(DOMString type);

  // ready state
  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

  // playback state
  attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  object getStartDate();
  readonly attribute boolean paused;
  attribute double defaultPlaybackRate;
  attribute double playbackRate;
  readonly attribute TimeRanges played;
  readonly attribute TimeRanges seekable;
  readonly attribute boolean ended;
  [CEReactions] attribute boolean autoplay;
  [CEReactions] attribute boolean loop;
  Promise<void> play();
  void pause();

  // controls
  [CEReactions] attribute boolean controls;
  attribute double volume;
  attribute boolean muted;
  [CEReactions] attribute boolean defaultMuted;

  // tracks
  [SameObject] readonly attribute AudioTrackList audioTracks;
  [SameObject] readonly attribute VideoTrackList videoTracks;
  [SameObject] readonly attribute TextTrackList textTracks;
  TextTrack addTextTrack(TextTrackKind kind, optional DOMString label = "", optional DOMString language = "");
};
The media element attributes, src, crossorigin, preload, autoplay, loop, muted, and controls, apply to all media elements. They are defined in this section.

Media elements are used to present audio data, or video and audio data, to the user. This is referred to as media data in this section, since this section applies equally to media elements for audio or for video. The term media resource is used to refer to the complete set of media data, e.g. the complete video file, or complete audio file.

A media resource can have multiple audio and video tracks. For the purposes of a media element, the video data of the media resource is only that of the currently selected track (if any) as given by the element's videoTracks attribute when the event loop last reached step 1, and the audio data of the media resource is the result of mixing all the currently enabled tracks (if any) given by the element's audioTracks attribute when the event loop last reached step 1.

Both audio and video elements can be used for both audio and video. The main difference between the two is simply that the audio element has no playback area for visual content (such as video or captions), whereas the video element does.

Except where otherwise explicitly specified, the task source for all the tasks queued in this section and its subsections is the media element event task source of the media element in question.

4.8.12.1 Error codes
media . error
Returns a MediaError object representing the current error state of the element.

Returns null if there is no error.

All media elements have an associated error status, which records the last error the element encountered since its resource selection algorithm was last invoked. The error attribute, on getting, must return the MediaError object created for this last error, or null if there has not been an error.

[Exposed=Window]
interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  readonly attribute unsigned short code;
  readonly attribute DOMString message;
};
media . error . code
Returns the current error's error code, from the list below.

media . error . message
Returns a specific informative diagnostic message about the error condition encountered. The message and message format are not generally uniform across different user agents. If no such message is available, then the empty string is returned.

Every MediaError object has a message, which is a string, and a code, which is one of the following:

MEDIA_ERR_ABORTED (numeric value 1)
The fetching process for the media resource was aborted by the user agent at the user's request.
MEDIA_ERR_NETWORK (numeric value 2)
A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.
MEDIA_ERR_DECODE (numeric value 3)
An error of some description occurred while decoding the media resource, after the resource was established to be usable.
MEDIA_ERR_SRC_NOT_SUPPORTED (numeric value 4)
The media resource indicated by the src attribute or assigned media provider object was not suitable.
To create a MediaError, given an error code which is one of the above values, return a new MediaError object whose code is the given error code and whose message is a string containing any details the user agent is able to supply about the cause of the error condition, or the empty string if the user agent is unable to supply such details. This message string must not contain only the information already available via the supplied error code; for example, it must not simply be a translation of the code into a string format. If no additional information is available beyond that provided by the error code, the message must be set to the empty string.

The code attribute of a MediaError object must return this MediaError object's code.

The message attribute of a MediaError object must return this MediaError object's message.

4.8.12.2 Location of the media resource
The src content attribute on media elements gives the URL of the media resource (video, audio) to show. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.

If the itemprop attribute is specified on the media element, then the src attribute must also be specified.

The crossorigin content attribute on media elements is a CORS settings attribute.

If a media element is created with a src attribute, the user agent must immediately invoke the media element's resource selection algorithm.

If a src attribute of a media element is set or changed, the user agent must invoke the media element's media element load algorithm. (Removing the src attribute does not do this, even if there are source elements present.)

The src IDL attribute on media elements must reflect the content attribute of the same name.

The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

A media provider object is an object that can represent a media resource, separate from a URL. MediaStream objects, MediaSource objects, and Blob objects are all media provider objects.

Each media element can have an assigned media provider object, which is a media provider object. When a media element is created, it has no assigned media provider object.

media . srcObject [ = source ]
Allows the media element to be assigned a media provider object.

media . currentSrc
Returns the URL of the current media resource, if any.

Returns the empty string when there is no media resource, or it doesn't have a URL.

The currentSrc IDL attribute must initially be set to the empty string. Its value is changed by the resource selection algorithm defined below.

The srcObject IDL attribute, on getting, must return the element's assigned media provider object, if any, or null otherwise. On setting, it must set the element's assigned media provider object to the new value, and then invoke the element's media element load algorithm.

There are three ways to specify a media resource: the srcObject IDL attribute, the src content attribute, and source elements. The IDL attribute takes priority, followed by the content attribute, followed by the elements.

4.8.12.3 MIME types
A media resource can be described in terms of its type, specifically a MIME type, in some cases with a codecs parameter. (Whether the codecs parameter is allowed or not depends on the MIME type.) [RFC6381]

Types are usually somewhat incomplete descriptions; for example "video/mpeg" doesn't say anything except what the container type is, and even a type like "video/mp4; codecs="avc1.42E01E, mp4a.40.2"" doesn't include information like the actual bitrate (only the maximum bitrate). Thus, given a type, a user agent can often only know whether it might be able to play media of that type (with varying levels of confidence), or whether it definitely cannot play media of that type.

A type that the user agent knows it cannot render is one that describes a resource that the user agent definitely does not support, for example because it doesn't recognize the container type, or it doesn't support the listed codecs.

The MIME type "application/octet-stream" with no parameters is never a type that the user agent knows it cannot render. User agents must treat that type as equivalent to the lack of any explicit Content-Type metadata when it is used to label a potential media resource.

Only the MIME type "application/octet-stream" with no parameters is special-cased here; if any parameter appears with it, it will be treated just like any other MIME type. This is a deviation from the rule that unknown MIME type parameters should be ignored.

media . canPlayType(type)
Returns the empty string (a negative response), "maybe", or "probably" based on how confident the user agent is that it can play media resources of the given type.

The canPlayType(type) method must return the empty string if type is a type that the user agent knows it cannot render or is the type "application/octet-stream"; it must return "probably" if the user agent is confident that the type represents a media resource that it can render if used in with this audio or video element; and it must return "maybe" otherwise. Implementors are encouraged to return "maybe" unless the type can be confidently established as being supported or not. Generally, a user agent should never return "probably" for a type that allows the codecs parameter if that parameter is not present.

This script tests to see if the user agent supports a (fictional) new format to dynamically decide whether to use a video element or a plugin:

<section id="video">
 <p><a href="playing-cats.nfv">Download video</a></p>
</section>
<script>
 var videoSection = document.getElementById('video');
 var videoElement = document.createElement('video');
 var support = videoElement.canPlayType('video/x-new-fictional-format;codecs="kittens,bunnies"');
 if (support != "probably" && "New Fictional Video Plugin" in navigator.plugins) {
   // not confident of browser support
   // but we have a plugin
   // so use plugin instead
   videoElement = document.createElement("embed");
 } else if (support == "") {
   // no support from browser and no plugin
   // do nothing
   videoElement = null;
 }
 if (videoElement) {
   while (videoSection.hasChildNodes())
     videoSection.removeChild(videoSection.firstChild);
   videoElement.setAttribute("src", "playing-cats.nfv");
   videoSection.appendChild(videoElement);
 }
</script>
The type attribute of the source element allows the user agent to avoid downloading resources that use formats it cannot render.

4.8.12.4 Network states
media . networkState
Returns the current state of network activity for the element, from the codes in the list below.

As media elements interact with the network, their current network activity is represented by the networkState attribute. On getting, it must return the current network state of the element, which must be one of the following values:

NETWORK_EMPTY (numeric value 0)
The element has not yet been initialized. All attributes are in their initial states.
NETWORK_IDLE (numeric value 1)
The element's resource selection algorithm is active and has selected a resource, but it is not actually using the network at this time.
NETWORK_LOADING (numeric value 2)
The user agent is actively trying to download data.
NETWORK_NO_SOURCE (numeric value 3)
The element's resource selection algorithm is active, but it has not yet found a resource to use.
The resource selection algorithm defined below describes exactly when the networkState attribute changes value and what events fire to indicate changes in this state.

4.8.12.5 Loading the media resource

Spec bugs: 27989

media . load()
Causes the element to reset and start selecting and loading a new media resource from scratch.

All media elements have a can autoplay flag, which must begin in the true state, and a delaying-the-load-event flag, which must begin in the false state. While the delaying-the-load-event flag is true, the element must delay the load event of its document.

When the load() method on a media element is invoked, the user agent must run the media element load algorithm.

The media element load algorithm consists of the following steps.

Abort any already-running instance of the resource selection algorithm for this element.

Let pending tasks be a list of all tasks from the media element's media element event task source in one of the task queues.

For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.

Remove each task in pending tasks from its task queue

Basically, pending events and callbacks are discarded and promises in-flight to be resolved/rejected are resolved/rejected immediately when the media element starts loading a new resource.

If the media element's networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue a task to fire an event named abort at the media element.

If the media element's networkState is not set to NETWORK_EMPTY, then:

Queue a task to fire an event named emptied at the media element.

If a fetching process is in progress for the media element, the user agent should stop it.

If the media element's assigned media provider object is a MediaSource object, then detach it.

Forget the media element's media-resource-specific tracks.

If readyState is not set to HAVE_NOTHING, then set it to that state.

If the paused attribute is false, then:

Set the paused attribute to true.

Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.

If seeking is true, set it to false.

Set the current playback position to 0.

Set the official playback position to 0.

If this changed the official playback position, then queue a task to fire an event named timeupdate at the media element.

Set the timeline offset to Not-a-Number (NaN).

Update the duration attribute to Not-a-Number (NaN).

The user agent will not fire a durationchange event for this particular change of the duration.

Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.

Set the error attribute to null and the can autoplay flag to true.

Invoke the media element's resource selection algorithm.

Playback of any previously playing media resource for this element stops.

The resource selection algorithm for a media element is as follows. This algorithm is always invoked as part of a task, but one of the first steps in the algorithm is to return and continue running the remaining steps in parallel. In addition, this algorithm interacts closely with the event loop mechanism; in particular, it has synchronous sections (which are triggered as part of the event loop algorithm). Steps in such sections are marked with ⌛.

Set the element's networkState attribute to the NETWORK_NO_SOURCE value.

Set the element's show poster flag to true.

Set the media element's delaying-the-load-event flag to true (this delays the load event).

Await a stable state, allowing the task that invoked this algorithm to continue. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

⌛ If the media element's blocked-on-parser flag is false, then populate the list of pending text tracks.

⌛ If the media element has an assigned media provider object, then let mode be object.

⌛ Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.

⌛ Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute, but does have a source element child, then let mode be children and let candidate be the first such source element child in tree order.

⌛ Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source element child: set the networkState to NETWORK_EMPTY, and return; the synchronous section ends.

⌛ Set the media element's networkState to NETWORK_LOADING.

⌛ Queue a task to fire an event named loadstart at the media element.

Run the appropriate steps from the following list:

If mode is object
⌛ Set the currentSrc attribute to the empty string.

End the synchronous section, continuing the remaining steps in parallel.

Run the resource fetch algorithm with the assigned media provider object. If that algorithm returns without aborting this one, then the load failed.

Failed with media provider: Reaching this step indicates that the media resource failed to load. Take pending play promises and queue a task to run the dedicated media source failure steps with the result.

Wait for the task queued by the previous step to have executed.

Return. The element won't attempt to load another resource until this algorithm is triggered again.

If mode is attribute
⌛ If the src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with attribute step below.

⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by the src attribute's value relative to the media element's node document when the src attribute was last changed.

⌛ If urlString was obtained successfully, set the currentSrc attribute to urlString.

End the synchronous section, continuing the remaining steps in parallel.

If urlRecord was obtained successfully, run the resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then the load failed.

Failed with attribute: Reaching this step indicates that the media resource failed to load or that the given URL could not be parsed. Take pending play promises and queue a task to run the dedicated media source failure steps with the result.

Wait for the task queued by the previous step to have executed.

Return. The element won't attempt to load another resource until this algorithm is triggered again.

Otherwise (mode is children)
⌛ Let pointer be a position defined by two adjacent nodes in the media element's child list, treating the start of the list (before the first child in the list, if any) and end of the list (after the last child in the list, if any) as nodes in their own right. One node is the node before pointer, and the other node is the node after pointer. Initially, let pointer be the position between the candidate node and the next node, if there are any, or the end of the list, if it is the last node.

As nodes are inserted and removed into the media element, pointer must be updated as follows:

If a new node is inserted between the two nodes that define pointer
Let pointer be the point between the node before pointer and the new node. In other words, insertions at pointer go after pointer.
If the node before pointer is removed
Let pointer be the point between the node after pointer and the node before the node after pointer. In other words, pointer doesn't move relative to the remaining nodes.
If the node after pointer is removed
Let pointer be the point between the node before pointer and the node after the node before pointer. Just as with the previous case, pointer doesn't move relative to the remaining nodes.
Other changes don't affect pointer.

⌛ Process candidate: If candidate does not have a src attribute, or if its src attribute's value is the empty string, then end the synchronous section, and jump down to the failed with elements step below.

⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively, that would have resulted from parsing the URL specified by candidate's src attribute's value relative to the candidate's node document when the src attribute was last changed.

⌛ If urlString was not obtained successfully, then end the synchronous section, and jump down to the failed with elements step below.

⌛ If candidate has a type attribute whose value, when parsed as a MIME type (including any codecs described by the codecs parameter, for types that define that parameter), represents a type that the user agent knows it cannot render, then end the synchronous section, and jump down to the failed with elements step below.

⌛ Set the currentSrc attribute to urlString.

End the synchronous section, continuing the remaining steps in parallel.

Run the resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then the load failed.

Failed with elements: Queue a task to fire an event named error at the candidate element.

Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

⌛ Forget the media element's media-resource-specific tracks.

⌛ Find next candidate: Let candidate be null.

⌛ Search loop: If the node after pointer is the end of the list, then jump to the waiting step below.

⌛ If the node after pointer is a source element, let candidate be that element.

⌛ Advance pointer so that the node before pointer is now the node that was after pointer, and the node after pointer is the node after the node that used to be after pointer, if any.

⌛ If candidate is null, jump back to the search loop step. Otherwise, jump back to the process candidate step.

⌛ Waiting: Set the element's networkState attribute to the NETWORK_NO_SOURCE value.

⌛ Set the element's show poster flag to true.

⌛ Queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.

End the synchronous section, continuing the remaining steps in parallel.

Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)

Await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

⌛ Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).

⌛ Set the networkState back to NETWORK_LOADING.

⌛ Jump back to the find next candidate step above.

The dedicated media source failure steps with a list of promises promises are the following steps:

Set the error attribute to the result of creating a MediaError with MEDIA_ERR_SRC_NOT_SUPPORTED.

Forget the media element's media-resource-specific tracks.

Set the element's networkState attribute to the NETWORK_NO_SOURCE value.

Set the element's show poster flag to true.

Fire an event named error at the media element.

Reject pending play promises with promises and a "NotSupportedError" DOMException.

Set the element's delaying-the-load-event flag to false. This stops delaying the load event.

The resource fetch algorithm for a media element and a given URL record or media provider object is as follows:

If the algorithm was invoked with media provider object or a URL record whose object is a media provider object, then let mode be local. Otherwise let mode be remote.

If mode is remote, then let the current media resource be the resource given by the URL record passed to this algorithm; otherwise, let the current media resource be the resource given by the media provider object. Either way, the current media resource is now the element's media resource.

Remove all media-resource-specific text tracks from the media element's list of pending text tracks, if any.

Run the appropriate steps from the following list:

If mode is remote
Optionally, run the following substeps. This is the expected behavior if the user agent intends to not attempt to fetch the resource until the user requests it explicitly (e.g. as a way to implement the preload attribute's none keyword).

Set the networkState to NETWORK_IDLE.

Queue a task to fire an event named suspend at the element.

Queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.

Wait for the task to be run.

Wait for an implementation-defined event (e.g. the user requesting that the media element begin playback).

Set the element's delaying-the-load-event flag back to true (this delays the load event again, in case it hasn't been fired yet).

Set the networkState to NETWORK_LOADING.

Let destination be "audio" if the media element is an audio element and to "video" otherwise.

Let request be the result of creating a potential-CORS request given current media resource's URL record, destination, and the media element's crossorigin content attribute value.

Set request's client to the media element's node document's Window object's environment settings object.

Fetch request.

The response's unsafe response obtained in this fashion, if any, contains the media data. It can be CORS-same-origin or CORS-cross-origin; this affects whether subtitles referenced in the media data are exposed in the API and, for video elements, whether a canvas gets tainted when the video is drawn on it.

The stall timeout is a user-agent defined length of time, which should be about three seconds. When a media element that is actively attempting to obtain media data has failed to receive any data for a duration equal to the stall timeout, the user agent must queue a task to fire an event named stalled at the element.

User agents may allow users to selectively block or slow media data downloads. When a media element's download has been blocked altogether, the user agent must act as if it was stalled (as opposed to acting as if the connection was closed). The rate of the download may also be throttled automatically by the user agent, e.g. to balance the download with other connections sharing the same bandwidth.

User agents may decide to not download more content at any time, e.g. after buffering five minutes of a one hour media resource, while waiting for the user to decide whether to play the resource or not, while waiting for user input in an interactive resource, or when the user navigates away from the page. When a media element's download has been suspended, the user agent must queue a task, to set the networkState to NETWORK_IDLE and fire an event named suspend at the element. If and when downloading of the resource resumes, the user agent must queue a task to set the networkState to NETWORK_LOADING. Between the queuing of these tasks, the load is suspended (so progress events don't fire, as described above).

The preload attribute provides a hint regarding how much buffering the author thinks is advisable, even in the absence of the autoplay attribute.

When a user agent decides to completely suspend a download, e.g., if it is waiting until the user starts playback before downloading any further content, the user agent must queue a task to set the element's delaying-the-load-event flag to false. This stops delaying the load event.

The user agent may use whatever means necessary to fetch the resource (within the constraints put forward by this and other specifications); for example, reconnecting to the server in the face of network errors, using HTTP range retrieval requests, or switching to a streaming protocol. The user agent must consider a resource erroneous only if it has given up trying to fetch it.

To determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically.

While the load is not suspended (see below), every 350ms (±200ms) or for every byte received, whichever is least frequent, queue a task to fire an event named progress at the element.

The networking task source tasks to process the data as it is being fetched must each immediately queue a task to run the first appropriate steps from the media data processing steps list below. (A new task is used for this so that the work described below occurs relative to the media element event task source rather than the networking task source.)

When the networking task source has queued the last task as part of fetching the media resource (i.e. once the download has completed), if the fetching process completes without errors, including decoding the media data, and if all of the data is available to the user agent without network access, then, the user agent must move on to the final step below. This might never happen, e.g. when streaming an infinite resource such as Web radio, or if the resource is longer than the user agent's ability to cache data.

While the user agent might still need network access to obtain parts of the media resource, the user agent must remain on this step.

For example, if the user agent has discarded the first half of a video, the user agent will remain at this step even once the playback has ended, because there is always the chance the user will seek back to the start. In fact, in this situation, once playback has ended, the user agent will end up firing a suspend event, as described earlier.

Otherwise (mode is local)
The resource described by the current media resource, if any, contains the media data. It is CORS-same-origin.

If the current media resource is a raw data stream (e.g. from a File object), then to determine the format of the media resource, the user agent must use the rules for sniffing audio and video specifically. Otherwise, if the data stream is pre-decoded, then the format is the format given by the relevant specification.

Whenever new data for the current media resource becomes available, queue a task to run the first appropriate steps from the media data processing steps list below.

When the current media resource is permanently exhausted (e.g. all the bytes of a Blob have been processed), if there were no decoding errors, then the user agent must move on to the final step below. This might never happen, e.g. if the current media resource is a MediaStream.

The media data processing steps list is as follows:

If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying to fetch the resource
If the media data can be fetched but is found by inspection to be in an unsupported format, or can otherwise not be rendered at all
DNS errors, HTTP 4xx and 5xx errors (and equivalents in other protocols), and other fatal network errors that occur before the user agent has established whether the current media resource is usable, as well as the file using an unsupported container format, or using unsupported codecs for all the data, must cause the user agent to execute the following steps:

The user agent should cancel the fetching process.

Abort this subalgorithm, returning to the resource selection algorithm.

If the media resource is found to have an audio track
Create an AudioTrack object to represent the audio track.

Update the media element's audioTracks attribute's AudioTrackList object with the new AudioTrack object.

Let enable be unknown.

If either the media resource or the URL of the current media resource indicate a particular set of audio tracks to enable, or if the user agent has information that would facilitate the selection of specific audio tracks to improve the user's experience, then: if this audio track is one of the ones to enable, then set enable to true, otherwise, set enable to false.

This could be triggered by media fragment syntax, but it could also be triggered e.g. by the user agent selecting a 5.1 surround sound audio track over a stereo audio track.

If enable is still unknown, then, if the media element does not yet have an enabled audio track, then set enable to true, otherwise, set enable to false.

If enable is true, then enable this audio track, otherwise, do not enable this audio track.

Fire an event named addtrack at this AudioTrackList object, using TrackEvent, with the track attribute initialized to the new AudioTrack object.

If the media resource is found to have a video track
Create a VideoTrack object to represent the video track.

Update the media element's videoTracks attribute's VideoTrackList object with the new VideoTrack object.

Let enable be unknown.

If either the media resource or the URL of the current media resource indicate a particular set of video tracks to enable, or if the user agent has information that would facilitate the selection of specific video tracks to improve the user's experience, then: if this video track is the first such video track, then set enable to true, otherwise, set enable to false.

This could again be triggered by media fragment syntax.

If enable is still unknown, then, if the media element does not yet have a selected video track, then set enable to true, otherwise, set enable to false.

If enable is true, then select this track and unselect any previously selected video tracks, otherwise, do not select this video track. If other tracks are unselected, then a change event will be fired.

Fire an event named addtrack at this VideoTrackList object, using TrackEvent, with the track attribute initialized to the new VideoTrack object.

Once enough of the media data has been fetched to determine the duration of the media resource, its dimensions, and other metadata
This indicates that the resource is usable. The user agent must follow these substeps:

Establish the media timeline for the purposes of the current playback position and the earliest possible position, based on the media data.

Update the timeline offset to the date and time that corresponds to the zero time in the media timeline established in the previous step, if any. If no explicit time and date is given by the media resource, the timeline offset must be set to Not-a-Number (NaN).

Set the current playback position and the official playback position to the earliest possible position.

Update the duration attribute with the time of the last frame of the resource, if known, on the media timeline established above. If it is not known (e.g. a stream that is in principle infinite), update the duration attribute to the value positive Infinity.

The user agent will queue a task to fire an event named durationchange at the element at this point.

For video elements, set the videoWidth and videoHeight attributes, and queue a task to fire an event named resize at the media element.

Further resize events will be fired if the dimensions subsequently change.

Set the readyState attribute to HAVE_METADATA.

A loadedmetadata DOM event will be fired as part of setting the readyState attribute to a new value.

Let jumped be false.

If the media element's default playback start position is greater than zero, then seek to that time, and let jumped be true.

Let the media element's default playback start position be zero.

Let the initial playback position be zero.

If either the media resource or the URL of the current media resource indicate a particular start time, then set the initial playback position to that time and, if jumped is still false, seek to that time.

For example, with media formats that support media fragment syntax, the fragment can be used to indicate a start position.

If there is no enabled audio track, then enable an audio track. This will cause a change event to be fired.

If there is no selected video track, then select a video track. This will cause a change event to be fired.

Once the readyState attribute reaches HAVE_CURRENT_DATA, after the loadeddata event has been fired, set the element's delaying-the-load-event flag to false. This stops delaying the load event.

A user agent that is attempting to reduce network usage while still fetching the metadata for each media resource would also stop buffering at this point, following the rules described previously, which involve the networkState attribute switching to the NETWORK_IDLE value and a suspend event firing.

The user agent is required to determine the duration of the media resource and go through this step before playing.

Once the entire media resource has been fetched (but potentially before any of it has been decoded)
Fire an event named progress at the media element.

Set the networkState to NETWORK_IDLE and fire an event named suspend at the media element.

If the user agent ever discards any media data and then needs to resume the network activity to obtain it again, then it must queue a task to set the networkState to NETWORK_LOADING.

If the user agent can keep the media resource loaded, then the algorithm will continue to its final step below, which aborts the algorithm.

If the connection is interrupted after some media data has been received, causing the user agent to give up trying to fetch the resource
Fatal network errors that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING) must cause the user agent to execute the following steps:

The user agent should cancel the fetching process.

Set the error attribute to the result of creating a MediaError with MEDIA_ERR_NETWORK.

Set the element's networkState attribute to the NETWORK_IDLE value.

Set the element's delaying-the-load-event flag to false. This stops delaying the load event.

Fire an event named error at the media element.

Abort the overall resource selection algorithm.

If the media data is corrupted
Fatal errors in decoding the media data that occur after the user agent has established whether the current media resource is usable (i.e. once the media element's readyState attribute is no longer HAVE_NOTHING) must cause the user agent to execute the following steps:

The user agent should cancel the fetching process.

Set the error attribute to the result of creating a MediaError with MEDIA_ERR_DECODE.

Set the element's networkState attribute to the NETWORK_IDLE value.

Set the element's delaying-the-load-event flag to false. This stops delaying the load event.

Fire an event named error at the media element.

Abort the overall resource selection algorithm.

If the media data fetching process is aborted by the user
The fetching process is aborted by the user, e.g. because the user pressed a "stop" button, the user agent must execute the following steps. These steps are not followed if the load() method itself is invoked while these steps are running, as the steps above handle that particular kind of abort.

The user agent should cancel the fetching process.

Set the error attribute to the result of creating a MediaError with MEDIA_ERR_ABORTED.

Fire an event named abort at the media element.

If the media element's readyState attribute has a value equal to HAVE_NOTHING, set the element's networkState attribute to the NETWORK_EMPTY value, set the element's show poster flag to true, and fire an event named emptied at the element.

Otherwise, set the element's networkState attribute to the NETWORK_IDLE value.

Set the element's delaying-the-load-event flag to false. This stops delaying the load event.

Abort the overall resource selection algorithm.

If the media data can be fetched but has non-fatal errors or uses, in part, codecs that are unsupported, preventing the user agent from rendering the content completely correctly but not preventing playback altogether
The server returning data that is partially usable but cannot be optimally rendered must cause the user agent to render just the bits it can handle, and ignore the rest.

If the media resource is found to declare a media-resource-specific text track that the user agent supports
If the media data is CORS-same-origin, run the steps to expose a media-resource-specific text track with the relevant data.

Cross-origin videos do not expose their subtitles, since that would allow attacks such as hostile sites reading subtitles from confidential videos on a user's intranet.

Final step: If the user agent ever reaches this step (which can only happen if the entire resource gets loaded and kept available): abort the overall resource selection algorithm.

When a media element is to forget the media element's media-resource-specific tracks, the user agent must remove from the media element's list of text tracks all the media-resource-specific text tracks, then empty the media element's audioTracks attribute's AudioTrackList object, then empty the media element's videoTracks attribute's VideoTrackList object. No events (in particular, no removetrack events) are fired as part of this; the error and emptied events, fired by the algorithms that invoke this one, can be used instead.

The preload attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword. The attribute can be changed even once the media resource is being buffered or played; the descriptions in the table below are to be interpreted with that in mind.

Keyword	State	Brief description
none	None	Hints to the user agent that either the author does not expect the user to need the media resource, or that the server wants to minimize unnecessary traffic. This state does not provide a hint regarding how aggressively to actually download the media resource if buffering starts anyway (e.g. once the user hits "play").
metadata	Metadata	Hints to the user agent that the author does not expect the user to need the media resource, but that fetching the resource metadata (dimensions, track list, duration, etc), and maybe even the first few frames, is reasonable. If the user agent precisely fetches no more than the metadata, then the media element will end up with its readyState attribute set to HAVE_METADATA; typically though, some frames will be obtained as well and it will probably be HAVE_CURRENT_DATA or HAVE_FUTURE_DATA. When the media resource is playing, hints to the user agent that bandwidth is to be considered scarce, e.g. suggesting throttling the download so that the media data is obtained at the slowest possible rate that still maintains consistent playback.
auto	Automatic	Hints to the user agent that the user agent can put the user's needs first without risk to the server, up to and including optimistically downloading the entire resource.
The empty string is also a valid keyword, and maps to the Automatic state. The attribute's missing value default and invalid value default are user-agent defined, though the Metadata state is suggested as a compromise between reducing server load and providing an optimal user experience.

Authors might switch the attribute from "none" or "metadata" to "auto" dynamically once the user begins playback. For example, on a page with many videos this might be used to indicate that the many videos are not to be downloaded unless requested, but that once one is requested it is to be downloaded aggressively.

The preload attribute is intended to provide a hint to the user agent about what the author thinks will lead to the best user experience. The attribute may be ignored altogether, for example based on explicit user preferences or based on the available connectivity.

The preload IDL attribute must reflect the content attribute of the same name, limited to only known values.

The autoplay attribute can override the preload attribute (since if the media plays, it naturally has to buffer first, regardless of the hint given by the preload attribute). Including both is not an error, however.

media . buffered
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has buffered.

The buffered attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent has buffered, at the time the attribute is evaluated. Users agents must accurately determine the ranges available, even for media streams where this can only be determined by tedious inspection.

Typically this will be a single range anchored at the zero point, but if, e.g. the user agent uses HTTP range requests in response to seeking, then there could be multiple ranges.

User agents may discard previously buffered data.

Thus, a time position included within a range of the objects return by the buffered attribute at one time can end up being not included in the range(s) of objects returned by the same attribute at later times.

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.

4.8.12.6 Offsets into the media resource
media . duration
Returns the length of the media resource, in seconds, assuming that the start of the media resource is at time zero.

Returns NaN if the duration isn't available.

Returns Infinity for unbounded streams.

media . currentTime [ = value ]
Returns the official playback position, in seconds.

Can be set, to seek to the given time.

A media resource has a media timeline that maps times (in seconds) to positions in the media resource. The origin of a timeline is its earliest defined position. The duration of a timeline is its last defined position.

Establishing the media timeline: if the media resource somehow specifies an explicit timeline whose origin is not negative (i.e. gives each frame a specific time offset and gives the first frame a zero or positive offset), then the media timeline should be that timeline. (Whether the media resource can specify a timeline or not depends on the media resource's format.) If the media resource specifies an explicit start time and date, then that time and date should be considered the zero point in the media timeline; the timeline offset will be the time and date, exposed using the getStartDate() method.

If the media resource has a discontinuous timeline, the user agent must extend the timeline used at the start of the resource across the entire resource, so that the media timeline of the media resource increases linearly starting from the earliest possible position (as defined below), even if the underlying media data has out-of-order or even overlapping time codes.

For example, if two clips have been concatenated into one video file, but the video format exposes the original times for the two clips, the video data might expose a timeline that goes, say, 00:15..00:29 and then 00:05..00:38. However, the user agent would not expose those times; it would instead expose the times as 00:15..00:29 and 00:29..01:02, as a single video.

In the rare case of a media resource that does not have an explicit timeline, the zero time on the media timeline should correspond to the first frame of the media resource. In the even rarer case of a media resource with no explicit timings of any kind, not even frame durations, the user agent must itself determine the time for each frame in a user-agent-defined manner.
An example of a file format with no explicit timeline but with explicit frame durations is the Animated GIF format. An example of a file format with no explicit timings at all is the JPEG-push format (multipart/x-mixed-replace with JPEG frames, often used as the format for MJPEG streams).

If, in the case of a resource with no timing information, the user agent will nonetheless be able to seek to an earlier point than the first frame originally provided by the server, then the zero time should correspond to the earliest seekable time of the media resource; otherwise, it should correspond to the first frame received from the server (the point in the media resource at which the user agent began receiving the stream).

At the time of writing, there is no known format that lacks explicit frame time offsets yet still supports seeking to a frame before the first frame sent by the server.

Consider a stream from a TV broadcaster, which begins streaming on a sunny Friday afternoon in October, and always sends connecting user agents the media data on the same media timeline, with its zero time set to the start of this stream. Months later, user agents connecting to this stream will find that the first frame they receive has a time with millions of seconds. The getStartDate() method would always return the date that the broadcast started; this would allow controllers to display real times in their scrubber (e.g. "2:30pm") rather than a time relative to when the broadcast began ("8 months, 4 hours, 12 minutes, and 23 seconds").

Consider a stream that carries a video with several concatenated fragments, broadcast by a server that does not allow user agents to request specific times but instead just streams the video data in a predetermined order, with the first frame delivered always being identified as the frame with time zero. If a user agent connects to this stream and receives fragments defined as covering timestamps 2010-03-20 23:15:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, it would expose this with a media timeline starting at 0s and extending to 3,600s (one hour). Assuming the streaming server disconnected at the end of the second clip, the duration attribute would then return 3,600. The getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:15:00 UTC. However, if a different user agent connected five minutes later, it would (presumably) receive fragments covering timestamps 2010-03-20 23:20:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, and would expose this with a media timeline starting at 0s and extending to 3,300s (fifty five minutes). In this case, the getStartDate() method would return a Date object with a time corresponding to 2010-03-20 23:20:00 UTC.

In both of these examples, the seekable attribute would give the ranges that the controller would want to actually display in its UI; typically, if the servers don't support seeking to arbitrary times, this would be the range of time from the moment the user agent connected to the stream up to the latest frame that the user agent has obtained; however, if the user agent starts discarding earlier information, the actual range might be shorter.

In any case, the user agent must ensure that the earliest possible position (as defined below) using the established media timeline, is greater than or equal to zero.

The media timeline also has an associated clock. Which clock is used is user-agent defined, and may be media resource-dependent, but it should approximate the user's wall clock.

Media elements have a current playback position, which must initially (i.e. in the absence of media data) be zero seconds. The current playback position is a time on the media timeline.

Media elements also have an official playback position, which must initially be set to zero seconds. The official playback position is an approximation of the current playback position that is kept stable while scripts are running.

Media elements also have a default playback start position, which must initially be set to zero seconds. This time is used to allow the element to be seeked even before the media is loaded.

Each media element has a show poster flag. When a media element is created, this flag must be set to true. This flag is used to control when the user agent is to show a poster frame for a video element instead of showing the video contents.

The currentTime attribute must, on getting, return the media element's default playback start position, unless that is zero, in which case it must return the element's official playback position. The returned value must be expressed in seconds. On setting, if the media element's readyState is HAVE_NOTHING, then it must set the media element's default playback start position to the new value; otherwise, it must set the official playback position to the new value and then seek to the new value. The new value must be interpreted as being in seconds.

If the media resource is a streaming resource, then the user agent might be unable to obtain certain parts of the resource after it has expired from its buffer. Similarly, some media resources might have a media timeline that doesn't start at zero. The earliest possible position is the earliest position in the stream or resource that the user agent can ever obtain again. It is also a time on the media timeline.

The earliest possible position is not explicitly exposed in the API; it corresponds to the start time of the first range in the seekable attribute's TimeRanges object, if any, or the current playback position otherwise.

When the earliest possible position changes, then: if the current playback position is before the earliest possible position, the user agent must seek to the earliest possible position; otherwise, if the user agent has not fired a timeupdate event at the element in the past 15 to 250ms and is not still running event handlers for such an event, then the user agent must queue a task to fire an event named timeupdate at the element.

Because of the above requirement and the requirement in the resource fetch algorithm that kicks in when the metadata of the clip becomes known, the current playback position can never be less than the earliest possible position.

If at any time the user agent learns that an audio or video track has ended and all media data relating to that track corresponds to parts of the media timeline that are before the earliest possible position, the user agent may queue a task to run these steps:

Remove the track from the audioTracks attribute's AudioTrackList object or the videoTracks attribute's VideoTrackList object as appropriate.

Fire an event named removetrack at the media element's aforementioned AudioTrackList or VideoTrackList object, using TrackEvent, with the track attribute initialized to the AudioTrack or VideoTrack object representing the track.

The duration attribute must return the time of the end of the media resource, in seconds, on the media timeline. If no media data is available, then the attributes must return the Not-a-Number (NaN) value. If the media resource is not known to be bounded (e.g. streaming radio, or a live event with no announced end time), then the attribute must return the positive Infinity value.

The user agent must determine the duration of the media resource before playing any part of the media data and before setting readyState to a value equal to or greater than HAVE_METADATA, even if doing so requires fetching multiple parts of the resource.

When the length of the media resource changes to a known value (e.g. from being unknown to known, or from a previously established length to a new length) the user agent must queue a task to fire an event named durationchange at the media element. (The event is not fired when the duration is reset as part of loading a new media resource.) If the duration is changed such that the current playback position ends up being greater than the time of the end of the media resource, then the user agent must also seek to the time of the end of the media resource.

If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the time of the last frame or sample in the stream, and the durationchange event would be fired. Similarly, if the user agent initially estimated the media resource's duration instead of determining it precisely, and later revises the estimate based on new information, then the duration would change and the durationchange event would be fired.

Some video files also have an explicit date and time corresponding to the zero time in the media timeline, known as the timeline offset. Initially, the timeline offset must be set to Not-a-Number (NaN).

The getStartDate() method must return a new Date object representing the current timeline offset.

The loop attribute is a boolean attribute that, if specified, indicates that the media element is to seek back to the start of the media resource upon reaching the end.

The loop IDL attribute must reflect the content attribute of the same name.

4.8.12.7 Ready states
media . readyState
Returns a value that expresses the current state of the element with respect to rendering the current playback position, from the codes in the list below.

Media elements have a ready state, which describes to what degree they are ready to be rendered at the current playback position. The possible values are as follows; the ready state of a media element at any particular time is the greatest value describing the state of the element:

HAVE_NOTHING (numeric value 0)
No information regarding the media resource is available. No data for the current playback position is available. Media elements whose networkState attribute are set to NETWORK_EMPTY are always in the HAVE_NOTHING state.

HAVE_METADATA (numeric value 1)
Enough of the resource has been obtained that the duration of the resource is available. In the case of a video element, the dimensions of the video are also available. No media data is available for the immediate current playback position.

HAVE_CURRENT_DATA (numeric value 2)
Data for the immediate current playback position is available, but either not enough data is available that the user agent could successfully advance the current playback position in the direction of playback at all without immediately reverting to the HAVE_METADATA state, or there is no more data to obtain in the direction of playback. For example, in video this corresponds to the user agent having data from the current frame, but not the next frame, when the current playback position is at the end of the current frame; and to when playback has ended.

HAVE_FUTURE_DATA (numeric value 3)
Data for the immediate current playback position is available, as well as enough data for the user agent to advance the current playback position in the direction of playback at least a little without immediately reverting to the HAVE_METADATA state, and the text tracks are ready. For example, in video this corresponds to the user agent having data for at least the current frame and the next frame when the current playback position is at the instant in time between the two frames, or to the user agent having the video data for the current frame and audio data to keep playing at least a little when the current playback position is in the middle of a frame. The user agent cannot be in this state if playback has ended, as the current playback position can never advance in this case.

HAVE_ENOUGH_DATA (numeric value 4)
All the conditions described for the HAVE_FUTURE_DATA state are met, and, in addition, either of the following conditions is also true:

The user agent estimates that data is being fetched at a rate where the current playback position, if it were to advance at the element's playbackRate, would not overtake the available data before playback reaches the end of the media resource.
The user agent has entered a state where waiting longer will not result in further data being obtained, and therefore nothing would be gained by delaying playback any further. (For example, the buffer might be full.)
In practice, the difference between HAVE_METADATA and HAVE_CURRENT_DATA is negligible. Really the only time the difference is relevant is when painting a video element onto a canvas, where it distinguishes the case where something will be drawn (HAVE_CURRENT_DATA or greater) from the case where nothing is drawn (HAVE_METADATA or less). Similarly, the difference between HAVE_CURRENT_DATA (only the current frame) and HAVE_FUTURE_DATA (at least this frame and the next) can be negligible (in the extreme, only one frame). The only time that distinction really matters is when a page provides an interface for "frame-by-frame" navigation.

When the ready state of a media element whose networkState is not NETWORK_EMPTY changes, the user agent must follow the steps given below:

Apply the first applicable set of substeps from the following list:

If the previous ready state was HAVE_NOTHING, and the new ready state is HAVE_METADATA
Queue a task to fire an event named loadedmetadata at the element.

Before this task is run, as part of the event loop mechanism, the rendering will have been updated to resize the video element if appropriate.

If the previous ready state was HAVE_METADATA and the new ready state is HAVE_CURRENT_DATA or greater
If this is the first time this occurs for this media element since the load() algorithm was last invoked, the user agent must queue a task to fire an event named loadeddata at the element.

If the new ready state is HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then the relevant steps below must then be run also.

If the previous ready state was HAVE_FUTURE_DATA or more, and the new ready state is HAVE_CURRENT_DATA or less
If the media element was potentially playing before its readyState attribute changed to a value lower than HAVE_FUTURE_DATA, and the element has not ended playback, and playback has not stopped due to errors, paused for user interaction, or paused for in-band content, the user agent must queue a task to fire an event named timeupdate at the element, and queue a task to fire an event named waiting at the element.

If the previous ready state was HAVE_CURRENT_DATA or less, and the new ready state is HAVE_FUTURE_DATA
The user agent must queue a task to fire an event named canplay at the element.

If the element's paused attribute is false, the user agent must notify about playing for the element.

If the new ready state is HAVE_ENOUGH_DATA
If the previous ready state was HAVE_CURRENT_DATA or less, the user agent must queue a task to fire an event named canplay at the element, and, if the element's paused attribute is false, notify about playing for the element.

The user agent must queue a task to fire an event named canplaythrough at the element.

If the element is not eligible for autoplay, then the user agent must abort these substeps.

The user agent may run the following substeps:

This specification doesn't define the precise timing for when the intersection is tested, but it is suggested that the timing match that of the Intersection Observer API. [INTERSECTIONOBSERVER]

Set the paused attribute to false.
If the element's show poster flag is true, set it to false and run the time marches on steps.
Queue a task to fire an event named play at the element.
Notify about playing for the element.
Alternatively, if the element is a video element, the user agent may start observing whether the element intersects the viewport. When the element starts intersecting the viewport, if the element is still eligible for autoplay, run the substeps above. Optionally, when the element stops intersecting the viewport, if the can autoplay flag is still true and the autoplay attribute is still specified, run the following substeps:

This specification doesn't define the precise timing for when the intersection is tested, but it is suggested that the timing match that of the Intersection Observer API. [INTERSECTIONOBSERVER]

Run the internal pause steps and set the can autoplay flag to true.
Queue a task to fire an event named pause at the element.
The substeps for playing and pausing can run multiple times as the element starts or stops intersecting the viewport, as long as the can autoplay flag is true.

User agents do not need to support autoplay, and it is suggested that user agents honor user preferences on the matter. Authors are urged to use the autoplay attribute rather than using script to force the video to play, so as to allow the user to override the behavior if so desired.

It is possible for the ready state of a media element to jump between these states discontinuously. For example, the state of a media element can jump straight from HAVE_METADATA to HAVE_ENOUGH_DATA without passing through the HAVE_CURRENT_DATA and HAVE_FUTURE_DATA states.

The readyState IDL attribute must, on getting, return the value described above that describes the current ready state of the media element.

The autoplay attribute is a boolean attribute. When present, the user agent (as described in the algorithm described herein) will automatically begin playback of the media resource as soon as it can do so without stopping.

Authors are urged to use the autoplay attribute rather than using script to trigger automatic playback, as this allows the user to override the automatic playback when it is not desired, e.g. when using a screen reader. Authors are also encouraged to consider not using the automatic playback behavior at all, and instead to let the user agent wait for the user to start playback explicitly.

The autoplay IDL attribute must reflect the content attribute of the same name.

4.8.12.8 Playing the media resource

Spec bugs: 28032

media . paused
Returns true if playback is paused; false otherwise.

media . ended
Returns true if playback has reached the end of the media resource.

media . defaultPlaybackRate [ = value ]
Returns the default rate of playback, for when the user is not fast-forwarding or reversing through the media resource.

Can be set, to change the default rate of playback.

The default rate has no direct effect on playback, but if the user switches to a fast-forward mode, when they return to the normal playback mode, it is expected that the rate of playback will be returned to the default rate of playback.

media . playbackRate [ = value ]
Returns the current rate playback, where 1.0 is normal speed.

Can be set, to change the rate of playback.

media . played
Returns a TimeRanges object that represents the ranges of the media resource that the user agent has played.

media . play()
Sets the paused attribute to false, loading the media resource and beginning playback if necessary. If the playback had ended, will restart it from the start.

media . pause()
Sets the paused attribute to true, loading the media resource if necessary.

The paused attribute represents whether the media element is paused or not. The attribute must initially be true.

A media element is a blocked media element if its readyState attribute is in the HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state, or if the element has paused for user interaction or paused for in-band content.

A media element is said to be potentially playing when its paused attribute is false, the element has not ended playback, playback has not stopped due to errors, and the element is not a blocked media element.

A waiting DOM event can be fired as a result of an element that is potentially playing stopping playback due to its readyState attribute changing to a value lower than HAVE_FUTURE_DATA.

A media element is said to be eligible for autoplay when its can autoplay flag is true, its paused attribute is true, the element has an autoplay attribute specified, and the element's node document's active sandboxing flag set does not have the sandboxed automatic features browsing context flag set.

A media element is said to be allowed to play if the user agent and the system allow media playback in the current context.

For example, a user agent could require that playback is triggered by user activation, but an exception could be made to allow playback while muted.

A media element is said to have ended playback when:

The element's readyState attribute is HAVE_METADATA or greater, and
Either:

The current playback position is the end of the media resource, and
The direction of playback is forwards, and
The media element does not have a loop attribute specified.
Or:

The current playback position is the earliest possible position, and
The direction of playback is backwards.
The ended attribute must return true if, the last time the event loop reached step 1, the media element had ended playback and the direction of playback was forwards, and false otherwise.

A media element is said to have stopped due to errors when the element's readyState attribute is HAVE_METADATA or greater, and the user agent encounters a non-fatal error during the processing of the media data, and due to that error, is not able to play the content at the current playback position.

A media element is said to have paused for user interaction when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has reached a point in the media resource where the user has to make a selection for the resource to continue.

It is possible for a media element to have both ended playback and paused for user interaction at the same time.

When a media element that is potentially playing stops playing because it has paused for user interaction, the user agent must queue a task to fire an event named timeupdate at the element.

A media element is said to have paused for in-band content when its paused attribute is false, the readyState attribute is either HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has suspended playback of the media resource in order to play content that is temporally anchored to the media resource and has a nonzero length, or to play content that is temporally anchored to a segment of the media resource but has a length longer than that segment.

One example of when a media element would be paused for in-band content is when the user agent is playing audio descriptions from an external WebVTT file, and the synthesized speech generated for a cue is longer than the time between the text track cue start time and the text track cue end time.

When the current playback position reaches the end of the media resource when the direction of playback is forwards, then the user agent must follow these steps:

If the media element has a loop attribute specified, then seek to the earliest possible position of the media resource and return.

As defined above, the ended IDL attribute starts returning true once the event loop returns to step 1.

Queue a task to run these steps:

Fire an event named timeupdate at the media element.

If the media element has ended playback, the direction of playback is forwards, and paused is false, then:

Set the paused attribute to true.

Fire an event named pause at the media element.

Take pending play promises and reject pending play promises with the result and an "AbortError" DOMException.

Fire an event named ended at the media element.

When the current playback position reaches the earliest possible position of the media resource when the direction of playback is backwards, then the user agent must only queue a task to fire an event named timeupdate at the element.

The word "reaches" here does not imply that the current playback position needs to have changed during normal playback; it could be via seeking, for instance.

The defaultPlaybackRate attribute gives the desired speed at which the media resource is to play, as a multiple of its intrinsic speed. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting the attribute must be set to the new value.

The defaultPlaybackRate is used by the user agent when it exposes a user interface to the user.

The playbackRate attribute gives the effective playback rate, which is the speed at which the media resource plays, as a multiple of its intrinsic speed. If it is not equal to the defaultPlaybackRate, then the implication is that the user is using a feature such as fast forward or slow motion playback. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting, the user agent must follow these steps:

If the given value is not supported by the user agent, then throw a "NotSupportedError" DOMException.

Set playbackRate to the new value, and if the element is potentially playing, change the playback speed.

When the defaultPlaybackRate or playbackRate attributes change value (either by being set by script or by being changed directly by the user agent, e.g. in response to user control) the user agent must queue a task to fire an event named ratechange at the media element.

The played attribute must return a new static normalized TimeRanges object that represents the ranges of points on the media timeline of the media resource reached through the usual monotonic increase of the current playback position during normal playback, if any, at the time the attribute is evaluated.

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.

Each media element has a list of pending play promises, which must initially be empty.

To take pending play promises for a media element, the user agent must run the following steps:

Let promises be an empty list of promises.

Copy the media element's list of pending play promises to promises.

Clear the media element's list of pending play promises.

Return promises.
To resolve pending play promises for a media element with a list of promises promises, the user agent must resolve each promise in promises with undefined.

To reject pending play promises for a media element with a list of promise promises and an exception name error, the user agent must reject each promise in promises with error.

To notify about playing for a media element, the user agent must run the following steps:

Take pending play promises and let promises be the result.

Queue a task to run these steps:

Fire an event named playing at the element.

Resolve pending play promises with promises.

When the play() method on a media element is invoked, the user agent must run the following steps.

If the media element is not allowed to play, return a promise rejected with a "NotAllowedError" DOMException.

If the media element's error attribute is not null and its code is MEDIA_ERR_SRC_NOT_SUPPORTED, return a promise rejected with a "NotSupportedError" DOMException.

This means that the dedicated media source failure steps have run. Playback is not possible until the media element load algorithm clears the error attribute.

Let promise be a new promise and append promise to the list of pending play promises.

If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.

If the playback has ended and the direction of playback is forwards, seek to the earliest possible position of the media resource.

This will cause the user agent to queue a task to fire an event named timeupdate at the media element.

If the media element's paused attribute is true, then:

Change the value of paused to false.

If the show poster flag is true, set the element's show poster flag to false and run the time marches on steps.

Queue a task to fire an event named play at the element.

If the media element's readyState attribute has the value HAVE_NOTHING, HAVE_METADATA, or HAVE_CURRENT_DATA, queue a task to fire an event named waiting at the element.

Otherwise, the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA: notify about playing for the element.

Otherwise, if the media element's readyState attribute has the value HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, take pending play promises and queue a task to resolve pending play promises with the result.

The media element is already playing. However, it's possible that promise will be rejected before the queued task is run.

Set the media element's can autoplay flag to false.

Return promise.

When the pause() method is invoked, and when the user agent is required to pause the media element, the user agent must run the following steps:

If the media element's networkState attribute has the value NETWORK_EMPTY, invoke the media element's resource selection algorithm.

Run the internal pause steps for the media element.

The internal pause steps for a media element are as follows:

Set the media element's can autoplay flag to false.

If the media element's paused attribute is false, run the following steps:

Change the value of paused to true.

Take pending play promises and let promises be the result.

Queue a task to run these steps:

Fire an event named timeupdate at the element.

Fire an event named pause at the element.

Reject pending play promises with promises and an "AbortError" DOMException.

Set the official playback position to the current playback position.

If the element's playbackRate is positive or zero, then the direction of playback is forwards. Otherwise, it is backwards.

When a media element is potentially playing and its Document is a fully active Document, its current playback position must increase monotonically at the element's playbackRate units of media time per unit time of the media timeline's clock. (This specification always refers to this as an increase, but that increase could actually be a decrease if the element's playbackRate is negative.)


Spec bugs: 28236

The element's playbackRate can be 0.0, in which case the current playback position doesn't move, despite playback not being paused (paused doesn't become true, and the pause event doesn't fire).

This specification doesn't define how the user agent achieves the appropriate playback rate — depending on the protocol and media available, it is plausible that the user agent could negotiate with the server to have the server provide the media data at the appropriate rate, so that (except for the period between when the rate is changed and when the server updates the stream's playback rate) the client doesn't actually have to drop or interpolate any frames.

Any time the user agent provides a stable state, the official playback position must be set to the current playback position.

While the direction of playback is backwards, any corresponding audio must be muted. While the element's playbackRate is so low or so high that the user agent cannot play audio usefully, the corresponding audio must also be muted. If the element's playbackRate is not 1.0, the user agent may apply pitch adjustments to the audio as necessary to render it faithfully.

When a media element is potentially playing, its audio data played must be synchronized with the current playback position, at the element's effective media volume. The user agent must play the audio from audio tracks that were enabled when the event loop last reached step 1.

When a media element is not potentially playing, audio must not play for the element.

Media elements that are potentially playing while not in a document must not play any video, but should play any audio component. Media elements must not stop playing just because all references to them have been removed; only once a media element is in a state where no further audio could ever be played by that element may the element be garbage collected.

It is possible for an element to which no explicit references exist to play audio, even if such an element is not still actively playing: for instance, it could be unpaused but stalled waiting for content to buffer, or it could be still buffering, but with a suspend event listener that begins playback. Even a media element whose media resource has no audio tracks could eventually play audio again if it had an event listener that changes the media resource.

Each media element has a list of newly introduced cues, which must be initially empty. Whenever a text track cue is added to the list of cues of a text track that is in the list of text tracks for a media element, that cue must be added to the media element's list of newly introduced cues. Whenever a text track is added to the list of text tracks for a media element, all of the cues in that text track's list of cues must be added to the media element's list of newly introduced cues. When a media element's list of newly introduced cues has new cues added while the media element's show poster flag is not set, then the user agent must run the time marches on steps.

When a text track cue is removed from the list of cues of a text track that is in the list of text tracks for a media element, and whenever a text track is removed from the list of text tracks of a media element, if the media element's show poster flag is not set, then the user agent must run the time marches on steps.

When the current playback position of a media element changes (e.g. due to playback or seeking), the user agent must run the time marches on steps. If the current playback position changes while the steps are running, then the user agent must wait for the steps to complete, and then must immediately rerun the steps. (These steps are thus run as often as possible or needed — if one iteration takes a long time, this can cause certain cues to be skipped over as the user agent rushes ahead to "catch up".)

The time marches on steps are as follows:

Let current cues be a list of cues, initialized to contain all the cues of all the hidden or showing text tracks of the media element (not the disabled ones) whose start times are less than or equal to the current playback position and whose end times are greater than the current playback position.

Let other cues be a list of cues, initialized to contain all the cues of hidden and showing text tracks of the media element that are not present in current cues.

Let last time be the current playback position at the time this algorithm was last run for this media element, if this is not the first time it has run.

If the current playback position has, since the last time this algorithm was run, only changed through its usual monotonic increase during normal playback, then let missed cues be the list of cues in other cues whose start times are greater than or equal to last time and whose end times are less than or equal to the current playback position. Otherwise, let missed cues be an empty list.

Remove all the cues in missed cues that are also in the media element's list of newly introduced cues, and then empty the element's list of newly introduced cues.

If the time was reached through the usual monotonic increase of the current playback position during normal playback, and if the user agent has not fired a timeupdate event at the element in the past 15 to 250ms and is not still running event handlers for such an event, then the user agent must queue a task to fire an event named timeupdate at the element. (In the other cases, such as explicit seeks, relevant events get fired as part of the overall process of changing the current playback position.)

The event thus is not to be fired faster than about 66Hz or slower than 4Hz (assuming the event handlers don't take longer than 250ms to run). User agents are encouraged to vary the frequency of the event based on the system load and the average cost of processing the event each time, so that the UI updates are not any more frequent than the user agent can comfortably handle while decoding the video.

If all of the cues in current cues have their text track cue active flag set, none of the cues in other cues have their text track cue active flag set, and missed cues is empty, then return.

If the time was reached through the usual monotonic increase of the current playback position during normal playback, and there are cues in other cues that have their text track cue pause-on-exit flag set and that either have their text track cue active flag set or are also in missed cues, then immediately pause the media element.

In the other cases, such as explicit seeks, playback is not paused by going past the end time of a cue, even if that cue has its text track cue pause-on-exit flag set.

Let events be a list of tasks, initially empty. Each task in this list will be associated with a text track, a text track cue, and a time, which are used to sort the list before the tasks are queued.

Let affected tracks be a list of text tracks, initially empty.

When the steps below say to prepare an event named event for a text track cue target with a time time, the user agent must run these steps:

Let track be the text track with which the text track cue target is associated.

Create a task to fire an event named event at target.

Add the newly created task to events, associated with the time time, the text track track, and the text track cue target.

Add track to affected tracks.

For each text track cue in missed cues, prepare an event named enter for the TextTrackCue object with the text track cue start time.

For each text track cue in other cues that either has its text track cue active flag set or is in missed cues, prepare an event named exit for the TextTrackCue object with the later of the text track cue end time and the text track cue start time.

For each text track cue in current cues that does not have its text track cue active flag set, prepare an event named enter for the TextTrackCue object with the text track cue start time.

Sort the tasks in events in ascending time order (tasks with earlier times first).

Further sort tasks in events that have the same time by the relative text track cue order of the text track cues associated with these tasks.

Finally, sort tasks in events that have the same time and same text track cue order by placing tasks that fire enter events before those that fire exit events.

Queue each task in events, in list order.

Sort affected tracks in the same order as the text tracks appear in the media element's list of text tracks, and remove duplicates.

For each text track in affected tracks, in the list order, queue a task to fire an event named cuechange at the TextTrack object, and, if the text track has a corresponding track element, to then fire an event named cuechange at the track element as well.

Set the text track cue active flag of all the cues in the current cues, and unset the text track cue active flag of all the cues in the other cues.

Run the rules for updating the text track rendering of each of the text tracks in affected tracks that are showing, providing the text track's text track language as the fallback language if it is not the empty string. For example, for text tracks based on WebVTT, the rules for updating the display of WebVTT text tracks. [WEBVTT]

For the purposes of the algorithm above, a text track cue is considered to be part of a text track only if it is listed in the text track list of cues, not merely if it is associated with the text track.

If the media element's node document stops being a fully active document, then the playback will stop until the document is active again.

When a media element is removed from a Document, the user agent must run the following steps:

Await a stable state, allowing the task that removed the media element from the Document to continue. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)

⌛ If the media element is in a document, return.

⌛ Run the internal pause steps for the media element.

4.8.12.9 Seeking
media . seeking
Returns true if the user agent is currently seeking.

media . seekable
Returns a TimeRanges object that represents the ranges of the media resource to which it is possible for the user agent to seek.

media . fastSeek( time )
Seeks to near the given time as fast as possible, trading precision for speed. (To seek to a precise time, use the currentTime attribute.)

This does nothing if the media resource has not been loaded.

The seeking attribute must initially have the value false.

The fastSeek() method must seek to the time given by the method's argument, with the approximate-for-speed flag set.

When the user agent is required to seek to a particular new playback position in the media resource, optionally with the approximate-for-speed flag set, it means that the user agent must run the following steps. This algorithm interacts closely with the event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). Steps in that section are marked with ⌛.


Spec bugs: 28929

Set the media element's show poster flag to false.

If the media element's readyState is HAVE_NOTHING, return.

If the element's seeking IDL attribute is true, then another instance of this algorithm is already running. Abort that other instance of the algorithm without waiting for the step that it is running to complete.

Set the seeking IDL attribute to true.

If the seek was in response to a DOM method call or setting of an IDL attribute, then continue the script. The remainder of these steps must be run in parallel. With the exception of the steps marked with ⌛, they could be aborted at any time by another instance of this algorithm being invoked.

If the new playback position is later than the end of the media resource, then let it be the end of the media resource instead.

If the new playback position is less than the earliest possible position, let it be that position instead.

If the (possibly now changed) new playback position is not in one of the ranges given in the seekable attribute, then let it be the position in one of the ranges given in the seekable attribute that is the nearest to the new playback position. If two positions both satisfy that constraint (i.e. the new playback position is exactly in the middle between two ranges in the seekable attribute) then use the position that is closest to the current playback position. If there are no ranges given in the seekable attribute then set the seeking IDL attribute to false and return.

If the approximate-for-speed flag is set, adjust the new playback position to a value that will allow for playback to resume promptly. If new playback position before this step is before current playback position, then the adjusted new playback position must also be before the current playback position. Similarly, if the new playback position before this step is after current playback position, then the adjusted new playback position must also be after the current playback position.

For example, the user agent could snap to a nearby key frame, so that it doesn't have to spend time decoding then discarding intermediate frames before resuming playback.

Queue a task to fire an event named seeking at the element.

Set the current playback position to the new playback position.

If the media element was potentially playing immediately before it started seeking, but seeking caused its readyState attribute to change to a value lower than HAVE_FUTURE_DATA, then a waiting event will be fired at the element.

This step sets the current playback position, and thus can immediately trigger other conditions, such as the rules regarding when playback "reaches the end of the media resource" (part of the logic that handles looping), even before the user agent is actually able to render the media data for that position (as determined in the next step).

The currentTime attribute returns the official playback position, not the current playback position, and therefore gets updated before script execution, separate from this algorithm.

Wait until the user agent has established whether or not the media data for the new playback position is available, and, if it is, until it has decoded enough data to play back that position.

Await a stable state. The synchronous section consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)

⌛ Set the seeking IDL attribute to false.

⌛ Run the time marches on steps.

⌛ Queue a task to fire an event named timeupdate at the element.

⌛ Queue a task to fire an event named seeked at the element.

The seekable attribute must return a new static normalized TimeRanges object that represents the ranges of the media resource, if any, that the user agent is able to seek to, at the time the attribute is evaluated.

If the user agent can seek to anywhere in the media resource, e.g. because it is a simple movie file and the user agent and the server support HTTP Range requests, then the attribute would return an object with one range, whose start is the time of the first frame (the earliest possible position, typically zero), and whose end is the same as the time of the first frame plus the duration attribute's value (which would equal the time of the last frame, and might be positive Infinity).

The range might be continuously changing, e.g. if the user agent is buffering a sliding window on an infinite stream. This is the behavior seen with DVRs viewing live TV, for instance.

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be costly to change it. It is not to be copied to new APIs.

User agents should adopt a very liberal and optimistic view of what is seekable. User agents should also buffer recent content where possible to enable seeking to be fast.

For instance, consider a large video file served on an HTTP server without support for HTTP Range requests. A browser could implement this by only buffering the current frame and data obtained for subsequent frames, never allow seeking, except for seeking to the very start by restarting the playback. However, this would be a poor implementation. A high quality implementation would buffer the last few minutes of content (or more, if sufficient storage space is available), allowing the user to jump back and rewatch something surprising without any latency, and would in addition allow arbitrary seeking by reloading the file from the start if necessary, which would be slower but still more convenient than having to literally restart the video and watch it all the way through just to get to an earlier unbuffered spot.

Media resources might be internally scripted or interactive. Thus, a media element could play in a non-linear fashion. If this happens, the user agent must act as if the algorithm for seeking was used whenever the current playback position changes in a discontinuous fashion (so that the relevant events fire).

4.8.12.10 Media resources with multiple media tracks
A media resource can have multiple embedded audio and video tracks. For example, in addition to the primary video and audio tracks, a media resource could have foreign-language dubbed dialogues, director's commentaries, audio descriptions, alternative angles, or sign-language overlays.

media . audioTracks
Returns an AudioTrackList object representing the audio tracks available in the media resource.

media . videoTracks
Returns a VideoTrackList object representing the video tracks available in the media resource.

The audioTracks attribute of a media element must return a live AudioTrackList object representing the audio tracks available in the media element's media resource.

The videoTracks attribute of a media element must return a live VideoTrackList object representing the video tracks available in the media element's media resource.

There are only ever one AudioTrackList object and one VideoTrackList object per media element, even if another media resource is loaded into the element: the objects are reused. (The AudioTrack and VideoTrack objects are not, though.)

4.8.12.10.1 AudioTrackList and VideoTrackList objects

Support: audiotracks
Chrome for Android	None
Chrome	None
iOS Safari	7.0+
UC Browser for Android	None
Firefox	None
Samsung Internet	None
IE	10+
Opera Mini	None
Safari	6.1+
Edge	12+
Android Browser	None
Opera	None

Source: caniuse.com

The AudioTrackList and VideoTrackList interfaces are used by attributes defined in the previous section.

[Exposed=Window]
interface AudioTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter AudioTrack (unsigned long index);
  AudioTrack? getTrackById(DOMString id);

  attribute EventHandler onchange;
  attribute EventHandler onaddtrack;
  attribute EventHandler onremovetrack;
};

[Exposed=Window]
interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  attribute boolean enabled;
};

[Exposed=Window]
interface VideoTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter VideoTrack (unsigned long index);
  VideoTrack? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

  attribute EventHandler onchange;
  attribute EventHandler onaddtrack;
  attribute EventHandler onremovetrack;
};

[Exposed=Window]
interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  attribute boolean selected;
};
media . audioTracks . length
media . videoTracks . length
Returns the number of tracks in the list.

audioTrack = media . audioTracks[index]
videoTrack = media . videoTracks[index]
Returns the specified AudioTrack or VideoTrack object.

audioTrack = media . audioTracks . getTrackById( id )
videoTrack = media . videoTracks . getTrackById( id )
Returns the AudioTrack or VideoTrack object with the given identifier, or null if no track has that identifier.

audioTrack . id
videoTrack . id
Returns the ID of the given track. This is the ID that can be used with a fragment if the format supports media fragment syntax, and that can be used with the getTrackById() method.

audioTrack . kind
videoTrack . kind
Returns the category the given track falls into. The possible track categories are given below.

audioTrack . label
videoTrack . label
Returns the label of the given track, if known, or the empty string otherwise.

audioTrack . language
videoTrack . language
Returns the language of the given track, if known, or the empty string otherwise.

audioTrack . enabled [ = value ]
Returns true if the given track is active, and false otherwise.

Can be set, to change whether the track is enabled or not. If multiple audio tracks are enabled simultaneously, they are mixed.

media . videoTracks . selectedIndex
Returns the index of the currently selected track, if any, or −1 otherwise.

videoTrack . selected [ = value ]
Returns true if the given track is active, and false otherwise.

Can be set, to change whether the track is selected or not. Either zero or one video track is selected; selecting a new track while a previous one is selected will unselect the previous one.

An AudioTrackList object represents a dynamic list of zero or more audio tracks, of which zero or more can be enabled at a time. Each audio track is represented by an AudioTrack object.

A VideoTrackList object represents a dynamic list of zero or more video tracks, of which zero or one can be selected at a time. Each video track is represented by a VideoTrack object.

Tracks in AudioTrackList and VideoTrackList objects must be consistently ordered. If the media resource is in a format that defines an order, then that order must be used; otherwise, the order must be the relative order in which the tracks are declared in the media resource. The order used is called the natural order of the list.

Each track in one of these objects thus has an index; the first has the index 0, and each subsequent track is numbered one higher than the previous one. If a media resource dynamically adds or removes audio or video tracks, then the indices of the tracks will change dynamically. If the media resource changes entirely, then all the previous tracks will be removed and replaced with new tracks.

The AudioTrackList.length and VideoTrackList.length attributes must return the number of tracks represented by their objects at the time of getting.

The supported property indices of AudioTrackList and VideoTrackList objects at any instant are the numbers from zero to the number of tracks represented by the respective object minus one, if any tracks are represented. If an AudioTrackList or VideoTrackList object represents no tracks, it has no supported property indices.

To determine the value of an indexed property for a given index index in an AudioTrackList or VideoTrackList object list, the user agent must return the AudioTrack or VideoTrack object that represents the indexth track in list.

The AudioTrackList.getTrackById(id) and VideoTrackList.getTrackById(id) methods must return the first AudioTrack or VideoTrack object (respectively) in the AudioTrackList or VideoTrackList object (respectively) whose identifier is equal to the value of the id argument (in the natural order of the list, as defined above). When no tracks match the given argument, the methods must return null.

The AudioTrack and VideoTrack objects represent specific tracks of a media resource. Each track can have an identifier, category, label, and language. These aspects of a track are permanent for the lifetime of the track; even if a track is removed from a media resource's AudioTrackList or VideoTrackList objects, those aspects do not change.

In addition, AudioTrack objects can each be enabled or disabled; this is the audio track's enabled state. When an AudioTrack is created, its enabled state must be set to false (disabled). The resource fetch algorithm can override this.

Similarly, a single VideoTrack object per VideoTrackList object can be selected, this is the video track's selection state. When a VideoTrack is created, its selection state must be set to false (not selected). The resource fetch algorithm can override this.

The AudioTrack.id and VideoTrack.id attributes must return the identifier of the track, if it has one, or the empty string otherwise. If the media resource is in a format that supports media fragment syntax, the identifier returned for a particular track must be the same identifier that would enable the track if used as the name of a track in the track dimension of such a fragment. [INBAND]

For example, in Ogg files, this would be the Name header field of the track. [OGGSKELETONHEADERS]

The AudioTrack.kind and VideoTrack.kind attributes must return the category of the track, if it has one, or the empty string otherwise.

The category of a track is the string given in the first column of the table below that is the most appropriate for the track based on the definitions in the table's second and third columns, as determined by the metadata included in the track in the media resource. The cell in the third column of a row says what the category given in the cell in the first column of that row applies to; a category is only appropriate for an audio track if it applies to audio tracks, and a category is only appropriate for video tracks if it applies to video tracks. Categories must only be returned for AudioTrack objects if they are appropriate for audio, and must only be returned for VideoTrack objects if they are appropriate for video.

For Ogg files, the Role header field of the track gives the relevant metadata. For DASH media resources, the Role element conveys the information. For WebM, only the FlagDefault element currently maps to a value. The Sourcing In-band Media Resource Tracks from Media Containers into HTML specification has further details. [OGGSKELETONHEADERS] [DASH] [WEBMCG] [INBAND]

Return values for AudioTrack.kind and VideoTrack.kind
Category	Definition	Applies to...	Examples
"alternative"	A possible alternative to the main track, e.g. a different take of a song (audio), or a different angle (video).	Audio and video.	Ogg: "audio/alternate" or "video/alternate"; DASH: "alternate" without "main" and "commentary" roles, and, for audio, without the "dub" role (other roles ignored).
"captions"	A version of the main video track with captions burnt in. (For legacy content; new content would use text tracks.)	Video only.	DASH: "caption" and "main" roles together (other roles ignored).
"descriptions"	An audio description of a video track.	Audio only.	Ogg: "audio/audiodesc".
"main"	The primary audio or video track.	Audio and video.	Ogg: "audio/main" or "video/main"; WebM: the "FlagDefault" element is set; DASH: "main" role without "caption", "subtitle", and "dub" roles (other roles ignored).
"main-desc"	The primary audio track, mixed with audio descriptions.	Audio only.	AC3 audio in MPEG-2 TS: bsmod=2 and full_svc=1.
"sign"	A sign-language interpretation of an audio track.	Video only.	Ogg: "video/sign".
"subtitles"	A version of the main video track with subtitles burnt in. (For legacy content; new content would use text tracks.)	Video only.	DASH: "subtitle" and "main" roles together (other roles ignored).
"translation"	A translated version of the main audio track.	Audio only.	Ogg: "audio/dub". DASH: "dub" and "main" roles together (other roles ignored).
"commentary"	Commentary on the primary audio or video track, e.g. a director's commentary.	Audio and video.	DASH: "commentary" role without "main" role (other roles ignored).
"" (empty string)	No explicit kind, or the kind given by the track's metadata is not recognized by the user agent.	Audio and video.
The AudioTrack.label and VideoTrack.label attributes must return the label of the track, if it has one, or the empty string otherwise. [INBAND]

The AudioTrack.language and VideoTrack.language attributes must return the BCP 47 language tag of the language of the track, if it has one, or the empty string otherwise. If the user agent is not able to express that language as a BCP 47 language tag (for example because the language information in the media resource's format is a free-form string without a defined interpretation), then the method must return the empty string, as if the track had no language. [INBAND]

The AudioTrack.enabled attribute, on getting, must return true if the track is currently enabled, and false otherwise. On setting, it must enable the track if the new value is true, and disable it otherwise. (If the track is no longer in an AudioTrackList object, then the track being enabled or disabled has no effect beyond changing the value of the attribute on the AudioTrack object.)

Whenever an audio track in an AudioTrackList that was disabled is enabled, and whenever one that was enabled is disabled, the user agent must queue a task to fire an event named change at the AudioTrackList object.

An audio track that has no data for a particular position on the media timeline, or that does not exist at that position, must be interpreted as being silent at that point on the timeline.

The VideoTrackList.selectedIndex attribute must return the index of the currently selected track, if any. If the VideoTrackList object does not currently represent any tracks, or if none of the tracks are selected, it must instead return −1.

The VideoTrack.selected attribute, on getting, must return true if the track is currently selected, and false otherwise. On setting, it must select the track if the new value is true, and unselect it otherwise. If the track is in a VideoTrackList, then all the other VideoTrack objects in that list must be unselected. (If the track is no longer in a VideoTrackList object, then the track being selected or unselected has no effect beyond changing the value of the attribute on the VideoTrack object.)

Whenever a track in a VideoTrackList that was previously not selected is selected, and whenever the selected track in a VideoTrackList is unselected without a new track being selected in its stead, the user agent must queue a task to fire an event named change at the VideoTrackList object. This task must be queued before the task that fires the resize event, if any.

A video track that has no data for a particular position on the media timeline must be interpreted as being transparent black at that point on the timeline, with the same dimensions as the last frame before that position, or, if the position is before all the data for that track, the same dimensions as the first frame for that track. A track that does not exist at all at the current position must be treated as if it existed but had no data.

For instance, if a video has a track that is only introduced after one hour of playback, and the user selects that track then goes back to the start, then the user agent will act as if that track started at the start of the media resource but was simply transparent until one hour in.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the AudioTrackList and VideoTrackList interfaces:

Event handler	Event handler event type
onchange	change
onaddtrack	addtrack
onremovetrack	removetrack
4.8.12.10.2 Selecting specific audio and video tracks declaratively
The audioTracks and videoTracks attributes allow scripts to select which track should play, but it is also possible to select specific tracks declaratively, by specifying particular tracks in the fragment of the URL of the media resource. The format of the fragment depends on the MIME type of the media resource. [RFC2046] [URL]

In this example, a video that uses a format that supports media fragment syntax is embedded in such a way that the alternative angles labeled "Alternative" are enabled instead of the default video track.

<video src="myvideo#track=Alternative"></video>
4.8.12.11 Timed text tracks
4.8.12.11.1 Text track model

Spec bugs: 28973

A media element can have a group of associated text tracks, known as the media element's list of text tracks. The text tracks are sorted as follows:

The text tracks corresponding to track element children of the media element, in tree order.
Any text tracks added using the addTextTrack() method, in the order they were added, oldest first.
Any media-resource-specific text tracks (text tracks corresponding to data in the media resource), in the order defined by the media resource's format specification.
A text track consists of:

The kind of text track
This decides how the track is handled by the user agent. The kind is represented by a string. The possible strings are:

subtitles
captions
descriptions
chapters
metadata
The kind of track can change dynamically, in the case of a text track corresponding to a track element.

A label
This is a human-readable string intended to identify the track for the user.

The label of a track can change dynamically, in the case of a text track corresponding to a track element.

When a text track label is the empty string, the user agent should automatically generate an appropriate label from the text track's other properties (e.g. the kind of text track and the text track's language) for use in its user interface. This automatically-generated label is not exposed in the API.

An in-band metadata track dispatch type
This is a string extracted from the media resource specifically for in-band metadata tracks to enable such tracks to be dispatched to different scripts in the document.

For example, a traditional TV station broadcast streamed on the Web and augmented with Web-specific interactive features could include text tracks with metadata for ad targeting, trivia game data during game shows, player states during sports games, recipe information during food programs, and so forth. As each program starts and ends, new tracks might be added or removed from the stream, and as each one is added, the user agent could bind them to dedicated script modules using the value of this attribute.

Other than for in-band metadata text tracks, the in-band metadata track dispatch type is the empty string. How this value is populated for different media formats is described in steps to expose a media-resource-specific text track.

A language
This is a string (a BCP 47 language tag) representing the language of the text track's cues. [BCP47]

The language of a text track can change dynamically, in the case of a text track corresponding to a track element.

A readiness state
One of the following:

Not loaded
Indicates that the text track's cues have not been obtained.

Loading
Indicates that the text track is loading and there have been no fatal errors encountered so far. Further cues might still be added to the track by the parser.

Loaded
Indicates that the text track has been loaded with no fatal errors.

Failed to load
Indicates that the text track was enabled, but when the user agent attempted to obtain it, this failed in some way (e.g. URL could not be parsed, network error, unknown text track format). Some or all of the cues are likely missing and will not be obtained.

The readiness state of a text track changes dynamically as the track is obtained.

A mode
One of the following:

Disabled
Indicates that the text track is not active. Other than for the purposes of exposing the track in the DOM, the user agent is ignoring the text track. No cues are active, no events are fired, and the user agent will not attempt to obtain the track's cues.

Hidden
Indicates that the text track is active, but that the user agent is not actively displaying the cues. If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily. The user agent is maintaining a list of which cues are active, and events are being fired accordingly.

Showing
Indicates that the text track is active. If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily. The user agent is maintaining a list of which cues are active, and events are being fired accordingly. In addition, for text tracks whose kind is subtitles or captions, the cues are being overlaid on the video as appropriate; for text tracks whose kind is descriptions, the user agent is making the cues available to the user in a non-visual fashion; and for text tracks whose kind is chapters, the user agent is making available to the user a mechanism by which the user can navigate to any point in the media resource by selecting a cue.

A list of zero or more cues
A list of text track cues, along with rules for updating the text track rendering. For example, for WebVTT, the rules for updating the display of WebVTT text tracks. [WEBVTT]

The list of cues of a text track can change dynamically, either because the text track has not yet been loaded or is still loading, or due to DOM manipulation.

Each text track has a corresponding TextTrack object.

Each media element has a list of pending text tracks, which must initially be empty, a blocked-on-parser flag, which must initially be false, and a did-perform-automatic-track-selection flag, which must also initially be false.

When the user agent is required to populate the list of pending text tracks of a media element, the user agent must add to the element's list of pending text tracks each text track in the element's list of text tracks whose text track mode is not disabled and whose text track readiness state is loading.

Whenever a track element's parent node changes, the user agent must remove the corresponding text track from any list of pending text tracks that it is in.

Whenever a text track's text track readiness state changes to either loaded or failed to load, the user agent must remove it from any list of pending text tracks that it is in.

When a media element is created by an HTML parser or XML parser, the user agent must set the element's blocked-on-parser flag to true. When a media element is popped off the stack of open elements of an HTML parser or XML parser, the user agent must honor user preferences for automatic text track selection, populate the list of pending text tracks, and set the element's blocked-on-parser flag to false.

The text tracks of a media element are ready when both the element's list of pending text tracks is empty and the element's blocked-on-parser flag is false.

Each media element has a pending text track change notification flag, which must initially be unset.

Whenever a text track that is in a media element's list of text tracks has its text track mode change value, the user agent must run the following steps for the media element:

If the media element's pending text track change notification flag is set, return.

Set the media element's pending text track change notification flag.

Queue a task to run these steps:

Unset the media element's pending text track change notification flag.

Fire an event named change at the media element's textTracks attribute's TextTrackList object.

If the media element's show poster flag is not set, run the time marches on steps.

The task source for the tasks listed in this section is the DOM manipulation task source.

A text track cue is the unit of time-sensitive data in a text track, corresponding for instance for subtitles and captions to the text that appears at a particular time and disappears at another time.

Each text track cue consists of:

An identifier
An arbitrary string.

A start time
The time, in seconds and fractions of a second, that describes the beginning of the range of the media data to which the cue applies.

An end time
The time, in seconds and fractions of a second, that describes the end of the range of the media data to which the cue applies.

A pause-on-exit flag
A boolean indicating whether playback of the media resource is to pause when the end of the range to which the cue applies is reached.

Some additional format-specific data
Additional fields, as needed for the format, including the actual data of the cue. For example, WebVTT has a text track cue writing direction and so forth. [WEBVTT]

The text track cue start time and text track cue end time can be negative. (The current playback position can never be negative, though, so cues entirely before time zero cannot be active.)

Each text track cue has a corresponding TextTrackCue object (or more specifically, an object that inherits from TextTrackCue — for example, WebVTT cues use the VTTCue interface). A text track cue's in-memory representation can be dynamically changed through this TextTrackCue API. [WEBVTT]

A text track cue is associated with rules for updating the text track rendering, as defined by the specification for the specific kind of text track cue. These rules are used specifically when the object representing the cue is added to a TextTrack object using the addCue() method.

In addition, each text track cue has two pieces of dynamic information:

The active flag
This flag must be initially unset. The flag is used to ensure events are fired appropriately when the cue becomes active or inactive, and to make sure the right cues are rendered.

The user agent must synchronously unset this flag whenever the text track cue is removed from its text track's text track list of cues; whenever the text track itself is removed from its media element's list of text tracks or has its text track mode changed to disabled; and whenever the media element's readyState is changed back to HAVE_NOTHING. When the flag is unset in this way for one or more cues in text tracks that were showing prior to the relevant incident, the user agent must, after having unset the flag for all the affected cues, apply the rules for updating the text track rendering of those text tracks. For example, for text tracks based on WebVTT, the rules for updating the display of WebVTT text tracks. [WEBVTT]

The display state
This is used as part of the rendering model, to keep cues in a consistent position. It must initially be empty. Whenever the text track cue active flag is unset, the user agent must empty the text track cue display state.

The text track cues of a media element's text tracks are ordered relative to each other in the text track cue order, which is determined as follows: first group the cues by their text track, with the groups being sorted in the same order as their text tracks appear in the media element's list of text tracks; then, within each group, cues must be sorted by their start time, earliest first; then, any cues with the same start time must be sorted by their end time, latest first; and finally, any cues with identical end times must be sorted in the order they were last added to their respective text track list of cues, oldest first (so e.g. for cues from a WebVTT file, that would initially be the order in which the cues were listed in the file). [WEBVTT]

4.8.12.11.2 Sourcing in-band text tracks
A media-resource-specific text track is a text track that corresponds to data found in the media resource.

Rules for processing and rendering such data are defined by the relevant specifications, e.g. the specification of the video format if the media resource is a video. Details for some legacy formats can be found in the Sourcing In-band Media Resource Tracks from Media Containers into HTML specification. [INBAND]

When a media resource contains data that the user agent recognizes and supports as being equivalent to a text track, the user agent runs the steps to expose a media-resource-specific text track with the relevant data, as follows.

Associate the relevant data with a new text track and its corresponding new TextTrack object. The text track is a media-resource-specific text track.

Set the new text track's kind, label, and language based on the semantics of the relevant data, as defined by the relevant specification. If there is no label in that data, then the label must be set to the empty string.

Associate the text track list of cues with the rules for updating the text track rendering appropriate for the format in question.

If the new text track's kind is chapters or metadata, then set the text track in-band metadata track dispatch type as follows, based on the type of the media resource:

If the media resource is an Ogg file
The text track in-band metadata track dispatch type must be set to the value of the Name header field. [OGGSKELETONHEADERS]
If the media resource is a WebM file
The text track in-band metadata track dispatch type must be set to the value of the CodecID element. [WEBMCG]
If the media resource is an MPEG-2 file
Let stream type be the value of the "stream_type" field describing the text track's type in the file's program map section, interpreted as an 8-bit unsigned integer. Let length be the value of the "ES_info_length" field for the track in the same part of the program map section, interpreted as an integer as defined by the MPEG-2 specification. Let descriptor bytes be the length bytes following the "ES_info_length" field. The text track in-band metadata track dispatch type must be set to the concatenation of the stream type byte and the zero or more descriptor bytes bytes, expressed in hexadecimal using ASCII upper hex digits. [MPEG2]
If the media resource is an MPEG-4 file
Let the first stsd box of the first stbl box of the first minf box of the first mdia box of the text track's trak box in the first moov box of the file be the stsd box, if any. If the file has no stsd box, or if the stsd box has neither a mett box nor a metx box, then the text track in-band metadata track dispatch type must be set to the empty string. Otherwise, if the stsd box has a mett box then the text track in-band metadata track dispatch type must be set to the concatenation of the string "mett", a U+0020 SPACE character, and the value of the first mime_format field of the first mett box of the stsd box, or the empty string if that field is absent in that box. Otherwise, if the stsd box has no mett box but has a metx box then the text track in-band metadata track dispatch type must be set to the concatenation of the string "metx", a U+0020 SPACE character, and the value of the first namespace field of the first metx box of the stsd box, or the empty string if that field is absent in that box. [MPEG4]
Populate the new text track's list of cues with the cues parsed so far, following the guidelines for exposing cues, and begin updating it dynamically as necessary.

Set the new text track's readiness state to loaded.

Set the new text track's mode to the mode consistent with the user's preferences and the requirements of the relevant specification for the data.

For instance, if there are no other active subtitles, and this is a forced subtitle track (a subtitle track giving subtitles in the audio track's primary language, but only for audio that is actually in another language), then those subtitles might be activated here.

Add the new text track to the media element's list of text tracks.

Fire an event named addtrack at the media element's textTracks attribute's TextTrackList object, using TrackEvent, with the track attribute initialized to the text track's TextTrack object.

4.8.12.11.3 Sourcing out-of-band text tracks
When a track element is created, it must be associated with a new text track (with its value set as defined below) and its corresponding new TextTrack object.

The text track kind is determined from the state of the element's kind attribute according to the following table; for a state given in a cell of the first column, the kind is the string given in the second column:

State	String
Subtitles	subtitles
Captions	captions
Descriptions	descriptions
Chapters metadata	chapters
Metadata	metadata
The text track label is the element's track label.

The text track language is the element's track language, if any, or the empty string otherwise.

As the kind, label, and srclang attributes are set, changed, or removed, the text track must update accordingly, as per the definitions above.

Changes to the track URL are handled in the algorithm below.

The text track readiness state is initially not loaded, and the text track mode is initially disabled.

The text track list of cues is initially empty. It is dynamically modified when the referenced file is parsed. Associated with the list are the rules for updating the text track rendering appropriate for the format in question; for WebVTT, this is the rules for updating the display of WebVTT text tracks. [WEBVTT]

When a track element's parent element changes and the new parent is a media element, then the user agent must add the track element's corresponding text track to the media element's list of text tracks, and then queue a task to fire an event named addtrack at the media element's textTracks attribute's TextTrackList object, using TrackEvent, with the track attribute initialized to the text track's TextTrack object.

When a track element's parent element changes and the old parent was a media element, then the user agent must remove the track element's corresponding text track from the media element's list of text tracks, and then queue a task to fire an event named removetrack at the media element's textTracks attribute's TextTrackList object, using TrackEvent, with the track attribute initialized to the text track's TextTrack object.

When a text track corresponding to a track element is added to a media element's list of text tracks, the user agent must queue a task to run the following steps for the media element:

If the element's blocked-on-parser flag is true, then return.

If the element's did-perform-automatic-track-selection flag is true, then return.

Honor user preferences for automatic text track selection for this element.

When the user agent is required to honor user preferences for automatic text track selection for a media element, the user agent must run the following steps:

Perform automatic text track selection for subtitles and captions.

Perform automatic text track selection for descriptions.

If there are any text tracks in the media element's list of text tracks whose text track kind is chapters or metadata that correspond to track elements with a default attribute set whose text track mode is set to disabled, then set the text track mode of all such tracks to hidden

Set the element's did-perform-automatic-track-selection flag to true.

When the steps above say to perform automatic text track selection for one or more text track kinds, it means to run the following steps:

Let candidates be a list consisting of the text tracks in the media element's list of text tracks whose text track kind is one of the kinds that were passed to the algorithm, if any, in the order given in the list of text tracks.

If candidates is empty, then return.

If any of the text tracks in candidates have a text track mode set to showing, return.

If the user has expressed an interest in having a track from candidates enabled based on its text track kind, text track language, and text track label, then set its text track mode to showing.

For example, the user could have set a browser preference to the effect of "I want French captions whenever possible", or "If there is a subtitle track with 'Commentary' in the title, enable it", or "If there are audio description tracks available, enable one, ideally in Swiss German, but failing that in Standard Swiss German or Standard German".

Otherwise, if there are any text tracks in candidates that correspond to track elements with a default attribute set whose text track mode is set to disabled, then set the text track mode of the first such track to showing.

When a text track corresponding to a track element experiences any of the following circumstances, the user agent must start the track processing model for that text track and its track element:

The track element is created.
The text track has its text track mode changed.
The track element's parent element changes and the new parent is a media element.
When a user agent is to start the track processing model for a text track and its track element, it must run the following algorithm. This algorithm interacts closely with the event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). The steps in that section are marked with ⌛.

If another occurrence of this algorithm is already running for this text track and its track element, return, letting that other algorithm take care of this element.

If the text track's text track mode is not set to one of hidden or showing, then return.

If the text track's track element does not have a media element as a parent, return.

Run the remainder of these steps in parallel, allowing whatever caused these steps to run to continue.

Top: Await a stable state. The synchronous section consists of the following steps. (The steps in the synchronous section are marked with ⌛.)

⌛ Set the text track readiness state to loading.

⌛ Let URL be the track URL of the track element.

⌛ If the track element's parent is a media element then let corsAttributeState be the state of the parent media element's crossorigin content attribute. Otherwise, let corsAttributeState be No CORS.

End the synchronous section, continuing the remaining steps in parallel.

If URL is not the empty string, then:

Let request be the result of creating a potential-CORS request given URL, "track", and corsAttributeState, and with the same-origin fallback flag set.

Set request's client to the track element's node document's Window object's environment settings object.

Fetch request.

The tasks queued by the fetching algorithm on the networking task source to process the data as it is being fetched must determine the type of the resource. If the type of the resource is not a supported text track format, the load will fail, as described below. Otherwise, the resource's data must be passed to the appropriate parser (e.g., the WebVTT parser) as it is received, with the text track list of cues being used for that parser's output. [WEBVTT]

The appropriate parser will incrementally update the text track list of cues during these networking task source tasks, as each such task is run with whatever data has been received from the network).

This specification does not currently say whether or how to check the MIME types of text tracks, or whether or how to perform file type sniffing using the actual file data. Implementors differ in their intentions on this matter and it is therefore unclear what the right solution is. In the absence of any requirement here, the HTTP specification's strict requirement to follow the Content-Type header prevails ("Content-Type specifies the media type of the underlying data." ... "If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource.").

If fetching fails for any reason (network error, the server returns an error code, CORS fails, etc), or if URL is the empty string, then queue a task to first change the text track readiness state to failed to load and then fire an event named error at the track element. This task must use the DOM manipulation task source.

If fetching does not fail, but the type of the resource is not a supported text track format, or the file was not successfully processed (e.g., the format in question is an XML format and the file contained a well-formedness error that the XML specification requires be detected and reported to the application), then the task that is queued by the networking task source in which the aforementioned problem is found must change the text track readiness state to failed to load and fire an event named error at the track element.

If fetching does not fail, and the file was successfully processed, then the final task that is queued by the networking task source, after it has finished parsing the data, must change the text track readiness state to loaded, and fire an event named load at the track element.

If, while fetching is ongoing, either:

the track URL changes so that it is no longer equal to URL, while the text track mode is set to hidden or showing; or
the text track mode changes to hidden or showing, while the track URL is not equal to URL
...then the user agent must abort fetching, discarding any pending tasks generated by that algorithm (and in particular, not adding any cues to the text track list of cues after the moment the URL changed), and then queue a task that first changes the text track readiness state to failed to load and then fires an event named error at the track element. This task must use the DOM manipulation task source.

Wait until the text track readiness state is no longer set to loading.

Wait until the track URL is no longer equal to URL, at the same time as the text track mode is set to hidden or showing.

Jump to the step labeled top.

Whenever a track element has its src attribute set, changed, or removed, the user agent must immediately empty the element's text track's text track list of cues. (This also causes the algorithm above to stop adding cues from the resource being obtained using the previously given URL, if any.)

4.8.12.11.4 Guidelines for exposing cues in various formats as text track cues
How a specific format's text track cues are to be interpreted for the purposes of processing by an HTML user agent is defined by that format. In the absence of such a specification, this section provides some constraints within which implementations can attempt to consistently expose such formats.

To support the text track model of HTML, each unit of timed data is converted to a text track cue. Where the mapping of the format's features to the aspects of a text track cue as defined in this specification are not defined, implementations must ensure that the mapping is consistent with the definitions of the aspects of a text track cue as defined above, as well as with the following constraints:

The text track cue identifier
Should be set to the empty string if the format has no obvious analogue to a per-cue identifier.

The text track cue pause-on-exit flag
Should be set to false.

4.8.12.11.5 Text track API
[Exposed=Window]
interface TextTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter TextTrack (unsigned long index);
  TextTrack? getTrackById(DOMString id);

  attribute EventHandler onchange;
  attribute EventHandler onaddtrack;
  attribute EventHandler onremovetrack;
};
media . textTracks . length
Returns the number of text tracks associated with the media element (e.g. from track elements). This is the number of text tracks in the media element's list of text tracks.

media . textTracks[ n ]
Returns the TextTrack object representing the nth text track in the media element's list of text tracks.

textTrack = media . textTracks . getTrackById( id )
Returns the TextTrack object with the given identifier, or null if no track has that identifier.

A TextTrackList object represents a dynamically updating list of text tracks in a given order.

The textTracks attribute of media elements must return a TextTrackList object representing the TextTrack objects of the text tracks in the media element's list of text tracks, in the same order as in the list of text tracks.

The length attribute of a TextTrackList object must return the number of text tracks in the list represented by the TextTrackList object.

The supported property indices of a TextTrackList object at any instant are the numbers from zero to the number of text tracks in the list represented by the TextTrackList object minus one, if any. If there are no text tracks in the list, there are no supported property indices.

To determine the value of an indexed property of a TextTrackList object for a given index index, the user agent must return the indexth text track in the list represented by the TextTrackList object.

The getTrackById(id) method must return the first TextTrack in the TextTrackList object whose id IDL attribute would return a value equal to the value of the id argument. When no tracks match the given argument, the method must return null.

enum TextTrackMode { "disabled",  "hidden",  "showing" };
enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };

[Exposed=Window]
interface TextTrack : EventTarget {
  readonly attribute TextTrackKind kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;

  readonly attribute DOMString id;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

  attribute TextTrackMode mode;

  readonly attribute TextTrackCueList? cues;
  readonly attribute TextTrackCueList? activeCues;

  void addCue(TextTrackCue cue);
  void removeCue(TextTrackCue cue);

  attribute EventHandler oncuechange;
};
textTrack = media . addTextTrack( kind [, label [, language ] ] )
Creates and returns a new TextTrack object, which is also added to the media element's list of text tracks.

textTrack . kind
Returns the text track kind string.

textTrack . label
Returns the text track label, if there is one, or the empty string otherwise (indicating that a custom label probably needs to be generated from the other attributes of the object if the object is exposed to the user).

textTrack . language
Returns the text track language string.

textTrack . id
Returns the ID of the given track.

For in-band tracks, this is the ID that can be used with a fragment if the format supports media fragment syntax, and that can be used with the getTrackById() method.

For TextTrack objects corresponding to track elements, this is the ID of the track element.

textTrack . inBandMetadataTrackDispatchType
Returns the text track in-band metadata track dispatch type string.

textTrack . mode [ = value ]
Returns the text track mode, represented by a string from the following list:

"disabled"
The text track disabled mode.

"hidden"
The text track hidden mode.

"showing"
The text track showing mode.

Can be set, to change the mode.

textTrack . cues
Returns the text track list of cues, as a TextTrackCueList object.

textTrack . activeCues
Returns the text track cues from the text track list of cues that are currently active (i.e. that start before the current playback position and end after it), as a TextTrackCueList object.

textTrack . addCue( cue )
Adds the given cue to textTrack's text track list of cues.

textTrack . removeCue( cue )
Removes the given cue from textTrack's text track list of cues.

The addTextTrack(kind, label, language) method of media elements, when invoked, must run the following steps:

Create a new TextTrack object.

Create a new text track corresponding to the new object, and set its text track kind to kind, its text track label to label, its text track language to language, its text track readiness state to the text track loaded state, its text track mode to the text track hidden mode, and its text track list of cues to an empty list.

Initially, the text track list of cues is not associated with any rules for updating the text track rendering. When a text track cue is added to it, the text track list of cues has its rules permanently set accordingly.

Add the new text track to the media element's list of text tracks.

Queue a task to fire an event named addtrack at the media element's textTracks attribute's TextTrackList object, using TrackEvent, with the track attribute initialized to the new text track's TextTrack object.

Return the new TextTrack object.

The kind attribute must return the text track kind of the text track that the TextTrack object represents.

The label attribute must return the text track label of the text track that the TextTrack object represents.

The language attribute must return the text track language of the text track that the TextTrack object represents.

The id attribute returns the track's identifier, if it has one, or the empty string otherwise. For tracks that correspond to track elements, the track's identifier is the value of the element's id attribute, if any. For in-band tracks, the track's identifier is specified by the media resource. If the media resource is in a format that supports media fragment syntax, the identifier returned for a particular track must be the same identifier that would enable the track if used as the name of a track in the track dimension of such a fragment.

The inBandMetadataTrackDispatchType attribute must return the text track in-band metadata track dispatch type of the text track that the TextTrack object represents.

The mode attribute, on getting, must return the string corresponding to the text track mode of the text track that the TextTrack object represents, as defined by the following list:

"disabled"
The text track disabled mode.
"hidden"
The text track hidden mode.
"showing"
The text track showing mode.
On setting, if the new value isn't equal to what the attribute would currently return, the new value must be processed as follows:

If the new value is "disabled"
Set the text track mode of the text track that the TextTrack object represents to the text track disabled mode.

If the new value is "hidden"
Set the text track mode of the text track that the TextTrack object represents to the text track hidden mode.

If the new value is "showing"
Set the text track mode of the text track that the TextTrack object represents to the text track showing mode.

If the text track mode of the text track that the TextTrack object represents is not the text track disabled mode, then the cues attribute must return a live TextTrackCueList object that represents the subset of the text track list of cues of the text track that the TextTrack object represents whose end times occur at or after the earliest possible position when the script started, in text track cue order. Otherwise, it must return null. For each TextTrack object, when an object is returned, the same TextTrackCueList object must be returned each time.

The earliest possible position when the script started is whatever the earliest possible position was the last time the event loop reached step 1.

If the text track mode of the text track that the TextTrack object represents is not the text track disabled mode, then the activeCues attribute must return a live TextTrackCueList object that represents the subset of the text track list of cues of the text track that the TextTrack object represents whose active flag was set when the script started, in text track cue order. Otherwise, it must return null. For each TextTrack object, when an object is returned, the same TextTrackCueList object must be returned each time.

A text track cue's active flag was set when the script started if its text track cue active flag was set the last time the event loop reached step 1.

The addCue(cue) method of TextTrack objects, when invoked, must run the following steps:

If the text track list of cues does not yet have any associated rules for updating the text track rendering, then associate the text track list of cues with the rules for updating the text track rendering appropriate to cue.

If text track list of cues' associated rules for updating the text track rendering are not the same rules for updating the text track rendering as appropriate for cue, then throw an "InvalidStateError" DOMException.

If the given cue is in a text track list of cues, then remove cue from that text track list of cues.

Add cue to the TextTrack object's text track's text track list of cues.

The removeCue(cue) method of TextTrack objects, when invoked, must run the following steps:

If the given cue is not in the TextTrack object's text track's text track list of cues, then throw a "NotFoundError" DOMException.

Remove cue from the TextTrack object's text track's text track list of cues.

In this example, an audio element is used to play a specific sound-effect from a sound file containing many sound effects. A cue is used to pause the audio, so that it ends exactly at the end of the clip, even if the browser is busy running some script. If the page had relied on script to pause the audio, then the start of the next clip might be heard if the browser was not able to run the script at the exact time specified.

var sfx = new Audio('sfx.wav');
var sounds = sfx.addTextTrack('metadata');

// add sounds we care about
function addFX(start, end, name) {
  var cue = new VTTCue(start, end, '');
  cue.id = name;
  cue.pauseOnExit = true;
  sounds.addCue(cue);
}
addFX(12.783, 13.612, 'dog bark');
addFX(13.612, 15.091, 'kitten mew'))

function playSound(id) {
  sfx.currentTime = sounds.getCueById(id).startTime;
  sfx.play();
}

// play a bark as soon as we can
sfx.oncanplaythrough = function () {
  playSound('dog bark');
}
// meow when the user tries to leave,
// and have the browser ask them to stay
window.onbeforeunload = function (e) {
  playSound('kitten mew');
  e.preventDefault();
}
[Exposed=Window]
interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter TextTrackCue (unsigned long index);
  TextTrackCue? getCueById(DOMString id);
};
cuelist . length
Returns the number of cues in the list.

cuelist[index]
Returns the text track cue with index index in the list. The cues are sorted in text track cue order.

cuelist . getCueById( id )
Returns the first text track cue (in text track cue order) with text track cue identifier id.

Returns null if none of the cues have the given identifier or if the argument is the empty string.

A TextTrackCueList object represents a dynamically updating list of text track cues in a given order.

The length attribute must return the number of cues in the list represented by the TextTrackCueList object.

The supported property indices of a TextTrackCueList object at any instant are the numbers from zero to the number of cues in the list represented by the TextTrackCueList object minus one, if any. If there are no cues in the list, there are no supported property indices.

To determine the value of an indexed property for a given index index, the user agent must return the indexth text track cue in the list represented by the TextTrackCueList object.

The getCueById(id) method, when called with an argument other than the empty string, must return the first text track cue in the list represented by the TextTrackCueList object whose text track cue identifier is id, if any, or null otherwise. If the argument is the empty string, then the method must return null.

[Exposed=Window]
interface TextTrackCue : EventTarget {
  readonly attribute TextTrack? track;

  attribute DOMString id;
  attribute double startTime;
  attribute double endTime;
  attribute boolean pauseOnExit;

  attribute EventHandler onenter;
  attribute EventHandler onexit;
};
cue . track
Returns the TextTrack object to which this text track cue belongs, if any, or null otherwise.

cue . id [ = value ]
Returns the text track cue identifier.

Can be set.

cue . startTime [ = value ]
Returns the text track cue start time, in seconds.

Can be set.

cue . endTime [ = value ]
Returns the text track cue end time, in seconds.

Can be set.

cue . pauseOnExit [ = value ]
Returns true if the text track cue pause-on-exit flag is set, false otherwise.

Can be set.

The track attribute, on getting, must return the TextTrack object of the text track in whose list of cues the text track cue that the TextTrackCue object represents finds itself, if any; or null otherwise.

The id attribute, on getting, must return the text track cue identifier of the text track cue that the TextTrackCue object represents. On setting, the text track cue identifier must be set to the new value.

The startTime attribute, on getting, must return the text track cue start time of the text track cue that the TextTrackCue object represents, in seconds. On setting, the text track cue start time must be set to the new value, interpreted in seconds; then, if the TextTrackCue object's text track cue is in a text track's list of cues, and that text track is in a media element's list of text tracks, and the media element's show poster flag is not set, then run the time marches on steps for that media element.

The endTime attribute, on getting, must return the text track cue end time of the text track cue that the TextTrackCue object represents, in seconds. On setting, the text track cue end time must be set to the new value, interpreted in seconds; then, if the TextTrackCue object's text track cue is in a text track's list of cues, and that text track is in a media element's list of text tracks, and the media element's show poster flag is not set, then run the time marches on steps for that media element.

The pauseOnExit attribute, on getting, must return true if the text track cue pause-on-exit flag of the text track cue that the TextTrackCue object represents is set; or false otherwise. On setting, the text track cue pause-on-exit flag must be set if the new value is true, and must be unset otherwise.

4.8.12.11.6 Event handlers for objects of the text track APIs
The following are the event handlers that (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the TextTrackList interface:

Event handler	Event handler event type
onchange	change
onaddtrack	addtrack
onremovetrack	removetrack
The following are the event handlers that (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the TextTrack interface:

Event handler	Event handler event type
oncuechange	cuechange
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the TextTrackCue interface:

Event handler	Event handler event type
onenter	enter
onexit	exit
4.8.12.11.7 Best practices for metadata text tracks
This section is non-normative.

Text tracks can be used for storing data relating to the media data, for interactive or augmented views.

For example, a page showing a sports broadcast could include information about the current score. Suppose a robotics competition was being streamed live. The image could be overlayed with the scores, as follows:



In order to make the score display render correctly whenever the user seeks to an arbitrary point in the video, the metadata text track cues need to be as long as is appropriate for the score. For example, in the frame above, there would be maybe one cue that lasts the length of the match that gives the match number, one cue that lasts until the blue alliance's score changes, and one cue that lasts until the red alliance's score changes. If the video is just a stream of the live event, the time in the bottom right would presumably be automatically derived from the current video time, rather than based on a cue. However, if the video was just the highlights, then that might be given in cues also.

The following shows what fragments of this could look like in a WebVTT file:

WEBVTT

...

05:10:00.000 --> 05:12:15.000
matchtype:qual
matchnumber:37

...

05:11:02.251 --> 05:11:17.198
red:78

05:11:03.672 --> 05:11:54.198
blue:66

05:11:17.198 --> 05:11:25.912
red:80

05:11:25.912 --> 05:11:26.522
red:83

05:11:26.522 --> 05:11:26.982
red:86

05:11:26.982 --> 05:11:27.499
red:89

...
The key here is to notice that the information is given in cues that span the length of time to which the relevant event applies. If, instead, the scores were given as zero-length (or very brief, nearly zero-length) cues when the score changes, for example saying "red+2" at 05:11:17.198, "red+3" at 05:11:25.912, etc, problems arise: primarily, seeking is much harder to implement, as the script has to walk the entire list of cues to make sure that no notifications have been missed; but also, if the cues are short it's possible the script will never see that they are active unless it listens to them specifically.

When using cues in this manner, authors are encouraged to use the cuechange event to update the current annotations. (In particular, using the timeupdate event would be less appropriate as it would require doing work even when the cues haven't changed, and, more importantly, would introduce a higher latency between when the metadata cues become active and when the display is updated, since timeupdate events are rate-limited.)

4.8.12.12 Identifying a track kind through a URL
Other specifications or formats that need a URL to identify the return values of the AudioTrack.kind or VideoTrack.kind IDL attributes, or identify the kind of text track, must use the about:html-kind URL.

4.8.12.13 User interface
The controls attribute is a boolean attribute. If present, it indicates that the author has not provided a scripted controller and would like the user agent to provide its own set of controls.

If the attribute is present, or if scripting is disabled for the media element, then the user agent should expose a user interface to the user. This user interface should include features to begin playback, pause playback, seek to an arbitrary position in the content (if the content supports arbitrary seeking), change the volume, change the display of closed captions or embedded sign-language tracks, select different audio tracks or turn on audio descriptions, and show the media content in manners more suitable to the user (e.g. fullscreen video or in an independent resizable window). Other controls may also be made available.

Even when the attribute is absent, however, user agents may provide controls to affect playback of the media resource (e.g. play, pause, seeking, track selection, and volume controls), but such features should not interfere with the page's normal rendering. For example, such features could be exposed in the media element's context menu, platform media keys, or a remote control. The user agent may implement this simply by exposing a user interface to the user as described above (as if the controls attribute was present).

If the user agent exposes a user interface to the user by displaying controls over the media element, then the user agent should suppress any user interaction events while the user agent is interacting with this interface. (For example, if the user clicks on a video's playback control, mousedown events and so forth would not simultaneously be fired at elements on the page.)

Where possible (specifically, for starting, stopping, pausing, and unpausing playback, for seeking, for changing the rate of playback, for fast-forwarding or rewinding, for listing, enabling, and disabling text tracks, and for muting or changing the volume of the audio), user interface features exposed by the user agent must be implemented in terms of the DOM API described above, so that, e.g., all the same events fire.

Features such as fast-forward or rewind must be implemented by only changing the playbackRate attribute (and not the defaultPlaybackRate attribute).

Seeking must be implemented in terms of seeking to the requested position in the media element's media timeline. For media resources where seeking to an arbitrary position would be slow, user agents are encouraged to use the approximate-for-speed flag when seeking in response to the user manipulating an approximate position interface such as a seek bar.

The controls IDL attribute must reflect the content attribute of the same name.

media . volume [ = value ]
Returns the current playback volume, as a number in the range 0.0 to 1.0, where 0.0 is the quietest and 1.0 the loudest.

Can be set, to change the volume.

Throws an "IndexSizeError" DOMException if the new value is not in the range 0.0 .. 1.0.

media . muted [ = value ]
Returns true if audio is muted, overriding the volume attribute, and false if the volume attribute is being honored.

Can be set, to change whether the audio is muted or not.

A media element has a playback volume, which is a fraction in the range 0.0 (silent) to 1.0 (loudest). Initially, the volume should be 1.0, but user agents may remember the last set value across sessions, on a per-site basis or otherwise, so the volume may start at other values.

The volume IDL attribute must return the playback volume of any audio portions of the media element. On setting, if the new value is in the range 0.0 to 1.0 inclusive, the media element's playback volume must be set to the new value. If the new value is outside the range 0.0 to 1.0 inclusive, then, on setting, an "IndexSizeError" DOMException must be thrown instead.

A media element can also be muted. If anything is muting the element, then it is muted. (For example, when the direction of playback is backwards, the element is muted.)

The muted IDL attribute must return the value to which it was last set. When a media element is created, if the element has a muted content attribute specified, then the muted IDL attribute should be set to true; otherwise, the user agents may set the value to the user's preferred value (e.g. remembering the last set value across sessions, on a per-site basis or otherwise). While the muted IDL attribute is set to true, the media element must be muted.

Whenever either of the values that would be returned by the volume and muted IDL attributes change, the user agent must queue a task to fire an event named volumechange at the media element. Then, if the media element is not allowed to play, the user agent must run the internal pause steps for the media element.

An element's effective media volume is determined as follows:

If the user has indicated that the user agent is to override the volume of the element, then return the volume desired by the user.

If the element's audio output is muted, then return zero.

Let volume be the playback volume of the audio portions of the media element, in range 0.0 (silent) to 1.0 (loudest).

Return volume, interpreted relative to the range 0.0 to 1.0, with 0.0 being silent, and 1.0 being the loudest setting, values in between increasing in loudness. The range need not be linear. The loudest setting may be lower than the system's loudest possible setting; for example the user could have set a maximum volume.

The muted content attribute on media elements is a boolean attribute that controls the default state of the audio output of the media resource, potentially overriding user preferences.

The defaultMuted IDL attribute must reflect the muted content attribute.

This attribute has no dynamic effect (it only controls the default state of the element).

This video (an advertisement) autoplays, but to avoid annoying users, it does so without sound, and allows the user to turn the sound on. The user agent can pause the video if it's unmuted without a user interaction.

<video src="adverts.cgi?kind=video" controls autoplay loop muted></video>
4.8.12.14 Time ranges
Objects implementing the TimeRanges interface represent a list of ranges (periods) of time.

[Exposed=Window]
interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};
media . length
Returns the number of ranges in the object.

time = media . start(index)
Returns the time for the start of the range with the given index.

Throws an "IndexSizeError" DOMException if the index is out of range.

time = media . end(index)
Returns the time for the end of the range with the given index.

Throws an "IndexSizeError" DOMException if the index is out of range.

The length IDL attribute must return the number of ranges represented by the object.

The start(index) method must return the position of the start of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.

The end(index) method must return the position of the end of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.

These methods must throw "IndexSizeError" DOMExceptions if called with an index argument greater than or equal to the number of ranges represented by the object.

When a TimeRanges object is said to be a normalized TimeRanges object, the ranges it represents must obey the following criteria:

The start of a range must be greater than the end of all earlier ranges.
The start of a range must be less than or equal to the end of that same range.
In other words, the ranges in such an object are ordered, don't overlap, and don't touch (adjacent ranges are folded into one bigger range). A range can be empty (referencing just a single moment in time), e.g. to indicate that only one frame is currently buffered in the case that the user agent has discarded the entire media resource except for the current frame, when a media element is paused.

Ranges in a TimeRanges object must be inclusive.

Thus, the end of a range would be equal to the start of a following adjacent (touching but not overlapping) range. Similarly, a range covering a whole timeline anchored at zero would have a start equal to zero and an end equal to the duration of the timeline.

The timelines used by the objects returned by the buffered, seekable and played IDL attributes of media elements must be that element's media timeline.

4.8.12.15 The TrackEvent interface
[Exposed=Window,
 Constructor(DOMString type, optional TrackEventInit eventInitDict)]
interface TrackEvent : Event {
  readonly attribute (VideoTrack or AudioTrack or TextTrack)? track;
};

dictionary TrackEventInit : EventInit {
  (VideoTrack or AudioTrack or TextTrack)? track = null;
};
event . track
Returns the track object (TextTrack, AudioTrack, or VideoTrack) to which the event relates.

The track attribute must return the value it was initialized to. It represents the context information for the event.

4.8.12.16 Events summary
This section is non-normative.

The following events fire on media elements as part of the processing model described above:

Event name	Interface	Fired when...	Preconditions
loadstart	Event	The user agent begins looking for media data, as part of the resource selection algorithm.	networkState equals NETWORK_LOADING
progress	Event	The user agent is fetching media data.	networkState equals NETWORK_LOADING
suspend	Event	The user agent is intentionally not currently fetching media data.	networkState equals NETWORK_IDLE
abort	Event	The user agent stops fetching the media data before it is completely downloaded, but not due to an error.	error is an object with the code MEDIA_ERR_ABORTED. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.
error	Event	An error occurs while fetching the media data or the type of the resource is not supported media format.	error is an object with the code MEDIA_ERR_NETWORK or higher. networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.
emptied	Event	A media element whose networkState was previously not in the NETWORK_EMPTY state has just switched to that state (either because of a fatal error during load that's about to be reported, or because the load() method was invoked while the resource selection algorithm was already running).	networkState is NETWORK_EMPTY; all the IDL attributes are in their initial states.
stalled	Event	The user agent is trying to fetch media data, but data is unexpectedly not forthcoming.	networkState is NETWORK_LOADING.
loadedmetadata	Event	The user agent has just determined the duration and dimensions of the media resource and the text tracks are ready.	readyState is newly equal to HAVE_METADATA or greater for the first time.
loadeddata	Event	The user agent can render the media data at the current playback position for the first time.	readyState newly increased to HAVE_CURRENT_DATA or greater for the first time.
canplay	Event	The user agent can resume playback of the media data, but estimates that if playback were to be started now, the media resource could not be rendered at the current playback rate up to its end without having to stop for further buffering of content.	readyState newly increased to HAVE_FUTURE_DATA or greater.
canplaythrough	Event	The user agent estimates that if playback were to be started now, the media resource could be rendered at the current playback rate all the way to its end without having to stop for further buffering.	readyState is newly equal to HAVE_ENOUGH_DATA.
playing	Event	Playback is ready to start after having been paused or delayed due to lack of media data.	readyState is newly equal to or greater than HAVE_FUTURE_DATA and paused is false, or paused is newly false and readyState is equal to or greater than HAVE_FUTURE_DATA. Even if this event fires, the element might still not be potentially playing, e.g. if the element is paused for user interaction or paused for in-band content.
waiting	Event	Playback has stopped because the next frame is not available, but the user agent expects that frame to become available in due course.	readyState is equal to or less than HAVE_CURRENT_DATA, and paused is false. Either seeking is true, or the current playback position is not contained in any of the ranges in buffered. It is possible for playback to stop for other reasons without paused being false, but those reasons do not fire this event (and when those situations resolve, a separate playing event is not fired either): e.g., playback has ended, or playback stopped due to errors, or the element has paused for user interaction or paused for in-band content.
seeking	Event	The seeking IDL attribute changed to true, and the user agent has started seeking to a new position.
seeked	Event	The seeking IDL attribute changed to false after the current playback position was changed.
ended	Event	Playback has stopped because the end of the media resource was reached.	currentTime equals the end of the media resource; ended is true.
durationchange	Event	The duration attribute has just been updated.
timeupdate	Event	The current playback position changed as part of normal playback or in an especially interesting way, for example discontinuously.
play	Event	The element is no longer paused. Fired after the play() method has returned, or when the autoplay attribute has caused playback to begin.	paused is newly false.
pause	Event	The element has been paused. Fired after the pause() method has returned.	paused is newly true.
ratechange	Event	Either the defaultPlaybackRate or the playbackRate attribute has just been updated.
resize	Event	One or both of the videoWidth and videoHeight attributes have just been updated.	Media element is a video element; readyState is not HAVE_NOTHING
volumechange	Event	Either the volume attribute or the muted attribute has changed. Fired after the relevant attribute's setter has returned.
The following event fires on source element:

Event name	Interface	Fired when...
error	Event	An error occurs while fetching the media data or the type of the resource is not supported media format.
The following events fire on AudioTrackList, VideoTrackList, and TextTrackList objects:

Event name	Interface	Fired when...
change	Event	One or more tracks in the track list have been enabled or disabled.
addtrack	TrackEvent	A track has been added to the track list.
removetrack	TrackEvent	A track has been removed from the track list.
The following event fires on TextTrack objects and track elements:

Event name	Interface	Fired when...
cuechange	Event	One or more cues in the track have become active or stopped being active.
The following events fire on track elements:

Event name	Interface	Fired when...
error	Event	An error occurs while fetching the track data or the type of the resource is not supported text track format.
load	Event	A track data has been fetched and successfully processed.
The following events fire on TextTrackCue objects:

Event name	Interface	Fired when...
enter	Event	The cue has become active.
exit	Event	The cue has stopped being active.
4.8.12.17 Security and privacy considerations
The main security and privacy implications of the video and audio elements come from the ability to embed media cross-origin. There are two directions that threats can flow: from hostile content to a victim page, and from a hostile page to victim content.

If a victim page embeds hostile content, the threat is that the content might contain scripted code that attempts to interact with the Document that embeds the content. To avoid this, user agents must ensure that there is no access from the content to the embedding page. In the case of media content that uses DOM concepts, the embedded content must be treated as if it was in its own unrelated top-level browsing context.

For instance, if an SVG animation was embedded in a video element, the user agent would not give it access to the DOM of the outer page. From the perspective of scripts in the SVG resource, the SVG file would appear to be in a lone top-level browsing context with no parent.

If a hostile page embeds victim content, the threat is that the embedding page could obtain information from the content that it would not otherwise have access to. The API does expose some information: the existence of the media, its type, its duration, its size, and the performance characteristics of its host. Such information is already potentially problematic, but in practice the same information can more or less be obtained using the img element, and so it has been deemed acceptable.

However, significantly more sensitive information could be obtained if the user agent further exposes metadata within the content, such as subtitles. That information is therefore only exposed if the video resource uses CORS. The crossorigin attribute allows authors to enable CORS. [FETCH]

Without this restriction, an attacker could trick a user running within a corporate network into visiting a site that attempts to load a video from a previously leaked location on the corporation's intranet. If such a video included confidential plans for a new product, then being able to read the subtitles would present a serious confidentiality breach.

4.8.12.18 Best practices for authors using media elements
This section is non-normative.

Playing audio and video resources on small devices such as set-top boxes or mobile phones is often constrained by limited hardware resources in the device. For example, a device might only support three simultaneous videos. For this reason, it is a good practice to release resources held by media elements when they are done playing, either by being very careful about removing all references to the element and allowing it to be garbage collected, or, even better, by removing the element's src attribute and any source element descendants, and invoking the element's load() method.

Similarly, when the playback rate is not exactly 1.0, hardware, software, or format limitations can cause video frames to be dropped and audio to be choppy or muted.

4.8.12.19 Best practices for implementers of media elements
This section is non-normative.

How accurately various aspects of the media element API are implemented is considered a quality-of-implementation issue.

For example, when implementing the buffered attribute, how precise an implementation reports the ranges that have been buffered depends on how carefully the user agent inspects the data. Since the API reports ranges as times, but the data is obtained in byte streams, a user agent receiving a variable-bitrate stream might only be able to determine precise times by actually decoding all of the data. User agents aren't required to do this, however; they can instead return estimates (e.g. based on the average bitrate seen so far) which get revised as more information becomes available.

As a general rule, user agents are urged to be conservative rather than optimistic. For example, it would be bad to report that everything had been buffered when it had not.

Another quality-of-implementation issue would be playing a video backwards when the codec is designed only for forward playback (e.g. there aren't many key frames, and they are far apart, and the intervening frames only have deltas from the previous frame). User agents could do a poor job, e.g. only showing key frames; however, better implementations would do more work and thus do a better job, e.g. actually decoding parts of the video forwards, storing the complete frames, and then playing the frames backwards.

Similarly, while implementations are allowed to drop buffered data at any time (there is no requirement that a user agent keep all the media data obtained for the lifetime of the media element), it is again a quality of implementation issue: user agents with sufficient resources to keep all the data around are encouraged to do so, as this allows for a better user experience. For example, if the user is watching a live stream, a user agent could allow the user only to view the live video; however, a better user agent would buffer everything and allow the user to seek through the earlier material, pause it, play it forwards and backwards, etc.

When a media element that is paused is removed from a document and not reinserted before the next time the event loop reaches step 1, implementations that are resource constrained are encouraged to take that opportunity to release all hardware resources (like video planes, networking resources, and data buffers) used by the media element. (User agents still have to keep track of the playback position and so forth, though, in case playback is later restarted.)

4.8.13 The map element
Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
name — Name of image map to reference from the usemap attribute
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLMapElement : HTMLElement {
  [CEReactions] attribute DOMString name;
  [SameObject] readonly attribute HTMLCollection areas;
};
The map element, in conjunction with an img element and any area element descendants, defines an image map. The element represents its children.

The name attribute gives the map a name so that it can be referenced. The attribute must be present and must have a non-empty value with no ASCII whitespace. The value of the name attribute must not be equal to the value of the name attribute of another map element in the same tree. If the id attribute is also specified, both attributes must have the same value.

map . areas
Returns an HTMLCollection of the area elements in the map.

The areas attribute must return an HTMLCollection rooted at the map element, whose filter matches only area elements.

The IDL attribute name must reflect the content attribute of the same name.

Image maps can be defined in conjunction with other content on the page, to ease maintenance. This example is of a page with an image map at the top of the page and a corresponding set of text links at the bottom.

<!DOCTYPE HTML>
<HTML LANG="EN">
<TITLE>Babies™: Toys</TITLE>
<HEADER>
 <H1>Toys</H1>
 <IMG SRC="/images/menu.gif"
      ALT="Babies™ navigation menu. Select a department to go to its page."
      USEMAP="#NAV">
</HEADER>
 ...
<FOOTER>
 <MAP NAME="NAV">
  <P>
   <A HREF="/clothes/">Clothes</A>
   <AREA ALT="Clothes" COORDS="0,0,100,50" HREF="/clothes/"> |
   <A HREF="/toys/">Toys</A>
   <AREA ALT="Toys" COORDS="100,0,200,50" HREF="/toys/"> |
   <A HREF="/food/">Food</A>
   <AREA ALT="Food" COORDS="200,0,300,50" HREF="/food/"> |
   <A HREF="/books/">Books</A>
   <AREA ALT="Books" COORDS="300,0,400,50" HREF="/books/">
  </P>
 </MAP>
</FOOTER>
4.8.14 The area element
Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected, but only if there is a map element ancestor.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
alt — Replacement text for use when images are not available
coords — Coordinates for the shape to be created in an image map
shape — The kind of shape to be created in an image map
href — Address of the hyperlink
target — Browsing context for hyperlink navigation
download — Whether to download the resource instead of navigating to it, and its file name if so
ping — URLs to ping
rel — Relationship between the location in the document containing the hyperlink and the destination resource
referrerpolicy — Referrer policy for fetches initiated by the element
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLAreaElement : HTMLElement {
  [CEReactions] attribute DOMString alt;
  [CEReactions] attribute DOMString coords;
  [CEReactions] attribute DOMString shape;
  [CEReactions] attribute DOMString target;
  [CEReactions] attribute DOMString download;
  [CEReactions] attribute USVString ping;
  [CEReactions] attribute DOMString rel;
  [SameObject, PutForwards=value] readonly attribute DOMTokenList relList;
  [CEReactions] attribute DOMString referrerPolicy;

  // also has obsolete members
};
HTMLAreaElement includes HTMLHyperlinkElementUtils;
The area element represents either a hyperlink with some text and a corresponding area on an image map, or a dead area on an image map.

An area element with a parent node must have a map element ancestor.

If the area element has an href attribute, then the area element represents a hyperlink. In this case, the alt attribute must be present. It specifies the text of the hyperlink. Its value must be text that, when presented with the texts specified for the other hyperlinks of the image map, and with the alternative text of the image, but without the image itself, provides the user with the same kind of choice as the hyperlink would when used without its text but with its shape applied to the image. The alt attribute may be left blank if there is another area element in the same image map that points to the same resource and has a non-blank alt attribute.

If the area element has no href attribute, then the area represented by the element cannot be selected, and the alt attribute must be omitted.

In both cases, the shape and coords attributes specify the area.

The shape attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.

State	Keywords	Notes
Circle state	circle
circ	Non-conforming
Default state	default
Polygon state	poly
polygon	Non-conforming
Rectangle state	rect
rectangle	Non-conforming
The attribute may be omitted. The missing value default and invalid value default are the rectangle state.

The coords attribute must, if specified, contain a valid list of floating-point numbers. This attribute gives the coordinates for the shape described by the shape attribute. The processing for this attribute is described as part of the image map processing model.

In the circle state, area elements must have a coords attribute present, with three integers, the last of which must be non-negative. The first integer must be the distance in CSS pixels from the left edge of the image to the center of the circle, the second integer must be the distance in CSS pixels from the top edge of the image to the center of the circle, and the third integer must be the radius of the circle, again in CSS pixels.

In the default state state, area elements must not have a coords attribute. (The area is the whole image.)

In the polygon state, area elements must have a coords attribute with at least six integers, and the number of integers must be even. Each pair of integers must represent a coordinate given as the distances from the left and the top of the image in CSS pixels respectively, and all the coordinates together must represent the points of the polygon, in order.

In the rectangle state, area elements must have a coords attribute with exactly four integers, the first of which must be less than the third, and the second of which must be less than the fourth. The four points must represent, respectively, the distance from the left edge of the image to the left side of the rectangle, the distance from the top edge to the top side, the distance from the left edge to the right side, and the distance from the top edge to the bottom side, all in CSS pixels.

When user agents allow users to follow hyperlinks or download hyperlinks created using the area element, as described in the next section, the href, target, download, and ping attributes decide how the link is followed. The rel attribute may be used to indicate to the user the likely nature of the target resource before the user follows the link.

The target, download, ping, rel, and referrerpolicy attributes must be omitted if the href attribute is not present.

If the itemprop attribute is specified on an area element, then the href attribute must also be specified.

The activation behavior of area elements is to follow the hyperlink or download the hyperlink created by the area element, if any, and as determined by the download attribute and any expressed user preference.

The IDL attributes alt, coords, target, download, ping, and rel, each must reflect the respective content attributes of the same name.

The IDL attribute shape must reflect the shape content attribute.

The IDL attribute relList must reflect the rel content attribute.

The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.

4.8.15 Image maps
4.8.15.1 Authoring
An image map allows geometric areas on an image to be associated with hyperlinks.

An image, in the form of an img element or an object element representing an image, may be associated with an image map (in the form of a map element) by specifying a usemap attribute on the img or object element. The usemap attribute, if specified, must be a valid hash-name reference to a map element.

Consider an image that looks as follows:



If we wanted just the colored areas to be clickable, we could do it as follows:

<p>
 Please select a shape:
 <img src="shapes.png" usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star.">
 </map>
</p>
4.8.15.2 Processing model
If an img element or an object element representing an image has a usemap attribute specified, user agents must process it as follows:

Parse the attribute's value using the rules for parsing a hash-name reference to a map element, with the element as the context node. This will return either an element (the map) or null.

If that returned null, then return. The image is not associated with an image map after all.

Otherwise, the user agent must collect all the area elements that are descendants of the map. Let those be the areas.

Having obtained the list of area elements that form the image map (the areas), interactive user agents must process the list in one of two ways.

If the user agent intends to show the text that the img element represents, then it must use the following steps.

In user agents that do not support images, or that have images disabled, object elements cannot represent images, and thus this section never applies (the fallback content is shown instead). The following steps therefore only apply to img elements.

Remove all the area elements in areas that have no href attribute.

Remove all the area elements in areas that have no alt attribute, or whose alt attribute's value is the empty string, if there is another area element in areas with the same value in the href attribute and with a non-empty alt attribute.

Each remaining area element in areas represents a hyperlink. Those hyperlinks should all be made available to the user in a manner associated with the text of the img.

In this context, user agents may represent area and img elements with no specified alt attributes, or whose alt attributes are the empty string or some other non-visible text, in a user-agent-defined fashion intended to indicate the lack of suitable author-provided text.

If the user agent intends to show the image and allow interaction with the image to select hyperlinks, then the image must be associated with a set of layered shapes, taken from the area elements in areas, in reverse tree order (so the last specified area element in the map is the bottom-most shape, and the first element in the map, in tree order, is the top-most shape).

Each area element in areas must be processed as follows to obtain a shape to layer onto the image:

Find the state that the element's shape attribute represents.

Use the rules for parsing a list of floating-point numbers to parse the element's coords attribute, if it is present, and let the result be the coords list. If the attribute is absent, let the coords list be the empty list.

If the number of items in the coords list is less than the minimum number given for the area element's current state, as per the following table, then the shape is empty; return.

State	Minimum number of items
Circle state	3
Default state	0
Polygon state	6
Rectangle state	4
Check for excess items in the coords list as per the entry in the following list corresponding to the shape attribute's state:

Circle state
Drop any items in the list beyond the third.
Default state
Drop all items in the list.
Polygon state
Drop the last item if there's an odd number of items.
Rectangle state
Drop any items in the list beyond the fourth.
If the shape attribute represents the rectangle state, and the first number in the list is numerically greater than the third number in the list, then swap those two numbers around.

If the shape attribute represents the rectangle state, and the second number in the list is numerically greater than the fourth number in the list, then swap those two numbers around.

If the shape attribute represents the circle state, and the third number in the list is less than or equal to zero, then the shape is empty; return.

Now, the shape represented by the element is the one described for the entry in the list below corresponding to the state of the shape attribute:

Circle state
Let x be the first number in coords, y be the second number, and r be the third number.

The shape is a circle whose center is x CSS pixels from the left edge of the image and y CSS pixels from the top edge of the image, and whose radius is r CSS pixels.

Default state
The shape is a rectangle that exactly covers the entire image.

Polygon state
Let xi be the (2i)th entry in coords, and yi be the (2i+1)th entry in coords (the first entry in coords being the one with index 0).

Let the coordinates be (xi, yi), interpreted in CSS pixels measured from the top left of the image, for all integer values of i from 0 to (N/2)-1, where N is the number of items in coords.

The shape is a polygon whose vertices are given by the coordinates, and whose interior is established using the even-odd rule. [GRAPHICS]

Rectangle state
Let x1 be the first number in coords, y1 be the second number, x2 be the third number, and y2 be the fourth number.

The shape is a rectangle whose top-left corner is given by the coordinate (x1, y1) and whose bottom right corner is given by the coordinate (x2, y2), those coordinates being interpreted as CSS pixels from the top left corner of the image.

For historical reasons, the coordinates must be interpreted relative to the displayed image after any stretching caused by the CSS 'width' and 'height' properties (or, for non-CSS browsers, the image element's width and height attributes — CSS browsers map those attributes to the aforementioned CSS properties).

Browser zoom features and transforms applied using CSS or SVG do not affect the coordinates.

Pointing device interaction with an image associated with a set of layered shapes per the above algorithm must result in the relevant user interaction events being first fired to the top-most shape covering the point that the pointing device indicated, if any, or to the image element itself, if there is no shape covering that point. User agents may also allow individual area elements representing hyperlinks to be selected and activated (e.g. using a keyboard).

Because a map element (and its area elements) can be associated with multiple img and object elements, it is possible for an area element to correspond to multiple focusable areas of the document.

Image maps are live; if the DOM is mutated, then the user agent must act as if it had rerun the algorithms for image maps.

4.8.16 MathML
The MathML math element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.

When the MathML annotation-xml element contains elements from the HTML namespace, such elements must all be flow content.

When the MathML token elements (mi, mo, mn, ms, and mtext) are descendants of HTML elements, they may contain phrasing content elements from the HTML namespace.

User agents must handle text other than inter-element whitespace found in MathML elements whose content models do not allow straight text by pretending for the purposes of MathML content models, layout, and rendering that the text is actually wrapped in a MathML mtext element. (Such text is not, however, conforming.)

User agents must act as if any MathML element whose contents does not match the element's content model was replaced, for the purposes of MathML layout and rendering, by a MathML merror element containing some appropriate error message.

To enable authors to use MathML tools that only accept MathML in its XML form, interactive HTML user agents are encouraged to provide a way to export any MathML fragment as an XML namespace-well-formed XML fragment.

The semantics of MathML elements are defined by the MathML specification and other applicable specifications. [MATHML]

Here is an example of the use of MathML in an HTML document:

<!DOCTYPE html>
<html lang="en">
 <head>
  <title>The quadratic formula</title>
 </head>
 <body>
  <h1>The quadratic formula</h1>
  <p>
   <math>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo form="prefix">−</mo> <mi>b</mi>
      <mo>±</mo>
      <msqrt>
       <msup> <mi>b</mi> <mn>2</mn> </msup>
       <mo>−</mo>
       <mn>4</mn> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mi>c</mi>
      </msqrt>
     </mrow>
     <mrow>
      <mn>2</mn> <mo>⁢</mo> <mi>a</mi>
     </mrow>
    </mfrac>
   </math>
  </p>
 </body>
</html>
4.8.17 SVG

Support: svg-html5
Chrome for Android	64+
Chrome	7+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	9+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	3+
Opera	11.6+

Source: caniuse.com

The SVG svg element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.

To enable authors to use SVG tools that only accept SVG in its XML form, interactive HTML user agents are encouraged to provide a way to export any SVG fragment as an XML namespace-well-formed XML fragment.

When the SVG foreignObject element contains elements from the HTML namespace, such elements must all be flow content.

The content model for the SVG title element inside HTML documents is phrasing content. (This further constrains the requirements given in the SVG specification.)

The semantics of SVG elements are defined by the SVG specification and other applicable specifications. [SVG]

doc = iframe . getSVGDocument()
doc = embed . getSVGDocument()
doc = object . getSVGDocument()
Returns the Document object, in the case of iframe, embed, or object elements being used to embed SVG images.

The getSVGDocument() method must run the following steps:

If the element's nested browsing context is null, then return null.

If the origin of the active document of the nested browsing context is not same origin-domain with the element's node document's origin, then return null.

If the nested browsing context's active document was created by the page load processing model for XML files section because the computed type of the resource in the navigate algorithm was image/svg+xml, then return that Document object.

Otherwise, return null.

4.8.18 Dimension attributes
Author requirements: The width and height attributes on img, iframe, embed, object, video, and, when their type attribute is in the Image Button state, input elements may be specified to give the dimensions of the visual content of the element (the width and height respectively, relative to the nominal direction of the output medium), in CSS pixels. The attributes, if specified, must have values that are valid non-negative integers.

The specified dimensions given may differ from the dimensions specified in the resource itself, since the resource may have a resolution that differs from the CSS pixel resolution. (On screens, CSS pixels have a resolution of 96ppi, but in general the CSS pixel resolution depends on the reading distance.) If both attributes are specified, then one of the following statements must be true:

specified width - 0.5 ≤ specified height * target ratio ≤ specified width + 0.5
specified height - 0.5 ≤ specified width / target ratio ≤ specified height + 0.5
specified height = specified width = 0
The target ratio is the ratio of the intrinsic width to the intrinsic height in the resource. The specified width and specified height are the values of the width and height attributes respectively.

The two attributes must be omitted if the resource in question does not have both an intrinsic width and an intrinsic height.

If the two attributes are both zero, it indicates that the element is not intended for the user (e.g. it might be a part of a service to count page views).

The dimension attributes are not intended to be used to stretch the image.

User agent requirements: User agents are expected to use these attributes as hints for the rendering.

The width and height IDL attributes on the iframe, embed, object, and video elements must reflect the respective content attributes of the same name.

For iframe, embed, and object the IDL attributes are DOMString; for video the IDL attributes are unsigned long.

The corresponding IDL attributes for img and input elements are defined in those respective elements' sections, as they are slightly more specific to those elements' other behaviors.

4.9 Tabular data
4.9.1 The table element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
In this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableElement : HTMLElement {
  [CEReactions] attribute HTMLTableCaptionElement? caption;
  HTMLTableCaptionElement createCaption();
  [CEReactions] void deleteCaption();

  [CEReactions] attribute HTMLTableSectionElement? tHead;
  HTMLTableSectionElement createTHead();
  [CEReactions] void deleteTHead();

  [CEReactions] attribute HTMLTableSectionElement? tFoot;
  HTMLTableSectionElement createTFoot();
  [CEReactions] void deleteTFoot();

  [SameObject] readonly attribute HTMLCollection tBodies;
  HTMLTableSectionElement createTBody();

  [SameObject] readonly attribute HTMLCollection rows;
  HTMLTableRowElement insertRow(optional long index = -1);
  [CEReactions] void deleteRow(long index);

  // also has obsolete members
};
The table element represents data with more than one dimension, in the form of a table.

The table element takes part in the table model. Tables have rows, columns, and cells given by their descendants. The rows and columns form a grid; a table's cells must completely cover that grid without overlap.

Precise rules for determining whether this conformance requirement is met are described in the description of the table model.

Authors are encouraged to provide information describing how to interpret complex tables. Guidance on how to provide such information is given below.

Tables must not be used as layout aids. Historically, some Web authors have misused tables in HTML as a way to control their page layout. This usage is non-conforming, because tools attempting to extract tabular data from such documents would obtain very confusing results. In particular, users of accessibility tools like screen readers are likely to find it very difficult to navigate pages with tables used for layout.

There are a variety of alternatives to using HTML tables for layout, primarily using CSS positioning and the CSS table model. [CSS]

Tables can be complicated to understand and navigate. To help users with this, user agents should clearly delineate cells in a table from each other, unless the user agent has classified the table as a (non-conforming) layout table.

Authors and implementers are encouraged to consider using some of the table design techniques described below to make tables easier to navigate for users.

User agents, especially those that do table analysis on arbitrary content, are encouraged to find heuristics to determine which tables actually contain data and which are merely being used for layout. This specification does not define a precise heuristic, but the following are suggested as possible indicators:

Feature	Indication
The use of the role attribute with the value presentation	Probably a layout table
The use of the non-conforming border attribute with the non-conforming value 0	Probably a layout table
The use of the non-conforming cellspacing and cellpadding attributes with the value 0	Probably a layout table
The use of caption, thead, or th elements	Probably a non-layout table
The use of the headers and scope attributes	Probably a non-layout table
The use of the non-conforming border attribute with a value other than 0	Probably a non-layout table
Explicit visible borders set using CSS	Probably a non-layout table
The use of the summary attribute	Not a good indicator (both layout and non-layout tables have historically been given this attribute)
It is quite possible that the above suggestions are wrong. Implementors are urged to provide feedback elaborating on their experiences with trying to create a layout table detection heuristic.

If a table element has a (non-conforming) summary attribute, and the user agent has not classified the table as a layout table, the user agent may report the contents of that attribute to the user.

table . caption [ = value ]
Returns the table's caption element.

Can be set, to replace the caption element.

caption = table . createCaption()
Ensures the table has a caption element, and returns it.

table . deleteCaption()
Ensures the table does not have a caption element.

table . tHead [ = value ]
Returns the table's thead element.

Can be set, to replace the thead element. If the new value is not a thead element, throws a "HierarchyRequestError" DOMException.

thead = table . createTHead()
Ensures the table has a thead element, and returns it.

table . deleteTHead()
Ensures the table does not have a thead element.

table . tFoot [ = value ]
Returns the table's tfoot element.

Can be set, to replace the tfoot element. If the new value is not a tfoot element, throws a "HierarchyRequestError" DOMException.

tfoot = table . createTFoot()
Ensures the table has a tfoot element, and returns it.

table . deleteTFoot()
Ensures the table does not have a tfoot element.

table . tBodies
Returns an HTMLCollection of the tbody elements of the table.

tbody = table . createTBody()
Creates a tbody element, inserts it into the table, and returns it.

table . rows
Returns an HTMLCollection of the tr elements of the table.

tr = table . insertRow( [ index ] )
Creates a tr element, along with a tbody if required, inserts them into the table at the position given by the argument, and returns the tr.

The position is relative to the rows in the table. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the table.

If the given position is less than −1 or greater than the number of rows, throws an "IndexSizeError" DOMException.

table . deleteRow(index)
Removes the tr element with the given position in the table.

The position is relative to the rows in the table. The index −1 is equivalent to deleting the last row of the table.

If the given position is less than −1 or greater than the index of the last row, or if there are no rows, throws an "IndexSizeError" DOMException.

In all of the following attribute and method definitions, when an element is to be table-created, that means to create an element given the table element's node document, the given local name, and the HTML namespace.

The caption IDL attribute must return, on getting, the first caption element child of the table element, if any, or null otherwise. On setting, the first caption element child of the table element, if any, must be removed, and the new value, if not null, must be inserted as the first node of the table element.

The createCaption() method must return the first caption element child of the table element, if any; otherwise a new caption element must be table-created, inserted as the first node of the table element, and then returned.

The deleteCaption() method must remove the first caption element child of the table element, if any.

The tHead IDL attribute must return, on getting, the first thead element child of the table element, if any, or null otherwise. On setting, if the new value is null or a thead element, the first thead element child of the table element, if any, must be removed, and the new value, if not null, must be inserted immediately before the first element in the table element that is neither a caption element nor a colgroup element, if any, or at the end of the table if there are no such elements. If the new value is neither null nor a thead element, then a "HierarchyRequestError" DOMException must be thrown instead.

The createTHead() method must return the first thead element child of the table element, if any; otherwise a new thead element must be table-created and inserted immediately before the first element in the table element that is neither a caption element nor a colgroup element, if any, or at the end of the table if there are no such elements, and then that new element must be returned.

The deleteTHead() method must remove the first thead element child of the table element, if any.

The tFoot IDL attribute must return, on getting, the first tfoot element child of the table element, if any, or null otherwise. On setting, if the new value is null or a tfoot element, the first tfoot element child of the table element, if any, must be removed, and the new value, if not null, must be inserted at the end of the table. If the new value is neither null nor a tfoot element, then a "HierarchyRequestError" DOMException must be thrown instead.

The createTFoot() method must return the first tfoot element child of the table element, if any; otherwise a new tfoot element must be table-created and inserted at the end of the table, and then that new element must be returned.

The deleteTFoot() method must remove the first tfoot element child of the table element, if any.

The tBodies attribute must return an HTMLCollection rooted at the table node, whose filter matches only tbody elements that are children of the table element.

The createTBody() method must table-create a new tbody element, insert it immediately after the last tbody element child in the table element, if any, or at the end of the table element if the table element has no tbody element children, and then must return the new tbody element.

The rows attribute must return an HTMLCollection rooted at the table node, whose filter matches only tr elements that are either children of the table element, or children of thead, tbody, or tfoot elements that are themselves children of the table element. The elements in the collection must be ordered such that those elements whose parent is a thead are included first, in tree order, followed by those elements whose parent is either a table or tbody element, again in tree order, followed finally by those elements whose parent is a tfoot element, still in tree order.

The behavior of the insertRow(index) method depends on the state of the table. When it is called, the method must act as required by the first item in the following list of conditions that describes the state of the table and the index argument:

If index is less than −1 or greater than the number of elements in rows collection:
The method must throw an "IndexSizeError" DOMException.
If the rows collection has zero elements in it, and the table has no tbody elements in it:
The method must table-create a tbody element, then table-create a tr element, then append the tr element to the tbody element, then append the tbody element to the table element, and finally return the tr element.
If the rows collection has zero elements in it:
The method must table-create a tr element, append it to the last tbody element in the table, and return the tr element.
If index is −1 or equal to the number of items in rows collection:
The method must table-create a tr element, and append it to the parent of the last tr element in the rows collection. Then, the newly created tr element must be returned.
Otherwise:
The method must table-create a tr element, insert it immediately before the indexth tr element in the rows collection, in the same parent, and finally must return the newly created tr element.
When the deleteRow(index) method is called, the user agent must run the following steps:

If index is less than −1 or greater than or equal to the number of elements in the rows collection, then throw an "IndexSizeError" DOMException.

If index is −1, then remove the last element in the rows collection from its parent, or do nothing if the rows collection is empty.

Otherwise, remove the indexth element in the rows collection from its parent.

Here is an example of a table being used to mark up a Sudoku puzzle. Observe the lack of headers, which are not necessary in such a table.

<style>
 #sudoku { border-collapse: collapse; border: solid thick; }
 #sudoku colgroup, table#sudoku tbody { border: solid medium; }
 #sudoku td { border: solid thin; height: 1.4em; width: 1.4em; text-align: center; padding: 0; }
</style>
<h1>Today's Sudoku</h1>
<table id="sudoku">
 <colgroup><col><col><col>
 <colgroup><col><col><col>
 <colgroup><col><col><col>
 <tbody>
  <tr> <td> 1 <td>   <td> 3 <td> 6 <td>   <td> 4 <td> 7 <td>   <td> 9
  <tr> <td>   <td> 2 <td>   <td>   <td> 9 <td>   <td>   <td> 1 <td>
  <tr> <td> 7 <td>   <td>   <td>   <td>   <td>   <td>   <td>   <td> 6
 <tbody>
  <tr> <td> 2 <td>   <td> 4 <td>   <td> 3 <td>   <td> 9 <td>   <td> 8
  <tr> <td>   <td>   <td>   <td>   <td>   <td>   <td>   <td>   <td>
  <tr> <td> 5 <td>   <td>   <td> 9 <td>   <td> 7 <td>   <td>   <td> 1
 <tbody>
  <tr> <td> 6 <td>   <td>   <td>   <td> 5 <td>   <td>   <td>   <td> 2
  <tr> <td>   <td>   <td>   <td>   <td> 7 <td>   <td>   <td>   <td>
  <tr> <td> 9 <td>   <td>   <td> 8 <td>   <td> 2 <td>   <td>   <td> 5
</table>
4.9.1.1 Techniques for describing tables
For tables that consist of more than just a grid of cells with headers in the first row and headers in the first column, and for any table in general where the reader might have difficulty understanding the content, authors should include explanatory information introducing the table. This information is useful for all users, but is especially useful for users who cannot see the table, e.g. users of screen readers.

Such explanatory information should introduce the purpose of the table, outline its basic cell structure, highlight any trends or patterns, and generally teach the user how to use the table.

For instance, the following table:

Characteristics with positive and negative sides
Negative	Characteristic	Positive
Sad	Mood	Happy
Failing	Grade	Passing
...might benefit from a description explaining the way the table is laid out, something like "Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column".

There are a variety of ways to include this information, such as:

In prose, surrounding the table
<p>In the following table, characteristics are given in the second
column, with the negative side in the left column and the positive
side in the right column.</p>
<table>
 <caption>Characteristics with positive and negative sides</caption>
 <thead>
  <tr>
   <th id="n"> Negative
   <th> Characteristic
   <th> Positive
 <tbody>
  <tr>
   <td headers="n r1"> Sad
   <th id="r1"> Mood
   <td> Happy
  <tr>
   <td headers="n r2"> Failing
   <th id="r2"> Grade
   <td> Passing
</table>
In the table's caption
<table>
 <caption>
  <strong>Characteristics with positive and negative sides.</strong>
  <p>Characteristics are given in the second column, with the
  negative side in the left column and the positive side in the right
  column.</p>
 </caption>
 <thead>
  <tr>
   <th id="n"> Negative
   <th> Characteristic
   <th> Positive
 <tbody>
  <tr>
   <td headers="n r1"> Sad
   <th id="r1"> Mood
   <td> Happy
  <tr>
   <td headers="n r2"> Failing
   <th id="r2"> Grade
   <td> Passing
</table>
In the table's caption, in a details element
<table>
 <caption>
  <strong>Characteristics with positive and negative sides.</strong>
  <details>
   <summary>Help</summary>
   <p>Characteristics are given in the second column, with the
   negative side in the left column and the positive side in the right
   column.</p>
  </details>
 </caption>
 <thead>
  <tr>
   <th id="n"> Negative
   <th> Characteristic
   <th> Positive
 <tbody>
  <tr>
   <td headers="n r1"> Sad
   <th id="r1"> Mood
   <td> Happy
  <tr>
   <td headers="n r2"> Failing
   <th id="r2"> Grade
   <td> Passing
</table>
Next to the table, in the same figure
<figure>
 <figcaption>Characteristics with positive and negative sides</figcaption>
 <p>Characteristics are given in the second column, with the
 negative side in the left column and the positive side in the right
 column.</p>
 <table>
  <thead>
   <tr>
    <th id="n"> Negative
    <th> Characteristic
    <th> Positive
  <tbody>
   <tr>
    <td headers="n r1"> Sad
    <th id="r1"> Mood
    <td> Happy
   <tr>
    <td headers="n r2"> Failing
    <th id="r2"> Grade
    <td> Passing
 </table>
</figure>
Next to the table, in a figure's figcaption
<figure>
 <figcaption>
  <strong>Characteristics with positive and negative sides</strong>
  <p>Characteristics are given in the second column, with the
  negative side in the left column and the positive side in the right
  column.</p>
 </figcaption>
 <table>
  <thead>
   <tr>
    <th id="n"> Negative
    <th> Characteristic
    <th> Positive
  <tbody>
   <tr>
    <td headers="n r1"> Sad
    <th id="r1"> Mood
    <td> Happy
   <tr>
    <td headers="n r2"> Failing
    <th id="r2"> Grade
    <td> Passing
 </table>
</figure>
Authors may also use other techniques, or combinations of the above techniques, as appropriate.

The best option, of course, rather than writing a description explaining the way the table is laid out, is to adjust the table such that no explanation is needed.

In the case of the table used in the examples above, a simple rearrangement of the table so that the headers are on the top and left sides removes the need for an explanation as well as removing the need for the use of headers attributes:

<table>
 <caption>Characteristics with positive and negative sides</caption>
 <thead>
  <tr>
   <th> Characteristic
   <th> Negative
   <th> Positive
 <tbody>
  <tr>
   <th> Mood
   <td> Sad
   <td> Happy
  <tr>
   <th> Grade
   <td> Failing
   <td> Passing
</table>
4.9.1.2 Techniques for table design
Good table design is key to making tables more readable and usable.

In visual media, providing column and row borders and alternating row backgrounds can be very effective to make complicated tables more readable.

For tables with large volumes of numeric content, using monospaced fonts can help users see patterns, especially in situations where a user agent does not render the borders. (Unfortunately, for historical reasons, not rendering borders on tables is a common default.)

In speech media, table cells can be distinguished by reporting the corresponding headers before reading the cell's contents, and by allowing users to navigate the table in a grid fashion, rather than serializing the entire contents of the table in source order.

Authors are encouraged to use CSS to achieve these effects.

User agents are encouraged to render tables using these techniques whenever the page does not use CSS and the table is not classified as a layout table.

4.9.2 The caption element
Categories:
None.
Contexts in which this element can be used:
As the first element child of a table element.
Content model:
Flow content, but with no descendant table elements.
Tag omission in text/html:
A caption element's end tag can be omitted if the caption element is not immediately followed by ASCII whitespace or a comment.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableCaptionElement : HTMLElement {
  // also has obsolete members
};
The caption element represents the title of the table that is its parent, if it has a parent and that is a table element.

The caption element takes part in the table model.

When a table element is the only content in a figure element other than the figcaption, the caption element should be omitted in favor of the figcaption.

A caption can introduce context for a table, making it significantly easier to understand.

Consider, for instance, the following table:

1	2	3	4	5	6
1	2	3	4	5	6	7
2	3	4	5	6	7	8
3	4	5	6	7	8	9
4	5	6	7	8	9	10
5	6	7	8	9	10	11
6	7	8	9	10	11	12
In the abstract, this table is not clear. However, with a caption giving the table's number (for reference in the main prose) and explaining its use, it makes more sense:

<caption>
<p>Table 1.
<p>This table shows the total score obtained from rolling two
six-sided dice. The first row represents the value of the first die,
the first column the value of the second die. The total is given in
the cell that corresponds to the values of the two dice.
</caption>
This provides the user with more context:

Table 1.

This table shows the total score obtained from rolling two six-sided dice. The first row represents the value of the first die, the first column the value of the second die. The total is given in the cell that corresponds to the values of the two dice.

1	2	3	4	5	6
1	2	3	4	5	6	7
2	3	4	5	6	7	8
3	4	5	6	7	8	9
4	5	6	7	8	9	10
5	6	7	8	9	10	11
6	7	8	9	10	11	12
4.9.3 The colgroup element
Categories:
None.
Contexts in which this element can be used:
As a child of a table element, after any caption elements and before any thead, tbody, tfoot, and tr elements.
Content model:
If the span attribute is present: Nothing.
If the span attribute is absent: Zero or more col and template elements.
Tag omission in text/html:
A colgroup element's start tag can be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can't be omitted if the element is empty.)
A colgroup element's end tag can be omitted if the colgroup element is not immediately followed by ASCII whitespace or a comment.
Content attributes:
Global attributes
span — Number of columns spanned by the element
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableColElement : HTMLElement {
  [CEReactions] attribute unsigned long span;

  // also has obsolete members
};
The colgroup element represents a group of one or more columns in the table that is its parent, if it has a parent and that is a table element.

If the colgroup element contains no col elements, then the element may have a span content attribute specified, whose value must be a valid non-negative integer greater than zero and less than or equal to 1000.

The colgroup element and its span attribute take part in the table model.

The span IDL attribute must reflect the content attribute of the same name. It is clamped to the range [1, 1000], and its default value is 1.

4.9.4 The col element
Categories:
None.
Contexts in which this element can be used:
As a child of a colgroup element that doesn't have a span attribute.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
span — Number of columns spanned by the element
DOM interface:
Uses HTMLTableColElement, as defined for colgroup elements.
If a col element has a parent and that is a colgroup element that itself has a parent that is a table element, then the col element represents one or more columns in the column group represented by that colgroup.

The element may have a span content attribute specified, whose value must be a valid non-negative integer greater than zero and less than or equal to 1000.

The col element and its span attribute take part in the table model.

The span IDL attribute must reflect the content attribute of the same name. It is clamped to the range [1, 1000], and its default value is 1.

4.9.5 The tbody element
Categories:
None.
Contexts in which this element can be used:
As a child of a table element, after any caption, colgroup, and thead elements, but only if there are no tr elements that are children of the table element.
Content model:
Zero or more tr and script-supporting elements.
Tag omission in text/html:
A tbody element's start tag can be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can't be omitted if the element is empty.)
A tbody element's end tag can be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableSectionElement : HTMLElement {
  [SameObject] readonly attribute HTMLCollection rows;
  HTMLElement insertRow(optional long index = -1);
  [CEReactions] void deleteRow(long index);

  // also has obsolete members
};
The HTMLTableSectionElement interface is also used for thead and tfoot elements.

The tbody element represents a block of rows that consist of a body of data for the parent table element, if the tbody element has a parent and it is a table.

The tbody element takes part in the table model.

tbody . rows
Returns an HTMLCollection of the tr elements of the table section.

tr = tbody . insertRow( [ index ] )
Creates a tr element, inserts it into the table section at the position given by the argument, and returns the tr.

The position is relative to the rows in the table section. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the table section.

If the given position is less than −1 or greater than the number of rows, throws an "IndexSizeError" DOMException.

tbody . deleteRow(index)
Removes the tr element with the given position in the table section.

The position is relative to the rows in the table section. The index −1 is equivalent to deleting the last row of the table section.

If the given position is less than −1 or greater than the index of the last row, or if there are no rows, throws an "IndexSizeError" DOMException.

The rows attribute must return an HTMLCollection rooted at this element, whose filter matches only tr elements that are children of this element.

The insertRow(index) method must act as follows:

If index is less than −1 or greater than the number of elements in the rows collection, throw an "IndexSizeError" DOMException.

Let table row be the result of creating an element given this element's node document, tr, and the HTML namespace.

If index is −1 or equal to the number of items in the rows collection, then append table row to this element.

Otherwise, insert table row as a child of this element, immediately before the indexth tr element in the rows collection.

Return table row.

The deleteRow(index) method must, when invoked, act as follows:

If index is less than −1 or greater than or equal to the number of elements in the rows collection, then throw an "IndexSizeError" DOMException.

If index is −1, then remove the last element in the rows collection from this element, or do nothing if the rows collection is empty.

Otherwise, remove the indexth element in the rows collection from this element.

4.9.6 The thead element
Categories:
None.
Contexts in which this element can be used:
As a child of a table element, after any caption, and colgroup elements and before any tbody, tfoot, and tr elements, but only if there are no other thead elements that are children of the table element.
Content model:
Zero or more tr and script-supporting elements.
Tag omission in text/html:
A thead element's end tag can be omitted if the thead element is immediately followed by a tbody or tfoot element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLTableSectionElement, as defined for tbody elements.
The thead element represents the block of rows that consist of the column labels (headers) for the parent table element, if the thead element has a parent and it is a table.

The thead element takes part in the table model.

This example shows a thead element being used. Notice the use of both th and td elements in the thead element: the first row is the headers, and the second row is an explanation of how to fill in the table.

<table>
 <caption> School auction sign-up sheet </caption>
 <thead>
  <tr>
   <th><label for=e1>Name</label>
   <th><label for=e2>Product</label>
   <th><label for=e3>Picture</label>
   <th><label for=e4>Price</label>
  <tr>
   <td>Your name here
   <td>What are you selling?
   <td>Link to a picture
   <td>Your reserve price
 <tbody>
  <tr>
   <td>Ms Danus
   <td>Doughnuts
   <td><img src="https://example.com/mydoughnuts.png" title="Doughnuts from Ms Danus">
   <td>$45
  <tr>
   <td><input id=e1 type=text name=who required form=f>
   <td><input id=e2 type=text name=what required form=f>
   <td><input id=e3 type=url name=pic form=f>
   <td><input id=e4 type=number step=0.01 min=0 value=0 required form=f>
</table>
<form id=f action="/auction.cgi">
 <input type=button name=add value="Submit">
</form>
4.9.7 The tfoot element
Categories:
None.
Contexts in which this element can be used:
As a child of a table element, after any caption, colgroup, thead, tbody, and tr elements, but only if there are no other tfoot elements that are children of the table element.
Content model:
Zero or more tr and script-supporting elements.
Tag omission in text/html:
A tfoot element's end tag can be omitted if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
Uses HTMLTableSectionElement, as defined for tbody elements.
The tfoot element represents the block of rows that consist of the column summaries (footers) for the parent table element, if the tfoot element has a parent and it is a table.

The tfoot element takes part in the table model.

4.9.8 The tr element
Categories:
None.
Contexts in which this element can be used:
As a child of a thead element.
As a child of a tbody element.
As a child of a tfoot element.
As a child of a table element, after any caption, colgroup, and thead elements, but only if there are no tbody elements that are children of the table element.
Content model:
Zero or more td, th, and script-supporting elements.
Tag omission in text/html:
A tr element's end tag can be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableRowElement : HTMLElement {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  [SameObject] readonly attribute HTMLCollection cells;
  HTMLTableCellElement insertCell(optional long index = -1);
  [CEReactions] void deleteCell(long index);

  // also has obsolete members
};
The tr element represents a row of cells in a table.

The tr element takes part in the table model.

tr . rowIndex
Returns the position of the row in the table's rows list.

Returns −1 if the element isn't in a table.

tr . sectionRowIndex
Returns the position of the row in the table section's rows list.

Returns −1 if the element isn't in a table section.

tr . cells
Returns an HTMLCollection of the td and th elements of the row.

cell = tr . insertCell( [ index ] )
Creates a td element, inserts it into the table row at the position given by the argument, and returns the td.

The position is relative to the cells in the row. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the row.

If the given position is less than −1 or greater than the number of cells, throws an "IndexSizeError" DOMException.

tr . deleteCell(index)
Removes the td or th element with the given position in the row.

The position is relative to the cells in the row. The index −1 is equivalent to deleting the last cell of the row.

If the given position is less than −1 or greater than the index of the last cell, or if there are no cells, throws an "IndexSizeError" DOMException.

The rowIndex attribute must, if this element has a parent table element, or a parent tbody, thead, or tfoot element and a grandparent table element, return the index of this tr element in that table element's rows collection. If there is no such table element, then the attribute must return −1.

The sectionRowIndex attribute must, if this element has a parent table, tbody, thead, or tfoot element, return the index of the tr element in the parent element's rows collection (for tables, that's HTMLTableElement's rows collection; for table sections, that's HTMLTableSectionElement's rows collection). If there is no such parent element, then the attribute must return −1.

The cells attribute must return an HTMLCollection rooted at this tr element, whose filter matches only td and th elements that are children of the tr element.

The insertCell(index) method must act as follows:

If index is less than −1 or greater than the number of elements in the cells collection, then throw an "IndexSizeError" DOMException.

Let table cell be the result of creating an element given this tr element's node document, td, and the HTML namespace.

If index is equal to −1 or equal to the number of items in cells collection, then append table cell to this tr element.

Otherwise, insert table cell as a child of this tr element, immediately before the indexth td or th element in the cells collection.

Return table cell.

The deleteCell(index) method must act as follows:

If index is less than −1 or greater than or equal to the number of elements in the cells collection, then throw an "IndexSizeError" DOMException.

If index is −1, then remove the last element in the cells collection from its parent, or do nothing if the cells collection is empty.

Otherwise, remove the indexth element in the cells collection from its parent.

4.9.9 The td element
Categories:
Sectioning root.
Contexts in which this element can be used:
As a child of a tr element.
Content model:
Flow content.
Tag omission in text/html:
A td element's end tag can be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
Content attributes:
Global attributes
colspan — Number of columns that the cell is to span
rowspan — Number of rows that the cell is to span
headers — The header cells for this cell
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTableCellElement : HTMLElement {
  [CEReactions] attribute unsigned long colSpan;
  [CEReactions] attribute unsigned long rowSpan;
  [CEReactions] attribute DOMString headers;
  readonly attribute long cellIndex;

  [CEReactions] attribute DOMString scope; // only conforming for th elements
  [CEReactions] attribute DOMString abbr;  // only conforming for th elements

  // also has obsolete members
};
The HTMLTableCellElement interface is also used for th elements.

The td element represents a data cell in a table.

The td element and its colspan, rowspan, and headers attributes take part in the table model.

User agents, especially in non-visual environments or where displaying the table as a 2D grid is impractical, may give the user context for the cell when rendering the contents of a cell; for instance, giving its position in the table model, or listing the cell's header cells (as determined by the algorithm for assigning header cells). When a cell's header cells are being listed, user agents may use the value of abbr attributes on those header cells, if any, instead of the contents of the header cells themselves.

In this example, we see a snippet of a Web application consisting of a grid of editable cells (essentially a simple spreadsheet). One of the cells has been configured to show the sum of the cells above it. Three have been marked as headings, which use th elements instead of td elements. A script would attach event handlers to these elements to maintain the total.

<table>
 <tr>
  <th><input value="Name">
  <th><input value="Paid ($)">
 <tr>
  <td><input value="Jeff">
  <td><input value="14">
 <tr>
  <td><input value="Britta">
  <td><input value="9">
 <tr>
  <td><input value="Abed">
  <td><input value="25">
 <tr>
  <td><input value="Shirley">
  <td><input value="2">
 <tr>
  <td><input value="Annie">
  <td><input value="5">
 <tr>
  <td><input value="Troy">
  <td><input value="5">
 <tr>
  <td><input value="Pierce">
  <td><input value="1000">
 <tr>
  <th><input value="Total">
  <td><output value="1060">
</table>
4.9.10 The th element
Categories:
None.
Contexts in which this element can be used:
As a child of a tr element.
Content model:
Flow content, but with no header, footer, sectioning content, or heading content descendants.
Tag omission in text/html:
A th element's end tag can be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
Content attributes:
Global attributes
colspan — Number of columns that the cell is to span
rowspan — Number of rows that the cell is to span
headers — The header cells for this cell
scope — Specifies which cells the header cell applies to
abbr — Alternative label to use for the header cell when referencing the cell in other contexts
DOM interface:
Uses HTMLTableCellElement, as defined for td elements.
The th element represents a header cell in a table.

The th element may have a scope content attribute specified. The scope attribute is an enumerated attribute with five states, four of which have explicit keywords:

The row keyword, which maps to the row state
The row state means the header cell applies to some of the subsequent cells in the same row(s).
The col keyword, which maps to the column state
The column state means the header cell applies to some of the subsequent cells in the same column(s).
The rowgroup keyword, which maps to the row group state
The row group state means the header cell applies to all the remaining cells in the row group. A th element's scope attribute must not be in the row group state if the element is not anchored in a row group.
The colgroup keyword, which maps to the column group state
The column group state means the header cell applies to all the remaining cells in the column group. A th element's scope attribute must not be in the column group state if the element is not anchored in a column group.
The auto state
The auto state makes the header cell apply to a set of cells selected based on context.
The scope attribute's missing value default and invalid value default are the auto state.

The th element may have an abbr content attribute specified. Its value must be an alternative label for the header cell, to be used when referencing the cell in other contexts (e.g. when describing the header cells that apply to a data cell). It is typically an abbreviated form of the full header cell, but can also be an expansion, or merely a different phrasing.

The th element and its colspan, rowspan, headers, and scope attributes take part in the table model.

The following example shows how the scope attribute's rowgroup value affects which data cells a header cell applies to.

Here is a markup fragment showing a table:

<table>
 <thead>
  <tr> <th> ID <th> Measurement <th> Average <th> Maximum
 <tbody>
  <tr> <td> <th scope=rowgroup> Cats <td> <td>
  <tr> <td> 93 <th scope=row> Legs <td> 3.5 <td> 4
  <tr> <td> 10 <th scope=row> Tails <td> 1 <td> 1
 <tbody>
  <tr> <td> <th scope=rowgroup> English speakers <td> <td>
  <tr> <td> 32 <th scope=row> Legs <td> 2.67 <td> 4
  <tr> <td> 35 <th scope=row> Tails <td> 0.33 <td> 1
</table>
This would result in the following table:

ID	Measurement	Average	Maximum
Cats
93	Legs	3.5	4
10	Tails	1	1
English speakers
32	Legs	2.67	4
35	Tails	0.33	1
The headers in the first row all apply directly down to the rows in their column.

The headers with the explicit scope attributes apply to all the cells in their row group other than the cells in the first column.

The remaining headers apply just to the cells to the right of them.


4.9.11 Attributes common to td and th elements
The td and th elements may have a colspan content attribute specified, whose value must be a valid non-negative integer greater than zero and less than or equal to 1000.

The td and th elements may also have a rowspan content attribute specified, whose value must be a valid non-negative integer less than or equal to 65534. For this attribute, the value zero means that the cell is to span all the remaining rows in the row group.

These attributes give the number of columns and rows respectively that the cell is to span. These attributes must not be used to overlap cells, as described in the description of the table model.

The td and th element may have a headers content attribute specified. The headers attribute, if specified, must contain a string consisting of an unordered set of unique space-separated tokens that are case-sensitive, each of which must have the value of an ID of a th element taking part in the same table as the td or th element (as defined by the table model).

A th element with ID id is said to be directly targeted by all td and th elements in the same table that have headers attributes whose values include as one of their tokens the ID id. A th element A is said to be targeted by a th or td element B if either A is directly targeted by B or if there exists an element C that is itself targeted by the element B and A is directly targeted by C.

A th element must not be targeted by itself.

The colspan, rowspan, and headers attributes take part in the table model.

cell . cellIndex
Returns the position of the cell in the row's cells list. This does not necessarily correspond to the x-position of the cell in the table, since earlier cells might cover multiple rows or columns.

Returns −1 if the element isn't in a row.

The colSpan IDL attribute must reflect the colspan content attribute. It is clamped to the range [1, 1000], and its default value is 1.

The rowSpan IDL attribute must reflect the rowspan content attribute. It is clamped to the range [0, 65534], and its default value is 1.

The headers IDL attribute must reflect the content attribute of the same name.

The cellIndex IDL attribute must, if the element has a parent tr element, return the index of the cell's element in the parent element's cells collection. If there is no such parent element, then the attribute must return −1.

The scope IDL attribute must reflect the content attribute of the same name, limited to only known values.

The abbr IDL attribute must reflect the content attribute of the same name.

4.9.12 Processing model
The various table elements and their content attributes together define the table model.

A table consists of cells aligned on a two-dimensional grid of slots with coordinates (x, y). The grid is finite, and is either empty or has one or more slots. If the grid has one or more slots, then the x coordinates are always in the range 0 ≤ x < xwidth, and the y coordinates are always in the range 0 ≤ y < yheight. If one or both of xwidth and yheight are zero, then the table is empty (has no slots). Tables correspond to table elements.

A cell is a set of slots anchored at a slot (cellx, celly), and with a particular width and height such that the cell covers all the slots with coordinates (x, y) where cellx ≤ x < cellx+width and celly ≤ y < celly+height. Cells can either be data cells or header cells. Data cells correspond to td elements, and header cells correspond to th elements. Cells of both types can have zero or more associated header cells.

It is possible, in certain error cases, for two cells to occupy the same slot.

A row is a complete set of slots from x=0 to x=xwidth-1, for a particular value of y. Rows usually correspond to tr elements, though a row group can have some implied rows at the end in some cases involving cells spanning multiple rows.

A column is a complete set of slots from y=0 to y=yheight-1, for a particular value of x. Columns can correspond to col elements. In the absence of col elements, columns are implied.

A row group is a set of rows anchored at a slot (0, groupy) with a particular height such that the row group covers all the slots with coordinates (x, y) where 0 ≤ x < xwidth and groupy ≤ y < groupy+height. Row groups correspond to tbody, thead, and tfoot elements. Not every row is necessarily in a row group.

A column group is a set of columns anchored at a slot (groupx, 0) with a particular width such that the column group covers all the slots with coordinates (x, y) where groupx ≤ x < groupx+width and 0 ≤ y < yheight. Column groups correspond to colgroup elements. Not every column is necessarily in a column group.

Row groups cannot overlap each other. Similarly, column groups cannot overlap each other.

A cell cannot cover slots that are from two or more row groups. It is, however, possible for a cell to be in multiple column groups. All the slots that form part of one cell are part of zero or one row groups and zero or more column groups.

In addition to cells, columns, rows, row groups, and column groups, tables can have a caption element associated with them. This gives the table a heading, or legend.

A table model error is an error with the data represented by table elements and their descendants. Documents must not have table model errors.

4.9.12.1 Forming a table
To determine which elements correspond to which slots in a table associated with a table element, to determine the dimensions of the table (xwidth and yheight), and to determine if there are any table model errors, user agents must use the following algorithm:

Let xwidth be zero.

Let yheight be zero.

Let pending tfoot elements be a list of tfoot elements, initially empty.

Let the table be the table represented by the table element. The xwidth and yheight variables give the table's dimensions. The table is initially empty.

If the table element has no children elements, then return the table (which will be empty).

Associate the first caption element child of the table element with the table. If there are no such children, then it has no associated caption element.

Let the current element be the first element child of the table element.

If a step in this algorithm ever requires the current element to be advanced to the next child of the table when there is no such next child, then the user agent must jump to the step labeled end, near the end of this algorithm.

While the current element is not one of the following elements, advance the current element to the next child of the table:

colgroup
thead
tbody
tfoot
tr
If the current element is a colgroup, follow these substeps:

Column groups: Process the current element according to the appropriate case below:

If the current element has any col element children
Follow these steps:

Let xstart have the value of xwidth.

Let the current column be the first col element child of the colgroup element.

Columns: If the current column col element has a span attribute, then parse its value using the rules for parsing non-negative integers.

If the result of parsing the value is not an error or zero, then let span be that value.

Otherwise, if the col element has no span attribute, or if trying to parse the attribute's value resulted in an error or zero, then let span be 1.

If span is greater than 1000, let it be 1000 instead.

Increase xwidth by span.

Let the last span columns in the table correspond to the current column col element.

If current column is not the last col element child of the colgroup element, then let the current column be the next col element child of the colgroup element, and return to the step labeled columns.

Let all the last columns in the table from x=xstart to x=xwidth-1 form a new column group, anchored at the slot (xstart, 0), with width xwidth-xstart, corresponding to the colgroup element.

If the current element has no col element children
If the colgroup element has a span attribute, then parse its value using the rules for parsing non-negative integers.

If the result of parsing the value is not an error or zero, then let span be that value.

Otherwise, if the colgroup element has no span attribute, or if trying to parse the attribute's value resulted in an error or zero, then let span be 1.

If span is greater than 1000, let it be 1000 instead.

Increase xwidth by span.

Let the last span columns in the table form a new column group, anchored at the slot (xwidth-span, 0), with width span, corresponding to the colgroup element.

Advance the current element to the next child of the table.

While the current element is not one of the following elements, advance the current element to the next child of the table:

colgroup
thead
tbody
tfoot
tr
If the current element is a colgroup element, jump to the step labeled column groups above.

Let ycurrent be zero.

Let the list of downward-growing cells be an empty list.

Rows: While the current element is not one of the following elements, advance the current element to the next child of the table:

thead
tbody
tfoot
tr
If the current element is a tr, then run the algorithm for processing rows, advance the current element to the next child of the table, and return to the step labeled rows.

Run the algorithm for ending a row group.

If the current element is a tfoot, then add that element to the list of pending tfoot elements, advance the current element to the next child of the table, and return to the step labeled rows.

The current element is either a thead or a tbody.

Run the algorithm for processing row groups.

Advance the current element to the next child of the table.

Return to the step labeled rows.

End: For each tfoot element in the list of pending tfoot elements, in tree order, run the algorithm for processing row groups.

If there exists a row or column in the table containing only slots that do not have a cell anchored to them, then this is a table model error.

Return the table.

The algorithm for processing row groups, which is invoked by the set of steps above for processing thead, tbody, and tfoot elements, is:

Let ystart have the value of yheight.

For each tr element that is a child of the element being processed, in tree order, run the algorithm for processing rows.

If yheight > ystart, then let all the last rows in the table from y=ystart to y=yheight-1 form a new row group, anchored at the slot with coordinate (0, ystart), with height yheight-ystart, corresponding to the element being processed.

Run the algorithm for ending a row group.

The algorithm for ending a row group, which is invoked by the set of steps above when starting and ending a block of rows, is:

While ycurrent is less than yheight, follow these steps:

Run the algorithm for growing downward-growing cells.

Increase ycurrent by 1.

Empty the list of downward-growing cells.

The algorithm for processing rows, which is invoked by the set of steps above for processing tr elements, is:

If yheight is equal to ycurrent, then increase yheight by 1. (ycurrent is never greater than yheight.)

Let xcurrent be 0.

Run the algorithm for growing downward-growing cells.

If the tr element being processed has no td or th element children, then increase ycurrent by 1, abort this set of steps, and return to the algorithm above.

Let current cell be the first td or th element child in the tr element being processed.

Cells: While xcurrent is less than xwidth and the slot with coordinate (xcurrent, ycurrent) already has a cell assigned to it, increase xcurrent by 1.

If xcurrent is equal to xwidth, increase xwidth by 1. (xcurrent is never greater than xwidth.)

If the current cell has a colspan attribute, then parse that attribute's value, and let colspan be the result.

If parsing that value failed, or returned zero, or if the attribute is absent, then let colspan be 1, instead.

If colspan is greater than 1000, let it be 1000 instead.

If the current cell has a rowspan attribute, then parse that attribute's value, and let rowspan be the result.

If parsing that value failed or if the attribute is absent, then let rowspan be 1, instead.

If rowspan is greater than 65534, let it be 65534 instead.

If rowspan is zero and the table element's node document is not set to quirks mode, then let cell grows downward be true, and set rowspan to 1. Otherwise, let cell grows downward be false.

If xwidth < xcurrent+colspan, then let xwidth be xcurrent+colspan.

If yheight < ycurrent+rowspan, then let yheight be ycurrent+rowspan.

Let the slots with coordinates (x, y) such that xcurrent ≤ x < xcurrent+colspan and ycurrent ≤ y < ycurrent+rowspan be covered by a new cell c, anchored at (xcurrent, ycurrent), which has width colspan and height rowspan, corresponding to the current cell element.

If the current cell element is a th element, let this new cell c be a header cell; otherwise, let it be a data cell.

To establish which header cells apply to the current cell element, use the algorithm for assigning header cells described in the next section.

If any of the slots involved already had a cell covering them, then this is a table model error. Those slots now have two cells overlapping.

If cell grows downward is true, then add the tuple {c, xcurrent, colspan} to the list of downward-growing cells.

Increase xcurrent by colspan.

If current cell is the last td or th element child in the tr element being processed, then increase ycurrent by 1, abort this set of steps, and return to the algorithm above.

Let current cell be the next td or th element child in the tr element being processed.

Return to the step labeled cells.

When the algorithms above require the user agent to run the algorithm for growing downward-growing cells, the user agent must, for each {cell, cellx, width} tuple in the list of downward-growing cells, if any, extend the cell cell so that it also covers the slots with coordinates (x, ycurrent), where cellx ≤ x < cellx+width.

4.9.12.2 Forming relationships between data cells and header cells
Each cell can be assigned zero or more header cells. The algorithm for assigning header cells to a cell principal cell is as follows.

Let header list be an empty list of cells.

Let (principalx, principaly) be the coordinate of the slot to which the principal cell is anchored.

If the principal cell has a headers attribute specified
Take the value of the principal cell's headers attribute and split it on ASCII whitespace, letting id list be the list of tokens obtained.

For each token in the id list, if the first element in the Document with an ID equal to the token is a cell in the same table, and that cell is not the principal cell, then add that cell to header list.

If principal cell does not have a headers attribute specified
Let principalwidth be the width of the principal cell.

Let principalheight be the height of the principal cell.

For each value of y from principaly to principaly+principalheight-1, run the internal algorithm for scanning and assigning header cells, with the principal cell, the header list, the initial coordinate (principalx,y), and the increments Δx=−1 and Δy=0.

For each value of x from principalx to principalx+principalwidth-1, run the internal algorithm for scanning and assigning header cells, with the principal cell, the header list, the initial coordinate (x,principaly), and the increments Δx=0 and Δy=−1.

If the principal cell is anchored in a row group, then add all header cells that are row group headers and are anchored in the same row group with an x-coordinate less than or equal to principalx+principalwidth-1 and a y-coordinate less than or equal to principaly+principalheight-1 to header list.

If the principal cell is anchored in a column group, then add all header cells that are column group headers and are anchored in the same column group with an x-coordinate less than or equal to principalx+principalwidth-1 and a y-coordinate less than or equal to principaly+principalheight-1 to header list.

Remove all the empty cells from the header list.

Remove any duplicates from the header list.

Remove principal cell from the header list if it is there.

Assign the headers in the header list to the principal cell.

The internal algorithm for scanning and assigning header cells, given a principal cell, a header list, an initial coordinate (initialx, initialy), and Δx and Δy increments, is as follows:

Let x equal initialx.

Let y equal initialy.

Let opaque headers be an empty list of cells.

If principal cell is a header cell
Let in header block be true, and let headers from current header block be a list of cells containing just the principal cell.

Otherwise
Let in header block be false and let headers from current header block be an empty list of cells.

Loop: Increment x by Δx; increment y by Δy.

For each invocation of this algorithm, one of Δx and Δy will be −1, and the other will be 0.

If either x or y are less than 0, then abort this internal algorithm.

If there is no cell covering slot (x, y), or if there is more than one cell covering slot (x, y), return to the substep labeled loop.

Let current cell be the cell covering slot (x, y).

If current cell is a header cell
Set in header block to true.

Add current cell to headers from current header block.

Let blocked be false.

If Δx is 0
If there are any cells in the opaque headers list anchored with the same x-coordinate as the current cell, and with the same width as current cell, then let blocked be true.

If the current cell is not a column header, then let blocked be true.

If Δy is 0
If there are any cells in the opaque headers list anchored with the same y-coordinate as the current cell, and with the same height as current cell, then let blocked be true.

If the current cell is not a row header, then let blocked be true.

If blocked is false, then add the current cell to the headers list.

If current cell is a data cell and in header block is true
Set in header block to false. Add all the cells in headers from current header block to the opaque headers list, and empty the headers from current header block list.

Return to the step labeled loop.

A header cell anchored at the slot with coordinate (x, y) with width width and height height is said to be a column header if any of the following conditions are true:

The cell's scope attribute is in the column state, or
The cell's scope attribute is in the auto state, and there are no data cells in any of the cells covering slots with y-coordinates y .. y+height-1.
A header cell anchored at the slot with coordinate (x, y) with width width and height height is said to be a row header if any of the following conditions are true:

The cell's scope attribute is in the row state, or
The cell's scope attribute is in the auto state, the cell is not a column header, and there are no data cells in any of the cells covering slots with x-coordinates x .. x+width-1.
A header cell is said to be a column group header if its scope attribute is in the column group state.

A header cell is said to be a row group header if its scope attribute is in the row group state.

A cell is said to be an empty cell if it contains no elements and its text content, if any, consists only of White_Space characters.

4.9.13 Examples
This section is non-normative.

The following shows how might one mark up the bottom part of table 45 of the Smithsonian physical tables, Volume 71:

<table>
 <caption>Specification values: <b>Steel</b>, <b>Castings</b>,
 Ann. A.S.T.M. A27-16, Class B;* P max. 0.06; S max. 0.05.</caption>
 <thead>
  <tr>
   <th rowspan=2>Grade.</th>
   <th rowspan=2>Yield Point.</th>
   <th colspan=2>Ultimate tensile strength</th>
   <th rowspan=2>Per cent elong. 50.8mm or 2 in.</th>
   <th rowspan=2>Per cent reduct. area.</th>
  </tr>
  <tr>
   <th>kg/mm<sup>2</sup></th>
   <th>lb/in<sup>2</sup></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Hard</td>
   <td>0.45 ultimate</td>
   <td>56.2</td>
   <td>80,000</td>
   <td>15</td>
   <td>20</td>
  </tr>
  <tr>
   <td>Medium</td>
   <td>0.45 ultimate</td>
   <td>49.2</td>
   <td>70,000</td>
   <td>18</td>
   <td>25</td>
  </tr>
  <tr>
   <td>Soft</td>
   <td>0.45 ultimate</td>
   <td>42.2</td>
   <td>60,000</td>
   <td>22</td>
   <td>30</td>
  </tr>
 </tbody>
</table>
This table could look like this:

Specification values: Steel, Castings, Ann. A.S.T.M. A27-16, Class B;* P max. 0.06; S max. 0.05.
Grade.	Yield Point.	Ultimate tensile strength	Per cent elong. 50.8 mm or 2 in.	Per cent reduct. area.
kg/mm2	lb/in2
Hard	0.45 ultimate	56.2	80,000	15	20
Medium	0.45 ultimate	49.2	70,000	18	25
Soft	0.45 ultimate	42.2	60,000	22	30
The following shows how one might mark up the gross margin table on page 46 of Apple, Inc's 10-K filing for fiscal year 2008:

<table>
 <thead>
  <tr>
   <th>
   <th>2008
   <th>2007
   <th>2006
 <tbody>
  <tr>
   <th>Net sales
   <td>$ 32,479
   <td>$ 24,006
   <td>$ 19,315
  <tr>
   <th>Cost of sales
   <td>  21,334
   <td>  15,852
   <td>  13,717
 <tbody>
  <tr>
   <th>Gross margin
   <td>$ 11,145
   <td>$  8,154
   <td>$  5,598
 <tfoot>
  <tr>
   <th>Gross margin percentage
   <td>34.3%
   <td>34.0%
   <td>29.0%
</table>
This table could look like this:

2008	2007	2006
Net sales	$ 32,479	$ 24,006	$ 19,315
Cost of sales	21,334	15,852	13,717
Gross margin	$ 11,145	$ 8,154	$ 5,598
Gross margin percentage	34.3%	34.0%	29.0%
The following shows how one might mark up the operating expenses table from lower on the same page of that document:

<table>
 <colgroup> <col>
 <colgroup> <col> <col> <col>
 <thead>
  <tr> <th> <th>2008 <th>2007 <th>2006
 <tbody>
  <tr> <th scope=rowgroup> Research and development
       <td> $ 1,109 <td> $ 782 <td> $ 712
  <tr> <th scope=row> Percentage of net sales
       <td> 3.4% <td> 3.3% <td> 3.7%
 <tbody>
  <tr> <th scope=rowgroup> Selling, general, and administrative
       <td> $ 3,761 <td> $ 2,963 <td> $ 2,433
  <tr> <th scope=row> Percentage of net sales
       <td> 11.6% <td> 12.3% <td> 12.6%
</table>
This table could look like this:

2008	2007	2006
Research and development	$ 1,109	$ 782	$ 712
Percentage of net sales	3.4%	3.3%	3.7%
Selling, general, and administrative	$ 3,761	$ 2,963	$ 2,433
Percentage of net sales	11.6%	12.3%	12.6%
4.10 Forms

Spec bugs: 12271

Support: forms
Chrome for Android (limited)	64+
Chrome	61+
iOS Safari (limited)	4.0+
UC Browser for Android	11.8+
Firefox (limited)	4+
Samsung Internet (limited)	4+
IE (limited)	10+
Opera Mini	None
Safari (limited)	4+
Edge	16+
Android Browser (limited)	4.4+
Opera (limited)	15+

Source: caniuse.com

4.10.1 Introduction
This section is non-normative.

A form is a component of a Web page that has form controls, such as text, buttons, checkboxes, range, or color picker controls. A user can interact with such a form, providing data that can then be sent to the server for further processing (e.g. returning the results of a search or calculation). No client-side scripting is needed in many cases, though an API is available so that scripts can augment the user experience or use forms for purposes other than submitting data to a server.

Writing a form consists of several steps, which can be performed in any order: writing the user interface, implementing the server-side processing, and configuring the user interface to communicate with the server.

4.10.1.1 Writing a form's user interface
This section is non-normative.

For the purposes of this brief introduction, we will create a pizza ordering form.

Any form starts with a form element, inside which are placed the controls. Most controls are represented by the input element, which by default provides a text control. To label a control, the label element is used; the label text and the control itself go inside the label element. Each part of a form is considered a paragraph, and is typically separated from other parts using p elements. Putting this together, here is how one might ask for the customer's name:

<form>
 <p><label>Customer name: <input></label></p>
</form>
To let the user select the size of the pizza, we can use a set of radio buttons. Radio buttons also use the input element, this time with a type attribute with the value radio. To make the radio buttons work as a group, they are given a common name using the name attribute. To group a batch of controls together, such as, in this case, the radio buttons, one can use the fieldset element. The title of such a group of controls is given by the first element in the fieldset, which has to be a legend element.

<form>
 <p><label>Customer name: <input></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
</form>
Changes from the previous step are highlighted.

To pick toppings, we can use checkboxes. These use the input element with a type attribute with the value checkbox:

<form>
 <p><label>Customer name: <input></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>
</form>
The pizzeria for which this form is being written is always making mistakes, so it needs a way to contact the customer. For this purpose, we can use form controls specifically for telephone numbers (input elements with their type attribute set to tel) and e-mail addresses (input elements with their type attribute set to email):

<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>
</form>
We can use an input element with its type attribute set to time to ask for a delivery time. Many of these form controls have attributes to control exactly what values can be specified; in this case, three attributes of particular interest are min, max, and step. These set the minimum time, the maximum time, and the interval between allowed values (in seconds). This pizzeria only delivers between 11am and 9pm, and doesn't promise anything better than 15 minute increments, which we can mark up as follows:

<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900"></label></p>
</form>
The textarea element can be used to provide a multiline text control. In this instance, we are going to use it to provide a space for the customer to give delivery instructions:

<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900"></label></p>
 <p><label>Delivery instructions: <textarea></textarea></label></p>
</form>
Finally, to make the form submittable we use the button element:

<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900"></label></p>
 <p><label>Delivery instructions: <textarea></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
4.10.1.2 Implementing the server-side processing for a form
This section is non-normative.

The exact details for writing a server-side processor are out of scope for this specification. For the purposes of this introduction, we will assume that the script at https://pizza.example.com/order.cgi is configured to accept submissions using the application/x-www-form-urlencoded format, expecting the following parameters sent in an HTTP POST body:

custname
Customer's name
custtel
Customer's telephone number
custemail
Customer's e-mail address
size
The pizza size, either small, medium, or large
topping
A topping, specified once for each selected topping, with the allowed values being bacon, cheese, onion, and mushroom
delivery
The requested delivery time
comments
The delivery instructions
4.10.1.3 Configuring a form to communicate with a server
This section is non-normative.

Form submissions are exposed to servers in a variety of ways, most commonly as HTTP GET or POST requests. To specify the exact method used, the method attribute is specified on the form element. This doesn't specify how the form data is encoded, though; to specify that, you use the enctype attribute. You also have to specify the URL of the service that will handle the submitted data, using the action attribute.

For each form control you want submitted, you then have to give a name that will be used to refer to the data in the submission. We already specified the name for the group of radio buttons; the same attribute (name) also specifies the submission name. Radio buttons can be distinguished from each other in the submission by giving them different values, using the value attribute.

Multiple controls can have the same name; for example, here we give all the checkboxes the same name, and the server distinguishes which checkbox was checked by seeing which values are submitted with that name — like the radio buttons, they are also given unique values with the value attribute.

Given the settings in the previous section, this all becomes:

<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname"></label></p>
 <p><label>Telephone: <input type=tel name="custtel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail"></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size value="small"> Small </label></p>
  <p><label> <input type=radio name=size value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery"></label></p>
 <p><label>Delivery instructions: <textarea name="comments"></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
There is no particular significance to the way some of the attributes have their values quoted and others don't. The HTML syntax allows a variety of equally valid ways to specify attributes, as discussed in the syntax section.

For example, if the customer entered "Denise Lawrence" as their name, "555-321-8642" as their telephone number, did not specify an e-mail address, asked for a medium-sized pizza, selected the Extra Cheese and Mushroom toppings, entered a delivery time of 7pm, and left the delivery instructions text control blank, the user agent would submit the following to the online Web service:

custname=Denise+Lawrence&custtel=555-321-8642&custemail=&size=medium&topping=cheese&topping=mushroom&delivery=19%3A00&comments=
4.10.1.4 Client-side form validation

Support: form-validation
Chrome for Android	64+
Chrome	10+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini (limited)	all+
Safari	10.1+
Edge	12+
Android Browser	4.4.3+
Opera	10.0+

Source: caniuse.com

This section is non-normative.

Forms can be annotated in such a way that the user agent will check the user's input before the form is submitted. The server still has to verify the input is valid (since hostile users can easily bypass the form validation), but it allows the user to avoid the wait incurred by having the server be the sole checker of the user's input.

The simplest annotation is the required attribute, which can be specified on input elements to indicate that the form is not to be submitted until a value is given. By adding this attribute to the customer name, pizza size, and delivery time fields, we allow the user agent to notify the user when the user submits the form without filling in those fields:

<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname" required></label></p>
 <p><label>Telephone: <input type=tel name="custtel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail"></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size required value="small"> Small </label></p>
  <p><label> <input type=radio name=size required value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size required value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery" required></label></p>
 <p><label>Delivery instructions: <textarea name="comments"></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
It is also possible to limit the length of the input, using the maxlength attribute. By adding this to the textarea element, we can limit users to 1000 characters, preventing them from writing huge essays to the busy delivery drivers instead of staying focused and to the point:

<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname" required></label></p>
 <p><label>Telephone: <input type=tel name="custtel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail"></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size required value="small"> Small </label></p>
  <p><label> <input type=radio name=size required value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size required value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery" required></label></p>
 <p><label>Delivery instructions: <textarea name="comments" maxlength=1000></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
When a form is submitted, invalid events are fired at each form control that is invalid, and then at the form element itself. This can be useful for displaying a summary of the problems with the form, since typically the browser itself will only report one problem at a time.

4.10.1.5 Enabling client-side automatic filling of form controls
This section is non-normative.

Some browsers attempt to aid the user by automatically filling form controls rather than having the user reenter their information each time. For example, a field asking for the user's telephone number can be automatically filled with the user's phone number.

To help the user agent with this, the autocomplete attribute can be used to describe the field's purpose. In the case of this form, we have three fields that can be usefully annotated in this way: the information about who the pizza is to be delivered to. Adding this information looks like this:

<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname" required autocomplete="shipping name"></label></p>
 <p><label>Telephone: <input type=tel name="custtel" autocomplete="shipping tel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail" autocomplete="shipping email"></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size required value="small"> Small </label></p>
  <p><label> <input type=radio name=size required value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size required value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery" required></label></p>
 <p><label>Delivery instructions: <textarea name="comments" maxlength=1000></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
4.10.1.6 Improving the user experience on mobile devices
This section is non-normative.

Some devices, in particular those with virtual keyboards can provide the user with multiple input modalities. For example, when typing in a credit card number the user may wish to only see keys for digits 0-9, while when typing in their name they may wish to see a form field that by default capitalizes each word.

Using the inputmode attribute we can select appropriate input modalities:

<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname" required autocomplete="shipping name"></label></p>
 <p><label>Telephone: <input type=tel name="custtel" autocomplete="shipping tel"></label></p>
 <p><label>Buzzer code: <input name="custbuzz" inputmode="number"></label></p>
 <p><label>E-mail address: <input type=email name="custemail" autocomplete="shipping email"></label></p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size required value="small"> Small </label></p>
  <p><label> <input type=radio name=size required value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size required value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery" required></label></p>
 <p><label>Delivery instructions: <textarea name="comments" maxlength=1000></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
4.10.1.7 The difference between the field type, the autofill field name, and the input modality
This section is non-normative.

The type, autocomplete, and inputmode attributes can seem confusingly similar. For instance, in all three cases, the string "email" is a valid value. This section attempts to illustrate the difference between the three attributes and provides advice suggesting how to use them.

The type attribute on input elements decides what kind of control the user agent will use to expose the field. Choosing between different values of this attribute is the same choice as choosing whether to use an input element, a textarea element, a select element, etc.

The autocomplete attribute, in contrast, describes what the value that the user will enter actually represents. Choosing between different values of this attribute is the same choice as choosing what the label for the element will be.

First, consider telephone numbers. If a page is asking for a telephone number from the user, the right form control to use is <input type=tel>. However, which autocomplete value to use depends on which phone number the page is asking for, whether they expect a telephone number in the international format or just the local format, and so forth.

For example, a page that forms part of a checkout process on an e-commerce site for a customer buying a gift to be shipped to a friend might need both the buyer's telephone number (in case of payment issues) and the friend's telephone number (in case of delivery issues). If the site expects international phone numbers (with the country code prefix), this could thus look like this:

<p><label>Your phone number: <input type=tel name=custtel autocomplete="billing tel"></label>
<p><label>Recipient's phone number: <input type=tel name=shiptel autocomplete="shipping tel"></label>
<p>Please enter complete phone numbers including the country code prefix, as in "+1 555 123 4567".
But if the site only supports British customers and recipients, it might instead look like this (notice the use of tel-national rather than tel):

<p><label>Your phone number: <input type=tel name=custtel autocomplete="billing tel-national"></label>
<p><label>Recipient's phone number: <input type=tel name=shiptel autocomplete="shipping tel-national"></label>
<p>Please enter complete UK phone numbers, as in "(01632) 960 123".
Now, consider a person's preferred languages. The right autocomplete value is language. However, there could be a number of different form controls used for the purpose: a text control (<input type=text>), a drop-down list (<select>), radio buttons (<input type=radio>), etc. It only depends on what kind of interface is desired.

Finally, consider names. If a page just wants one name from the user, then the relevant control is <input type=text>. If the page is asking for the user's full name, then the relevant autocomplete value is name.

<p><label>Japanese name: <input name="j" type="text" autocomplete="section-jp name"></label>
<label>Romanized name: <input name="e" type="text" autocomplete="section-en name"></label>
In this example, the "section-*" keywords in the autocomplete attributes' values tell the user agent that the two fields expect different names. Without them, the user agent could automatically fill the second field with the value given in the first field when the user gave a value to the first field.

The "-jp" and "-en" parts of the keywords are opaque to the user agent; the user agent cannot guess, from those, that the two names are expected to be in Japanese and English respectively.

Separate from the choices regarding type and autocomplete, the inputmode attribute decides what kind of input modality (e.g., virtual keyboard) to use, when the control is a text control.

Consider credit card numbers. The appropriate input type is not <input type=number>, as explained below; it is instead <input type=text>. To encourage the user agent to use a numeric input modality anyway (e.g., a virtual keyboard displaying only digits), the page would use

<p><label>Credit card number:
                <input name="cc" type="text" inputmode="numeric" pattern="[0-9]{8,19}" autocomplete="cc-number">
</label></p>
4.10.1.8 Date, time, and number formats
This section is non-normative.

In this pizza delivery example, the times are specified in the format "HH:MM": two digits for the hour, in 24-hour format, and two digits for the time. (Seconds could also be specified, though they are not necessary in this example.)

In some locales, however, times are often expressed differently when presented to users. For example, in the United States, it is still common to use the 12-hour clock with an am/pm indicator, as in "2pm". In France, it is common to separate the hours from the minutes using an "h" character, as in "14h00".

Similar issues exist with dates, with the added complication that even the order of the components is not always consistent — for example, in Cyprus the first of February 2003 would typically be written "1/2/03", while that same date in Japan would typically be written as "2003年02月01日" — and even with numbers, where locales differ, for example, in what punctuation is used as the decimal separator and the thousands separator.

It is therefore important to distinguish the time, date, and number formats used in HTML and in form submissions, which are always the formats defined in this specification (and based on the well-established ISO 8601 standard for computer-readable date and time formats), from the time, date, and number formats presented to the user by the browser and accepted as input from the user by the browser.

The format used "on the wire", i.e. in HTML markup and in form submissions, is intended to be computer-readable and consistent irrespective of the user's locale. Dates, for instance, are always written in the format "YYYY-MM-DD", as in "2003-02-01". Users are not expected to ever see this format.

The time, date, or number given by the page in the wire format is then translated to the user's preferred presentation (based on user preferences or on the locale of the page itself), before being displayed to the user. Similarly, after the user inputs a time, date, or number using their preferred format, the user agent converts it back to the wire format before putting it in the DOM or submitting it.

This allows scripts in pages and on servers to process times, dates, and numbers in a consistent manner without needing to support dozens of different formats, while still supporting the users' needs.

See also the implementation notes regarding localization of form controls.

4.10.2 Categories
Mostly for historical reasons, elements in this section fall into several overlapping (but subtly different) categories in addition to the usual ones like flow content, phrasing content, and interactive content.

A number of the elements are form-associated elements, which means they can have a form owner.

buttonfieldsetinputobjectoutputselecttextareaimg
The form-associated elements fall into several subcategories:

Listed elements
Denotes elements that are listed in the form.elements and fieldset.elements APIs. These elements also have a form content attribute, and a matching form IDL attribute, that allow authors to specify an explicit form owner.

buttonfieldsetinputobjectoutputselecttextarea
Submittable elements
Denotes elements that can be used for constructing the form data set when a form element is submitted.

buttoninputobjectselecttextarea
Some submittable elements can be, depending on their attributes, buttons. The prose below defines when an element is a button. Some buttons are specifically submit buttons.

Resettable elements
Denotes elements that can be affected when a form element is reset.

inputoutputselecttextarea
Autocapitalize-inheriting elements
Denotes elements that inherit the autocapitalize attribute from their form owner.

buttonfieldsetinputoutputselecttextarea
Some elements, not all of them form-associated, are categorized as labelable elements. These are elements that can be associated with a label element.

buttoninput (if the type attribute is not in the Hidden state)meteroutputprogressselecttextarea
4.10.3 The form element
Categories:
Flow content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content, but with no form element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
accept-charset — Character encodings to use for form submission
action — URL to use for form submission
autocomplete — Default setting for autofill feature for controls in the form
enctype — Form data set encoding type to use for form submission
method — HTTP method to use for form submission
name — Name of form to use in the document.forms API
novalidate — Bypass form control validation for form submission
target — Browsing context for form submission
DOM interface:
[Exposed=Window,
 OverrideBuiltins,
 LegacyUnenumerableNamedProperties,
 HTMLConstructor]
interface HTMLFormElement : HTMLElement {
  [CEReactions] attribute DOMString acceptCharset;
  [CEReactions] attribute USVString action;
  [CEReactions] attribute DOMString autocomplete;
  [CEReactions] attribute DOMString enctype;
  [CEReactions] attribute DOMString encoding;
  [CEReactions] attribute DOMString method;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute boolean noValidate;
  [CEReactions] attribute DOMString target;

  [SameObject] readonly attribute HTMLFormControlsCollection elements;
  readonly attribute unsigned long length;
  getter Element (unsigned long index);
  getter (RadioNodeList or Element) (DOMString name);

  void submit();
  [CEReactions] void reset();
  boolean checkValidity();
  boolean reportValidity();
};
The form element represents a collection of form-associated elements, some of which can represent editable values that can be submitted to a server for processing.

The accept-charset attribute gives the character encodings that are to be used for the submission. If specified, the value must be an ordered set of unique space-separated tokens that are ASCII case-insensitive, and each token must be an ASCII case-insensitive match for one of the labels of an ASCII-compatible encoding. [ENCODING]

The name attribute represents the form's name within the forms collection. The value must not be the empty string, and the value must be unique amongst the form elements in the forms collection that it is in, if any.

The autocomplete attribute is an enumerated attribute. The attribute has two states. The on keyword maps to the on state, and the off keyword maps to the off state. The attribute may also be omitted. The missing value default and the invalid value default are the on state. The off state indicates that by default, form controls in the form will have their autofill field name set to "off"; the on state indicates that by default, form controls in the form will have their autofill field name set to "on".

The action, enctype, method, novalidate, and target attributes are attributes for form submission.

form . elements
Returns an HTMLFormControlsCollection of the form controls in the form (excluding image buttons for historical reasons).

form . length
Returns the number of form controls in the form (excluding image buttons for historical reasons).

form[index]
Returns the indexth element in the form (excluding image buttons for historical reasons).

form[name]
Returns the form control (or, if there are several, a RadioNodeList of the form controls) in the form with the given ID or name (excluding image buttons for historical reasons); or, if there are none, returns the img element with the given ID.

Once an element has been referenced using a particular name, that name will continue being available as a way to reference that element in this method, even if the element's actual ID or name changes, for as long as the element remains in the tree.

If there are multiple matching items, then a RadioNodeList object containing all those elements is returned.

form . submit()
Submits the form.

form . reset()
Resets the form.

form . checkValidity()
Returns true if the form's controls are all valid; otherwise, returns false.

form . reportValidity()
Returns true if the form's controls are all valid; otherwise, returns false and informs the user.

The autocomplete IDL attribute must reflect the content attribute of the same name, limited to only known values.

The name IDL attribute must reflect the content attribute of the same name.

The acceptCharset IDL attribute must reflect the accept-charset content attribute.

The elements IDL attribute must return an HTMLFormControlsCollection rooted at the form element's root, whose filter matches listed elements whose form owner is the form element, with the exception of input elements whose type attribute is in the Image Button state, which must, for historical reasons, be excluded from this particular collection.

The length IDL attribute must return the number of nodes represented by the elements collection.

The supported property indices at any instant are the indices supported by the object returned by the elements attribute at that instant.

To determine the value of an indexed property for a form element, the user agent must return the value returned by the item method on the elements collection, when invoked with the given index as its argument.

Each form element has a mapping of names to elements called the past names map. It is used to persist names of controls even when they change names.

The supported property names consist of the names obtained from the following algorithm, in the order obtained from this algorithm:

Let sourced names be an initially empty ordered list of tuples consisting of a string, an element, a source, where the source is either id, name, or past, and, if the source is past, an age.

For each listed element candidate whose form owner is the form element, with the exception of any input elements whose type attribute is in the Image Button state:

If candidate has an id attribute, add an entry to sourced names with that id attribute's value as the string, candidate as the element, and id as the source.

If candidate has a name attribute, add an entry to sourced names with that name attribute's value as the string, candidate as the element, and name as the source.

For each img element candidate whose form owner is the form element:

If candidate has an id attribute, add an entry to sourced names with that id attribute's value as the string, candidate as the element, and id as the source.

If candidate has a name attribute, add an entry to sourced names with that name attribute's value as the string, candidate as the element, and name as the source.

For each entry past entry in the past names map add an entry to sourced names with the past entry's name as the string, past entry's element as the element, past as the source, and the length of time past entry has been in the past names map as the age.

Sort sourced names by tree order of the element entry of each tuple, sorting entries with the same element by putting entries whose source is id first, then entries whose source is name, and finally entries whose source is past, and sorting entries with the same element and source by their age, oldest first.

Remove any entries in sourced names that have the empty string as their name.

Remove any entries in sourced names that have the same name as an earlier entry in the map.

Return the list of names from sourced names, maintaining their relative order.

To determine the value of a named property name for a form element, the user agent must run the following steps:

Let candidates be a live RadioNodeList object containing all the listed elements, whose form owner is the form element, that have either an id attribute or a name attribute equal to name, with the exception of input elements whose type attribute is in the Image Button state, in tree order.

If candidates is empty, let candidates be a live RadioNodeList object containing all the img elements, whose form owner is the form element, that have either an id attribute or a name attribute equal to name, in tree order.

If candidates is empty, name is the name of one of the entries in the form element's past names map: return the object associated with name in that map.

If candidates contains more than one node, return candidates.

Otherwise, candidates contains exactly one node. Add a mapping from name to the node in candidates in the form element's past names map, replacing the previous entry with the same name, if any.

Return the node in candidates.

If an element listed in a form element's past names map changes form owner, then its entries must be removed from that map.

The submit() method, when invoked, must submit the form element from the form element itself, with the submitted from submit() method flag set.

The reset() method, when invoked, must run the following steps:

If the form element is marked as locked for reset, then return.

Mark the form element as locked for reset.

Reset the form element.

Unmark the form element as locked for reset.

If the checkValidity() method is invoked, the user agent must statically validate the constraints of the form element, and return true if the constraint validation return a positive result, and false if it returned a negative result.

If the reportValidity() method is invoked, the user agent must interactively validate the constraints of the form element, and return true if the constraint validation return a positive result, and false if it returned a negative result.

This example shows two search forms:

<form action="https://www.google.com/search" method="get">
 <label>Google: <input type="search" name="q"></label> <input type="submit" value="Search...">
</form>
<form action="https://www.bing.com/search" method="get">
 <label>Bing: <input type="search" name="q"></label> <input type="submit" value="Search...">
</form>
4.10.4 The label element
Categories:
Flow content.
Phrasing content.
Interactive content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content, but with no descendant labelable elements unless it is the element's labeled control, and no descendant label elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
for — Associate the label with form control
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLLabelElement : HTMLElement {
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute DOMString htmlFor;
  readonly attribute HTMLElement? control;
};
The label element represents a caption in a user interface. The caption can be associated with a specific form control, known as the label element's labeled control, either using the for attribute, or by putting the form control inside the label element itself.

Except where otherwise specified by the following rules, a label element has no labeled control.

The for attribute may be specified to indicate a form control with which the caption is to be associated. If the attribute is specified, the attribute's value must be the ID of a labelable element in the same tree as the label element. If the attribute is specified and there is an element in the tree whose ID is equal to the value of the for attribute, and the first such element in tree order is a labelable element, then that element is the label element's labeled control.

If the for attribute is not specified, but the label element has a labelable element descendant, then the first such descendant in tree order is the label element's labeled control.

The label element's exact default presentation and behavior, in particular what its activation behavior might be, if anything, should match the platform's label behavior. The activation behavior of a label element for events targeted at interactive content descendants of a label element, and any descendants of those interactive content descendants, must be to do nothing.

For example, on platforms where clicking a checkbox label checks the checkbox, clicking the label in the following snippet could trigger the user agent to fire a click event at the input element, as if the element itself had been triggered by the user:

<label><input type=checkbox name=lost> Lost</label>
On other platforms, the behavior might be just to focus the control, or do nothing.

The following example shows three form controls each with a label, two of which have small text showing the right format for users to use.

<p><label>Full name: <input name=fn> <small>Format: First Last</small></label></p>
<p><label>Age: <input name=age type=number min=0></label></p>
<p><label>Post code: <input name=pc> <small>Format: AB12 3CD</small></label></p>
label . control
Returns the form control that is associated with this element.

label . form
Returns the form owner of the form control that is associated with this element.

Returns null if there isn't one.

The htmlFor IDL attribute must reflect the for content attribute.

The control IDL attribute must return the label element's labeled control, if any, or null if there isn't one.

The form IDL attribute must run the following steps:

If the label element has no labeled control, then return null.

If the label element's labeled control is not a form-associated element, then return null.

Return the label element's labeled control's form owner (which can still be null).

The form IDL attribute on the label element is different from the form IDL attribute on listed form-associated elements, and the label element does not have a form content attribute.

control . labels
Returns a NodeList of all the label elements that the form control is associated with.

Labelable elements and all input elements have a live NodeList object associated with them that represents the list of label elements, in tree order, whose labeled control is the element in question. The labels IDL attribute of labelable elements and input elements, on getting, must return that NodeList object, and that same value must always be returned, unless this element is an input element whose type attribute is in the Hidden state, in which case it must instead return null.

This (non-conforming) example shows what happens to the NodeList and what labels returns when an input element has its type attribute changed.

<!doctype html>
<p><label><input></label></p>
<script>
 const input = document.querySelector('input');
 const labels = input.labels;
 console.assert(labels.length === 1);

 input.type = 'hidden';
 console.assert(labels.length === 0); // the input is no longer the label's labeled control
 console.assert(input.labels === null);

 input.type = 'checkbox';
 console.assert(labels.length === 1); // the input is once again the label's labeled control
 console.assert(input.labels === labels); // same value as returned originally
</script>
4.10.5 The input element
Categories:
Flow content.
Phrasing content.
If the type attribute is not in the Hidden state: Interactive content.
If the type attribute is not in the Hidden state: Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
If the type attribute is in the Hidden state: Listed, submittable, resettable, and autocapitalize-inheriting form-associated element.
If the type attribute is not in the Hidden state: Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Nothing.
Tag omission in text/html:
No end tag.
Content attributes:
Global attributes
accept — Hint for expected file type in file upload controls
alt — Replacement text for use when images are not available
autocomplete — Hint for form autofill feature
autofocus — Automatically focus the form control when the page is loaded
checked — Whether the control is checked
dirname — Name of form control to use for sending the element's directionality in form submission
disabled — Whether the form control is disabled
form — Associates the control with a form element
formaction — URL to use for form submission
formenctype — Form data set encoding type to use for form submission
formmethod — HTTP method to use for form submission
formnovalidate — Bypass form control validation for form submission
formtarget — Browsing context for form submission
height — Vertical dimension
list — List of autocomplete options
max — Maximum value
maxlength — Maximum length of value
min — Minimum value
minlength — Minimum length of value
multiple — Whether to allow multiple values
name — Name of form control to use for form submission and in the form.elements API
pattern — Pattern to be matched by the form control's value
placeholder — User-visible label to be placed within the form control
readonly — Whether to allow the value to be edited by the user
required — Whether the control is required for form submission
size — Size of the control
src — Address of the resource
step — Granularity to be matched by the form control's value
type — Type of form control
value — Value of the form control
width — Horizontal dimension
Also, the title attribute has special semantics on this element: Description of pattern (when used with pattern attribute).
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLInputElement : HTMLElement {
  [CEReactions] attribute DOMString accept;
  [CEReactions] attribute DOMString alt;
  [CEReactions] attribute DOMString autocomplete;
  [CEReactions] attribute boolean autofocus;
  [CEReactions] attribute boolean defaultChecked;
  attribute boolean checked;
  [CEReactions] attribute DOMString dirName;
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  attribute FileList? files;
  [CEReactions] attribute USVString formAction;
  [CEReactions] attribute DOMString formEnctype;
  [CEReactions] attribute DOMString formMethod;
  [CEReactions] attribute boolean formNoValidate;
  [CEReactions] attribute DOMString formTarget;
  [CEReactions] attribute unsigned long height;
  attribute boolean indeterminate;
  readonly attribute HTMLElement? list;
  [CEReactions] attribute DOMString max;
  [CEReactions] attribute long maxLength;
  [CEReactions] attribute DOMString min;
  [CEReactions] attribute long minLength;
  [CEReactions] attribute boolean multiple;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString pattern;
  [CEReactions] attribute DOMString placeholder;
  [CEReactions] attribute boolean readOnly;
  [CEReactions] attribute boolean required;
  [CEReactions] attribute unsigned long size;
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString step;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute DOMString defaultValue;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString value;
  attribute object? valueAsDate;
  attribute unrestricted double valueAsNumber;
  [CEReactions] attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList? labels;

  void select();
  attribute unsigned long? selectionStart;
  attribute unsigned long? selectionEnd;
  attribute DOMString? selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode = "preserve");
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);

  // also has obsolete members
};
The input element represents a typed data field, usually with a form control to allow the user to edit the data.

The type attribute controls the data type (and associated control) of the element. It is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

Keyword	State	Data type	Control type
hidden	Hidden	An arbitrary string	n/a
text	Text	Text with no line breaks	A text control
search	Search	Text with no line breaks	Search control
tel	Telephone	Text with no line breaks	A text control
url	URL	An absolute URL	A text control
email	E-mail	An e-mail address or list of e-mail addresses	A text control
password	Password	Text with no line breaks (sensitive information)	A text control that obscures data entry
date	Date	A date (year, month, day) with no time zone	A date control
month	Month	A date consisting of a year and a month with no time zone	A month control
week	Week	A date consisting of a week-year number and a week number with no time zone	A week control
time	Time	A time (hour, minute, seconds, fractional seconds) with no time zone	A time control
datetime-local	Local Date and Time	A date and time (year, month, day, hour, minute, second, fraction of a second) with no time zone	A date and time control
number	Number	A numerical value	A text control or spinner control
range	Range	A numerical value, with the extra semantic that the exact value is not important	A slider control or similar
color	Color	An sRGB color with 8-bit red, green, and blue components	A color picker
checkbox	Checkbox	A set of zero or more values from a predefined list	A checkbox
radio	Radio Button	An enumerated value	A radio button
file	File Upload	Zero or more files each with a MIME type and optionally a file name	A label and a button
submit	Submit Button	An enumerated value, with the extra semantic that it must be the last value selected and initiates form submission	A button
image	Image Button	A coordinate, relative to a particular image's size, with the extra semantic that it must be the last value selected and initiates form submission	Either a clickable image, or a button
reset	Reset Button	n/a	A button
button	Button	n/a	A button
The missing value default and the invalid value default are the Text state.

Which of the accept, alt, autocomplete, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width content attributes, the checked, files, valueAsDate, valueAsNumber, and list IDL attributes, the select() method, the selectionStart, selectionEnd, and selectionDirection, IDL attributes, the setRangeText() and setSelectionRange() methods, the stepUp() and stepDown() methods, and the input and change events apply to an input element depends on the state of its type attribute. The subsections that define each type also clearly define in normative "bookkeeping" sections which of these feature apply, and which do not apply, to each type. The behavior of these features depends on whether they apply or not, as defined in their various sections (q.v. for content attributes, for APIs, for events).

The following table is non-normative and summarizes which of those content attributes, IDL attributes, methods, and events apply to each state:

Hidden
Text,
Search
URL,
Telephone
E-mail
Password
Date,
Month,
Week,
Time
Local Date and Time
Number
Range
Color
Checkbox,
Radio Button
File Upload
Submit Button
Image Button
Reset Button,
Button
Content attributes
accept	·	·	·	·	·	·	·	·	·	·	·	Yes	·	·	·
alt	·	·	·	·	·	·	·	·	·	·	·	·	·	Yes	·
autocomplete	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	·	·	·	·	·
checked	·	·	·	·	·	·	·	·	·	·	Yes	·	·	·	·
dirname	·	Yes	·	·	·	·	·	·	·	·	·	·	·	·	·
formaction	·	·	·	·	·	·	·	·	·	·	·	·	Yes	Yes	·
formenctype	·	·	·	·	·	·	·	·	·	·	·	·	Yes	Yes	·
formmethod	·	·	·	·	·	·	·	·	·	·	·	·	Yes	Yes	·
formnovalidate	·	·	·	·	·	·	·	·	·	·	·	·	Yes	Yes	·
formtarget	·	·	·	·	·	·	·	·	·	·	·	·	Yes	Yes	·
height	·	·	·	·	·	·	·	·	·	·	·	·	·	Yes	·
list	·	Yes	Yes	Yes	·	Yes	Yes	Yes	Yes	Yes	·	·	·	·	·
max	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
maxlength	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·	·	·	·	·
min	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
minlength	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·	·	·	·	·
multiple	·	·	·	Yes	·	·	·	·	·	·	·	Yes	·	·	·
pattern	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·	·	·	·	·
placeholder	·	Yes	Yes	Yes	Yes	·	·	Yes	·	·	·	·	·	·	·
readonly	·	Yes	Yes	Yes	Yes	Yes	Yes	Yes	·	·	·	·	·	·	·
required	·	Yes	Yes	Yes	Yes	Yes	Yes	Yes	·	·	Yes	Yes	·	·	·
size	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·	·	·	·	·
src	·	·	·	·	·	·	·	·	·	·	·	·	·	Yes	·
step	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
width	·	·	·	·	·	·	·	·	·	·	·	·	·	Yes	·
IDL attributes and methods
checked	·	·	·	·	·	·	·	·	·	·	Yes	·	·	·	·
files	·	·	·	·	·	·	·	·	·	·	·	Yes	·	·	·
value	default	value	value	value	value	value	value	value	value	value	default/on	filename	default	default	default
valueAsDate	·	·	·	·	·	Yes	·	·	·	·	·	·	·	·	·
valueAsNumber	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
list	·	Yes	Yes	Yes	·	Yes	Yes	Yes	Yes	Yes	·	·	·	·	·
select()	·	Yes	Yes	Yes†	Yes	Yes†	Yes†	Yes†	·	Yes†	·	Yes†	·	·	·
selectionStart	·	Yes	Yes	·	Yes	·	·	·	·	·	·	·	·	·	·
selectionEnd	·	Yes	Yes	·	Yes	·	·	·	·	·	·	·	·	·	·
selectionDirection	·	Yes	Yes	·	Yes	·	·	·	·	·	·	·	·	·	·
setRangeText()	·	Yes	Yes	·	Yes	·	·	·	·	·	·	·	·	·	·
setSelectionRange()	·	Yes	Yes	·	Yes	·	·	·	·	·	·	·	·	·	·
stepDown()	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
stepUp()	·	·	·	·	·	Yes	Yes	Yes	Yes	·	·	·	·	·	·
Events
input event	·	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	·	·	·
change event	·	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	Yes	·	·	·
† If the control has no selectable text, the select() method results in a no-op, with no "InvalidStateError" DOMException.

Some states of the type attribute define a value sanitization algorithm.

Each input element has a value, which is exposed by the value IDL attribute. Some states define an algorithm to convert a string to a number, an algorithm to convert a number to a string, an algorithm to convert a string to a Date object, and an algorithm to convert a Date object to a string, which are used by max, min, step, valueAsDate, valueAsNumber, and stepUp().

An input element's dirty value flag must be set to true whenever the user interacts with the control in a way that changes the value. (It is also set to true when the value is programmatically changed, as described in the definition of the value IDL attribute.)

The value content attribute gives the default value of the input element. When the value content attribute is added, set, or removed, if the control's dirty value flag is false, the user agent must set the value of the element to the value of the value content attribute, if there is one, or the empty string otherwise, and then run the current value sanitization algorithm, if one is defined.

Each input element has a checkedness, which is exposed by the checked IDL attribute.

Each input element has a boolean dirty checkedness flag. When it is true, the element is said to have a dirty checkedness. The dirty checkedness flag must be initially set to false when the element is created, and must be set to true whenever the user interacts with the control in a way that changes the checkedness.

The checked content attribute is a boolean attribute that gives the default checkedness of the input element. When the checked content attribute is added, if the control does not have dirty checkedness, the user agent must set the checkedness of the element to true; when the checked content attribute is removed, if the control does not have dirty checkedness, the user agent must set the checkedness of the element to false.

The reset algorithm for input elements is to set the dirty value flag and dirty checkedness flag back to false, set the value of the element to the value of the value content attribute, if there is one, or the empty string otherwise, set the checkedness of the element to true if the element has a checked content attribute and false if it does not, empty the list of selected files, and then invoke the value sanitization algorithm, if the type attribute's current state defines one.

Each input element can be mutable. Except where otherwise specified, an input element is always mutable. Similarly, except where otherwise specified, the user agent should not allow the user to modify the element's value or checkedness.

When an input element is disabled, it is not mutable.

The readonly attribute can also in some cases (e.g. for the Date state, but not the Checkbox state) stop an input element from being mutable.

The cloning steps for input elements must propagate the value, dirty value flag, checkedness, and dirty checkedness flag from the node being cloned to the copy.

The activation behavior for input elements are these steps:

If this element is not mutable, then return.

Run this element's input activation behavior, if any, and do nothing otherwise.

The legacy-pre-activation behavior for input elements are these steps:

If this element is not mutable, then return.

If this element's type attribute is in the Checkbox state, then set this element's checkedness to its opposite value (i.e. true if it is false, false if it is true) and set this element's indeterminate IDL attribute to false.

If this element's type attribute is in the Radio Button state, then get a reference to the element in this element's radio button group that has its checkedness set to true, if any, and then set this element's checkedness to true.

The legacy-canceled-activation behavior for input elements are these steps:

If the element is not mutable, then return.

If the element's type attribute is in the Checkbox state, then set the element's checkedness and the element's indeterminate IDL attribute back to the values they had before the legacy-pre-activation behavior was run.

If this element's type attribute is in the Radio Button state, then if the element to which a reference was obtained in the legacy-pre-activation behavior, if any, is still in what is now this element's radio button group, if it still has one, and if so, setting that element's checkedness to true; or else, if there was no such element, or that element is no longer in this element's radio button group, or if this element no longer has a radio button group, setting this element's checkedness to false.

When an input element is first created, the element's rendering and behavior must be set to the rendering and behavior defined for the type attribute's state, and the value sanitization algorithm, if one is defined for the type attribute's state, must be invoked.

When an input element's type attribute changes state, the user agent must run the following steps:

If the previous state of the element's type attribute put the value IDL attribute in the value mode, and the element's value is not the empty string, and the new state of the element's type attribute puts the value IDL attribute in either the default mode or the default/on mode, then set the element's value content attribute to the element's value.

Otherwise, if the previous state of the element's type attribute put the value IDL attribute in any mode other than the value mode, and the new state of the element's type attribute puts the value IDL attribute in the value mode, then set the value of the element to the value of the value content attribute, if there is one, or the empty string otherwise, and then set the control's dirty value flag to false.

Otherwise, if the previous state of the element's type attribute put the value IDL attribute in any mode other than the filename mode, and the new state of the element's type attribute puts the value IDL attribute in the filename mode, then set the value of the element to the empty string.

Update the element's rendering and behavior to the new state's.

Signal a type change for the element. (The Radio Button state uses this, in particular.)

Invoke the value sanitization algorithm, if one is defined for the type attribute's new state.

Let previouslySelectable be true if setRangeText() previously applied to the element, and false otherwise.

Let nowSelectable be true if setRangeText() now applies to the element, and false otherwise.

If previouslySelectable is false and nowSelectable is true, set the element's text entry cursor position to the beginning of the text control, and set its selection direction to "none".

The name attribute represents the element's name. The dirname attribute controls how the element's directionality is submitted. The disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The form attribute is used to explicitly associate the input element with its form owner. The autofocus attribute controls focus. The autocomplete attribute controls how the user agent provides autofill behavior.

The indeterminate IDL attribute must initially be set to false. On getting, it must return the last value it was set to. On setting, it must be set to the new value. It has no effect except for changing the appearance of checkbox controls.


Support: indeterminate-checkbox
Chrome for Android	64+
Chrome	28+
iOS Safari	None
UC Browser for Android	None
Firefox	3.6+
Samsung Internet	4+
IE	6+
Opera Mini	None
Safari	6+
Edge	12+
Android Browser	4.4+
Opera	11.6+

Source: caniuse.com

The accept, alt, max, min, multiple, pattern, placeholder, required, size, src, and step IDL attributes must reflect the respective content attributes of the same name. The dirName IDL attribute must reflect the dirname content attribute. The readOnly IDL attribute must reflect the readonly content attribute. The defaultChecked IDL attribute must reflect the checked content attribute. The defaultValue IDL attribute must reflect the value content attribute.

The type IDL attribute must reflect the respective content attribute of the same name, limited to only known values. The maxLength IDL attribute must reflect the maxlength content attribute, limited to only non-negative numbers. The minLength IDL attribute must reflect the minlength content attribute, limited to only non-negative numbers.

The IDL attributes width and height must return the rendered width and height of the image, in CSS pixels, if an image is being rendered, and is being rendered to a visual medium; or else the intrinsic width and height of the image, in CSS pixels, if an image is available but not being rendered to a visual medium; or else 0, if no image is available. When the input element's type attribute is not in the Image Button state, then no image is available. [CSS]

On setting, they must act as if they reflected the respective content attributes of the same name.

The willValidate, validity, and validationMessage IDL attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The labels IDL attribute provides a list of the element's labels. The select(), selectionStart, selectionEnd, selectionDirection, setRangeText(), and setSelectionRange() methods and IDL attributes expose the element's text selection. The autofocus, disabled, form, and name IDL attributes are part of the element's forms API.

4.10.5.1 States of the type attribute
4.10.5.1.1 Hidden state (type=hidden)
When an input element's type attribute is in the Hidden state, the rules in this section apply.

The input element represents a value that is not intended to be examined or manipulated by the user.

Constraint validation: If an input element's type attribute is in the Hidden state, it is barred from constraint validation.

If the name attribute is present and has a value that is a case-sensitive match for the string "_charset_", then the element's value attribute must be omitted.

The autocomplete content attribute applies to this element.

The value IDL attribute applies to this element and is in mode default.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

The input and change events do not apply.

4.10.5.1.2 Text (type=text) state and Search state (type=search)

Support: input-search
Chrome for Android	64+
Chrome	15+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	2.3+
Opera	11.6+

Source: caniuse.com

When an input element's type attribute is in the Text state or the Search state, the rules in this section apply.

The input element represents a one line plain text edit control for the element's value.

The difference between the Text state and the Search state is primarily stylistic: on platforms where search controls are distinguished from regular text controls, the Search state might result in an appearance consistent with the platform's search controls rather than appearing like a regular text control.

If the element is mutable, its value should be editable by the user. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the element's value.

If the element is mutable, the user agent should allow the user to change the writing direction of the element, setting it either to a left-to-right writing direction or a right-to-left writing direction. If the user does so, the user agent must then run the following steps:

Set the element's dir attribute to "ltr" if the user selected a left-to-right writing direction, and "rtl" if the user selected a right-to-left writing direction.

Queue a task to fire an event named input at the input element, with the bubbles attribute initialized to true.

The value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The value sanitization algorithm is as follows: Strip newlines from the value.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, dirname, list, maxlength, minlength, pattern, placeholder, readonly, required, and size content attributes; list, selectionStart, selectionEnd, selectionDirection, and value IDL attributes; select(), setRangeText(), and setSelectionRange() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, formaction, formenctype, formmethod, formnovalidate, formtarget, height, max, min, multiple, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, valueAsDate, and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

4.10.5.1.3 Telephone state (type=tel)

Support: input-email-tel-url
Chrome for Android	64+
Chrome	5+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	3+
Opera	9.5+

Source: caniuse.com

When an input element's type attribute is in the Telephone state, the rules in this section apply.

The input element represents a control for editing a telephone number given in the element's value.

If the element is mutable, its value should be editable by the user. User agents may change the spacing and, with care, the punctuation of values that the user enters. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the element's value.

The value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The value sanitization algorithm is as follows: Strip newlines from the value.

Unlike the URL and E-mail types, the Telephone type does not enforce a particular syntax. This is intentional; in practice, telephone number fields tend to be free-form fields, because there are a wide variety of valid phone numbers. Systems that need to enforce a particular format are encouraged to use the pattern attribute or the setCustomValidity() method to hook into the client-side validation mechanism.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, maxlength, minlength, pattern, placeholder, readonly, required, and size content attributes; list, selectionStart, selectionEnd, selectionDirection, and value IDL attributes; select(), setRangeText(), and setSelectionRange() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, max, min, multiple, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, valueAsDate, and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

4.10.5.1.4 URL state (type=url)
When an input element's type attribute is in the URL state, the rules in this section apply.

The input element represents a control for editing a single absolute URL given in the element's value.

If the element is mutable, the user agent should allow the user to change the URL represented by its value. User agents may allow the user to set the value to a string that is not a valid absolute URL, but may also or instead automatically escape characters entered by the user so that the value is always a valid absolute URL (even if that isn't the actual value seen and edited by the user in the interface). User agents should allow the user to set the value to the empty string. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the value.

The value attribute, if specified and not empty, must have a value that is a valid URL potentially surrounded by spaces that is also an absolute URL.

The value sanitization algorithm is as follows: Strip newlines from the value, then strip leading and trailing ASCII whitespace from the value.

Constraint validation: While the value of the element is neither the empty string nor a valid absolute URL, the element is suffering from a type mismatch.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, maxlength, minlength, pattern, placeholder, readonly, required, and size content attributes; list, selectionStart, selectionEnd, selectionDirection, and value IDL attributes; select(), setRangeText(), and setSelectionRange() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, max, min, multiple, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, valueAsDate, and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

If a document contained the following markup:

<input type="url" name="location" list="urls">
<datalist id="urls">
 <option label="MIME: Format of Internet Message Bodies" value="https://tools.ietf.org/html/rfc2045">
 <option label="HTML" value="https://html.spec.whatwg.org/">
 <option label="DOM" value="https://dom.spec.whatwg.org/">
 <option label="Fullscreen" value="https://fullscreen.spec.whatwg.org/">
 <option label="Media Session" value="https://mediasession.spec.whatwg.org/">
 <option label="The Single UNIX Specification, Version 3" value="http://www.unix.org/version3/">
</datalist>
...and the user had typed "spec.w", and the user agent had also found that the user had visited https://url.spec.whatwg.org/#url-parsing and https://streams.spec.whatwg.org/ in the recent past, then the rendering might look like this:



The first four URLs in this sample consist of the four URLs in the author-specified list that match the text the user has entered, sorted in some UA-defined manner (maybe by how frequently the user refers to those URLs). Note how the UA is using the knowledge that the values are URLs to allow the user to omit the scheme part and perform intelligent matching on the domain name.

The last two URLs (and probably many more, given the scrollbar's indications of more values being available) are the matches from the user agent's session history data. This data is not made available to the page DOM. In this particular case, the UA has no titles to provide for those values.

4.10.5.1.5 E-mail state (type=email)

Spec bugs: 15489

When an input element's type attribute is in the E-mail state, the rules in this section apply.

How the E-mail state operates depends on whether the multiple attribute is specified or not.

When the multiple attribute is not specified on the element
The input element represents a control for editing an e-mail address given in the element's value.

If the element is mutable, the user agent should allow the user to change the e-mail address represented by its value. User agents may allow the user to set the value to a string that is not a valid e-mail address. The user agent should act in a manner consistent with expecting the user to provide a single e-mail address. User agents should allow the user to set the value to the empty string. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the value. User agents may transform the value for display and editing; in particular, user agents should convert punycode in the domain labels of the value to IDN in the display and vice versa.

Constraint validation: While the user interface is representing input that the user agent cannot convert to punycode, the control is suffering from bad input.

The value attribute, if specified and not empty, must have a value that is a single valid e-mail address.

The value sanitization algorithm is as follows: Strip newlines from the value, then strip leading and trailing ASCII whitespace from the value.

Constraint validation: While the value of the element is neither the empty string nor a single valid e-mail address, the element is suffering from a type mismatch.

When the multiple attribute is specified on the element
The input element represents a control for adding, removing, and editing the e-mail addresses given in the element's values.

If the element is mutable, the user agent should allow the user to add, remove, and edit the e-mail addresses represented by its values. User agents may allow the user to set any individual value in the list of values to a string that is not a valid e-mail address, but must not allow users to set any individual value to a string containing U+002C COMMA (,), U+000A LINE FEED (LF), or U+000D CARRIAGE RETURN (CR) characters. User agents should allow the user to remove all the addresses in the element's values. User agents may transform the values for display and editing; in particular, user agents should convert punycode in the domain labels of the value to IDN in the display and vice versa.

Constraint validation: While the user interface describes a situation where an individual value contains a U+002C COMMA (,) or is representing input that the user agent cannot convert to punycode, the control is suffering from bad input.

Whenever the user changes the element's values, the user agent must run the following steps:

Let latest values be a copy of the element's values.

Strip leading and trailing ASCII whitespace from each value in latest values.

Let the element's value be the result of concatenating all the values in latest values, separating each value from the next by a single U+002C COMMA character (,), maintaining the list's order.

The value attribute, if specified, must have a value that is a valid e-mail address list.

The value sanitization algorithm is as follows:

Split on commas the element's value, strip leading and trailing ASCII whitespace from each resulting token, if any, and let the element's values be the (possibly empty) resulting list of (possibly empty) tokens, maintaining the original order.

Let the element's value be the result of concatenating the element's values, separating each value from the next by a single U+002C COMMA character (,), maintaining the list's order.

Constraint validation: While the value of the element is not a valid e-mail address list, the element is suffering from a type mismatch.

When the multiple attribute is set or removed, the user agent must run the value sanitization algorithm.

A valid e-mail address is a string that matches the email production of the following ABNF, the character set for which is Unicode. This ABNF implements the extensions described in RFC 1123. [ABNF] [RFC5322] [RFC1034] [RFC1123]

email         = 1*( atext / "." ) "@" label *( "." label )
label         = let-dig [ [ ldh-str ] let-dig ]  ; limited to a length of 63 characters by RFC 1034 section 3.5
atext         = < as defined in RFC 5322 section 3.2.3 >
let-dig       = < as defined in RFC 1034 section 3.5 >
ldh-str       = < as defined in RFC 1034 section 3.5 >
This requirement is a willful violation of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the "@" character), too vague (after the "@" character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.

The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.

/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
A valid e-mail address list is a set of comma-separated tokens, where each token is itself a valid e-mail address. To obtain the list of tokens from a valid e-mail address list, an implementation must split the string on commas.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, maxlength, minlength, multiple, pattern, placeholder, readonly, required, and size content attributes; list and value IDL attributes; select() method.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, max, min, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; setRangeText(), setSelectionRange(), stepDown() and stepUp() methods.

4.10.5.1.6 Password state (type=password)
When an input element's type attribute is in the Password state, the rules in this section apply.

The input element represents a one line plain text edit control for the element's value. The user agent should obscure the value so that people other than the user cannot see it.

If the element is mutable, its value should be editable by the user. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the value.

The value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The value sanitization algorithm is as follows: Strip newlines from the value.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, maxlength, minlength, pattern, placeholder, readonly, required, and size content attributes; selectionStart, selectionEnd, selectionDirection, and value IDL attributes; select(), setRangeText(), and setSelectionRange() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, min, multiple, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, list, valueAsDate, and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

4.10.5.1.7 Date state (type=date)

Support: input-datetime
Chrome for Android	64+
Chrome	25+
iOS Safari (limited)	5.0+
UC Browser for Android	11.8+
Firefox (limited)	57+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	None
Edge	13+
Android Browser	4.4+
Opera	9+

Source: caniuse.com

When an input element's type attribute is in the Date state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a specific date.

If the element is mutable, the user agent should allow the user to change the date represented by its value, as obtained by parsing a date from it. User agents must not allow the user to set the value to a non-empty string that is not a valid date string. If the user agent provides a user interface for selecting a date, then the value must be set to a valid date string representing the user's selection. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid date string, the control is suffering from bad input.

See the introduction section for a discussion of the difference between the input format and submission format for date, time, and number form controls, and the implementation notes regarding localization of form controls.

The value attribute, if specified and not empty, must have a value that is a valid date string.

The value sanitization algorithm is as follows: If the value of the element is not a valid date string, then set it to the empty string instead.

The min attribute, if specified, must have a value that is a valid date string. The max attribute, if specified, must have a value that is a valid date string.

The step attribute is expressed in days. The step scale factor is 86,400,000 (which converts the days to milliseconds, as used in the other algorithms). The default step is 1 day.

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest date for which the element would not suffer from a step mismatch.

The algorithm to convert a string to a number, given a string input, is as follows: If parsing a date from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z") to midnight UTC on the morning of the parsed date, ignoring leap seconds.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid date string that represents the date that, in UTC, is current input milliseconds after midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z").

The algorithm to convert a string to a Date object, given a string input, is as follows: If parsing a date from input results in an error, then return an error; otherwise, return a new Date object representing midnight UTC on the morning of the parsed date.

The algorithm to convert a Date object to a string, given a Date object input, is as follows: Return a valid date string that represents the date current at the time represented by input in the UTC time zone.

The Date state (and other date- and time-related states described in subsequent sections) is not intended for the entry of values for which a precise date and time relative to the contemporary calendar cannot be established. For example, it would be inappropriate for the entry of times like "one millisecond after the big bang", "the early part of the Jurassic period", or "a winter around 250 BCE".

For the input of dates before the introduction of the Gregorian calendar, authors are encouraged to not use the Date state (and the other date- and time-related states described in subsequent sections), as user agents are not required to support converting dates and times from earlier periods to the Gregorian calendar, and asking users to do so manually puts an undue burden on users. (This is complicated by the manner in which the Gregorian calendar was phased in, which occurred at different times in different countries, ranging from partway through the 16th century all the way to early in the 20th.) Instead, authors are encouraged to provide fine-grained input controls using the select element and input elements with the Number state.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, readonly, required, and step content attributes; list, value, valueAsDate, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, selectionStart, selectionEnd, and selectionDirection IDL attributes; setRangeText(), and setSelectionRange() methods.

4.10.5.1.8 Month state (type=month)
When an input element's type attribute is in the Month state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a specific month.

If the element is mutable, the user agent should allow the user to change the month represented by its value, as obtained by parsing a month from it. User agents must not allow the user to set the value to a non-empty string that is not a valid month string. If the user agent provides a user interface for selecting a month, then the value must be set to a valid month string representing the user's selection. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid month string, the control is suffering from bad input.

See the introduction section for a discussion of the difference between the input format and submission format for date, time, and number form controls, and the implementation notes regarding localization of form controls.

The value attribute, if specified and not empty, must have a value that is a valid month string.

The value sanitization algorithm is as follows: If the value of the element is not a valid month string, then set it to the empty string instead.

The min attribute, if specified, must have a value that is a valid month string. The max attribute, if specified, must have a value that is a valid month string.

The step attribute is expressed in months. The step scale factor is 1 (there is no conversion needed as the algorithms use months). The default step is 1 month.

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest month for which the element would not suffer from a step mismatch.

The algorithm to convert a string to a number, given a string input, is as follows: If parsing a month from input results in an error, then return an error; otherwise, return the number of months between January 1970 and the parsed month.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid month string that represents the month that has input months between it and January 1970.

The algorithm to convert a string to a Date object, given a string input, is as follows: If parsing a month from input results in an error, then return an error; otherwise, return a new Date object representing midnight UTC on the morning of the first day of the parsed month.

The algorithm to convert a Date object to a string, given a Date object input, is as follows: Return a valid month string that represents the month current at the time represented by input in the UTC time zone.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, readonly, required, and step content attributes; list, value, valueAsDate, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, and selectionDirection IDL attributes; setRangeText(), and setSelectionRange() methods.

4.10.5.1.9 Week state (type=week)
When an input element's type attribute is in the Week state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a specific week.

If the element is mutable, the user agent should allow the user to change the week represented by its value, as obtained by parsing a week from it. User agents must not allow the user to set the value to a non-empty string that is not a valid week string. If the user agent provides a user interface for selecting a week, then the value must be set to a valid week string representing the user's selection. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid week string, the control is suffering from bad input.

See the introduction section for a discussion of the difference between the input format and submission format for date, time, and number form controls, and the implementation notes regarding localization of form controls.

The value attribute, if specified and not empty, must have a value that is a valid week string.

The value sanitization algorithm is as follows: If the value of the element is not a valid week string, then set it to the empty string instead.

The min attribute, if specified, must have a value that is a valid week string. The max attribute, if specified, must have a value that is a valid week string.

The step attribute is expressed in weeks. The step scale factor is 604,800,000 (which converts the weeks to milliseconds, as used in the other algorithms). The default step is 1 week. The default step base is −259,200,000 (the start of week 1970-W01).

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest week for which the element would not suffer from a step mismatch.

The algorithm to convert a string to a number, given a string input, is as follows: If parsing a week string from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z") to midnight UTC on the morning of the Monday of the parsed week, ignoring leap seconds.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid week string that represents the week that, in UTC, is current input milliseconds after midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z").

The algorithm to convert a string to a Date object, given a string input, is as follows: If parsing a week from input results in an error, then return an error; otherwise, return a new Date object representing midnight UTC on the morning of the Monday of the parsed week.

The algorithm to convert a Date object to a string, given a Date object input, is as follows: Return a valid week string that represents the week current at the time represented by input in the UTC time zone.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, readonly, required, and step content attributes; list, value, valueAsDate, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, and selectionDirection IDL attributes; setRangeText(), and setSelectionRange() methods.

4.10.5.1.10 Time state (type=time)
When an input element's type attribute is in the Time state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a specific time.

If the element is mutable, the user agent should allow the user to change the time represented by its value, as obtained by parsing a time from it. User agents must not allow the user to set the value to a non-empty string that is not a valid time string. If the user agent provides a user interface for selecting a time, then the value must be set to a valid time string representing the user's selection. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid time string, the control is suffering from bad input.

See the introduction section for a discussion of the difference between the input format and submission format for date, time, and number form controls, and the implementation notes regarding localization of form controls.

The value attribute, if specified and not empty, must have a value that is a valid time string.

The value sanitization algorithm is as follows: If the value of the element is not a valid time string, then set it to the empty string instead.

The form control has a periodic domain.

The min attribute, if specified, must have a value that is a valid time string. The max attribute, if specified, must have a value that is a valid time string.

The step attribute is expressed in seconds. The step scale factor is 1000 (which converts the seconds to milliseconds, as used in the other algorithms). The default step is 60 seconds.

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest time for which the element would not suffer from a step mismatch.

The algorithm to convert a string to a number, given a string input, is as follows: If parsing a time from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight to the parsed time on a day with no time changes.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid time string that represents the time that is input milliseconds after midnight on a day with no time changes.

The algorithm to convert a string to a Date object, given a string input, is as follows: If parsing a time from input results in an error, then return an error; otherwise, return a new Date object representing the parsed time in UTC on 1970-01-01.

The algorithm to convert a Date object to a string, given a Date object input, is as follows: Return a valid time string that represents the UTC time component that is represented by input.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, readonly, required, and step content attributes; list, value, valueAsDate, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, and selectionDirection IDL attributes; setRangeText(), and setSelectionRange() methods.

4.10.5.1.11 Local Date and Time state (type=datetime-local)
When an input element's type attribute is in the Local Date and Time state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a local date and time, with no time-zone offset information.

If the element is mutable, the user agent should allow the user to change the date and time represented by its value, as obtained by parsing a date and time from it. User agents must not allow the user to set the value to a non-empty string that is not a valid normalized local date and time string. If the user agent provides a user interface for selecting a local date and time, then the value must be set to a valid normalized local date and time string representing the user's selection. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid normalized local date and time string, the control is suffering from bad input.

See the introduction section for a discussion of the difference between the input format and submission format for date, time, and number form controls, and the implementation notes regarding localization of form controls.

The value attribute, if specified and not empty, must have a value that is a valid local date and time string.

The value sanitization algorithm is as follows: If the value of the element is a valid local date and time string, then set it to a valid normalized local date and time string representing the same date and time; otherwise, set it to the empty string instead.

The min attribute, if specified, must have a value that is a valid local date and time string. The max attribute, if specified, must have a value that is a valid local date and time string.

The step attribute is expressed in seconds. The step scale factor is 1000 (which converts the seconds to milliseconds, as used in the other algorithms). The default step is 60 seconds.

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest local date and time for which the element would not suffer from a step mismatch.

The algorithm to convert a string to a number, given a string input, is as follows: If parsing a date and time from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0") to the parsed local date and time, ignoring leap seconds.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid normalized local date and time string that represents the date and time that is input milliseconds after midnight on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0").

See the note on historical dates in the Date state section.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, readonly, required, and step content attributes; list, value, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, selectionDirection, and valueAsDate IDL attributes; setRangeText(), and setSelectionRange() methods.

The following example shows part of a flight booking application. The application uses an input element with its type attribute set to datetime-local, and it then interprets the given date and time in the time zone of the selected airport.

<fieldset>
 <legend>Destination</legend>
 <p><label>Airport: <input type=text name=to list=airports></label></p>
 <p><label>Departure time: <input type=datetime-local name=totime step=3600></label></p>
</fieldset>
<datalist id=airports>
 <option value=ATL label="Atlanta">
 <option value=MEM label="Memphis">
 <option value=LHR label="London Heathrow">
 <option value=LAX label="Los Angeles">
 <option value=FRA label="Frankfurt">
</datalist>
4.10.5.1.12 Number state (type=number)

Support: input-number
Chrome for Android (limited)	64+
Chrome	6+
iOS Safari (limited)	3.2+
UC Browser for Android (limited)	11.8+
Firefox	29+
Samsung Internet (limited)	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser (limited)	4+
Opera	9+

Source: caniuse.com

When an input element's type attribute is in the Number state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a number.

If the element is mutable, the user agent should allow the user to change the number represented by its value, as obtained from applying the rules for parsing floating-point number values to it. User agents must not allow the user to set the value to a non-empty string that is not a valid floating-point number. If the user agent provides a user interface for selecting a number, then the value must be set to the best representation of the number representing the user's selection as a floating-point number. User agents should allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid floating-point number, the control is suffering from bad input.

This specification does not define what user interface user agents are to use; user agent vendors are encouraged to consider what would best serve their users' needs. For example, a user agent in Persian or Arabic markets might support Persian and Arabic numeric input (converting it to the format required for submission as described above). Similarly, a user agent designed for Romans might display the value in Roman numerals rather than in decimal; or (more realistically) a user agent designed for the French market might display the value with apostrophes between thousands and commas before the decimals, and allow the user to enter a value in that manner, internally converting it to the submission format described above.

The value attribute, if specified and not empty, must have a value that is a valid floating-point number.

The value sanitization algorithm is as follows: If the value of the element is not a valid floating-point number, then set it to the empty string instead.

The min attribute, if specified, must have a value that is a valid floating-point number. The max attribute, if specified, must have a value that is a valid floating-point number.

The step scale factor is 1. The default step is 1 (allowing only integers to be selected by the user, unless the step base has a non-integer value).

When the element is suffering from a step mismatch, the user agent may round the element's value to the nearest number for which the element would not suffer from a step mismatch. If there are two such numbers, user agents are encouraged to pick the one nearest positive infinity.

The algorithm to convert a string to a number, given a string input, is as follows: If applying the rules for parsing floating-point number values to input results in an error, then return an error; otherwise, return the resulting number.

The algorithm to convert a number to a string, given a number input, is as follows: Return a valid floating-point number that represents input.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, placeholder, readonly, required, and step content attributes; list, value, and valueAsNumber IDL attributes; select(), stepDown(), and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, selectionDirection, and valueAsDate IDL attributes; setRangeText(), and setSelectionRange() methods.

Here is an example of using a numeric input control:

<label>How much do you want to charge? $<input type=number min=0 step=0.01 name=price></label>
As described above, a user agent might support numeric input in the user's local format, converting it to the format required for submission as described above. This might include handling grouping separators (as in "872,000,000,000") and various decimal separators (such as "3,99" vs "3.99") or using local digits (such as those in Arabic, Devanagari, Persian, and Thai).

The type=number state is not appropriate for input that happens to only consist of numbers but isn't strictly speaking a number. For example, it would be inappropriate for credit card numbers or US postal codes. A simple way of determining whether to use type=number is to consider whether it would make sense for the input control to have a spinbox interface (e.g. with "up" and "down" arrows). Getting a credit card number wrong by 1 in the last digit isn't a minor mistake, it's as wrong as getting every digit incorrect. So it would not make sense for the user to select a credit card number using "up" and "down" buttons. When a spinbox interface is not appropriate, type=text is probably the right choice (possibly with a pattern attribute).

4.10.5.1.13 Range state (type=range)

Support: input-range
Chrome for Android	64+
Chrome	4+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	23+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	3.1+
Edge	12+
Android Browser	4.2+
Opera	9+

Source: caniuse.com

When an input element's type attribute is in the Range state, the rules in this section apply.

The input element represents a control for setting the element's value to a string representing a number, but with the caveat that the exact value is not important, letting UAs provide a simpler interface than they do for the Number state.

If the element is mutable, the user agent should allow the user to change the number represented by its value, as obtained from applying the rules for parsing floating-point number values to it. User agents must not allow the user to set the value to a string that is not a valid floating-point number. If the user agent provides a user interface for selecting a number, then the value must be set to a best representation of the number representing the user's selection as a floating-point number. User agents must not allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid floating-point number, the control is suffering from bad input.

The value attribute, if specified, must have a value that is a valid floating-point number.

The value sanitization algorithm is as follows: If the value of the element is not a valid floating-point number, then set it to the best representation, as a floating-point number, of the default value.

The default value is the minimum plus half the difference between the minimum and the maximum, unless the maximum is less than the minimum, in which case the default value is the minimum.

When the element is suffering from an underflow, the user agent must set the element's value to the best representation, as a floating-point number, of the minimum.

When the element is suffering from an overflow, if the maximum is not less than the minimum, the user agent must set the element's value to a valid floating-point number that represents the maximum.

When the element is suffering from a step mismatch, the user agent must round the element's value to the nearest number for which the element would not suffer from a step mismatch, and which is greater than or equal to the minimum, and, if the maximum is not less than the minimum, which is less than or equal to the maximum, if there is a number that matches these constraints. If two numbers match these constraints, then user agents must use the one nearest to positive infinity.

For example, the markup <input type="range" min=0 max=100 step=20 value=50> results in a range control whose initial value is 60.

Here is an example of a range control using an autocomplete list with the list attribute. This could be useful if there are values along the full range of the control that are especially important, such as preconfigured light levels or typical speed limits in a range control used as a speed control. The following markup fragment:

<input type="range" min="-100" max="100" value="0" step="10" name="power" list="powers">
<datalist id="powers">
<option value="0">
<option value="-30">
<option value="30">
 <option value="++50">
</datalist>
...with the following style sheet applied:

input { height: 75px; width: 49px; background: #D5CCBB; color: black; }
...might render as:



Note how the UA determined the orientation of the control from the ratio of the style-sheet-specified height and width properties. The colors were similarly derived from the style sheet. The tick marks, however, were derived from the markup. In particular, the step attribute has not affected the placement of tick marks, the UA deciding to only use the author-specified completion values and then adding longer tick marks at the extremes.

Note also how the invalid value ++50 was completely ignored.

For another example, consider the following markup fragment:

<input name=x type=range min=100 max=700 step=9.09090909 value=509.090909>
A user agent could display in a variety of ways, for instance:



Or, alternatively, for instance:



The user agent could pick which one to display based on the dimensions given in the style sheet. This would allow it to maintain the same resolution for the tick marks, despite the differences in width.

Finally, here is an example of a range control with two labeled values:

<input type="range" name="a" list="a-values">
<datalist id="a-values">
<option value="10" label="Low">
<option value="90" label="High">
</datalist>
With styles that make the control draw vertically, it might look as follows:



In this state, the range and step constraints are enforced even during user input, and there is no way to set the value to the empty string.

The min attribute, if specified, must have a value that is a valid floating-point number. The default minimum is 0. The max attribute, if specified, must have a value that is a valid floating-point number. The default maximum is 100.

The step scale factor is 1. The default step is 1 (allowing only integers, unless the min attribute has a non-integer value).

The algorithm to convert a string to a number, given a string input, is as follows: If applying the rules for parsing floating-point number values to input results in an error, then return an error; otherwise, return the resulting number.

The algorithm to convert a number to a string, given a number input, is as follows: Return the best representation, as a floating-point number, of input.

The following common input element content attributes, IDL attributes, and methods apply to the element: autocomplete, list, max, min, and step content attributes; list, value, and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, maxlength, minlength, multiple, pattern, placeholder, readonly, required, size, src, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, selectionDirection, and valueAsDate IDL attributes; select(), setRangeText(), and setSelectionRange() methods.

4.10.5.1.14 Color state (type=color)

Support: input-color
Chrome for Android	64+
Chrome	20+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	29+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	11+
Edge	14+
Android Browser	4.4+
Opera	17+

Source: caniuse.com

When an input element's type attribute is in the Color state, the rules in this section apply.

The input element represents a color well control, for setting the element's value to a string representing a simple color.

In this state, there is always a color picked, and there is no way to set the value to the empty string.

If the element is mutable, the user agent should allow the user to change the color represented by its value, as obtained from applying the rules for parsing simple color values to it. User agents must not allow the user to set the value to a string that is not a valid lowercase simple color. If the user agent provides a user interface for selecting a color, then the value must be set to the result of using the rules for serializing simple color values to the user's selection. User agents must not allow the user to set the value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid lowercase simple color, the control is suffering from bad input.

The value attribute, if specified and not empty, must have a value that is a valid simple color.

The value sanitization algorithm is as follows: If the value of the element is a valid simple color, then set it to the value of the element converted to ASCII lowercase; otherwise, set it to the string "#000000".

The following common input element content attributes and IDL attributes apply to the element: autocomplete and list content attributes; list and value IDL attributes; select() method.

The value IDL attribute is in mode value.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, selectionStart, selectionEnd, selectionDirection, valueAsDate and, valueAsNumber IDL attributes; setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

4.10.5.1.15 Checkbox state (type=checkbox)
When an input element's type attribute is in the Checkbox state, the rules in this section apply.

The input element represents a two-state control that represents the element's checkedness state. If the element's checkedness state is true, the control represents a positive selection, and if it is false, a negative selection. If the element's indeterminate IDL attribute is set to true, then the control's selection should be obscured as if the control was in a third, indeterminate, state.

The control is never a true tri-state control, even if the element's indeterminate IDL attribute is set to true. The indeterminate IDL attribute only gives the appearance of a third state.

The input activation behavior is to fire an event named input at the element, with the bubbles attribute initialized to true, and then fire an event named change at the element, with the bubbles attribute initialized to true.

Constraint validation: If the element is required and its checkedness is false, then the element is suffering from being missing.

input . indeterminate [ = value ]
When set, overrides the rendering of checkbox controls so that the current value is not visible.

The following common input element content attributes and IDL attributes apply to the element: checked, and required content attributes; checked and value IDL attributes.

The value IDL attribute is in mode default/on.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, autocomplete, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

4.10.5.1.16 Radio Button state (type=radio)
When an input element's type attribute is in the Radio Button state, the rules in this section apply.

The input element represents a control that, when used in conjunction with other input elements, forms a radio button group in which only one control can have its checkedness state set to true. If the element's checkedness state is true, the control represents the selected control in the group, and if it is false, it indicates a control in the group that is not selected.

The radio button group that contains an input element a also contains all the other input elements b that fulfill all of the following conditions:

The input element b's type attribute is in the Radio Button state.
Either a and b have the same form owner, or they both have no form owner.
Both a and b are in the same tree.
They both have a name attribute, their name attributes are not empty, and the value of a's name attribute equals the value of b's name attribute.
A tree must not contain an input element whose radio button group contains only that element.

When any of the following phenomena occur, if the element's checkedness state is true after the occurrence, the checkedness state of all the other elements in the same radio button group must be set to false:

The element's checkedness state is set to true (for whatever reason).
The element's name attribute is set, changed, or removed.
The element's form owner changes.
A type change is signalled for the element.
The input activation behavior is to fire an event named input at the element, with the bubbles attribute initialized to true, and then fire an event named change at the element, with the bubbles attribute initialized to true.

Constraint validation: If an element in the radio button group is required, and all of the input elements in the radio button group have a checkedness that is false, then the element is suffering from being missing.

The following example, for some reason, has specified that puppers are both required and disabled:

<form>
 <p><label><input type="radio" name="dog-type" value="pupper" required disabled> Pupper</label>
 <p><label><input type="radio" name="dog-type" value="doggo"> Doggo</label>
 <p><button>Make your choice</button>
</form>
If the user tries to submit this form without first selecting "Doggo", then both input elements will be suffering from being missing, since an element in the radio button group is required (viz. the first element), and both of the elements in the radio button group have a false checkedness.

On the other hand, if the user selects "Doggo" and then submits the form, then neither input element will be suffering from being missing, since while one of them is required, not all of them have a false checkedness.

If none of the radio buttons in a radio button group are checked, then they will all be initially unchecked in the interface, until such time as one of them is checked (either by the user or by script).

The following common input element content attributes and IDL attributes apply to the element: checked and required content attributes; checked and value IDL attributes.

The value IDL attribute is in mode default/on.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: accept, alt, autocomplete, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

4.10.5.1.17 File Upload state (type=file)
When an input element's type attribute is in the File Upload state, the rules in this section apply.

The input element represents a list of selected files, each file consisting of a file name, a file type, and a file body (the contents of the file).

File names must not contain path components, even in the case that a user has selected an entire directory hierarchy or multiple files with the same name from different directories. Path components, for the purposes of the File Upload state, are those parts of file names that are separated by U+005C REVERSE SOLIDUS character (\) characters.

Unless the multiple attribute is set, there must be no more than one file in the list of selected files.

The element's input activation behavior is to run the following steps:

If the algorithm is not triggered by user activation, then return without doing anything else.

Run these steps in parallel:

Optionally, wait until any prior execution of this algorithm has terminated.

Display a prompt to the user requesting that the user specify some files. If the multiple attribute is not set, there must be no more than one file selected; otherwise, any number may be selected. Files can be from the filesystem or created on the fly, e.g., a picture taken from a camera connected to the user's device.

Wait for the user to have made their selection.

Queue a task to first update the element's selected files so that it represents the user's selection, then fire an event named input at the input element, with the bubbles attribute initialized to true, and finally fire an event named change at the input element, with the bubbles attribute initialized to true.

If the element is mutable, the user agent should allow the user to change the files on the list in other ways also, e.g. adding or removing files by drag-and-drop. When the user does so, the user agent must queue a task to first update the element's selected files so that it represents the user's new selection, then fire an event named input at the input element, with the bubbles attribute initialized to true, and finally fire an event named change at the input element, with the bubbles attribute initialized to true.

If the element is not mutable, the user agent must not allow the user to change the element's selection.

Constraint validation: If the element is required and the list of selected files is empty, then the element is suffering from being missing.

The accept attribute may be specified to provide user agents with a hint of what file types will be accepted.


Support: input-file-accept
Chrome for Android (limited)	64+
Chrome	26+
iOS Safari (limited)	8+
UC Browser for Android	None
Firefox	37+
Samsung Internet (limited)	4+
IE	10+
Opera Mini	None
Safari	11.1+
Edge	None
Android Browser	None
Opera	15+

Source: caniuse.com

If specified, the attribute must consist of a set of comma-separated tokens, each of which must be an ASCII case-insensitive match for one of the following:

The string "audio/*"
Indicates that sound files are accepted.
The string "video/*"
Indicates that video files are accepted.
The string "image/*"
Indicates that image files are accepted.
A valid MIME type string with no parameters
Indicates that files of the specified type are accepted.
A string whose first character is a U+002E FULL STOP character (.)
Indicates that files with the specified file extension are accepted.
The tokens must not be ASCII case-insensitive matches for any of the other tokens (i.e. duplicates are not allowed). To obtain the list of tokens from the attribute, the user agent must split the attribute value on commas.

User agents may use the value of this attribute to display a more appropriate user interface than a generic file picker. For instance, given the value image/*, a user agent could offer the user the option of using a local camera or selecting a photograph from their photo collection; given the value audio/*, a user agent could offer the user the option of recording a clip using a headset microphone.

User agents should prevent the user from selecting files that are not accepted by one (or more) of these tokens.

Authors are encouraged to specify both any MIME types and any corresponding extensions when looking for data in a specific format.

For example, consider an application that converts Microsoft Word documents to Open Document Format files. Since Microsoft Word documents are described with a wide variety of MIME types and extensions, the site can list several, as follows:

<input type="file" accept=".doc,.docx,.xml,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
On platforms that only use file extensions to describe file types, the extensions listed here can be used to filter the allowed documents, while the MIME types can be used with the system's type registration table (mapping MIME types to extensions used by the system), if any, to determine any other extensions to allow. Similarly, on a system that does not have file names or extensions but labels documents with MIME types internally, the MIME types can be used to pick the allowed files, while the extensions can be used if the system has an extension registration table that maps known extensions to MIME types used by the system.

Extensions tend to be ambiguous (e.g. there are an untold number of formats that use the ".dat" extension, and users can typically quite easily rename their files to have a ".doc" extension even if they are not Microsoft Word documents), and MIME types tend to be unreliable (e.g. many formats have no formally registered types, and many formats are in practice labeled using a number of different MIME types). Authors are reminded that, as usual, data received from a client should be treated with caution, as it may not be in an expected format even if the user is not hostile and the user agent fully obeyed the accept attribute's requirements.

For historical reasons, the value IDL attribute prefixes the file name with the string "C:\fakepath\". Some legacy user agents actually included the full path (which was a security vulnerability). As a result of this, obtaining the file name from the value IDL attribute in a backwards-compatible way is non-trivial. The following function extracts the file name in a suitably compatible manner:

function extractFilename(path) {
  if (path.substr(0, 12) == "C:\\fakepath\\")
    return path.substr(12); // modern browser
  var x;
  x = path.lastIndexOf('/');
  if (x >= 0) // Unix-based path
    return path.substr(x+1);
  x = path.lastIndexOf('\\');
  if (x >= 0) // Windows-based path
    return path.substr(x+1);
  return path; // just the file name
}
This can be used as follows:

<p><input type=file name=image onchange="updateFilename(this.value)"></p>
<p>The name of the file you picked is: <span id="filename">(none)</span></p>
<script>
 function updateFilename(path) {
   var name = extractFilename(path);
   document.getElementById('filename').textContent = name;
 }
</script>
The following common input element content attributes and IDL attributes apply to the element: accept, multiple, and required content attributes; files and value IDL attributes; select() method.

The value IDL attribute is in mode filename.

The input and change events apply.

The following content attributes must not be specified and do not apply to the element: alt, autocomplete, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, pattern, placeholder, readonly, size, src, step, and width.

The element's value attribute must be omitted.

The following IDL attributes and methods do not apply to the element: checked, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

4.10.5.1.18 Submit Button state (type=submit)
When an input element's type attribute is in the Submit Button state, the rules in this section apply.

The input element represents a button that, when activated, submits the form. If the element has a value attribute, the button's label must be the value of that attribute; otherwise, it must be an implementation-defined string that means "Submit" or some such. The element is a button, specifically a submit button.
Since the default label is implementation-defined, and the width of the button typically depends on the button's label, the button's width can leak a few bits of fingerprintable information. These bits are likely to be strongly correlated to the identity of the user agent and the user's locale.

The element's input activation behavior is as follows: if the element has a form owner, and the element's node document is fully active, submit the form owner from the input element; otherwise, do nothing.

The formaction, formenctype, formmethod, formnovalidate, and formtarget attributes are attributes for form submission.

The formnovalidate attribute can be used to make submit buttons that do not trigger the constraint validation.

The following common input element content attributes and IDL attributes apply to the element: formaction, formenctype, formmethod, formnovalidate, and formtarget content attributes; value IDL attribute.

The value IDL attribute is in mode default.

The following content attributes must not be specified and do not apply to the element: accept, alt, autocomplete, checked, dirname, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

The input and change events do not apply.

4.10.5.1.19 Image Button state (type=image)
When an input element's type attribute is in the Image Button state, the rules in this section apply.

The input element represents either an image from which a user can select a coordinate and submit the form, or alternatively a button from which the user can submit the form. The element is a button, specifically a submit button.

The coordinate is sent to the server during form submission by sending two entries for the element, derived from the name of the control but with ".x" and ".y" appended to the name with the x and y components of the coordinate respectively.

The image is given by the src attribute. The src attribute must be present, and must contain a valid non-empty URL potentially surrounded by spaces referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.

When any of the these events occur

the input element's type attribute is first set to the Image Button state (possibly when the element is first created), and the src attribute is present
the input element's type attribute is changed back to the Image Button state, and the src attribute is present, and its value has changed since the last time the type attribute was in the Image Button state
the input element's type attribute is in the Image Button state, and the src attribute is set or changed
then unless the user agent cannot support images, or its support for images has been disabled, or the user agent only fetches images on demand, or the src attribute's value is the empty string, the user agent must parse the value of the src attribute value, relative to the element's node document, and if that is successful, then:

Let request be a new request whose url is the resulting URL record, client is the element's node document's relevant settings object, destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.

Fetch request.

Fetching the image must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined below) has been run.

If the image was successfully obtained, with no network errors, and the image's type is a supported image type, and the image is a valid image of that type, then the image is said to be available. If this is true before the image is completely downloaded, each task that is queued by the networking task source while the image is being fetched must update the presentation of the image appropriately.

The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type headers giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's associated Content-Type headers.

User agents must not support non-image resources with the input element. User agents must not run executable code embedded in the image resource. User agents must only display the first page of a multipage resource. User agents must not allow the resource to act in an interactive fashion, but should honor any animation in the resource.

The task that is queued by the networking task source once the resource has been fetched, must, if the download was successful and the image is available, queue a task to fire an event named load at the input element; and otherwise, if the fetching process fails without a response from the remote server, or completes but the image is not a valid or supported image, queue a task to fire an event named error on the input element.

The alt attribute provides the textual label for the button for users and user agents who cannot use the image. The alt attribute must be present, and must contain a non-empty string giving the label that would be appropriate for an equivalent button if the image was unavailable.

The input element supports dimension attributes.

If the src attribute is set, and the image is available and the user agent is configured to display that image, then: The element represents a control for selecting a coordinate from the image specified by the src attribute; if the element is mutable, the user agent should allow the user to select this coordinate, and the element's input activation behavior is as follows: if the element has a form owner, and the element's node document is fully active, take the user's selected coordinate, and submit the input element's form owner from the input element. If the user activates the control without explicitly selecting a coordinate, then the coordinate (0,0) must be assumed.

Otherwise, the element represents a submit button whose label is given by the value of the alt attribute; the element's input activation behavior is as follows: if the element has a form owner, and the element's node document is fully active, set the selected coordinate to (0,0), and submit the input element's form owner from the input element.

In either case, if the element has no form owner or the element's node document is not fully active, then its input activation behavior must be to do nothing..

The selected coordinate must consist of an x-component and a y-component. The coordinates represent the position relative to the edge of the image, with the coordinate space having the positive x direction to the right, and the positive y direction downwards.

The x-component must be a valid integer representing a number x in the range −(borderleft+paddingleft) ≤ x ≤ width+borderright+paddingright, where width is the rendered width of the image, borderleft is the width of the border on the left of the image, paddingleft is the width of the padding on the left of the image, borderright is the width of the border on the right of the image, and paddingright is the width of the padding on the right of the image, with all dimensions given in CSS pixels.

The y-component must be a valid integer representing a number y in the range −(bordertop+paddingtop) ≤ y ≤ height+borderbottom+paddingbottom, where height is the rendered height of the image, bordertop is the width of the border above the image, paddingtop is the width of the padding above the image, borderbottom is the width of the border below the image, and paddingbottom is the width of the padding below the image, with all dimensions given in CSS pixels.

Where a border or padding is missing, its width is zero CSS pixels.

The formaction, formenctype, formmethod, formnovalidate, and formtarget attributes are attributes for form submission.

image . width [ = value ]
image . height [ = value ]
These attributes return the actual rendered dimensions of the image, or zero if the dimensions are not known.

They can be set, to change the corresponding content attributes.

The following common input element content attributes and IDL attributes apply to the element: alt, formaction, formenctype, formmethod, formnovalidate, formtarget, height, src, and width content attributes; value IDL attribute.

The value IDL attribute is in mode default.

The following content attributes must not be specified and do not apply to the element: accept, autocomplete, checked, dirname, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, and step.

The element's value attribute must be omitted.

The following IDL attributes and methods do not apply to the element: checked, files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

The input and change events do not apply.

Many aspects of this state's behavior are similar to the behavior of the img element. Readers are encouraged to read that section, where many of the same requirements are described in more detail.

Take the following form:

<form action="process.cgi">
 <input type=image src=map.png name=where alt="Show location list">
</form>
If the user clicked on the image at coordinate (127,40) then the URL used to submit the form would be "process.cgi?where.x=127&where.y=40".

(In this example, it's assumed that for users who don't see the map, and who instead just see a button labeled "Show location list", clicking the button will cause the server to show a list of locations to pick from instead of the map.)

4.10.5.1.20 Reset Button state (type=reset)
When an input element's type attribute is in the Reset Button state, the rules in this section apply.

The input element represents a button that, when activated, resets the form. If the element has a value attribute, the button's label must be the value of that attribute; otherwise, it must be an implementation-defined string that means "Reset" or some such. The element is a button.
Since the default label is implementation-defined, and the width of the button typically depends on the button's label, the button's width can leak a few bits of fingerprintable information. These bits are likely to be strongly correlated to the identity of the user agent and the user's locale.

The element's input activation behavior, if the element has a form owner and the element's node document is fully active, is to reset the form owner; otherwise, it is to do nothing.

Constraint validation: The element is barred from constraint validation.

The value IDL attribute applies to this element and is in mode default.

The following content attributes must not be specified and do not apply to the element: accept, alt, autocomplete, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

The input and change events do not apply.

4.10.5.1.21 Button state (type=button)
When an input element's type attribute is in the Button state, the rules in this section apply.

The input element represents a button with no default behavior. A label for the button must be provided in the value attribute, though it may be the empty string. If the element has a value attribute, the button's label must be the value of that attribute; otherwise, it must be the empty string. The element is a button.

The element has no input activation behavior.

Constraint validation: The element is barred from constraint validation.

The value IDL attribute applies to this element and is in mode default.

The following content attributes must not be specified and do not apply to the element: accept, alt, autocomplete, checked, dirname, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, maxlength, min, minlength, multiple, pattern, placeholder, readonly, required, size, src, step, and width.

The following IDL attributes and methods do not apply to the element: checked, files, list, selectionStart, selectionEnd, selectionDirection, valueAsDate, and valueAsNumber IDL attributes; select(), setRangeText(), setSelectionRange(), stepDown(), and stepUp() methods.

The input and change events do not apply.

4.10.5.2 Implementation notes regarding localization of form controls
This section is non-normative.

The formats shown to the user in date, time, and number controls is independent of the format used for form submission.

Browsers are encouraged to use user interfaces that present dates, times, and numbers according to the conventions of either the locale implied by the input element's language or the user's preferred locale. Using the page's locale will ensure consistency with page-provided data.

For example, it would be confusing to users if an American English page claimed that a Cirque De Soleil show was going to be showing on 02/03, but their browser, configured to use the British English locale, only showed the date 03/02 in the ticket purchase date picker. Using the page's locale would at least ensure that the date was presented in the same format everywhere. (There's still a risk that the user would end up arriving a month late, of course, but there's only so much that can be done about such cultural differences...)

4.10.5.3 Common input element attributes
These attributes only apply to an input element if its type attribute is in a state whose definition declares that the attribute applies. When an attribute doesn't apply to an input element, user agents must ignore the attribute, regardless of the requirements and definitions below.

4.10.5.3.1 The maxlength and minlength attributes

Support: input-minlength
Chrome for Android	64+
Chrome	40+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	51+
Samsung Internet	5+
IE	None
Opera Mini	None
Safari	10.1+
Edge	17+
Android Browser	62+
Opera	27+

Source: caniuse.com

The maxlength attribute, when it applies, is a form control maxlength attribute.


Support: maxlength
Chrome for Android	64+
Chrome	4+
iOS Safari	9.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini (limited)	all+
Safari	5.1+
Edge	12+
Android Browser	2.3+
Opera	15+

Source: caniuse.com

The minlength attribute, when it applies, is a form control minlength attribute.

If the input element has a maximum allowed value length, then the JavaScript string length of the value of the element's value attribute must be equal to or less than the element's maximum allowed value length.

The following extract shows how a messaging client's text entry could be arbitrarily restricted to a fixed number of characters, thus forcing any conversation through this medium to be terse and discouraging intelligent discourse.

<label>What are you doing? <input name=status maxlength=140></label>
Here, a password is given a minimum length:

<p><label>Username: <input name=u required></label>
<p><label>Password: <input name=p required minlength=12></label>
4.10.5.3.2 The size attribute
The size attribute gives the number of characters that, in a visual rendering, the user agent is to allow the user to see while editing the element's value.

The size attribute, if specified, must have a value that is a valid non-negative integer greater than zero.

If the attribute is present, then its value must be parsed using the rules for parsing non-negative integers, and if the result is a number greater than zero, then the user agent should ensure that at least that many characters are visible.

The size IDL attribute is limited to only non-negative numbers greater than zero and has a default value of 20.

4.10.5.3.3 The readonly attribute
The readonly attribute is a boolean attribute that controls whether or not the user can edit the form control. When specified, the element is not mutable.


Support: readonly-attr
Chrome for Android	64+
Chrome	26+
iOS Safari	7.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	6+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	2.3+
Opera	15+

Source: caniuse.com

Constraint validation: If the readonly attribute is specified on an input element, the element is barred from constraint validation.

The difference between disabled and readonly is that read-only controls can still function, whereas disabled controls generally do not function as controls until they are enabled. This is spelled out in more detail elsewhere in this specification with normative requirements that refer to the disabled concept (for example, the element's activation behavior, whether or not it is a focusable area, or when constructing the form data set). Any other behavior related to user interaction with disabled controls, such as whether text can be selected or copied, is not defined in this specification.

Only text controls can be made read-only, since for other controls (such as checkboxes and buttons) there is no useful distinction between being read-only and being disabled, so the readonly attribute does not apply.

In the following example, the existing product identifiers cannot be modified, but they are still displayed as part of the form, for consistency with the row representing a new product (where the identifier is not yet filled in).

<form action="products.cgi" method="post" enctype="multipart/form-data">
 <table>
  <tr> <th> Product ID <th> Product name <th> Price <th> Action
  <tr>
   <td> <input readonly="readonly" name="1.pid" value="H412">
   <td> <input required="required" name="1.pname" value="Floor lamp Ulke">
   <td> $<input required="required" type="number" min="0" step="0.01" name="1.pprice" value="49.99">
   <td> <button formnovalidate="formnovalidate" name="action" value="delete:1">Delete</button>
  <tr>
   <td> <input readonly="readonly" name="2.pid" value="FG28">
   <td> <input required="required" name="2.pname" value="Table lamp Ulke">
   <td> $<input required="required" type="number" min="0" step="0.01" name="2.pprice" value="24.99">
   <td> <button formnovalidate="formnovalidate" name="action" value="delete:2">Delete</button>
  <tr>
   <td> <input required="required" name="3.pid" value="" pattern="[A-Z0-9]+">
   <td> <input required="required" name="3.pname" value="">
   <td> $<input required="required" type="number" min="0" step="0.01" name="3.pprice" value="">
   <td> <button formnovalidate="formnovalidate" name="action" value="delete:3">Delete</button>
 </table>
 <p> <button formnovalidate="formnovalidate" name="action" value="add">Add</button> </p>
 <p> <button name="action" value="update">Save</button> </p>
</form>
4.10.5.3.4 The required attribute
The required attribute is a boolean attribute. When specified, the element is required.

Constraint validation: If the element is required, and its value IDL attribute applies and is in the mode value, and the element is mutable, and the element's value is the empty string, then the element is suffering from being missing.

The following form has two required fields, one for an e-mail address and one for a password. It also has a third field that is only considered valid if the user types the same password in the password field and this third field.

<h1>Create new account</h1>
<form action="/newaccount" method=post
      oninput="up2.setCustomValidity(up2.value != up.value ? 'Passwords do not match.' : '')">
 <p>
  <label for="username">E-mail address:</label>
  <input id="username" type=email required name=un>
 <p>
  <label for="password1">Password:</label>
  <input id="password1" type=password required name=up>
 <p>
  <label for="password2">Confirm password:</label>
  <input id="password2" type=password name=up2>
 <p>
  <input type=submit value="Create account">
</form>
For radio buttons, the required attribute is satisfied if any of the radio buttons in the group is selected. Thus, in the following example, any of the radio buttons can be checked, not just the one marked as required:

<fieldset>
 <legend>Did the movie pass the Bechdel test?</legend>
 <p><label><input type="radio" name="bechdel" value="no-characters"> No, there are not even two female characters in the movie. </label>
 <p><label><input type="radio" name="bechdel" value="no-names"> No, the female characters never talk to each other. </label>
 <p><label><input type="radio" name="bechdel" value="no-topic"> No, when female characters talk to each other it's always about a male character. </label>
 <p><label><input type="radio" name="bechdel" value="yes" required> Yes. </label>
 <p><label><input type="radio" name="bechdel" value="unknown"> I don't know. </label>
</fieldset>
To avoid confusion as to whether a radio button group is required or not, authors are encouraged to specify the attribute on all the radio buttons in a group. Indeed, in general, authors are encouraged to avoid having radio button groups that do not have any initially checked controls in the first place, as this is a state that the user cannot return to, and is therefore generally considered a poor user interface.

4.10.5.3.5 The multiple attribute
The multiple attribute is a boolean attribute that indicates whether the user is to be allowed to specify more than one value.


Support: input-file-multiple
Chrome for Android (limited)	64+
Chrome	5+
iOS Safari	6.0+
UC Browser for Android	None
Firefox	3.6+
Samsung Internet (limited)	5+
IE	10+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	None
Opera	10.6+

Source: caniuse.com

The following extract shows how an e-mail client's "To" field could accept multiple e-mail addresses.

<label>To: <input type=email multiple name=to></label>
If the user had, amongst many friends in their user contacts database, two friends "Spider-Man" (with address "spider@parker.example.net") and "Scarlet Witch" (with address "scarlet@avengers.example.net"), then, after the user has typed "s", the user agent might suggest these two e-mail addresses to the user.



The page could also link in the user's contacts database from the site:

<label>To: <input type=email multiple name=to list=contacts></label>
...
<datalist id="contacts">
 <option value="hedral@damowmow.com">
 <option value="pillar@example.com">
 <option value="astrophy@cute.example">
 <option value="astronomy@science.example.org">
</datalist>
Suppose the user had entered "bob@example.net" into this text control, and then started typing a second e-mail address starting with "s". The user agent might show both the two friends mentioned earlier, as well as the "astrophy" and "astronomy" values given in the datalist element.



The following extract shows how an e-mail client's "Attachments" field could accept multiple files for upload.

<label>Attachments: <input type=file multiple name=att></label>
4.10.5.3.6 The pattern attribute

Support: input-pattern
Chrome for Android	64+
Chrome	10+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	10.1+
Edge	12+
Android Browser	4.4.3+
Opera	9.5+

Source: caniuse.com

The pattern attribute specifies a regular expression against which the control's value, or, when the multiple attribute applies and is set, the control's values, are to be checked.

If specified, the attribute's value must match the JavaScript Pattern production.

If an input element has a pattern attribute specified, and the attribute's value, when compiled as a JavaScript regular expression with only the "u" flag specified, compiles successfully, then the resulting regular expression is the element's compiled pattern regular expression. If the element has no such attribute, or if the value doesn't compile successfully, then the element has no compiled pattern regular expression. [JAVASCRIPT]

If the value doesn't compile successfully, user agents are encouraged to log this fact in a developer console, to aid debugging.

Constraint validation: If the element's value is not the empty string, and either the element's multiple attribute is not specified or it does not apply to the input element given its type attribute's current state, and the element has a compiled pattern regular expression but that regular expression does not match the entirety of the element's value, then the element is suffering from a pattern mismatch.

Constraint validation: If the element's value is not the empty string, and the element's multiple attribute is specified and applies to the input element, and the element has a compiled pattern regular expression but that regular expression does not match the entirety of each of the element's values, then the element is suffering from a pattern mismatch.

The compiled pattern regular expression, when matched against a string, must have its start anchored to the start of the string and its end anchored to the end of the string.

This implies that the regular expression language used for this attribute is the same as that used in JavaScript, except that the pattern attribute is matched against the entire value, not just any subset (somewhat as if it implied a ^(?: at the start of the pattern and a )$ at the end).

When an input element has a pattern attribute specified, authors should include a title attribute to give a description of the pattern. User agents may use the contents of this attribute, if it is present, when informing the user that the pattern is not matched, or at any other suitable time, such as in a tooltip or read out by assistive technology when the control gains focus.

For example, the following snippet:

<label> Part number:
 <input pattern="[0-9][A-Z]{3}" name="part"
        title="A part number is a digit followed by three uppercase letters."/>
</label>
...could cause the UA to display an alert such as:

A part number is a digit followed by three uppercase letters.
You cannot submit this form when the field is incorrect.
When a control has a pattern attribute, the title attribute, if used, must describe the pattern. Additional information could also be included, so long as it assists the user in filling in the control. Otherwise, assistive technology would be impaired.

For instance, if the title attribute contained the caption of the control, assistive technology could end up saying something like The text you have entered does not match the required pattern. Birthday, which is not useful.

UAs may still show the title in non-error situations (for example, as a tooltip when hovering over the control), so authors should be careful not to word titles as if an error has necessarily occurred.

4.10.5.3.7 The min and max attributes
Some form controls can have explicit constraints applied limiting the allowed range of values that the user can provide. Normally, such a range would be linear and continuous. A form control can have a periodic domain, however, in which case the form control's broadest possible range is finite, and authors can specify explicit ranges within it that span the boundaries.

Specifically, the broadest range of a type=time control is midnight to midnight (24 hours), and authors can set both continuous linear ranges (such as 9pm to 11pm) and discontinuous ranges spanning midnight (such as 11pm to 1am).

The min and max attributes indicate the allowed range of values for the element.

Their syntax is defined by the section that defines the type attribute's current state.

If the element has a min attribute, and the result of applying the algorithm to convert a string to a number to the value of the min attribute is a number, then that number is the element's minimum; otherwise, if the type attribute's current state defines a default minimum, then that is the minimum; otherwise, the element has no minimum.

The min attribute also defines the step base.

If the element has a max attribute, and the result of applying the algorithm to convert a string to a number to the value of the max attribute is a number, then that number is the element's maximum; otherwise, if the type attribute's current state defines a default maximum, then that is the maximum; otherwise, the element has no maximum.

If the element does not have a periodic domain, the max attribute's value (the maximum) must not be less than the min attribute's value (its minimum).

If an element that does not have a periodic domain has a maximum that is less than its minimum, then so long as the element has a value, it will either be suffering from an underflow or suffering from an overflow.

An element has a reversed range if it has a periodic domain and its maximum is less than its minimum.

An element has range limitations if it has a defined minimum or a defined maximum.

Constraint validation: When the element has a minimum and does not have a reversed range, and the result of applying the algorithm to convert a string to a number to the string given by the element's value is a number, and the number obtained from that algorithm is less than the minimum, the element is suffering from an underflow.

Constraint validation: When the element has a maximum and does not have a reversed range, and the result of applying the algorithm to convert a string to a number to the string given by the element's value is a number, and the number obtained from that algorithm is more than the maximum, the element is suffering from an overflow.

Constraint validation: When an element has a reversed range, and the result of applying the algorithm to convert a string to a number to the string given by the element's value is a number, and the number obtained from that algorithm is more than the maximum and less than the minimum, the element is simultaneously suffering from an underflow and suffering from an overflow.

The following date control limits input to dates that are before the 1980s:

<input name=bday type=date max="1979-12-31">
The following number control limits input to whole numbers greater than zero:

<input name=quantity required="" type="number" min="1" value="1">
The following time control limits input to those minutes that occur between 9pm and 6am, defaulting to midnight:

<input name="sleepStart" type=time min="21:00" max="06:00" step="60" value="00:00">
4.10.5.3.8 The step attribute
The step attribute indicates the granularity that is expected (and required) of the value or values, by limiting the allowed values. The section that defines the type attribute's current state also defines the default step, the step scale factor, and in some cases the default step base, which are used in processing the attribute as described below.

The step attribute, if specified, must either have a value that is a valid floating-point number that parses to a number that is greater than zero, or must have a value that is an ASCII case-insensitive match for the string "any".

The attribute provides the allowed value step for the element, as follows:

If the attribute is absent, then the allowed value step is the default step multiplied by the step scale factor.
Otherwise, if the attribute's value is an ASCII case-insensitive match for the string "any", then there is no allowed value step.
Otherwise, if the rules for parsing floating-point number values, when they are applied to the attribute's value, return an error, zero, or a number less than zero, then the allowed value step is the default step multiplied by the step scale factor.
Otherwise, the allowed value step is the number returned by the rules for parsing floating-point number values when they are applied to the attribute's value, multiplied by the step scale factor.
The step base is the value returned by the following algorithm:

If the element has a min content attribute, and the result of applying the algorithm to convert a string to a number to the value of the min content attribute is not an error, then return that result.

If the element has a value content attribute, and the result of applying the algorithm to convert a string to a number to the value of the value content attribute is not an error, then return that result.

If a default step base is defined for this element given its type attribute's state, then return it.

Return zero.

Constraint validation: When the element has an allowed value step, and the result of applying the algorithm to convert a string to a number to the string given by the element's value is a number, and that number subtracted from the step base is not an integral multiple of the allowed value step, the element is suffering from a step mismatch.

The following range control only accepts values in the range 0..1, and allows 256 steps in that range:

<input name=opacity type=range min=0 max=1 step=0.00392156863>
The following control allows any time in the day to be selected, with any accuracy (e.g. thousandth-of-a-second accuracy or more):

<input name=favtime type=time step=any>
Normally, time controls are limited to an accuracy of one minute.

4.10.5.3.9 The list attribute
The list attribute is used to identify an element that lists predefined options suggested to the user.

If present, its value must be the ID of a datalist element in the same tree.

The suggestions source element is the first element in the tree in tree order to have an ID equal to the value of the list attribute, if that element is a datalist element. If there is no list attribute, or if there is no element with that ID, or if the first element with that ID is not a datalist element, then there is no suggestions source element.

If there is a suggestions source element, then, when the user agent is allowing the user to edit the input element's value, the user agent should offer the suggestions represented by the suggestions source element to the user in a manner suitable for the type of control used. If appropriate, the user agent should use the suggestion's label and value to identify the suggestion to the user.

User agents are encouraged to filter the suggestions represented by the suggestions source element when the number of suggestions is large, including only the most relevant ones (e.g. based on the user's input so far). No precise threshold is defined, but capping the list at four to seven values is reasonable. If filtering based on the user's input, user agents should use substring matching against both the suggestions' label and value.

This text field allows you to choose a type of JavaScript function.

<input type="text" list="function-types">
<datalist id="function-types">
  <option value="function">function</option>
  <option value="async function">async function</option>
  <option value="function*">generator function</option>
  <option value="=>">arrow function</option>
  <option value="async =>">async arrow function</option>
  <option value="async function*">async generator function</option>
</datalist>
For user agents that follow the above suggestions, both the label and value would be shown:



Then, typing "arrow" or "=>" would filter the list to the entries with labels "arrow function" and "async arrow function". Typing "generator" or "*" would filter the list to the entries with labels "generator function" and "async generator function".

As always, user agents are free to make user interface decisions which are appropriate for their particular requirements and for the user's particular circumstances. However, this has historically been an area of confusion for implementers, web developers, and users alike, so we've given some "should" suggestions above.

How user selections of suggestions are handled depends on whether the element is a control accepting a single value only, or whether it accepts multiple values:

If the element does not have a multiple attribute specified or if the multiple attribute does not apply
When the user selects a suggestion, the input element's value must be set to the selected suggestion's value, as if the user had written that value themself.

If the element's type attribute is in the Email state and the element has a multiple attribute specified
When the user selects a suggestion, the user agent must either add a new entry to the input element's values, whose value is the selected suggestion's value, or change an existing entry in the input element's values to have the value given by the selected suggestion's value, as if the user had themself added an entry with that value, or edited an existing entry to be that value. Which behavior is to be applied depends on the user interface in a user-agent-defined manner.

If the list attribute does not apply, there is no suggestions source element.

This URL field offers some suggestions.

<label>Homepage: <input name=hp type=url list=hpurls></label>
<datalist id=hpurls>
 <option value="https://www.google.com/" label="Google">
 <option value="https://www.reddit.com/" label="Reddit">
</datalist>
Other URLs from the user's history might show also; this is up to the user agent.

This example demonstrates how to design a form that uses the autocompletion list feature while still degrading usefully in legacy user agents.

If the autocompletion list is merely an aid, and is not important to the content, then simply using a datalist element with children option elements is enough. To prevent the values from being rendered in legacy user agents, they need to be placed inside the value attribute instead of inline.

<p>
 <label>
  Enter a breed:
  <input type="text" name="breed" list="breeds">
  <datalist id="breeds">
   <option value="Abyssinian">
   <option value="Alpaca">
   <!-- ... -->
  </datalist>
 </label>
</p>
However, if the values need to be shown in legacy UAs, then fallback content can be placed inside the datalist element, as follows:

<p>
 <label>
  Enter a breed:
  <input type="text" name="breed" list="breeds">
 </label>
 <datalist id="breeds">
  <label>
   or select one from the list:
   <select name="breed">
    <option value=""> (none selected)
    <option>Abyssinian
    <option>Alpaca
    <!-- ... -->
   </select>
  </label>
 </datalist>
</p>
The fallback content will only be shown in UAs that don't support datalist. The options, on the other hand, will be detected by all UAs, even though they are not children of the datalist element.

Note that if an option element used in a datalist is selected, it will be selected by default by legacy UAs (because it affects the select), but it will not have any effect on the input element in UAs that support datalist.

4.10.5.3.10 The placeholder attribute
The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format. The attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.


Support: input-placeholder
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	all+
Safari	5+
Edge	12+
Android Browser	4.2+
Opera	11.5+

Source: caniuse.com

The placeholder attribute should not be used as an alternative to a label. For a longer hint or other advisory text, the title attribute is more appropriate.

These mechanisms are very similar but subtly different: the hint given by the control's label is shown at all times; the short hint given in the placeholder attribute is shown before the user enters a value; and the hint in the title attribute is shown when the user requests further help.

User agents should present this hint to the user, after having stripped newlines from it, when the element's value is the empty string, especially if the control is not focused.

If a user agent normally doesn't show this hint to the user when the control is focused, then the user agent should nonetheless show the hint for the control if it was focused as a result of the autofocus attribute, since in that case the user will not have had an opportunity to examine the control before focusing it.

Here is an example of a mail configuration user interface that uses the placeholder attribute:

<fieldset>
 <legend>Mail Account</legend>
 <p><label>Name: <input type="text" name="fullname" placeholder="John Ratzenberger"></label></p>
 <p><label>Address: <input type="email" name="address" placeholder="john@example.net"></label></p>
 <p><label>Password: <input type="password" name="password"></label></p>
 <p><label>Description: <input type="text" name="desc" placeholder="My Email Account"></label></p>
</fieldset>
In situations where the control's content has one directionality but the placeholder needs to have a different directionality, Unicode's bidirectional-algorithm formatting characters can be used in the attribute value:

<input name=t1 type=tel placeholder="&#x202B; رقم الهاتف 1 &#x202E;">
<input name=t2 type=tel placeholder="&#x202B; رقم الهاتف 2 &#x202E;">
For slightly more clarity, here's the same example using numeric character references instead of inline Arabic:

<input name=t1 type=tel placeholder="&#x202B;&#1585;&#1602;&#1605; &#1575;&#1604;&#1607;&#1575;&#1578;&#1601; 1&#x202E;">
<input name=t2 type=tel placeholder="&#x202B;&#1585;&#1602;&#1605; &#1575;&#1604;&#1607;&#1575;&#1578;&#1601; 2&#x202E;">
4.10.5.4 Common input element APIs
input . value [ = value ]
Returns the current value of the form control.

Can be set, to change the value.

Throws an "InvalidStateError" DOMException if it is set to any value other than the empty string when the control is a file upload control.

input . checked [ = value ]
Returns the current checkedness of the form control.

Can be set, to change the checkedness.

input . files [ = files ]
Returns a FileList object listing the selected files of the form control.

Returns null if the control isn't a file control.

Can be set to a FileList object to change the selected files of the form control. For instance, as the result of a drag-and-drop operation.

input . valueAsDate [ = value ]
Returns a Date object representing the form control's value, if applicable; otherwise, returns null.

Can be set, to change the value.

Throws an "InvalidStateError" DOMException if the control isn't date- or time-based.

input . valueAsNumber [ = value ]
Returns a number representing the form control's value, if applicable; otherwise, returns NaN.

Can be set, to change the value. Setting this to NaN will set the underlying value to the empty string.

Throws an "InvalidStateError" DOMException if the control is neither date- or time-based nor numeric.

input . stepUp( [ n ] )
input . stepDown( [ n ] )
Changes the form control's value by the value given in the step attribute, multiplied by n. The default value for n is 1.

Throws "InvalidStateError" DOMException if the control is neither date- or time-based nor numeric, or if the step attribute's value is "any".

input . list
Returns the datalist element indicated by the list attribute.

The value IDL attribute allows scripts to manipulate the value of an input element. The attribute is in one of the following modes, which define its behavior:

value
On getting, return the current value of the element.

On setting:

Let oldValue be the element's value.

Set the element's value to the new value.

Set the element's dirty value flag to true.

Invoke the value sanitization algorithm, if the element's type attribute's current state defines one.

If the element's value (after applying the value sanitization algorithm) is different from oldValue, and the element has a text entry cursor position, move the text entry cursor position to the end of the text control, unselecting any selected text and resetting the selection direction to "none".

default
On getting, if the element has a value content attribute, return that attribute's value; otherwise, return the empty string.

On setting, set the value of the element's value content attribute to the new value.

default/on
On getting, if the element has a value content attribute, return that attribute's value; otherwise, return the string "on".

On setting, set the value of the element's value content attribute to the new value.

filename
On getting, return the string "C:\fakepath\" followed by the name of the first file in the list of selected files, if any, or the empty string if the list is empty.

On setting, if the new value is the empty string, empty the list of selected files; otherwise, throw an "InvalidStateError" DOMException.

This "fakepath" requirement is a sad accident of history. See the example in the File Upload state section for more information.

Since path components are not permitted in file names in the list of selected files, the "\fakepath\" cannot be mistaken for a path component.

The checked IDL attribute allows scripts to manipulate the checkedness of an input element. On getting, it must return the current checkedness of the element; and on setting, it must set the element's checkedness to the new value and set the element's dirty checkedness flag to true.

The files IDL attribute allows scripts to access the element's selected files.

On getting, if the IDL attribute applies, it must return a FileList object that represents the current selected files. The same object must be returned until the list of selected files changes. If the IDL attribute does not apply, then it must instead return null. [FILEAPI]

On setting, it must run these steps:

If the IDL attribute does not apply or the given value is null, then return.

Replace the element's selected files with the given value.

The valueAsDate IDL attribute represents the value of the element, interpreted as a date.

On getting, if the valueAsDate attribute does not apply, as defined for the input element's type attribute's current state, then return null. Otherwise, run the algorithm to convert a string to a Date object defined for that state to the element's value; if the algorithm returned a Date object, then return it, otherwise, return null.

On setting, if the valueAsDate attribute does not apply, as defined for the input element's type attribute's current state, then throw an "InvalidStateError" DOMException; otherwise, if the new value is not null and not a Date object throw a TypeError exception; otherwise if the new value is null or a Date object representing the NaN time value, then set the value of the element to the empty string; otherwise, run the algorithm to convert a Date object to a string, as defined for that state, on the new value, and set the value of the element to the resulting string.

The valueAsNumber IDL attribute represents the value of the element, interpreted as a number.

On getting, if the valueAsNumber attribute does not apply, as defined for the input element's type attribute's current state, then return a Not-a-Number (NaN) value. Otherwise, run the algorithm to convert a string to a number defined for that state to the element's value; if the algorithm returned a number, then return it, otherwise, return a Not-a-Number (NaN) value.

On setting, if the new value is infinite, then throw a TypeError exception. Otherwise, if the valueAsNumber attribute does not apply, as defined for the input element's type attribute's current state, then throw an "InvalidStateError" DOMException. Otherwise, if the new value is a Not-a-Number (NaN) value, then set the value of the element to the empty string. Otherwise, run the algorithm to convert a number to a string, as defined for that state, on the new value, and set the value of the element to the resulting string.

The stepDown(n) and stepUp(n) methods, when invoked, must run the following algorithm:

If the stepDown() and stepUp() methods do not apply, as defined for the input element's type attribute's current state, then throw an "InvalidStateError" DOMException.

If the element has no allowed value step, then throw an "InvalidStateError" DOMException.

If the element has a minimum and a maximum and the minimum is greater than the maximum, then return.

If the element has a minimum and a maximum and there is no value greater than or equal to the element's minimum and less than or equal to the element's maximum that, when subtracted from the step base, is an integral multiple of the allowed value step, then return.

If applying the algorithm to convert a string to a number to the string given by the element's value does not result in an error, then let value be the result of that algorithm. Otherwise, let value be zero.

Let valueBeforeStepping be value.

If value subtracted from the step base is not an integral multiple of the allowed value step, then set value to the nearest value that, when subtracted from the step base, is an integral multiple of the allowed value step, and that is less than value if the method invoked was the stepDown() method, and more than value otherwise.

Otherwise (value subtracted from the step base is an integral multiple of the allowed value step):

Let n be the argument.

Let delta be the allowed value step multiplied by n.

If the method invoked was the stepDown() method, negate delta.

Let value be the result of adding delta to value.

If the element has a minimum, and value is less than that minimum, then set value to the smallest value that, when subtracted from the step base, is an integral multiple of the allowed value step, and that is more than or equal to minimum.

If the element has a maximum, and value is greater than that maximum, then set value to the largest value that, when subtracted from the step base, is an integral multiple of the allowed value step, and that is less than or equal to maximum.

If either the method invoked was the stepDown() method and value is greater than valueBeforeStepping, or the method invoked was the stepUp() method and value is less than valueBeforeStepping, then return.

This ensures that invoking the stepUp() method on the input element in the following example does not change the value of that element:

<input type=number value=1 max=0>
Let value as string be the result of running the algorithm to convert a number to a string, as defined for the input element's type attribute's current state, on value.

Set the value of the element to value as string.

The list IDL attribute must return the current suggestions source element, if any, or null otherwise.

4.10.5.5 Common event behaviors
When the input and change events apply (which is the case for all input controls other than buttons and those with the type attribute in the Hidden state), the events are fired to indicate that the user has interacted with the control. The input event fires whenever the user has modified the data of the control. The change event fires when the value is committed, if that makes sense for the control, or else when the control loses focus. In all cases, the input event comes before the corresponding change event (if any).

When an input element has a defined input activation behavior, the rules for dispatching these events, if they apply, are given in the section above that defines the type attribute's state. (This is the case for all input controls with the type attribute in the Checkbox state, the Radio Button state, or the File Upload state.)

For input elements without a defined input activation behavior, but to which these events apply, and for which the user interface involves both interactive manipulation and an explicit commit action, then when the user changes the element's value, the user agent must queue a task to fire an event named input at the input element, with the bubbles attribute initialized to true, and any time the user commits the change, the user agent must queue a task to fire an event named change at the input element, with the bubbles attribute initialized to true.

An example of a user interface involving both interactive manipulation and a commit action would be a Range controls that use a slider, when manipulated using a pointing device. While the user is dragging the control's knob, input events would fire whenever the position changed, whereas the change event would only fire when the user let go of the knob, committing to a specific value.

For input elements without a defined input activation behavior, but to which these events apply, and for which the user interface involves an explicit commit action but no intermediate manipulation, then any time the user commits a change to the element's value, the user agent must queue a task to first fire an event named input at the input element, with the bubbles attribute initialized to true, and then fire an event named change at the input element, with the bubbles attribute initialized to true.

An example of a user interface with a commit action would be a Color control that consists of a single button that brings up a color wheel: if the value only changes when the dialog is closed, then that would be the explicit commit action. On the other hand, if manipulating the control changes the color interactively, then there might be no commit action.

Another example of a user interface with a commit action would be a Date control that allows both text-based user input and user selection from a drop-down calendar: while text input might not have an explicit commit step, selecting a date from the drop down calendar and then dismissing the drop down would be a commit action.

For input elements without a defined input activation behavior, but to which these events apply, any time the user causes the element's value to change without an explicit commit action, the user agent must queue a task to fire an event named input at the input element, with the bubbles attribute initialized to true. The corresponding change event, if any, will be fired when the control loses focus.

Examples of a user changing the element's value would include the user typing into a text control, pasting a new value into the control, or undoing an edit in that control. Some user interactions do not cause changes to the value, e.g., hitting the "delete" key in an empty text control, or replacing some text in the control with text from the clipboard that happens to be exactly the same text.

A Range control in the form of a slider that the user has focused and is interacting with using a keyboard would be another example of the user changing the element's value without a commit step.

In the case of tasks that just fire an input event, user agents may wait for a suitable break in the user's interaction before queuing the tasks; for example, a user agent could wait for the user to have not hit a key for 100ms, so as to only fire the event when the user pauses, instead of continuously for each keystroke.

When the user agent is to change an input element's value on behalf of the user (e.g. as part of a form prefilling feature), the user agent must queue a task to first update the value accordingly, then fire an event named input at the input element, with the bubbles attribute initialized to true, then fire an event named change at the input element, with the bubbles attribute initialized to true.

These events are not fired in response to changes made to the values of form controls by scripts. (This is to make it easier to update the values of form controls in response to the user manipulating the controls, without having to then filter out the script's own changes to avoid an infinite loop.)

The task source for these tasks is the user interaction task source.

4.10.6 The button element
Categories:
Flow content.
Phrasing content.
Interactive content.
Listed, labelable, submittable, and autocapitalize-inheriting form-associated element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content, but there must be no interactive content descendant.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
autofocus — Automatically focus the form control when the page is loaded
disabled — Whether the form control is disabled
form — Associates the control with a form element
formaction — URL to use for form submission
formenctype — Form data set encoding type to use for form submission
formmethod — HTTP method to use for form submission
formnovalidate — Bypass form control validation for form submission
formtarget — Browsing context for form submission
name — Name of form control to use for form submission and in the form.elements API
type — Type of button
value — Value to be used for form submission
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLButtonElement : HTMLElement {
  [CEReactions] attribute boolean autofocus;
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute USVString formAction;
  [CEReactions] attribute DOMString formEnctype;
  [CEReactions] attribute DOMString formMethod;
  [CEReactions] attribute boolean formNoValidate;
  [CEReactions] attribute DOMString formTarget;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};
The button element represents a button labeled by its contents.

The element is a button.

The type attribute controls the behavior of the button when it is activated. It is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

Keyword	State	Brief description
submit	Submit Button	Submits the form.
reset	Reset Button	Resets the form.
button	Button	Does nothing.
The missing value default and invalid value default are the Submit Button state.

If the type attribute is in the Submit Button state, the element is specifically a submit button.

Constraint validation: If the type attribute is in the Reset Button state or the Button state, the element is barred from constraint validation.

A button element's activation behavior is to run the steps defined in the following list for the current state of this element's type attribute, if this element is not disabled, and do nothing otherwise:

Submit Button
If the element has a form owner and the element's node document is fully active, the element must submit the form owner from the button element.

Reset Button
If the element has a form owner and the element's node document is fully active, the element must reset the form owner.

Button
Do nothing.

The form attribute is used to explicitly associate the button element with its form owner. The name attribute represents the element's name. The disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The autofocus attribute controls focus. The formaction, formenctype, formmethod, formnovalidate, and formtarget attributes are attributes for form submission.

The formnovalidate attribute can be used to make submit buttons that do not trigger the constraint validation.

The formaction, formenctype, formmethod, formnovalidate, and formtarget must not be specified if the element's type attribute is not in the Submit Button state.

The value attribute gives the element's value for the purposes of form submission. The element's value is the value of the element's value attribute, if there is one, or the empty string otherwise.

A button (and its value) is only included in the form submission if the button itself was used to initiate the form submission.

The value IDL attribute must reflect the content attribute of the same name.

The type IDL attribute must reflect the content attribute of the same name, limited to only known values.

The willValidate, validity, and validationMessage IDL attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The labels IDL attribute provides a list of the element's labels. The autofocus, disabled, form, and name IDL attributes are part of the element's forms API.

The following button is labeled "Show hint" and pops up a dialog box when activated:

<button type=button
        onclick="alert('This 15-20 minute piece was composed by George Gershwin.')">
 Show hint
</button>
4.10.7 The select element

Spec bugs: 25027

Categories:
Flow content.
Phrasing content.
Interactive content.
Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Zero or more option, optgroup, and script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
autocomplete — Hint for form autofill feature
autofocus — Automatically focus the form control when the page is loaded
disabled — Whether the form control is disabled
form — Associates the control with a form element
multiple — Whether to allow multiple values
name — Name of form control to use for form submission and in the form.elements API
required — Whether the control is required for form submission
size — Size of the control
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLSelectElement : HTMLElement {
  [CEReactions] attribute DOMString autocomplete;
  [CEReactions] attribute boolean autofocus;
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute boolean multiple;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute boolean required;
  [CEReactions] attribute unsigned long size;

  readonly attribute DOMString type;

  [SameObject] readonly attribute HTMLOptionsCollection options;
  [CEReactions] attribute unsigned long length;
  getter Element? item(unsigned long index);
  HTMLOptionElement? namedItem(DOMString name);
  [CEReactions] void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  [CEReactions] void remove(); // ChildNode overload
  [CEReactions] void remove(long index);
  [CEReactions] setter void (unsigned long index, HTMLOptionElement? option);

  [SameObject] readonly attribute HTMLCollection selectedOptions;
  attribute long selectedIndex;
  attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};
The select element represents a control for selecting amongst a set of options.

The multiple attribute is a boolean attribute. If the attribute is present, then the select element represents a control for selecting zero or more options from the list of options. If the attribute is absent, then the select element represents a control for selecting a single option from the list of options.

The size attribute gives the number of options to show to the user. The size attribute, if specified, must have a value that is a valid non-negative integer greater than zero.

The display size of a select element is the result of applying the rules for parsing non-negative integers to the value of element's size attribute, if it has one and parsing it is successful. If applying those rules to the attribute's value is not successful, or if the size attribute is absent, then the element's display size is 4 if the element's multiple content attribute is present, and 1 otherwise.

The list of options for a select element consists of all the option element children of the select element, and all the option element children of all the optgroup element children of the select element, in tree order.

The required attribute is a boolean attribute. When specified, the user will be required to select a value before submitting the form.

If a select element has a required attribute specified, does not have a multiple attribute specified, and has a display size of 1; and if the value of the first option element in the select element's list of options (if any) is the empty string, and that option element's parent node is the select element (and not an optgroup element), then that option is the select element's placeholder label option.

If a select element has a required attribute specified, does not have a multiple attribute specified, and has a display size of 1, then the select element must have a placeholder label option.

In practice, the requirement stated in the paragraph above can only apply when a select element does not have a size attribute with a value greater than 1.

Constraint validation: If the element has its required attribute specified, and either none of the option elements in the select element's list of options have their selectedness set to true, or the only option element in the select element's list of options with its selectedness set to true is the placeholder label option, then the element is suffering from being missing.

If the multiple attribute is absent, and the element is not disabled, then the user agent should allow the user to pick an option element in its list of options that is itself not disabled. Upon this option element being picked (either through a click, or through unfocusing the element after changing its value, or through a menu command, or through any other mechanism), and before the relevant user interaction event is queued (e.g. before the click event), the user agent must set the selectedness of the picked option element to true, set its dirtiness to true, and then send select update notifications.

If the multiple attribute is absent, whenever an option element in the select element's list of options has its selectedness set to true, and whenever an option element with its selectedness set to true is added to the select element's list of options, the user agent must set the selectedness of all the other option elements in its list of options to false.

If the multiple attribute is absent and the element's display size is greater than 1, then the user agent should also allow the user to request that the option whose selectedness is true, if any, be unselected. Upon this request being conveyed to the user agent, and before the relevant user interaction event is queued (e.g. before the click event), the user agent must set the selectedness of that option element to false, set its dirtiness to true, and then send select update notifications.

If nodes are inserted or nodes are removed causing the list of options to gain or lose one or more option elements, or if an option element in the list of options asks for a reset, then, if the select element's multiple attribute is absent, the user agent must run the first applicable set of steps from the following list:

If the select element's display size is 1, and no option elements in the select element's list of options have their selectedness set to true
Set the selectedness of the first option element in the list of options in tree order that is not disabled, if any, to true.

If two or more option elements in the select element's list of options have their selectedness set to true
Set the selectedness of all but the last option element with its selectedness set to true in the list of options in tree order to false.

If the multiple attribute is present, and the element is not disabled, then the user agent should allow the user to toggle the selectedness of the option elements in its list of options that are themselves not disabled. Upon such an element being toggled (either through a click, or through a menu command, or any other mechanism), and before the relevant user interaction event is queued (e.g. before a related click event), the selectedness of the option element must be changed (from true to false or false to true), the dirtiness of the element must be set to true, and the user agent must send select update notifications.

When the user agent is to send select update notifications, queue a task, using the user interaction task source, to run these steps:

Fire an event named input at the select element, with the bubbles attribute initialized to true.

Fire an event named change at the select element, with the bubbles attribute initialized to true.

The reset algorithm for select elements is to go through all the option elements in the element's list of options, set their selectedness to true if the option element has a selected attribute, and false otherwise, set their dirtiness to false, and then have the option elements ask for a reset.

The form attribute is used to explicitly associate the select element with its form owner. The name attribute represents the element's name. The disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The autofocus attribute controls focus. The autocomplete attribute controls how the user agent provides autofill behavior.

A select element that is not disabled is mutable.

select . type
Returns "select-multiple" if the element has a multiple attribute, and "select-one" otherwise.

select . options
Returns an HTMLOptionsCollection of the list of options.

select . length [ = value ]
Returns the number of elements in the list of options.

When set to a smaller number, truncates the number of option elements in the select.

When set to a greater number, adds new blank option elements to the select.

element = select . item(index)
select[index]
Returns the item with index index from the list of options. The items are sorted in tree order.

element = select . namedItem(name)
Returns the first item with ID or name name from the list of options.

Returns null if no element with that ID could be found.

select . add(element [, before ] )
Inserts element before the node given by before.

The before argument can be a number, in which case element is inserted before the item with that number, or an element from the list of options, in which case element is inserted before that element.

If before is omitted, null, or a number out of range, then element will be added at the end of the list.

This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.

select . selectedOptions
Returns an HTMLCollection of the list of options that are selected.

select . selectedIndex [ = value ]
Returns the index of the first selected item, if any, or −1 if there is no selected item.

Can be set, to change the selection.

select . value [ = value ]
Returns the value of the first selected item, if any, or the empty string if there is no selected item.

Can be set, to change the selection.

The type IDL attribute, on getting, must return the string "select-one" if the multiple attribute is absent, and the string "select-multiple" if the multiple attribute is present.

The options IDL attribute must return an HTMLOptionsCollection rooted at the select node, whose filter matches the elements in the list of options.

The options collection is also mirrored on the HTMLSelectElement object. The supported property indices at any instant are the indices supported by the object returned by the options attribute at that instant.

The length IDL attribute must return the number of nodes represented by the options collection. On setting, it must act like the attribute of the same name on the options collection.

The item(index) method must return the value returned by the method of the same name on the options collection, when invoked with the same argument.

The namedItem(name) method must return the value returned by the method of the same name on the options collection, when invoked with the same argument.

When the user agent is to set the value of a new indexed property or set the value of an existing indexed property for a select element, it must instead run the corresponding algorithm on the select element's options collection.

Similarly, the add() method must act like its namesake method on that same options collection.

The remove() method must act like its namesake method on that same options collection when it has arguments, and like its namesake method on the ChildNode interface implemented by the HTMLSelectElement ancestor interface Element when it has no arguments.

The selectedOptions IDL attribute must return an HTMLCollection rooted at the select node, whose filter matches the elements in the list of options that have their selectedness set to true.

The selectedIndex IDL attribute, on getting, must return the index of the first option element in the list of options in tree order that has its selectedness set to true, if any. If there isn't one, then it must return −1.

On setting, the selectedIndex attribute must set the selectedness of all the option elements in the list of options to false, and then the option element in the list of options whose index is the given new value, if any, must have its selectedness set to true and its dirtiness set to true.

This can result in no element having a selectedness set to true even in the case of the select element having no multiple attribute and a display size of 1.

The value IDL attribute, on getting, must return the value of the first option element in the list of options in tree order that has its selectedness set to true, if any. If there isn't one, then it must return the empty string.

On setting, the value attribute must set the selectedness of all the option elements in the list of options to false, and then the first option element in the list of options, in tree order, whose value is equal to the given new value, if any, must have its selectedness set to true and its dirtiness set to true.

This can result in no element having a selectedness set to true even in the case of the select element having no multiple attribute and a display size of 1.

The multiple, required, and size IDL attributes must reflect the respective content attributes of the same name. The size IDL attribute has a default value of zero.

For historical reasons, the default value of the size IDL attribute does not return the actual size used, which, in the absence of the size content attribute, is either 1 or 4 depending on the presence of the multiple attribute.

The willValidate, validity, and validationMessage IDL attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The labels IDL attribute provides a list of the element's labels. The autofocus, disabled, form, and name IDL attributes are part of the element's forms API.

The following example shows how a select element can be used to offer the user with a set of options from which the user can select a single option. The default option is preselected.

<p>
 <label for="unittype">Select unit type:</label>
 <select id="unittype" name="unittype">
  <option value="1"> Miner </option>
  <option value="2"> Puffer </option>
  <option value="3" selected> Snipey </option>
  <option value="4"> Max </option>
  <option value="5"> Firebot </option>
 </select>
</p>
When there is no default option, a placeholder can be used instead:

<select name="unittype" required>
 <option value=""> Select unit type </option>
 <option value="1"> Miner </option>
 <option value="2"> Puffer </option>
 <option value="3"> Snipey </option>
 <option value="4"> Max </option>
 <option value="5"> Firebot </option>
</select>
Here, the user is offered a set of options from which they can select any number. By default, all five options are selected.

<p>
 <label for="allowedunits">Select unit types to enable on this map:</label>
 <select id="allowedunits" name="allowedunits" multiple>
  <option value="1" selected> Miner </option>
  <option value="2" selected> Puffer </option>
  <option value="3" selected> Snipey </option>
  <option value="4" selected> Max </option>
  <option value="5" selected> Firebot </option>
 </select>
</p>
Sometimes, a user has to select one or more items. This example shows such an interface.

<label>
 Select the songs from that you would like on your Act II Mix Tape:
 <select multiple required name="act2">
  <option value="s1">It Sucks to Be Me (Reprise)
  <option value="s2">There is Life Outside Your Apartment
  <option value="s3">The More You Ruv Someone
  <option value="s4">Schadenfreude
  <option value="s5">I Wish I Could Go Back to College
  <option value="s6">The Money Song
  <option value="s7">School for Monsters
  <option value="s8">The Money Song (Reprise)
  <option value="s9">There's a Fine, Fine Line (Reprise)
  <option value="s10">What Do You Do With a B.A. in English? (Reprise)
  <option value="s11">For Now
 </select>
</label>
4.10.8 The datalist element

Support: datalist
Chrome for Android	64+
Chrome (limited)	20+
Firefox (limited)	4+
Samsung Internet	4+
IE (limited)	10+
Opera Mini	None
Edge (limited)	12+
Android Browser (limited)	62+
Opera (limited)	15+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Either: phrasing content.
Or: Zero or more option and script-supporting elements.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDataListElement : HTMLElement {
  [SameObject] readonly attribute HTMLCollection options;
};
The datalist element represents a set of option elements that represent predefined options for other controls. In the rendering, the datalist element represents nothing and it, along with its children, should be hidden.

The datalist element can be used in two ways. In the simplest case, the datalist element has just option element children.

<label>
 Sex:
 <input name=sex list=sexes>
 <datalist id=sexes>
  <option value="Female">
  <option value="Male">
 </datalist>
</label>
In the more elaborate case, the datalist element can be given contents that are to be displayed for down-level clients that don't support datalist. In this case, the option elements are provided inside a select element inside the datalist element.

<label>
 Sex:
 <input name=sex list=sexes>
</label>
<datalist id=sexes>
 <label>
  or select from the list:
  <select name=sex>
   <option value="">
   <option>Female
   <option>Male
  </select>
 </label>
</datalist>
The datalist element is hooked up to an input element using the list attribute on the input element.

Each option element that is a descendant of the datalist element, that is not disabled, and whose value is a string that isn't the empty string, represents a suggestion. Each suggestion has a value and a label.

datalist . options
Returns an HTMLCollection of the option elements of the datalist element.

The options IDL attribute must return an HTMLCollection rooted at the datalist node, whose filter matches option elements.

Constraint validation: If an element has a datalist element ancestor, it is barred from constraint validation.

4.10.9 The optgroup element
Categories:
None.
Contexts in which this element can be used:
As a child of a select element.
Content model:
Zero or more option and script-supporting elements.
Tag omission in text/html:
An optgroup element's end tag can be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
Content attributes:
Global attributes
disabled — Whether the form control is disabled
label — User-visible label
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLOptGroupElement : HTMLElement {
  [CEReactions] attribute boolean disabled;
  [CEReactions] attribute DOMString label;
};
The optgroup element represents a group of option elements with a common label.

The element's group of option elements consists of the option elements that are children of the optgroup element.

When showing option elements in select elements, user agents should show the option elements of such groups as being related to each other and separate from other option elements.

The disabled attribute is a boolean attribute and can be used to disable a group of option elements together.

The label attribute must be specified. Its value gives the name of the group, for the purposes of the user interface. User agents should use this attribute's value when labeling the group of option elements in a select element.

The disabled and label attributes must reflect the respective content attributes of the same name.

There is no way to select an optgroup element. Only option elements can be selected. An optgroup element merely provides a label for a group of option elements.

The following snippet shows how a set of lessons from three courses could be offered in a select drop-down widget:

<form action="courseselector.dll" method="get">
 <p>Which course would you like to watch today?
 <p><label>Course:
  <select name="c">
   <optgroup label="8.01 Physics I: Classical Mechanics">
    <option value="8.01.1">Lecture 01: Powers of Ten
    <option value="8.01.2">Lecture 02: 1D Kinematics
    <option value="8.01.3">Lecture 03: Vectors
   <optgroup label="8.02 Electricity and Magnestism">
    <option value="8.02.1">Lecture 01: What holds our world together?
    <option value="8.02.2">Lecture 02: Electric Field
    <option value="8.02.3">Lecture 03: Electric Flux
   <optgroup label="8.03 Physics III: Vibrations and Waves">
    <option value="8.03.1">Lecture 01: Periodic Phenomenon
    <option value="8.03.2">Lecture 02: Beats
    <option value="8.03.3">Lecture 03: Forced Oscillations with Damping
  </select>
 </label>
 <p><input type=submit value="▶ Play">
</form>
4.10.10 The option element
Categories:
None.
Contexts in which this element can be used:
As a child of a select element.
As a child of a datalist element.
As a child of an optgroup element.
Content model:
If the element has a label attribute and a value attribute: Nothing.
If the element has a label attribute but no value attribute: Text.
If the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace.
If the element has no label attribute and is a child of a datalist element: Text.
Tag omission in text/html:
An option element's end tag can be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
Content attributes:
Global attributes
disabled — Whether the form control is disabled
label — User-visible label
selected — Whether the option is selected by default
value — Value to be used for form submission
DOM interface:
[Exposed=Window,
 HTMLConstructor,
 NamedConstructor=Option(optional DOMString text = "", optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : HTMLElement {
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute DOMString label;
  [CEReactions] attribute boolean defaultSelected;
  attribute boolean selected;
  [CEReactions] attribute DOMString value;

  [CEReactions] attribute DOMString text;
  readonly attribute long index;
};
The option element represents an option in a select element or as part of a list of suggestions in a datalist element.

In certain circumstances described in the definition of the select element, an option element can be a select element's placeholder label option. A placeholder label option does not represent an actual option, but instead represents a label for the select control.

The disabled attribute is a boolean attribute. An option element is disabled if its disabled attribute is present or if it is a child of an optgroup element whose disabled attribute is present.

An option element that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.

The label attribute provides a label for element. The label of an option element is the value of the label content attribute, if there is one and its value is not the empty string, or, otherwise, the value of the element's text IDL attribute.

The label content attribute, if specified, must not be empty.

The value attribute provides a value for element. The value of an option element is the value of the value content attribute, if there is one, or, if there is not, the value of the element's text IDL attribute.

The selected attribute is a boolean attribute. It represents the default selectedness of the element.

The dirtiness of an option element is a boolean state, initially false. It controls whether adding or removing the selected content attribute has any effect.

The selectedness of an option element is a boolean state, initially false. Except where otherwise specified, when the element is created, its selectedness must be set to true if the element has a selected attribute. Whenever an option element's selected attribute is added, if its dirtiness is false, its selectedness must be set to true. Whenever an option element's selected attribute is removed, if its dirtiness is false, its selectedness must be set to false.

The Option() constructor, when called with three or fewer arguments, overrides the initial state of the selectedness state to always be false even if the third argument is true (implying that a selected attribute is to be set). The fourth argument can be used to explicitly set the initial selectedness state when using the constructor.

A select element whose multiple attribute is not specified must not have more than one descendant option element with its selected attribute set.

An option element's index is the number of option elements that are in the same list of options but that come before it in tree order. If the option element is not in a list of options, then the option element's index is zero.

option . selected
Returns true if the element is selected, and false otherwise.

Can be set, to override the current state of the element.

option . index
Returns the index of the element in its select element's options list.

option . form
Returns the element's form element, if any, or null otherwise.

option . text
Same as textContent, except that spaces are collapsed and script elements are skipped.

option = new Option( [ text [, value [, defaultSelected [, selected ] ] ] ] )
Returns a new option element.

The text argument sets the contents of the element.

The value argument sets the value attribute.

The defaultSelected argument sets the selected attribute.

The selected argument sets whether or not the element is selected. If it is omitted, even if the defaultSelected argument is true, the element is not selected.

The disabled IDL attribute must reflect the content attribute of the same name. The defaultSelected IDL attribute must reflect the selected content attribute.

The label IDL attribute, on getting, if there is a label content attribute, must return that attribute's value; otherwise, it must return the element's label. On setting, the element's label content attribute must be set to the new value.

The value IDL attribute, on getting, must return the element's value. On setting, the element's value content attribute must be set to the new value.

The selected IDL attribute, on getting, must return true if the element's selectedness is true, and false otherwise. On setting, it must set the element's selectedness to the new value, set its dirtiness to true, and then cause the element to ask for a reset.

The index IDL attribute must return the element's index.

The text IDL attribute, on getting, must return the result of stripping and collapsing ASCII whitespace from the concatenation of data of all the Text node descendants of the option element, in tree order, excluding any that are descendants of descendants of the option element that are themselves script or SVG script elements.

On setting, the text attribute must act as if the textContent IDL attribute on the element had been set to the new value.

The form IDL attribute's behavior depends on whether the option element is in a select element or not. If the option has a select element as its parent, or has an optgroup element as its parent and that optgroup element has a select element as its parent, then the form IDL attribute must return the same value as the form IDL attribute on that select element. Otherwise, it must return null.

A constructor is provided for creating HTMLOptionElement objects (in addition to the factory methods from DOM such as createElement()): Option(text, value, defaultSelected, selected). When invoked, the constructor must perform the following steps:

Let document be the current global object's associated Document.

Let option be the result of creating an element given document, option, and the HTML namespace.

If text is not the empty string, then append to option a new Text node whose data is text.

If value is given, then set an attribute value for option using "value" and value.

If defaultSelected is true, then set an attribute value for option using "selected" and the empty string.

If selected is true, then set option's selectedness to true; otherwise set its selectedness to false (even if defaultSelected is true).

Return option.

4.10.11 The textarea element

Spec bugs: 15291

Categories:
Flow content.
Phrasing content.
Interactive content.
Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Text.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
autocomplete — Hint for form autofill feature
autofocus — Automatically focus the form control when the page is loaded
cols — Maximum number of characters per line
dirname — Name of form control to use for sending the element's directionality in form submission
disabled — Whether the form control is disabled
form — Associates the control with a form element
maxlength — Maximum length of value
minlength — Minimum length of value
name — Name of form control to use for form submission and in the form.elements API
placeholder — User-visible label to be placed within the form control
readonly — Whether to allow the value to be edited by the user
required — Whether the control is required for form submission
rows — Number of lines to show
wrap — How the value of the form control is to be wrapped for form submission
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTextAreaElement : HTMLElement {
  [CEReactions] attribute DOMString autocomplete;
  [CEReactions] attribute boolean autofocus;
  [CEReactions] attribute unsigned long cols;
  [CEReactions] attribute DOMString dirName;
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute long maxLength;
  [CEReactions] attribute long minLength;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString placeholder;
  [CEReactions] attribute boolean readOnly;
  [CEReactions] attribute boolean required;
  [CEReactions] attribute unsigned long rows;
  [CEReactions] attribute DOMString wrap;

  readonly attribute DOMString type;
  [CEReactions] attribute DOMString defaultValue;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;

  void select();
  attribute unsigned long selectionStart;
  attribute unsigned long selectionEnd;
  attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode = "preserve");
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
The textarea element represents a multiline plain text edit control for the element's raw value. The contents of the control represent the control's default value.

The raw value of a textarea control must be initially the empty string.

This element has rendering requirements involving the bidirectional algorithm.

The readonly attribute is a boolean attribute used to control whether the text can be edited by the user or not.

In this example, a text control is marked read-only because it represents a read-only file:

Filename: <code>/etc/bash.bashrc</code>
<textarea name="buffer" readonly>
# System-wide .bashrc file for interactive bash(1) shells.

# To enable the settings / commands in this file for login shells as well,
# this file has to be sourced in /etc/profile.

# If not running interactively, don't do anything
[ -z "$PS1" ] &amp;&amp; return

...</textarea>
Constraint validation: If the readonly attribute is specified on a textarea element, the element is barred from constraint validation.

A textarea element is mutable if it is neither disabled nor has a readonly attribute specified.

When a textarea is mutable, its raw value should be editable by the user: the user agent should allow the user to edit, insert, and remove text, and to insert and remove line breaks in the form of U+000A LINE FEED (LF) characters. Any time the user causes the element's raw value to change, the user agent must queue a task to fire an event named input at the textarea element, with the bubbles attribute initialized to true. User agents may wait for a suitable break in the user's interaction before queuing the task; for example, a user agent could wait for the user to have not hit a key for 100ms, so as to only fire the event when the user pauses, instead of continuously for each keystroke.

A textarea element's dirty value flag must be set to true whenever the user interacts with the control in a way that changes the raw value.

The cloning steps for textarea elements must propagate the raw value and dirty value flag from the node being cloned to the copy.

The child text content change steps for textarea elements must, if the element's dirty value flag is false, set the element's raw value to its child text content.

The reset algorithm for textarea elements is to set the dirty value flag back to false, and set the raw value of element to its child text content.

When a textarea element is popped off the stack of open elements of an HTML parser or XML parser, then the user agent must invoke the element's reset algorithm.

If the element is mutable, the user agent should allow the user to change the writing direction of the element, setting it either to a left-to-right writing direction or a right-to-left writing direction. If the user does so, the user agent must then run the following steps:

Set the element's dir attribute to "ltr" if the user selected a left-to-right writing direction, and "rtl" if the user selected a right-to-left writing direction.

Queue a task to fire an event named input at the textarea element, with the bubbles attribute initialized to true.

The cols attribute specifies the expected maximum number of characters per line. If the cols attribute is specified, its value must be a valid non-negative integer greater than zero. If applying the rules for parsing non-negative integers to the attribute's value results in a number greater than zero, then the element's character width is that value; otherwise, it is 20.

The user agent may use the textarea element's character width as a hint to the user as to how many characters the server prefers per line (e.g. for visual user agents by making the width of the control be that many characters). In visual renderings, the user agent should wrap the user's input in the rendering so that each line is no wider than this number of characters.

The rows attribute specifies the number of lines to show. If the rows attribute is specified, its value must be a valid non-negative integer greater than zero. If applying the rules for parsing non-negative integers to the attribute's value results in a number greater than zero, then the element's character height is that value; otherwise, it is 2.

Visual user agents should set the height of the control to the number of lines given by character height.

The wrap attribute is an enumerated attribute with two keywords and states: the soft keyword which maps to the Soft state, and the hard keyword which maps to the Hard state. The missing value default and invalid value default are the Soft state.

The Soft state indicates that the text in the textarea is not to be wrapped when it is submitted (though it can still be wrapped in the rendering).

The Hard state indicates that the text in the textarea is to have newlines added by the user agent so that the text is wrapped when it is submitted.

If the element's wrap attribute is in the Hard state, the cols attribute must be specified.

For historical reasons, the element's value is normalized in three different ways for three different purposes. The raw value is the value as it was originally set. It is not normalized. The API value is the value used in the value IDL attribute, textLength IDL attribute, and by the maxlength and minlength content attributes. It is normalized so that line breaks use U+000A LINE FEED (LF) characters. Finally, there is the value, as used in form submission and other processing models in this specification. It is normalized so that line breaks use U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pairs, and in addition, if necessary given the element's wrap attribute, additional line breaks are inserted to wrap the text at the given width.

The algorithm for obtaining the element's API value is to return the element's raw value with the textarea line break normalization transformation applied. The textarea line break normalization transformation is the following algorithm, as applied to a string:

Replace every U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair with a single U+000A LINE FEED (LF) character.

Replace every remaining U+000D CARRIAGE RETURN character with a single U+000A LINE FEED (LF) character.

The element's value is defined to be the element's raw value with the textarea wrapping transformation applied. The textarea wrapping transformation is the following algorithm, as applied to a string:

Replace every occurrence of a U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF) character, and every occurrence of a U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, by a two-character string consisting of a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair.

If the element's wrap attribute is in the Hard state, insert U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pairs into the string using a UA-defined algorithm so that each line has no more than character width characters. For the purposes of this requirement, lines are delimited by the start of the string, the end of the string, and U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pairs.

The maxlength attribute is a form control maxlength attribute.

If the textarea element has a maximum allowed value length, then the element's children must be such that the JavaScript string length of the value of the element's textContent IDL attribute with the textarea line break normalization transformation applied is equal to or less than the element's maximum allowed value length.

The minlength attribute is a form control minlength attribute.

The required attribute is a boolean attribute. When specified, the user will be required to enter a value before submitting the form.

Constraint validation: If the element has its required attribute specified, and the element is mutable, and the element's value is the empty string, then the element is suffering from being missing.

The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format.

The placeholder attribute should not be used as an alternative to a label. For a longer hint or other advisory text, the title attribute is more appropriate.

These mechanisms are very similar but subtly different: the hint given by the control's label is shown at all times; the short hint given in the placeholder attribute is shown before the user enters a value; and the hint in the title attribute is shown when the user requests further help.

User agents should present this hint to the user when the element's value is the empty string and the control is not focused (e.g. by displaying it inside a blank unfocused control). All U+000D CARRIAGE RETURN U+000A LINE FEED character pairs (CRLF) in the hint, as well as all other U+000D CARRIAGE RETURN (CR) and U+000A LINE FEED (LF) characters in the hint, must be treated as line breaks when rendering the hint.

The name attribute represents the element's name. The dirname attribute controls how the element's directionality is submitted. The disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The form attribute is used to explicitly associate the textarea element with its form owner. The autofocus attribute controls focus. The autocomplete attribute controls how the user agent provides autofill behavior.

textarea . type
Returns the string "textarea".

textarea . value
Returns the current value of the element.

Can be set, to change the value.

The cols, placeholder, required, rows, and wrap IDL attributes must reflect the respective content attributes of the same name. The cols and rows attributes are limited to only non-negative numbers greater than zero with fallback. The cols IDL attribute's default value is 20. The rows IDL attribute's default value is 2. The dirName IDL attribute must reflect the dirname content attribute. The maxLength IDL attribute must reflect the maxlength content attribute, limited to only non-negative numbers. The minLength IDL attribute must reflect the minlength content attribute, limited to only non-negative numbers. The readOnly IDL attribute must reflect the readonly content attribute.

The type IDL attribute must return the value "textarea".

The defaultValue IDL attribute must, on getting, return the element's child text content. On setting, it must act as the setter for the element's textContent IDL attribute.

The value IDL attribute must, on getting, return the element's API value. On setting, it must perform the following steps:

Let oldAPIValue be this element's API value.

Set this element's raw value to the new value.

Set this element's dirty value flag to true.

If the new API value is different from oldAPIValue, then move the text entry cursor position to the end of the text control, unselecting any selected text and resetting the selection direction to "none".

The textLength IDL attribute must return the JavaScript string length of the element's API value.

The willValidate, validity, and validationMessage IDL attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The labels IDL attribute provides a list of the element's labels. The select(), selectionStart, selectionEnd, selectionDirection, setRangeText(), and setSelectionRange() methods and IDL attributes expose the element's text selection. The autofocus, disabled, form, and name IDL attributes are part of the element's forms API.

Here is an example of a textarea being used for unrestricted free-form text input in a form:

<p>If you have any comments, please let us know: <textarea cols=80 name=comments></textarea></p>
To specify a maximum length for the comments, one can use the maxlength attribute:

<p>If you have any short comments, please let us know: <textarea cols=80 name=comments maxlength=200></textarea></p>
To give a default value, text can be included inside the element:

<p>If you have any comments, please let us know: <textarea cols=80 name=comments>You rock!</textarea></p>
You can also give a minimum length. Here, a letter needs to be filled out by the user; a template (which is shorter than the minimum length) is provided, but is insufficient to submit the form:

<textarea required minlength="500">Dear Madam Speaker,

Regarding your letter dated ...

...

Yours Sincerely,

...</textarea>
A placeholder can be given as well, to suggest the basic form to the user, without providing an explicit template:

<textarea placeholder="Dear Francine,

They closed the parks this week, so we won't be able to
meet your there. Should we just have dinner?

Love,
Daddy"></textarea>
To have the browser submit the directionality of the element along with the value, the dirname attribute can be specified:

<p>If you have any comments, please let us know (you may use either English or Hebrew for your comments):
<textarea cols=80 name=comments dirname=comments.dir></textarea></p>
4.10.12 The output element
Categories:
Flow content.
Phrasing content.
Listed, labelable, resettable, and autocapitalize-inheriting form-associated element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
for — Specifies controls from which the output was calculated
form — Associates the control with a form element
name — Name of form control to use in the form.elements API
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLOutputElement : HTMLElement {
  [SameObject, PutForwards=value] readonly attribute DOMTokenList htmlFor;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute DOMString name;

  readonly attribute DOMString type;
  [CEReactions] attribute DOMString defaultValue;
  [CEReactions] attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};
The output element represents the result of a calculation performed by the application, or the result of a user action.

This element can be contrasted with the samp element, which is the appropriate element for quoting the output of other programs run previously.

The for content attribute allows an explicit relationship to be made between the result of a calculation and the elements that represent the values that went into the calculation or that otherwise influenced the calculation. The for attribute, if specified, must contain a string consisting of an unordered set of unique space-separated tokens that are case-sensitive, each of which must have the value of an ID of an element in the same tree.

The form attribute is used to explicitly associate the output element with its form owner. The name attribute represents the element's name. The output element is associated with a form so that it can be easily referenced from the event handlers of form controls; the element's value itself is not submitted when the form is submitted.

The element has a value mode flag which is either value or default. Initially, the value mode flag must be set to default.

The element also has a default value. Initially, the default value must be the empty string.

When the value mode flag is in mode default, the contents of the element represent both the value of the element and its default value. When the value mode flag is in mode value, the contents of the element represent the value of the element only, and the default value is only accessible using the defaultValue IDL attribute.

Whenever the element's descendants are changed in any way, if the value mode flag is in mode default, the element's default value must be set to the value of the element's textContent IDL attribute.

The reset algorithm for output elements is to set the element's value mode flag to default and then to set the element's textContent IDL attribute to the value of the element's default value (thus replacing the element's child nodes).

output . value [ = value ]
Returns the element's current value.

Can be set, to change the value.

output . defaultValue [ = value ]
Returns the element's current default value.

Can be set, to change the default value.

output . type
Returns the string "output".

The value IDL attribute must act like the element's textContent IDL attribute, except that on setting, in addition, before the child nodes are changed, the element's value mode flag must be set to value.

The defaultValue IDL attribute, on getting, must return the element's default value. On setting, the attribute must set the element's default value, and, if the element's value mode flag is in the mode default, set the element's textContent IDL attribute as well.

The type attribute must return the string "output".

The htmlFor IDL attribute must reflect the for content attribute.

The willValidate, validity, and validationMessage IDL attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The labels IDL attribute provides a list of the element's labels. The form and name IDL attributes are part of the element's forms API.

A simple calculator could use output for its display of calculated results:

<form onsubmit="return false" oninput="o.value = a.valueAsNumber + b.valueAsNumber">
 <input id=a type=number step=any> +
 <input id=b type=number step=any> =
 <output id=o for="a b"></output>
</form>
In this example, an output element is used to report the results of a calculation performed by a remote server, as they come in:

<output id="result"></output>
<script>
 var primeSource = new WebSocket('ws://primes.example.net/');
 primeSource.onmessage = function (event) {
   document.getElementById('result').value = event.data;
 }
</script>
4.10.13 The progress element

Support: progress
Chrome for Android	64+
Chrome	8+
iOS Safari (limited)	7.0+
UC Browser for Android	11.8+
Firefox	6+
Samsung Internet	4+
IE	10+
Opera Mini	all+
Safari	6+
Edge	12+
Android Browser	4.4+
Opera	11+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Labelable element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content, but there must be no progress element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
value — Current value of the element
max — Upper bound of range
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLProgressElement : HTMLElement {
  [CEReactions] attribute double value;
  [CEReactions] attribute double max;
  readonly attribute double position;
  readonly attribute NodeList labels;
};
The progress element represents the completion progress of a task. The progress is either indeterminate, indicating that progress is being made but that it is not clear how much more work remains to be done before the task is complete (e.g. because the task is waiting for a remote host to respond), or the progress is a number in the range zero to a maximum, giving the fraction of work that has so far been completed.

There are two attributes that determine the current task completion represented by the element. The value attribute specifies how much of the task has been completed, and the max attribute specifies how much work the task requires in total. The units are arbitrary and not specified.

To make a determinate progress bar, add a value attribute with the current progress (either a number from 0.0 to 1.0, or, if the max attribute is specified, a number from 0 to the value of the max attribute). To make an indeterminate progress bar, remove the value attribute.

Authors are encouraged to also include the current value and the maximum value inline as text inside the element, so that the progress is made available to users of legacy user agents.

Here is a snippet of a Web application that shows the progress of some automated task:

<section>
 <h2>Task Progress</h2>
 <p>Progress: <progress id="p" max=100><span>0</span>%</progress></p>
 <script>
  var progressBar = document.getElementById('p');
  function updateProgress(newValue) {
    progressBar.value = newValue;
    progressBar.getElementsByTagName('span')[0].textContent = newValue;
  }
 </script>
</section>
(The updateProgress() method in this example would be called by some other code on the page to update the actual progress bar as the task progressed.)

The value and max attributes, when present, must have values that are valid floating-point numbers. The value attribute, if present, must have a value equal to or greater than zero, and less than or equal to the value of the max attribute, if present, or 1.0, otherwise. The max attribute, if present, must have a value greater than zero.

The progress element is the wrong element to use for something that is just a gauge, as opposed to task progress. For instance, indicating disk space usage using progress would be inappropriate. Instead, the meter element is available for such use cases.

User agent requirements: If the value attribute is omitted, then the progress bar is an indeterminate progress bar. Otherwise, it is a determinate progress bar.

If the progress bar is a determinate progress bar and the element has a max attribute, the user agent must parse the max attribute's value according to the rules for parsing floating-point number values. If this does not result in an error, and if the parsed value is greater than zero, then the maximum value of the progress bar is that value. Otherwise, if the element has no max attribute, or if it has one but parsing it resulted in an error, or if the parsed value was less than or equal to zero, then the maximum value of the progress bar is 1.0.

If the progress bar is a determinate progress bar, user agents must parse the value attribute's value according to the rules for parsing floating-point number values. If this does not result in an error and the parsed value is greater than zero, then the value of the progress bar is that parsed value. Otherwise, if parsing the value attribute's value resulted in an error or a number less than or equal to zero, then the value of the progress bar is zero.

If the progress bar is a determinate progress bar, then the current value is the maximum value, if value is greater than the maximum value, and value otherwise.

UA requirements for showing the progress bar: When representing a progress element to the user, the UA should indicate whether it is a determinate or indeterminate progress bar, and in the former case, should indicate the relative position of the current value relative to the maximum value.

progress . position
For a determinate progress bar (one with known current and maximum values), returns the result of dividing the current value by the maximum value.

For an indeterminate progress bar, returns −1.

If the progress bar is an indeterminate progress bar, then the position IDL attribute must return −1. Otherwise, it must return the result of dividing the current value by the maximum value.

If the progress bar is an indeterminate progress bar, then the value IDL attribute, on getting, must return 0. Otherwise, it must return the current value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the value content attribute must be set to that string.

Setting the value IDL attribute to itself when the corresponding content attribute is absent would change the progress bar from an indeterminate progress bar to a determinate progress bar with no progress.

The max IDL attribute must reflect the content attribute of the same name, limited to numbers greater than zero. The default value for max is 1.0.

The labels IDL attribute provides a list of the element's labels.

4.10.14 The meter element

Support: meter
Chrome for Android	64+
Chrome	8+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	16+
Samsung Internet	4+
IE	None
Opera Mini	all+
Safari	6+
Edge	13+
Android Browser	4.4+
Opera	11+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Labelable element.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Phrasing content, but there must be no meter element descendants.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
value — Current value of the element
min — Lower bound of range
max — Upper bound of range
low — High limit of low range
high — Low limit of high range
optimum — Optimum value in gauge
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLMeterElement : HTMLElement {
  [CEReactions] attribute double value;
  [CEReactions] attribute double min;
  [CEReactions] attribute double max;
  [CEReactions] attribute double low;
  [CEReactions] attribute double high;
  [CEReactions] attribute double optimum;
  readonly attribute NodeList labels;
};
The meter element represents a scalar measurement within a known range, or a fractional value; for example disk usage, the relevance of a query result, or the fraction of a voting population to have selected a particular candidate.

This is also known as a gauge.

The meter element should not be used to indicate progress (as in a progress bar). For that role, HTML provides a separate progress element.

The meter element also does not represent a scalar value of arbitrary range — for example, it would be wrong to use this to report a weight, or height, unless there is a known maximum value.

There are six attributes that determine the semantics of the gauge represented by the element.

The min attribute specifies the lower bound of the range, and the max attribute specifies the upper bound. The value attribute specifies the value to have the gauge indicate as the "measured" value.

The other three attributes can be used to segment the gauge's range into "low", "medium", and "high" parts, and to indicate which part of the gauge is the "optimum" part. The low attribute specifies the range that is considered to be the "low" part, and the high attribute specifies the range that is considered to be the "high" part. The optimum attribute gives the position that is "optimum"; if that is higher than the "high" value then this indicates that the higher the value, the better; if it's lower than the "low" mark then it indicates that lower values are better, and naturally if it is in between then it indicates that neither high nor low values are good.

Authoring requirements: The value attribute must be specified. The value, min, low, high, max, and optimum attributes, when present, must have values that are valid floating-point numbers.

In addition, the attributes' values are further constrained:

Let value be the value attribute's number.

If the min attribute is specified, then let minimum be that attribute's value; otherwise, let it be zero.

If the max attribute is specified, then let maximum be that attribute's value; otherwise, let it be 1.0.

The following inequalities must hold, as applicable:

minimum ≤ value ≤ maximum
minimum ≤ low ≤ maximum (if low is specified)
minimum ≤ high ≤ maximum (if high is specified)
minimum ≤ optimum ≤ maximum (if optimum is specified)
low ≤ high (if both low and high are specified)
If no minimum or maximum is specified, then the range is assumed to be 0..1, and the value thus has to be within that range.

Authors are encouraged to include a textual representation of the gauge's state in the element's contents, for users of user agents that do not support the meter element.

When used with microdata, the meter element's value attribute provides the element's machine-readable value.

The following examples show three gauges that would all be three-quarters full:

Storage space usage: <meter value=6 max=8>6 blocks used (out of 8 total)</meter>
Voter turnout: <meter value=0.75><img alt="75%" src="graph75.png"></meter>
Tickets sold: <meter min="0" max="100" value="75"></meter>
The following example is incorrect use of the element, because it doesn't give a range (and since the default maximum is 1, both of the gauges would end up looking maxed out):

<p>The grapefruit pie had a radius of <meter value=12>12cm</meter>
and a height of <meter value=2>2cm</meter>.</p> <!-- BAD! -->
Instead, one would either not include the meter element, or use the meter element with a defined range to give the dimensions in context compared to other pies:

<p>The grapefruit pie had a radius of 12cm and a height of
2cm.</p>
<dl>
 <dt>Radius: <dd> <meter min=0 max=20 value=12>12cm</meter>
 <dt>Height: <dd> <meter min=0 max=10 value=2>2cm</meter>
</dl>
There is no explicit way to specify units in the meter element, but the units may be specified in the title attribute in free-form text.

The example above could be extended to mention the units:

<dl>
 <dt>Radius: <dd> <meter min=0 max=20 value=12 title="centimeters">12cm</meter>
 <dt>Height: <dd> <meter min=0 max=10 value=2 title="centimeters">2cm</meter>
</dl>
User agent requirements: User agents must parse the min, max, value, low, high, and optimum attributes using the rules for parsing floating-point number values.

User agents must then use all these numbers to obtain values for six points on the gauge, as follows. (The order in which these are evaluated is important, as some of the values refer to earlier ones.)

The minimum value
If the min attribute is specified and a value could be parsed out of it, then the minimum value is that value. Otherwise, the minimum value is zero.

The maximum value
If the max attribute is specified and a value could be parsed out of it, then the candidate maximum value is that value. Otherwise, the candidate maximum value is 1.0.

If the candidate maximum value is greater than or equal to the minimum value, then the maximum value is the candidate maximum value. Otherwise, the maximum value is the same as the minimum value.

The actual value
If the value attribute is specified and a value could be parsed out of it, then that value is the candidate actual value. Otherwise, the candidate actual value is zero.

If the candidate actual value is less than the minimum value, then the actual value is the minimum value.

Otherwise, if the candidate actual value is greater than the maximum value, then the actual value is the maximum value.

Otherwise, the actual value is the candidate actual value.

The low boundary
If the low attribute is specified and a value could be parsed out of it, then the candidate low boundary is that value. Otherwise, the candidate low boundary is the same as the minimum value.

If the candidate low boundary is less than the minimum value, then the low boundary is the minimum value.

Otherwise, if the candidate low boundary is greater than the maximum value, then the low boundary is the maximum value.

Otherwise, the low boundary is the candidate low boundary.

The high boundary
If the high attribute is specified and a value could be parsed out of it, then the candidate high boundary is that value. Otherwise, the candidate high boundary is the same as the maximum value.

If the candidate high boundary is less than the low boundary, then the high boundary is the low boundary.

Otherwise, if the candidate high boundary is greater than the maximum value, then the high boundary is the maximum value.

Otherwise, the high boundary is the candidate high boundary.

The optimum point
If the optimum attribute is specified and a value could be parsed out of it, then the candidate optimum point is that value. Otherwise, the candidate optimum point is the midpoint between the minimum value and the maximum value.

If the candidate optimum point is less than the minimum value, then the optimum point is the minimum value.

Otherwise, if the candidate optimum point is greater than the maximum value, then the optimum point is the maximum value.

Otherwise, the optimum point is the candidate optimum point.

All of which will result in the following inequalities all being true:

minimum value ≤ actual value ≤ maximum value
minimum value ≤ low boundary ≤ high boundary ≤ maximum value
minimum value ≤ optimum point ≤ maximum value
UA requirements for regions of the gauge: If the optimum point is equal to the low boundary or the high boundary, or anywhere in between them, then the region between the low and high boundaries of the gauge must be treated as the optimum region, and the low and high parts, if any, must be treated as suboptimal. Otherwise, if the optimum point is less than the low boundary, then the region between the minimum value and the low boundary must be treated as the optimum region, the region from the low boundary up to the high boundary must be treated as a suboptimal region, and the remaining region must be treated as an even less good region. Finally, if the optimum point is higher than the high boundary, then the situation is reversed; the region between the high boundary and the maximum value must be treated as the optimum region, the region from the high boundary down to the low boundary must be treated as a suboptimal region, and the remaining region must be treated as an even less good region.

UA requirements for showing the gauge: When representing a meter element to the user, the UA should indicate the relative position of the actual value to the minimum and maximum values, and the relationship between the actual value and the three regions of the gauge.

The following markup:

<h3>Suggested groups</h3>
<menu>
 <li><a href="?cmd=hsg" onclick="hideSuggestedGroups()">Hide suggested groups</a></li>
</menu>
<ul>
 <li>
  <p><a href="/group/comp.infosystems.www.authoring.stylesheets/view">comp.infosystems.www.authoring.stylesheets</a> -
     <a href="/group/comp.infosystems.www.authoring.stylesheets/subscribe">join</a></p>
  <p>Group description: <strong>Layout/presentation on the WWW.</strong></p>
  <p><meter value="0.5">Moderate activity,</meter> Usenet, 618 subscribers</p>
 </li>
 <li>
  <p><a href="/group/netscape.public.mozilla.xpinstall/view">netscape.public.mozilla.xpinstall</a> -
     <a href="/group/netscape.public.mozilla.xpinstall/subscribe">join</a></p>
  <p>Group description: <strong>Mozilla XPInstall discussion.</strong></p>
  <p><meter value="0.25">Low activity,</meter> Usenet, 22 subscribers</p>
 </li>
 <li>
  <p><a href="/group/mozilla.dev.general/view">mozilla.dev.general</a> -
     <a href="/group/mozilla.dev.general/subscribe">join</a></p>
  <p><meter value="0.25">Low activity,</meter> Usenet, 66 subscribers</p>
 </li>
</ul>
Might be rendered as follows:



User agents may combine the value of the title attribute and the other attributes to provide context-sensitive help or inline text detailing the actual values.

For example, the following snippet:

<meter min=0 max=60 value=23.2 title=seconds></meter>
...might cause the user agent to display a gauge with a tooltip saying "Value: 23.2 out of 60." on one line and "seconds" on a second line.

The value IDL attribute, on getting, must return the actual value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the value content attribute must be set to that string.

The min IDL attribute, on getting, must return the minimum value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the min content attribute must be set to that string.

The max IDL attribute, on getting, must return the maximum value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the max content attribute must be set to that string.

The low IDL attribute, on getting, must return the low boundary. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the low content attribute must be set to that string.

The high IDL attribute, on getting, must return the high boundary. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the high content attribute must be set to that string.

The optimum IDL attribute, on getting, must return the optimum value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then the optimum content attribute must be set to that string.

The labels IDL attribute provides a list of the element's labels.

The following example shows how a gauge could fall back to localized or pretty-printed text.

<p>Disk usage: <meter min=0 value=170261928 max=233257824>170 261 928 bytes used
out of 233 257 824 bytes available</meter></p>
4.10.15 The fieldset element
Categories:
Flow content.
Sectioning root.
Listed and autocapitalize-inheriting form-associated element.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Optionally a legend element, followed by flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
disabled — Whether the form control is disabled
form — Associates the control with a form element
name — Name of form control to use in the form.elements API
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLFieldSetElement : HTMLElement {
  [CEReactions] attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  [CEReactions] attribute DOMString name;

  readonly attribute DOMString type;

  [SameObject] readonly attribute HTMLCollection elements;

  readonly attribute boolean willValidate;
  [SameObject] readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  boolean reportValidity();
  void setCustomValidity(DOMString error);
};
The fieldset element represents a set of form controls optionally grouped under a common name.

The name of the group is given by the first legend element that is a child of the fieldset element, if any. The remainder of the descendants form the group.

The disabled attribute, when specified, causes all the form control descendants of the fieldset element, excluding those that are descendants of the fieldset element's first legend element child, if any, to be disabled.


Support: fieldset-disabled
Chrome for Android	64+
Chrome	20+
iOS Safari	6.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE (limited)	6+
Opera Mini (limited)	all+
Safari	6+
Edge	12+
Android Browser	4.4+
Opera	10.0+

Source: caniuse.com

A fieldset element is a disabled fieldset if it matches any of the following conditions:

Its disabled attribute is specified
It is a descendant of another fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.
The form attribute is used to explicitly associate the fieldset element with its form owner. The name attribute represents the element's name.

fieldset . type
Returns the string "fieldset".

fieldset . elements
Returns an HTMLCollection of the form controls in the element.

The disabled IDL attribute must reflect the content attribute of the same name.

The type IDL attribute must return the string "fieldset".

The elements IDL attribute must return an HTMLCollection rooted at the fieldset element, whose filter matches listed elements.

The willValidate, validity, and validationMessage attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API. The form and name IDL attributes are part of the element's forms API.

This example shows a fieldset element being used to group a set of related controls:

<fieldset>
 <legend>Display</legend>
 <p><label><input type=radio name=c value=0 checked> Black on White</label>
 <p><label><input type=radio name=c value=1> White on Black</label>
 <p><label><input type=checkbox name=g> Use grayscale</label>
 <p><label>Enhance contrast <input type=range name=e list=contrast min=0 max=100 value=0 step=1></label>
 <datalist id=contrast>
  <option label=Normal value=0>
  <option label=Maximum value=100>
 </datalist>
</fieldset>
The following snippet shows a fieldset with a checkbox in the legend that controls whether or not the fieldset is enabled. The contents of the fieldset consist of two required text controls and an optional year/month control.

<fieldset name="clubfields" disabled>
 <legend> <label>
  <input type=checkbox name=club onchange="form.clubfields.disabled = !checked">
  Use Club Card
 </label> </legend>
 <p><label>Name on card: <input name=clubname required></label></p>
 <p><label>Card number: <input name=clubnum required pattern="[-0-9]+"></label></p>
 <p><label>Expiry date: <input name=clubexp type=month></label></p>
</fieldset>
You can also nest fieldset elements. Here is an example expanding on the previous one that does so:

<fieldset name="clubfields" disabled>
 <legend> <label>
  <input type=checkbox name=club onchange="form.clubfields.disabled = !checked">
  Use Club Card
 </label> </legend>
 <p><label>Name on card: <input name=clubname required></label></p>
 <fieldset name="numfields">
  <legend> <label>
   <input type=radio checked name=clubtype onchange="form.numfields.disabled = !checked">
   My card has numbers on it
  </label> </legend>
  <p><label>Card number: <input name=clubnum required pattern="[-0-9]+"></label></p>
 </fieldset>
 <fieldset name="letfields" disabled>
  <legend> <label>
   <input type=radio name=clubtype onchange="form.letfields.disabled = !checked">
   My card has letters on it
  </label> </legend>
  <p><label>Card code: <input name=clublet required pattern="[A-Za-z]+"></label></p>
 </fieldset>
</fieldset>
In this example, if the outer "Use Club Card" checkbox is not checked, everything inside the outer fieldset, including the two radio buttons in the legends of the two nested fieldsets, will be disabled. However, if the checkbox is checked, then the radio buttons will both be enabled and will let you select which of the two inner fieldsets is to be enabled.

4.10.16 The legend element
Categories:
None.
Contexts in which this element can be used:
As the first child of a fieldset element.
Content model:
Phrasing content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLLegendElement : HTMLElement {
  readonly attribute HTMLFormElement? form;

  // also has obsolete members
};
The legend element represents a caption for the rest of the contents of the legend element's parent fieldset element, if any.

legend . form
Returns the element's form element, if any, or null otherwise.

The form IDL attribute's behavior depends on whether the legend element is in a fieldset element or not. If the legend has a fieldset element as its parent, then the form IDL attribute must return the same value as the form IDL attribute on that fieldset element. Otherwise, it must return null.

4.10.17 Form control infrastructure
4.10.17.1 A form control's value
Most form controls have a value and a checkedness. (The latter is only used by input elements.) These are used to describe how the user interacts with the control.

A control's value is its internal state. As such, it might not match the user's current input.

For instance, if a user enters the word "three" into a numeric field that expects digits, the user's input would be the string "three" but the control's value would remain unchanged. Or, if a user enters the email address "  awesome@example.com" (with leading whitespace) into an email field, the user's input would be the string "  awesome@example.com" but the browser's UI for email fields might translate that into a value of "awesome@example.com" (without the leading whitespace).

input and textarea elements have a dirty value flag. This is used to track the interaction between the value and default value. If it is false, value mirrors the default value. If it is true, the default value is ignored.

To define the behavior of constraint validation in the face of the input element's multiple attribute, input elements can also have separately defined values.

To define the behavior of the maxlength and minlength attributes, as well as other APIs specific to the textarea element, all form control with a value also have an algorithm for obtaining an API value. By default this algorithm is to simply return the control's value.

The select element does not have a value; the selectedness of its option elements is what is used instead.

4.10.17.2 Mutability
A form control can be designated as mutable.

This determines (by means of definitions and requirements in this specification that rely on whether an element is so designated) whether or not the user can modify the value or checkedness of a form control, or whether or not a control can be automatically prefilled.

4.10.17.3 Association of controls and forms
A form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-associated element is not associated with a form element, its form owner is said to be null.

A form-associated element has an associated parser inserted flag.

A form-associated element is, by default, associated with its nearest ancestor form element (as described below), but, if it is listed, may have a form attribute specified to override this.


Support: form-attribute
Chrome for Android	64+
Chrome	10+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	None
Opera Mini	all+
Safari	5.1+
Edge	16+
Android Browser	3+
Opera	9.5+

Source: caniuse.com

This feature allows authors to work around the lack of support for nested form elements.

If a listed form-associated element has a form attribute specified, then that attribute's value must be the ID of a form element in the element's tree.

The rules in this section are complicated by the fact that although conforming documents or trees will never contain nested form elements, it is quite possible (e.g., using a script that performs DOM manipulation) to generate trees that have such nested elements. They are also complicated by rules in the HTML parser that, for historical reasons, can result in a form-associated element being associated with a form element that is not its ancestor.

When a form-associated element is created, its form owner must be initialized to null (no owner).

When a form-associated element is to be associated with a form, its form owner must be set to that form.

When a form-associated element or one of its ancestors is inserted, then:

If the form-associated element's parser inserted flag is set, then return.

Reset the form owner of the form-associated element.

When a form-associated element or one of its ancestors is removed, then:

If the form-associated element has a form owner and the form-associated element and its form owner are no longer in the same tree, then reset the form owner of the form-associated element.

When a listed form-associated element's form attribute is set, changed, or removed, then the user agent must reset the form owner of that element.

When a listed form-associated element has a form attribute and the ID of any of the elements in the tree changes, then the user agent must reset the form owner of that form-associated element.

When a listed form-associated element has a form attribute and an element with an ID is inserted into or removed from the Document, then the user agent must reset the form owner of that form-associated element.

When the user agent is to reset the form owner of a form-associated element element, it must run the following steps:

Unset element's parser inserted flag.

If all of the following conditions are true

element's form owner is not null
element is not listed or its form content attribute is not present
element's form owner is its nearest form element ancestor after the change to the ancestor chain
then do nothing, and return.

Set element's form owner to null.

If element is listed, has a form content attribute, and is connected, then:

If the first element in element's tree, in tree order, to have an ID that is case-sensitively equal to element's form content attribute's value, is a form element, then associate the element with that form element.

Otherwise, if element has an ancestor form element, then associate element with the nearest such ancestor form element.

In the following non-conforming snippet:

...
 <form id="a">
  <div id="b"></div>
 </form>
 <script>
  document.getElementById('b').innerHTML =
     '<table><tr><td></form><form id="c"><input id="d"></table>' +
     '<input id="e">';
 </script>
...
The form owner of "d" would be the inner nested form "c", while the form owner of "e" would be the outer form "a".

This happens as follows: First, the "e" node gets associated with "c" in the HTML parser. Then, the innerHTML algorithm moves the nodes from the temporary document to the "b" element. At this point, the nodes see their ancestor chain change, and thus all the "magic" associations done by the parser are reset to normal ancestor associations.

This example is a non-conforming document, though, as it is a violation of the content models to nest form elements, and there is a parse error for the </form> tag.

element . form
Returns the element's form owner.

Returns null if there isn't one.

Listed form-associated elements have a form IDL attribute, which, on getting, must return the element's form owner, or null if there isn't one.

4.10.18 Attributes common to form controls
4.10.18.1 Naming form controls: the name attribute
The name content attribute gives the name of the form control, as used in form submission and in the form element's elements object. If the attribute is specified, its value must not be the empty string or isindex.

A number of user agents historically implemented special support for first-in-form text controls with the name isindex, and this specification previously defined related user agent requirements for it. However, some user agents subsequently dropped that special support, and the related requirements were removed from this specification. So, to avoid problematic reinterpretations in legacy user agents, the name isindex is no longer allowed.

Other than isindex, any non-empty value for name is allowed. The name _charset_ is special: if used as the name of a Hidden control with no value attribute, then during submission the value attribute is automatically given a value consisting of the submission character encoding.

The name IDL attribute must reflect the name content attribute.

DOM clobbering is a common cause of security issues. Avoid using the names of built-in form properties with the name content attribute.

In this example, the input element overrides the built-in method property:

let form = document.createElement("form");
let input = document.createElement("input");
form.appendChild(input);

form.method;           // => "get"
input.name = "method"; // DOM clobbering occurs here
form.method === input; // => true
Since the input name takes precedence over built-in form properties, the JavaScript reference form.method will point to the input element named "method" instead of the built-in method property.

4.10.18.2 Submitting element directionality: the dirname attribute
The dirname attribute on a form control element enables the submission of the directionality of the element, and gives the name of the control that contains this value during form submission. If such an attribute is specified, its value must not be the empty string.

In this example, a form contains a text control and a submission button:

<form action="addcomment.cgi" method=post>
 <p><label>Comment: <input type=text name="comment" dirname="comment.dir" required></label></p>
 <p><button name="mode" type=submit value="add">Post Comment</button></p>
</form>
When the user submits the form, the user agent includes three fields, one called "comment", one called "comment.dir", and one called "mode"; so if the user types "Hello", the submission body might be something like:

comment=Hello&comment.dir=ltr&mode=add
If the user manually switches to a right-to-left writing direction and enters "مرحبا", the submission body might be something like:

comment=%D9%85%D8%B1%D8%AD%D8%A8%D8%A7&comment.dir=rtl&mode=add
4.10.18.3 Limiting user input length: the maxlength attribute
A form control maxlength attribute, controlled by the dirty value flag, declares a limit on the number of characters a user can input. The "number of characters" is measured using JavaScript string length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).

If an element has its form control maxlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's maximum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no maximum allowed value length.

Constraint validation: If an element has a maximum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the JavaScript string length of the element's API value is greater than the element's maximum allowed value length, then the element is suffering from being too long.

User agents may prevent the user from causing the element's API value to be set to a value whose JavaScript string length is greater than the element's maximum allowed value length.

In the case of textarea elements, the API value and value differ. In particular, the textarea line break normalization transformation is applied before the maximum allowed value length is checked (whereas the textarea wrapping transformation is not applied).

4.10.18.4 Setting minimum input length requirements: the minlength attribute
A form control minlength attribute, controlled by the dirty value flag, declares a lower bound on the number of characters a user can input. The "number of characters" is measured using JavaScript string length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).

The minlength attribute does not imply the required attribute. If the form control has no required attribute, then the value can still be omitted; the minlength attribute only kicks in once the user has entered a value at all. If the empty string is not allowed, then the required attribute also needs to be set.

If an element has its form control minlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's minimum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no minimum allowed value length.

If an element has both a maximum allowed value length and a minimum allowed value length, the minimum allowed value length must be smaller than or equal to the maximum allowed value length.

Constraint validation: If an element has a minimum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), its value is not the empty string, and the JavaScript string length of the element's API value is less than the element's minimum allowed value length, then the element is suffering from being too short.

In this example, there are four text controls. The first is required, and has to be at least 5 characters long. The other three are optional, but if the user fills one in, the user has to enter at least 10 characters.

<form action="/events/menu.cgi" method="post">
 <p><label>Name of Event: <input required minlength=5 maxlength=50 name=event></label></p>
 <p><label>Describe what you would like for breakfast, if anything:
    <textarea name="breakfast" minlength="10"></textarea></label></p>
 <p><label>Describe what you would like for lunch, if anything:
    <textarea name="lunch" minlength="10"></textarea></label></p>
 <p><label>Describe what you would like for dinner, if anything:
    <textarea name="dinner" minlength="10"></textarea></label></p>
 <p><input type=submit value="Submit Request"></p>
</form>
4.10.18.5 Enabling and disabling form controls: the disabled attribute
The disabled content attribute is a boolean attribute.

The disabled attribute for option elements and the disabled attribute for optgroup elements are defined separately.

A form control is disabled if any of the following conditions are met:

The element is a button, input, select, or textarea element, and the disabled attribute is specified on this element (regardless of its value).
The element is a descendant of a fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.
A form control that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.

Constraint validation: If an element is disabled, it is barred from constraint validation.

The disabled IDL attribute must reflect the disabled content attribute.

4.10.18.6 Form submission
Attributes for form submission can be specified both on form elements and on submit buttons (elements that represent buttons that submit forms, e.g. an input element whose type attribute is in the Submit Button state).


Support: form-submit-attributes
Chrome for Android	64+
Chrome	15+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	4+
Opera	10.6+

Source: caniuse.com

The attributes for form submission that may be specified on form elements are action, enctype, method, novalidate, and target.

The corresponding attributes for form submission that may be specified on submit buttons are formaction, formenctype, formmethod, formnovalidate, and formtarget. When omitted, they default to the values given on the corresponding attributes on the form element.

The action and formaction content attributes, if specified, must have a value that is a valid non-empty URL potentially surrounded by spaces.

The action of an element is the value of the element's formaction attribute, if the element is a submit button and has such an attribute, or the value of its form owner's action attribute, if it has one, or else the empty string.

The method and formmethod content attributes are enumerated attributes with the following keywords and states:

The keyword get, mapping to the state GET, indicating the HTTP GET method.
The keyword post, mapping to the state POST, indicating the HTTP POST method.
The keyword dialog, mapping to the state dialog, indicating that submitting the form is intended to close the dialog box in which the form finds itself, if any, and otherwise not submit.
The invalid value default for these attributes is the GET state. The missing value default for the method attribute is also the GET state. (There is no missing value default or invalid value default for the formmethod attribute.)

The method of an element is one of those states. If the element is a submit button and has a formmethod attribute, then the element's method is that attribute's state; otherwise, it is the form owner's method attribute's state.

Here the method attribute is used to explicitly specify the default value, "get", so that the search query is submitted in the URL:

<form method="get" action="/search.cgi">
 <p><label>Search terms: <input type=search name=q></label></p>
 <p><input type=submit></p>
</form>
On the other hand, here the method attribute is used to specify the value "post", so that the user's message is submitted in the HTTP request's body:

<form method="post" action="/post-message.cgi">
 <p><label>Message: <input type=text name=m></label></p>
 <p><input type=submit value="Submit message"></p>
</form>
In this example, a form is used with a dialog. The method attribute's "dialog" keyword is used to have the dialog automatically close when the form is submitted.

<dialog id="ship">
 <form method=dialog>
  <p>A ship has arrived in the harbour.</p>
  <button type=submit value="board">Board the ship</button>
  <button type=submit value="call">Call to the captain</button>
 </form>
</dialog>
<script>
 var ship = document.getElementById('ship');
 ship.showModal();
 ship.onclose = function (event) {
   if (ship.returnValue == 'board') {
     // ...
   } else {
     // ...
   }
 };
</script>
The enctype and formenctype content attributes are enumerated attributes with the following keywords and states:

The "application/x-www-form-urlencoded" keyword and corresponding state.
The "multipart/form-data" keyword and corresponding state.
The "text/plain" keyword and corresponding state.
The invalid value default for these attributes is the application/x-www-form-urlencoded state. The missing value default for the enctype attribute is also the application/x-www-form-urlencoded state. (There is no missing value default or invalid value default for the formenctype attribute.)

The enctype of an element is one of those three states. If the element is a submit button and has a formenctype attribute, then the element's enctype is that attribute's state; otherwise, it is the form owner's enctype attribute's state.

The target and formtarget content attributes, if specified, must have values that are valid browsing context names or keywords.

The novalidate and formnovalidate content attributes are boolean attributes. If present, they indicate that the form is not to be validated during submission.

The no-validate state of an element is true if the element is a submit button and the element's formnovalidate attribute is present, or if the element's form owner's novalidate attribute is present, and false otherwise.

This attribute is useful to include "save" buttons on forms that have validation constraints, to allow users to save their progress even though they haven't fully entered the data in the form. The following example shows a simple form that has two required fields. There are three buttons: one to submit the form, which requires both fields to be filled in; one to save the form so that the user can come back and fill it in later; and one to cancel the form altogether.

<form action="editor.cgi" method="post">
 <p><label>Name: <input required name=fn></label></p>
 <p><label>Essay: <textarea required name=essay></textarea></label></p>
 <p><input type=submit name=submit value="Submit essay"></p>
 <p><input type=submit formnovalidate name=save value="Save essay"></p>
 <p><input type=submit formnovalidate name=cancel value="Cancel"></p>
</form>
The action IDL attribute must reflect the content attribute of the same name, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The target IDL attribute must reflect the content attribute of the same name. The method and enctype IDL attributes must reflect the respective content attributes of the same name, limited to only known values. The encoding IDL attribute must reflect the enctype content attribute, limited to only known values. The noValidate IDL attribute must reflect the novalidate content attribute. The formAction IDL attribute must reflect the formaction content attribute, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The formEnctype IDL attribute must reflect the formenctype content attribute, limited to only known values. The formMethod IDL attribute must reflect the formmethod content attribute, limited to only known values. The formNoValidate IDL attribute must reflect the formnovalidate content attribute. The formTarget IDL attribute must reflect the formtarget content attribute.

4.10.18.6.1 Autofocusing a form control: the autofocus attribute

Support: autofocus
Chrome for Android	64+
Chrome	5+
iOS Safari	None
UC Browser for Android	None
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	3+
Opera	9.5+

Source: caniuse.com

The autofocus content attribute allows the author to indicate that a control is to be focused as soon as the page is loaded or as soon as the dialog within which it finds itself is shown, allowing the user to just start typing without having to manually focus the main control.

The autofocus attribute is a boolean attribute.

An element's nearest ancestor autofocus scoping root element is the element itself if the element is a dialog element, or else is the element's nearest ancestor dialog element, if any, or else is the element's last inclusive ancestor element.

There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus attribute specified.

When an element with the autofocus attribute specified is inserted into a document, queue a task on the user interaction task source to run the following steps:

If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then optionally return.

Let target be the element's node document.

If target has no browsing context, then return.

If target's browsing context has no top-level browsing context (e.g., it is a nested browsing context with no parent browsing context), then return.

If target's active sandboxing flag set has the sandboxed automatic features browsing context flag, then return.

If target's origin is not the same as the origin of the node document of the currently focused element in target's top-level browsing context, then return.

If target's origin is not the same as the origin of the active document of target's top-level browsing context, then return.

If the user agent has already reached the last step of this list of steps in response to an element being inserted into a Document whose top-level browsing context's active document is the same as target's top-level browsing context's active document, then return.

Run the focusing steps for the element. User agents may also change the scrolling position of the document, or perform some other action that brings the element to the user's attention.

This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements also processes the autofocus attribute.

Focusing the control does not imply that the user agent has to focus the browser window if it has lost focus.

The autofocus IDL attribute must reflect the content attribute of the same name.

In the following snippet, the text control would be focused when the document was loaded.

<input maxlength="256" name="q" value="" autofocus>
<input type="submit" value="Search">
4.10.18.7 Autofill

Support: input-autocomplete-onoff
Chrome for Android	64+
Chrome (limited)	27+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox (limited)	30+
Samsung Internet	4+
IE (limited)	11+
Opera Mini	all+
Safari (limited)	7+
Edge (limited)	12+
Android Browser	2.1+
Opera	9+

Source: caniuse.com

4.10.18.7.1 Autofilling form controls: the autocomplete attribute
User agents sometimes have features for helping users fill forms in, for example prefilling the user's address based on earlier user input. The autocomplete content attribute can be used to hint to the user agent how to, or indeed whether to, provide such a feature.

There are two ways this attribute is used. When wearing the autofill expectation mantle, the autocomplete attribute describes what input is expected from users. When wearing the autofill anchor mantle, the autocomplete attribute describes the meaning of the given value.

On an input element whose type attribute is in the Hidden state, the autocomplete attribute wears the autofill anchor mantle. In all other cases, it wears the autofill expectation mantle.

When wearing the autofill expectation mantle, the autocomplete attribute, if specified, must have a value that is an ordered set of space-separated tokens consisting of either a single token that is an ASCII case-insensitive match for the string "off", or a single token that is an ASCII case-insensitive match for the string "on", or autofill detail tokens.

When wearing the autofill anchor mantle, the autocomplete attribute, if specified, must have a value that is an ordered set of space-separated tokens consisting of just autofill detail tokens (i.e. the "on" and "off" keywords are not allowed).

Autofill detail tokens are the following, in the order given below:

Optionally, a token whose first eight characters are an ASCII case-insensitive match for the string "section-", meaning that the field belongs to the named group.

For example, if there are two shipping addresses in the form, then they could be marked up as:

<fieldset>
 <legend>Ship the blue gift to...</legend>
 <p> <label> Address:     <textarea name=ba autocomplete="section-blue shipping street-address"></textarea> </label>
 <p> <label> City:        <input name=bc autocomplete="section-blue shipping address-level2"> </label>
 <p> <label> Postal Code: <input name=bp autocomplete="section-blue shipping postal-code"> </label>
</fieldset>
<fieldset>
 <legend>Ship the red gift to...</legend>
 <p> <label> Address:     <textarea name=ra autocomplete="section-red shipping street-address"></textarea> </label>
 <p> <label> City:        <input name=rc autocomplete="section-red shipping address-level2"> </label>
 <p> <label> Postal Code: <input name=rp autocomplete="section-red shipping postal-code"> </label>
</fieldset>
Optionally, a token that is an ASCII case-insensitive match for one of the following strings:

"shipping", meaning the field is part of the shipping address or contact information
"billing", meaning the field is part of the billing address or contact information
Either of the following two options:

A token that is an ASCII case-insensitive match for one of the following autofill field names, excluding those that are inappropriate for the control:

"name"
"honorific-prefix"
"given-name"
"additional-name"
"family-name"
"honorific-suffix"
"nickname"
"username"
"new-password"
"current-password"
"organization-title"
"organization"
"street-address"
"address-line1"
"address-line2"
"address-line3"
"address-level4"
"address-level3"
"address-level2"
"address-level1"
"country"
"country-name"
"postal-code"
"cc-name"
"cc-given-name"
"cc-additional-name"
"cc-family-name"
"cc-number"
"cc-exp"
"cc-exp-month"
"cc-exp-year"
"cc-csc"
"cc-type"
"transaction-currency"
"transaction-amount"
"language"
"bday"
"bday-day"
"bday-month"
"bday-year"
"sex"
"url"
"photo"
(See the table below for descriptions of these values.)

The following, in the given order:

Optionally, a token that is an ASCII case-insensitive match for one of the following strings:

"home", meaning the field is for contacting someone at their residence
"work", meaning the field is for contacting someone at their workplace
"mobile", meaning the field is for contacting someone regardless of location
"fax", meaning the field describes a fax machine's contact details
"pager", meaning the field describes a pager's or beeper's contact details
A token that is an ASCII case-insensitive match for one of the following autofill field names, excluding those that are inappropriate for the control:

"tel"
"tel-country-code"
"tel-national"
"tel-area-code"
"tel-local"
"tel-local-prefix"
"tel-local-suffix"
"tel-extension"
"email"
"impp"
(See the table below for descriptions of these values.)

As noted earlier, the meaning of the attribute and its keywords depends on the mantle that the attribute is wearing.

When wearing the autofill expectation mantle...
The "off" keyword indicates either that the control's input data is particularly sensitive (for example the activation code for a nuclear weapon); or that it is a value that will never be reused (for example a one-time-key for a bank login) and the user will therefore have to explicitly enter the data each time, instead of being able to rely on the UA to prefill the value for them; or that the document provides its own autocomplete mechanism and does not want the user agent to provide autocompletion values.

The "on" keyword indicates that the user agent is allowed to provide the user with autocompletion values, but does not provide any further information about what kind of data the user might be expected to enter. User agents would have to use heuristics to decide what autocompletion values to suggest.

The autofill field listed above indicate that the user agent is allowed to provide the user with autocompletion values, and specifies what kind of value is expected. The meaning of each such keyword is described in the table below.

If the autocomplete attribute is omitted, the default value corresponding to the state of the element's form owner's autocomplete attribute is used instead (either "on" or "off"). If there is no form owner, then the value "on" is used.

When wearing the autofill anchor mantle...
The autofill field listed above indicate that the value of the particular kind of value specified is that value provided for this element. The meaning of each such keyword is described in the table below.

In this example the page has explicitly specified the currency and amount of the transaction. The form requests a credit card and other billing details. The user agent could use this information to suggest a credit card that it knows has sufficient balance and that supports the relevant currency.

<form method=post action="step2.cgi">
 <input type=hidden autocomplete=transaction-currency value="CHF">
 <input type=hidden autocomplete=transaction-amount value="15.00">
 <p><label>Credit card number: <input type=text inputmode=numeric autocomplete=cc-number></label>
 <p><label>Expiry Date: <input type=month autocomplete=cc-exp></label>
 <p><input type=submit value="Continue...">
</form>
The autofill field keywords relate to each other as described in the table below. Each field name listed on a row of this table corresponds to the meaning given in the cell for that row in the column labeled "Meaning". Some fields correspond to subparts of other fields; for example, a credit card expiry date can be expressed as one field giving both the month and year of expiry ("cc-exp"), or as two fields, one giving the month ("cc-exp-month") and one the year ("cc-exp-year"). In such cases, the names of the broader fields cover multiple rows, in which the narrower fields are defined.

Generally, authors are encouraged to use the broader fields rather than the narrower fields, as the narrower fields tend to expose Western biases. For example, while it is common in some Western cultures to have a given name and a family name, in that order (and thus often referred to as a first name and a surname), many cultures put the family name first and the given name second, and many others simply have one name (a mononym). Having a single field is therefore more flexible.

Some fields are only appropriate for certain form controls. An autofill field name is inappropriate for a control if the control does not belong to the group listed for that autofill field in the fifth column of the first row describing that autofill field in the table below. What controls fall into each group is described below the table.

Field name	Meaning	Canonical Format	Canonical Format Example	Control group
"name"	Full name	Free-form text, no newlines	Sir Timothy John Berners-Lee, OM, KBE, FRS, FREng, FRSA	Text
"honorific-prefix"	Prefix or title (e.g. "Mr.", "Ms.", "Dr.", "Mlle")	Free-form text, no newlines	Sir	Text
"given-name"	Given name (in some Western cultures, also known as the first name)	Free-form text, no newlines	Timothy	Text
"additional-name"	Additional names (in some Western cultures, also known as middle names, forenames other than the first name)	Free-form text, no newlines	John	Text
"family-name"	Family name (in some Western cultures, also known as the last name or surname)	Free-form text, no newlines	Berners-Lee	Text
"honorific-suffix"	Suffix (e.g. "Jr.", "B.Sc.", "MBASW", "II")	Free-form text, no newlines	OM, KBE, FRS, FREng, FRSA	Text
"nickname"	Nickname, screen name, handle: a typically short name used instead of the full name	Free-form text, no newlines	Tim	Text
"organization-title"	Job title (e.g. "Software Engineer", "Senior Vice President", "Deputy Managing Director")	Free-form text, no newlines	Professor	Text
"username"	A username	Free-form text, no newlines	timbl	Text
"new-password"	A new password (e.g. when creating an account or changing a password)	Free-form text, no newlines	GUMFXbadyrS3	Password
"current-password"	The current password for the account identified by the username field (e.g. when logging in)	Free-form text, no newlines	qwerty	Password
"organization"	Company name corresponding to the person, address, or contact information in the other fields associated with this field	Free-form text, no newlines	World Wide Web Consortium	Text
"street-address"	Street address (multiple lines, newlines preserved)	Free-form text	32 Vassar Street
MIT Room 32-G524	Multiline
"address-line1"	Street address (one line per field)	Free-form text, no newlines	32 Vassar Street	Text
"address-line2"	Free-form text, no newlines	MIT Room 32-G524	Text
"address-line3"	Free-form text, no newlines		Text
"address-level4"	The most fine-grained administrative level, in addresses with four administrative levels	Free-form text, no newlines		Text
"address-level3"	The third administrative level, in addresses with three or more administrative levels	Free-form text, no newlines		Text
"address-level2"	The second administrative level, in addresses with two or more administrative levels; in the countries with two administrative levels, this would typically be the city, town, village, or other locality within which the relevant street address is found	Free-form text, no newlines	Cambridge	Text
"address-level1"	The broadest administrative level in the address, i.e. the province within which the locality is found; for example, in the US, this would be the state; in Switzerland it would be the canton; in the UK, the post town	Free-form text, no newlines	MA	Text
"country"	Country code	Valid ISO 3166-1-alpha-2 country code [ISO3166]	US	Text
"country-name"	Country name	Free-form text, no newlines; derived from country in some cases	US	Text
"postal-code"	Postal code, post code, ZIP code, CEDEX code (if CEDEX, append "CEDEX", and the arrondissement, if relevant, to the address-level2 field)	Free-form text, no newlines	02139	Text
"cc-name"	Full name as given on the payment instrument	Free-form text, no newlines	Tim Berners-Lee	Text
"cc-given-name"	Given name as given on the payment instrument (in some Western cultures, also known as the first name)	Free-form text, no newlines	Tim	Text
"cc-additional-name"	Additional names given on the payment instrument (in some Western cultures, also known as middle names, forenames other than the first name)	Free-form text, no newlines		Text
"cc-family-name"	Family name given on the payment instrument (in some Western cultures, also known as the last name or surname)	Free-form text, no newlines	Berners-Lee	Text
"cc-number"	Code identifying the payment instrument (e.g. the credit card number)	ASCII digits	4114360123456785	Text
"cc-exp"	Expiration date of the payment instrument	Valid month string	2014-12	Month
"cc-exp-month"	Month component of the expiration date of the payment instrument	Valid integer in the range 1..12	12	Numeric
"cc-exp-year"	Year component of the expiration date of the payment instrument	Valid integer greater than zero	2014	Numeric
"cc-csc"	Security code for the payment instrument (also known as the card security code (CSC), card validation code (CVC), card verification value (CVV), signature panel code (SPC), credit card ID (CCID), etc)	ASCII digits	419	Text
"cc-type"	Type of payment instrument	Free-form text, no newlines	Visa	Text
"transaction-currency"	The currency that the user would prefer the transaction to use	ISO 4217 currency code [ISO4217]	GBP	Text
"transaction-amount"	The amount that the user would like for the transaction (e.g. when entering a bid or sale price)	Valid floating-point number	401.00	Numeric
"language"	Preferred language	Valid BCP 47 language tag [BCP47]	en	Text
"bday"	Birthday	Valid date string	1955-06-08	Date
"bday-day"	Day component of birthday	Valid integer in the range 1..31	8	Numeric
"bday-month"	Month component of birthday	Valid integer in the range 1..12	6	Numeric
"bday-year"	Year component of birthday	Valid integer greater than zero	1955	Numeric
"sex"	Gender identity (e.g. Female, Fa'afafine)	Free-form text, no newlines	Male	Text
"url"	Home page or other Web page corresponding to the company, person, address, or contact information in the other fields associated with this field	Valid URL string	https://www.w3.org/People/Berners-Lee/	URL
"photo"	Photograph, icon, or other image corresponding to the company, person, address, or contact information in the other fields associated with this field	Valid URL string	https://www.w3.org/Press/Stock/Berners-Lee/2001-europaeum-eighth.jpg	URL
"tel"	Full telephone number, including country code	ASCII digits and U+0020 SPACE characters, prefixed by a U+002B PLUS SIGN character (+)	+1 617 253 5702	Tel
"tel-country-code"	Country code component of the telephone number	ASCII digits prefixed by a U+002B PLUS SIGN character (+)	+1	Text
"tel-national"	Telephone number without the county code component, with a country-internal prefix applied if applicable	ASCII digits and U+0020 SPACE characters	617 253 5702	Text
"tel-area-code"	Area code component of the telephone number, with a country-internal prefix applied if applicable	ASCII digits	617	Text
"tel-local"	Telephone number without the country code and area code components	ASCII digits	2535702	Text
"tel-local-prefix"	First part of the component of the telephone number that follows the area code, when that component is split into two components	ASCII digits	253	Text
"tel-local-suffix"	Second part of the component of the telephone number that follows the area code, when that component is split into two components	ASCII digits	5702	Text
"tel-extension"	Telephone number internal extension code	ASCII digits	1000	Text
"email"	E-mail address	Valid e-mail address	timbl@w3.org	E-mail
"impp"	URL representing an instant messaging protocol endpoint (for example, "aim:goim?screenname=example" or "xmpp:fred@example.net")	Valid URL string	irc://example.org/timbl,isuser	URL
The groups correspond to controls as follows:

Text
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
textarea elements
select elements
Multiline
input elements with a type attribute in the Hidden state
textarea elements
select elements
Password
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the Password state
textarea elements
select elements
URL
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the URL state
textarea elements
select elements
E-mail
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the E-mail state
textarea elements
select elements
Tel
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the Telephone state
textarea elements
select elements
Numeric
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the Number state
textarea elements
select elements
Month
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the Month state
textarea elements
select elements
Date
input elements with a type attribute in the Hidden state
input elements with a type attribute in the Text state
input elements with a type attribute in the Search state
input elements with a type attribute in the Date state
textarea elements
select elements
Address levels: The "address-level1" – "address-level4" fields are used to describe the locality of the street address. Different locales have different numbers of levels. For example, the US uses two levels (state and town), the UK uses one or two depending on the address (the post town, and in some cases the locality), and China can use three (province, city, district). The "address-level1" field represents the widest administrative division. Different locales order the fields in different ways; for example, in the US the town (level 2) precedes the state (level 1); while in Japan the prefecture (level 1) precedes the city (level 2) which precedes the district (level 3). Authors are encouraged to provide forms that are presented in a way that matches the country's conventions (hiding, showing, and rearranging fields accordingly as the user changes the country).

4.10.18.7.2 Processing model
Each input element to which the autocomplete attribute applies, each select element, and each textarea element, has an autofill hint set, an autofill scope, an autofill field name, and an IDL-exposed autofill value.

The autofill field name specifies the specific kind of data expected in the field, e.g. "street-address" or "cc-exp".

The autofill hint set identifies what address or contact information type the user agent is to look at, e.g. "shipping fax" or "billing".

The autofill scope identifies the group of fields whose information concerns the same subject, and consists of the autofill hint set with, if applicable, the "section-*" prefix, e.g. "billing", "section-parent shipping", or "section-child shipping home".

These values are defined as the result of running the following algorithm:

If the element has no autocomplete attribute, then jump to the step labeled default.

Let tokens be the result of splitting the attribute's value on ASCII whitespace.

If tokens is empty, then jump to the step labeled default.

Let index be the index of the last token in tokens.

If the indexth token in tokens is not an ASCII case-insensitive match for one of the tokens given in the first column of the following table, or if the number of tokens in tokens is greater than the maximum number given in the cell in the second column of that token's row, then jump to the step labeled default. Otherwise, let field be the string given in the cell of the first column of the matching row, and let category be the value of the cell in the third column of that same row.

Token	Maximum number of tokens	Category
"off"	1	Off
"on"	1	Automatic
"name"	3	Normal
"honorific-prefix"	3	Normal
"given-name"	3	Normal
"additional-name"	3	Normal
"family-name"	3	Normal
"honorific-suffix"	3	Normal
"nickname"	3	Normal
"organization-title"	3	Normal
"username"	3	Normal
"new-password"	3	Normal
"current-password"	3	Normal
"organization"	3	Normal
"street-address"	3	Normal
"address-line1"	3	Normal
"address-line2"	3	Normal
"address-line3"	3	Normal
"address-level4"	3	Normal
"address-level3"	3	Normal
"address-level2"	3	Normal
"address-level1"	3	Normal
"country"	3	Normal
"country-name"	3	Normal
"postal-code"	3	Normal
"cc-name"	3	Normal
"cc-given-name"	3	Normal
"cc-additional-name"	3	Normal
"cc-family-name"	3	Normal
"cc-number"	3	Normal
"cc-exp"	3	Normal
"cc-exp-month"	3	Normal
"cc-exp-year"	3	Normal
"cc-csc"	3	Normal
"cc-type"	3	Normal
"transaction-currency"	3	Normal
"transaction-amount"	3	Normal
"language"	3	Normal
"bday"	3	Normal
"bday-day"	3	Normal
"bday-month"	3	Normal
"bday-year"	3	Normal
"sex"	3	Normal
"url"	3	Normal
"photo"	3	Normal
"tel"	4	Contact
"tel-country-code"	4	Contact
"tel-national"	4	Contact
"tel-area-code"	4	Contact
"tel-local"	4	Contact
"tel-local-prefix"	4	Contact
"tel-local-suffix"	4	Contact
"tel-extension"	4	Contact
"email"	4	Contact
"impp"	4	Contact
If category is Off or Automatic but the element's autocomplete attribute is wearing the autofill anchor mantle, then jump to the step labeled default.

If category is Off, let the element's autofill field name be the string "off", let its autofill hint set be empty, and let its IDL-exposed autofill value be the string "off". Then, return.

If category is Automatic, let the element's autofill field name be the string "on", let its autofill hint set be empty, and let its IDL-exposed autofill value be the string "on". Then, return.

Let scope tokens be an empty list.

Let hint tokens be an empty set.

Let IDL value have the same value as field.

If the indexth token in tokens is the first entry, then skip to the step labeled done.

Decrement index by one.

If category is Contact and the indexth token in tokens is an ASCII case-insensitive match for one of the strings in the following list, then run the substeps that follow:

"home"
"work"
"mobile"
"fax"
"pager"
The substeps are:

Let contact be the matching string from the list above.

Insert contact at the start of scope tokens.

Add contact to hint tokens.

Let IDL value be the concatenation of contact, a U+0020 SPACE character, and the previous value of IDL value (which at this point will always be field).

If the indexth entry in tokens is the first entry, then skip to the step labeled done.

Decrement index by one.

If the indexth token in tokens is an ASCII case-insensitive match for one of the strings in the following list, then run the substeps that follow:

"shipping"
"billing"
The substeps are:

Let mode be the matching string from the list above.

Insert mode at the start of scope tokens.

Add mode to hint tokens.

Let IDL value be the concatenation of mode, a U+0020 SPACE character, and the previous value of IDL value (which at this point will either be field or the concatenation of contact, a space, and field).

If the indexth entry in tokens is the first entry, then skip to the step labeled done.

Decrement index by one.

If the indexth entry in tokens is not the first entry, then jump to the step labeled default.

If the first eight characters of the indexth token in tokens are not an ASCII case-insensitive match for the string "section-", then jump to the step labeled default.

Let section be the indexth token in tokens, converted to ASCII lowercase.

Insert section at the start of scope tokens.

Let IDL value be the concatenation of section, a U+0020 SPACE character, and the previous value of IDL value.

Done: Let the element's autofill hint set be hint tokens.

Let the element's autofill scope be scope tokens.

Let the element's autofill field name be field.

Let the element's IDL-exposed autofill value be IDL value.

Return.

Default: Let the element's IDL-exposed autofill value be the empty string, and its autofill hint set and autofill scope be empty.

If the element's autocomplete attribute is wearing the autofill anchor mantle, then let the element's autofill field name be the empty string and return.

Let form be the element's form owner, if any, or null otherwise.

If form is not null and form's autocomplete attribute is in the off state, then let the element's autofill field name be "off".

Otherwise, let the element's autofill field name be "on".

For the purposes of autofill, a control's data depends on the kind of control:

An input element with its type attribute in the E-mail state and with the multiple attribute specified
The element's values.
Any other input element
A textarea element
The element's value.
A select element with its multiple attribute specified
The option elements in the select element's list of options that have their selectedness set to true.
Any other select element
The option element in the select element's list of options that has its selectedness set to true.
How to process the autofill hint set, autofill scope, and autofill field name depends on the mantle that the autocomplete attribute is wearing.

When wearing the autofill expectation mantle...
When an element's autofill field name is "off", the user agent should not remember the control's data, and should not offer past values to the user.

In addition, when an element's autofill field name is "off", values are reset when traversing the history.

Banks frequently do not want UAs to prefill login information:

<p><label>Account: <input type="text" name="ac" autocomplete="off"></label></p>
<p><label>PIN: <input type="password" name="pin" autocomplete="off"></label></p>
When an element's autofill field name is not "off", the user agent may store the control's data, and may offer previously stored values to the user.

For example, suppose a user visits a page with this control:

<select name="country">
 <option>Afghanistan
 <option>Albania
 <option>Algeria
 <option>Andorra
 <option>Angola
 <option>Antigua and Barbuda
 <option>Argentina
 <option>Armenia
 <!-- ... -->
 <option>Yemen
 <option>Zambia
 <option>Zimbabwe
</select>
This might render as follows:



Suppose that on the first visit to this page, the user selects "Zambia". On the second visit, the user agent could duplicate the entry for Zambia at the top of the list, so that the interface instead looks like this:



When the autofill field name is "on", the user agent should attempt to use heuristics to determine the most appropriate values to offer the user, e.g. based on the element's name value, the position of the element in its tree, what other fields exist in the form, and so forth.

When the autofill field name is one of the names of the autofill fields described above, the user agent should provide suggestions that match the meaning of the field name as given in the table earlier in this section. The autofill hint set should be used to select amongst multiple possible suggestions.

For example, if a user once entered one address into fields that used the "shipping" keyword, and another address into fields that used the "billing" keyword, then in subsequent forms only the first address would be suggested for form controls whose autofill hint set contains the keyword "shipping". Both addresses might be suggested, however, for address-related form controls whose autofill hint set does not contain either keyword.

When wearing the autofill anchor mantle...
When the autofill field name is not the empty string, then the user agent must act as if the user had specified the control's data for the given autofill hint set, autofill scope, and autofill field name combination.

When the user agent autofills form controls, elements with the same form owner and the same autofill scope must use data relating to the same person, address, payment instrument, and contact details. When a user agent autofills "country" and "country-name" fields with the same form owner and autofill scope, and the user agent has a value for the country" field(s), then the "country-name" field(s) must be filled using a human-readable name for the same country. When a user agent fills in multiple fields at once, all fields with the same autofill field name, form owner and autofill scope must be filled with the same value.

Suppose a user agent knows of two phone numbers, +1 555 123 1234 and +1 555 666 7777. It would not be conforming for the user agent to fill a field with autocomplete="shipping tel-local-prefix" with the value "123" and another field in the same form with autocomplete="shipping tel-local-suffix" with the value "7777". The only valid prefilled values given the aforementioned information would be "123" and "1234", or "666" and "7777", respectively.

Similarly, if a form for some reason contained both a "cc-exp" field and a "cc-exp-month" field, and the user agent prefilled the form, then the month component of the former would have to match the latter.

This requirement interacts with the autofill anchor mantle also. Consider the following markup snippet:

<form>
 <input type=hidden autocomplete="nickname" value="TreePlate">
 <input type=text autocomplete="nickname">
</form>
The only value that a conforming user agent could suggest in the text control is "TreePlate", the value given by the hidden input element.

The "section-*" tokens in the autofill scope are opaque; user agents must not attempt to derive meaning from the precise values of these tokens.

For example, it would not be conforming if the user agent decided that it should offer the address it knows to be the user's daughter's address for "section-child" and the addresses it knows to be the user's spouses' addresses for "section-spouse".

The autocompletion mechanism must be implemented by the user agent acting as if the user had modified the control's data, and must be done at a time where the element is mutable (e.g. just after the element has been inserted into the document, or when the user agent stops parsing). User agents must only prefill controls using values that the user could have entered.

For example, if a select element only has option elements with values "Steve" and "Rebecca", "Jay", and "Bob", and has an autofill field name "given-name", but the user agent's only idea for what to prefill the field with is "Evan", then the user agent cannot prefill the field. It would not be conforming to somehow set the select element to the value "Evan", since the user could not have done so themselves.

A user agent prefilling a form control must not discriminate between form controls that are in a document tree and those that are connected; that is, it is not conforming to make the decision on whether or not to autofill based on whether the element's root is a shadow root versus a Document.

A user agent prefilling a form control's value must not cause that control to suffer from a type mismatch, suffer from being too long, suffer from being too short, suffer from an underflow, suffer from an overflow, or suffer from a step mismatch. A user agent prefilling a form control's value must not cause that control to suffer from a pattern mismatch either. Where possible given the control's constraints, user agents must use the format given as canonical in the aforementioned table. Where it's not possible for the canonical format to be used, user agents should use heuristics to attempt to convert values so that they can be used.

For example, if the user agent knows that the user's middle name is "Ines", and attempts to prefill a form control that looks like this:

<input name=middle-initial maxlength=1 autocomplete="additional-name">
...then the user agent could convert "Ines" to "I" and prefill it that way.

A more elaborate example would be with month values. If the user agent knows that the user's birthday is the 27th of July 2012, then it might try to prefill all of the following controls with slightly different values, all driven from this information:

<input name=b type=month autocomplete="bday">
2012-07	The day is dropped since the Month state only accepts a month/year combination. (Note that this example is non-conforming, because the autofill field name bday is not allowed with the Month state.)
<select name=c autocomplete="bday">
 <option>Jan
 <option>Feb
 ...
 <option>Jul
 <option>Aug
 ...
</select>
July	The user agent picks the month from the listed options, either by noticing there are twelve options and picking the 7th, or by recognizing that one of the strings (three characters "Jul" followed by a newline and a space) is a close match for the name of the month (July) in one of the user agent's supported languages, or through some other similar mechanism.
<input name=a type=number min=1 max=12 autocomplete="bday-month">
7	User agent converts "July" to a month number in the range 1..12, like the field.
<input name=a type=number min=0 max=11 autocomplete="bday-month">
6	User agent converts "July" to a month number in the range 0..11, like the field.
<input name=a type=number min=1 max=11 autocomplete="bday-month">
User agent doesn't fill in the field, since it can't make a good guess as to what the form expects.
A user agent may allow the user to override an element's autofill field name, e.g. to change it from "off" to "on" to allow values to be remembered and prefilled despite the page author's objections, or to always "off", never remembering values.

More specifically, user agents may in particular consider replacing the autofill field name of form controls that match the description given in the first column of the following table, when their autofill field name is either "on" or "off", with the value given in the second cell of that row. If this table is used, the replacements must be done in tree order, since all but the first row references the autofill field name of earlier elements. When the descriptions below refer to form controls being preceded or followed by others, they mean in the list of listed elements that share the same form owner.

Form control	New autofill field name
an input element whose type attribute is in the Text state that is followed by an input element whose type attribute is in the Password state	"username"
an input element whose type attribute is in the Password state that is preceded by an input element whose autofill field name is "username"	"current-password"
an input element whose type attribute is in the Password state that is preceded by an input element whose autofill field name is "current-password"	"new-password"
an input element whose type attribute is in the Password state that is preceded by an input element whose autofill field name is "new-password"	"new-password"
The autocomplete IDL attribute, on getting, must return the element's IDL-exposed autofill value, and on setting, must reflect the content attribute of the same name.

4.10.19 APIs for the text control selections
The input and textarea elements define several attributes and methods for handling their selection. Their shared algorithms are defined here.

element . select()
Selects everything in the text control.

element . selectionStart [ = value ]
Returns the offset to the start of the selection.

Can be set, to change the start of the selection.

element . selectionEnd [ = value ]
Returns the offset to the end of the selection.

Can be set, to change the end of the selection.

element . selectionDirection [ = value ]
Returns the current direction of the selection.

Can be set, to change the direction of the selection.

The possible values are "forward", "backward", and "none".

element . setSelectionRange(start, end [, direction] )
Changes the selection to cover the given substring in the given direction. If the direction is omitted, it will be reset to be the platform default (none or forward).

element . setRangeText(replacement [, start, end [, selectionMode ] ] )
Replaces a range of text with the new text. If the start and end arguments are not provided, the range is assumed to be the selection.

The final argument determines how the selection will be set after the text has been replaced. The possible values are:

"select"
Selects the newly inserted text.
"start"
Moves the selection to just before the inserted text.
"end"
Moves the selection to just after the selected text.
"preserve"
Attempts to preserve the selection. This is the default.
For input elements, these methods and attributes must operate on the element's value. For textarea elements, these methods and attributes must operate on the element's raw value.

Where possible, user interface features for changing the text selection in input and textarea elements must be implemented in terms of the DOM API described in this section, so that, e.g., all the same events fire.

The selections of input and textarea elements have a selection direction, which is either "forward", "backward", or "none". This direction is set when the user manipulates the selection. The exact meaning of the selection direction depends on the platform. To set the selection direction of an element to a given direction, update the element's selection direction to the given direction, unless the direction is "none" and the platform does not support that direction; in that case, update the element's selection direction to "forward".

On Windows, the direction indicates the position of the caret relative to the selection: a "forward" selection has the caret at the end of the selection and a "backward" selection has the caret at the start of the selection. Windows has no "none" direction.

On Mac, the direction indicates which end of the selection is affected when the user adjusts the size of the selection using the arrow keys with the Shift modifier: the "forward" direction means the end of the selection is modified, and the "backward" direction means the start of the selection is modified. The "none" direction is the default on Mac, it indicates that no particular direction has yet been selected. The user sets the direction implicitly when first adjusting the selection, based on which directional arrow key was used.

The select() method, when invoked, must run the following steps:

If this element is an input element, and either select() does not apply to this element or the corresponding control has no selectable text, return.

For instance, in a user agent where <input type=color> is rendered as a color well with a picker, as opposed to a text control accepting a hexadecimal color code, there would be no selectable text, and thus calls to the method are ignored.

Set the selection range with 0 and infinity.

The selectionStart attribute's getter must run the following steps:

If this element is an input element, and selectionStart does not apply to this element, return null.

If there is no selection, return the offset (in logical order) to the character that immediately follows the text entry cursor.

Return the offset (in logical order) to the character that immediately follows the start of the selection.

The selectionStart attribute's setter must run the following steps:

If this element is an input element, and selectionStart does not apply to this element, throw an "InvalidStateError" DOMException.

Let end be the value of this element's selectionEnd attribute.

If end is less than the given value, set end to the given value.

Set the selection range with the given value, end, and the value of this element's selectionDirection attribute.

The selectionEnd attribute's getter must run the following steps:

If this element is an input element, and selectionEnd does not apply to this element, return null.

If there is no selection, return the offset (in logical order) to the character that immediately follows the text entry cursor.

Return the offset (in logical order) to the character that immediately follows the end of the selection.

The selectionEnd attribute's setter must run the following steps:

If this element is an input element, and selectionEnd does not apply to this element, throw an "InvalidStateError" DOMException.

Set the selection range with the value of this element's selectionStart attribute, the given value, and the value of this element's selectionDirection attribute.

The selectionDirection attribute's getter must run the following steps:

If this element is an input element, and selectionDirection does not apply to this element, return null.

Return this element's selection direction.

The selectionDirection attribute's setter must run the following steps:

If this element is an input element, and selectionDirection does not apply to this element, throw an "InvalidStateError" DOMException.

Set the selection range with the value of this element's selectionStart attribute, the value of this element's selectionEnd attribute, and the given value.

The setSelectionRange(start, end, direction) method, when invoked, must run the following steps:


Support: input-selection
Chrome for Android	64+
Chrome	4+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	9+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.1+
Opera	10.6+

Source: caniuse.com

If this element is an input element, and setSelectionRange() does not apply to this element, throw an "InvalidStateError" DOMException.

Set the selection range with start, end, and direction.

To set the selection range with an integer or null start, an integer or null or the special value infinity end, and optionally a string direction, run the following steps:

If start is null, let start be zero.

If end is null, let end be zero.

Set the selection of the text control to the sequence of characters starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position. Arguments greater than the length of the value of the text control (including the special value infinity) must be treated as pointing at the end of the text control. If end is less than or equal to start then the start of the selection and the end of the selection must both be placed immediately before the character with offset end. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end.

If direction is not a case-sensitive match for either the string "backward" or "forward", or if the direction argument was omitted, set direction to "none".

Set the selection direction of the text control to direction.

If the previous steps caused the selection of the text control to be modified (in either extent or direction), then queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.

The setRangeText(replacement, start, end, selectMode) method, when invoked, must run the following steps:

If this element is an input element, and setRangeText() does not apply to this element, throw an "InvalidStateError" DOMException.

Set this element's dirty value flag to true.

If the method has only one argument, then let start and end have the values of the selectionStart attribute and the selectionEnd attribute respectively.

Otherwise, let start, end have the values of the second and third arguments respectively.

If start is greater than end, then throw an "IndexSizeError" DOMException.

If start is greater than the length of the value of the text control, then set it to the length of the value of the text control.

If end is greater than the length of the value of the text control, then set it to the length of the value of the text control.

Let selection start be the current value of the selectionStart attribute.

Let selection end be the current value of the selectionEnd attribute.

If start is less than end, delete the sequence of characters starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position.

Insert the value of the first argument into the text of the value of the text control, immediately before the startth character.

Let new length be the length of the value of the first argument.

Let new end be the sum of start and new length.

Run the appropriate set of substeps from the following list:

If the fourth argument's value is "select"
Let selection start be start.

Let selection end be new end.

If the fourth argument's value is "start"
Let selection start and selection end be start.

If the fourth argument's value is "end"
Let selection start and selection end be new end.

If the fourth argument's value is "preserve" (the default)
Let old length be end minus start.

Let delta be new length minus old length.

If selection start is greater than end, then increment it by delta. (If delta is negative, i.e. the new text is shorter than the old text, then this will decrease the value of selection start.)

Otherwise: if selection start is greater than start, then set it to start. (This snaps the start of the selection to the start of the new text if it was in the middle of the text that it replaced.)

If selection end is greater than end, then increment it by delta in the same way.

Otherwise: if selection end is greater than start, then set it to new end. (This snaps the end of the selection to the end of the new text if it was in the middle of the text that it replaced.)

Set the selection range with selection start and selection end.

The setRangeText() method uses the following enumeration:

enum SelectionMode {
  "select",
  "start",
  "end",
  "preserve" // default
};
All elements to which this API applies have either a selection or a text entry cursor position at all times (even for elements that are not being rendered). The initial state must consist of a text entry cursor at the beginning of the control.

Characters with no visible rendering, such as U+200D ZERO WIDTH JOINER, still count as characters. Thus, for instance, the selection can include just an invisible character, and the text insertion cursor can be placed to one side or another of such a character.

To obtain the currently selected text, the following JavaScript suffices:

var selectionText = control.value.substring(control.selectionStart, control.selectionEnd);
...where control is the input or textarea element.

To add some text at the start of a text control, while maintaining the text selection, the three attributes must be preserved:

var oldStart = control.selectionStart;
var oldEnd = control.selectionEnd;
var oldDirection = control.selectionDirection;
var prefix = "http://";
control.value = prefix + control.value;
control.setSelectionRange(oldStart + prefix.length, oldEnd + prefix.length, oldDirection);
...where control is the input or textarea element.

4.10.20 Constraints
4.10.20.1 Definitions
A submittable element is a candidate for constraint validation except when a condition has barred the element from constraint validation. (For example, an element is barred from constraint validation if it is an object element.)

An element can have a custom validity error message defined. Initially, an element must have its custom validity error message set to the empty string. When its value is not the empty string, the element is suffering from a custom error. It can be set using the setCustomValidity() method. The user agent should use the custom validity error message when alerting the user to the problem with the control.

An element can be constrained in various ways. The following is the list of validity states that a form control can be in, making the control invalid for the purposes of constraint validation. (The definitions below are non-normative; other parts of this specification define more precisely when each state applies or does not.)

Suffering from being missing
When a control has no value but has a required attribute (input required, textarea required); or, more complicated rules for select elements and controls in radio button groups, as specified in their sections.

Suffering from a type mismatch
When a control that allows arbitrary user input has a value that is not in the correct syntax (E-mail, URL).

Suffering from a pattern mismatch
When a control has a value that doesn't satisfy the pattern attribute.

Suffering from being too long
When a control has a value that is too long for the form control maxlength attribute (input maxlength, textarea maxlength).

Suffering from being too short
When a control has a value that is too short for the form control minlength attribute (input minlength, textarea minlength).

Suffering from an underflow
When a control has a value that is not the empty string and is too low for the min attribute.

Suffering from an overflow
When a control has a value that is not the empty string and is too high for the max attribute.

Suffering from a step mismatch
When a control has a value that doesn't fit the rules given by the step attribute.

Suffering from bad input
When a control has incomplete input and the user agent does not think the user ought to be able to submit the form in its current state.

Suffering from a custom error
When a control's custom validity error message (as set by the element's setCustomValidity() method) is not the empty string.

An element can still suffer from these states even when the element is disabled; thus these states can be represented in the DOM even if validating the form during submission wouldn't indicate a problem to the user.

An element satisfies its constraints if it is not suffering from any of the above validity states.

4.10.20.2 Constraint validation
When the user agent is required to statically validate the constraints of form element form, it must run the following steps, which return either a positive result (all the controls in the form are valid) or a negative result (there are invalid controls) along with a (possibly empty) list of elements that are invalid and for which no script has claimed responsibility:

Let controls be a list of all the submittable elements whose form owner is form, in tree order.

Let invalid controls be an initially empty list of elements.

For each element field in controls, in tree order:

If field is not a candidate for constraint validation, then move on to the next element.

Otherwise, if field satisfies its constraints, then move on to the next element.

Otherwise, add field to invalid controls.

If invalid controls is empty, then return a positive result.

Let unhandled invalid controls be an initially empty list of elements.

For each element field in invalid controls, if any, in tree order:

Let notCanceled be the result of firing an event named invalid at field, with the cancelable attribute initialized to true.

If notCanceled is true, then add field to unhandled invalid controls.

Return a negative result with the list of elements in the unhandled invalid controls list.

If a user agent is to interactively validate the constraints of form element form, then the user agent must run the following steps:

Statically validate the constraints of form, and let unhandled invalid controls be the list of elements returned if the result was negative.

If the result was positive, then return that result.

Report the problems with the constraints of at least one of the elements given in unhandled invalid controls to the user. User agents may focus one of those elements in the process, by running the focusing steps for that element, and may change the scrolling position of the document, or perform some other action that brings the element to the user's attention. User agents may report more than one constraint violation. User agents may coalesce related constraint violation reports if appropriate (e.g. if multiple radio buttons in a group are marked as required, only one error need be reported). If one of the controls is not being rendered (e.g. it has the hidden attribute set) then user agents may report a script error.

Return a negative result.

4.10.20.3 The constraint validation API

Support: constraint-validation
Chrome for Android	64+
Chrome	40+
iOS Safari	10.0+
UC Browser for Android	11.8+
Firefox	51+
Samsung Internet	4+
IE (limited)	10+
Opera Mini	None
Safari	10+
Edge	17+
Android Browser	62+
Opera	27+

Source: caniuse.com

element . willValidate
Returns true if the element will be validated when the form is submitted; false otherwise.

element . setCustomValidity(message)
Sets a custom error, so that the element would fail to validate. The given message is the message to be shown to the user when reporting the problem to the user.

If the argument is the empty string, clears the custom error.

element . validity . valueMissing
Returns true if the element has no value but is a required field; false otherwise.

element . validity . typeMismatch
Returns true if the element's value is not in the correct syntax; false otherwise.

element . validity . patternMismatch
Returns true if the element's value doesn't match the provided pattern; false otherwise.

element . validity . tooLong
Returns true if the element's value is longer than the provided maximum length; false otherwise.

element . validity . tooShort
Returns true if the element's value, if it is not the empty string, is shorter than the provided minimum length; false otherwise.

element . validity . rangeUnderflow
Returns true if the element's value is lower than the provided minimum; false otherwise.

element . validity . rangeOverflow
Returns true if the element's value is higher than the provided maximum; false otherwise.

element . validity . stepMismatch
Returns true if the element's value doesn't fit the rules given by the step attribute; false otherwise.

element . validity . badInput
Returns true if the user has provided input in the user interface that the user agent is unable to convert to a value; false otherwise.

element . validity . customError
Returns true if the element has a custom error; false otherwise.

element . validity . valid
Returns true if the element's value has no validity problems; false otherwise.

valid = element . checkValidity()
Returns true if the element's value has no validity problems; false otherwise. Fires an invalid event at the element in the latter case.

valid = element . reportValidity()
Returns true if the element's value has no validity problems; otherwise, returns false, fires an invalid event at the element, and (if the event isn't canceled) reports the problem to the user.

element . validationMessage
Returns the error message that would be shown to the user if the element was to be checked for validity.

The willValidate attribute's getter must return true, if this element is a candidate for constraint validation, and false otherwise (i.e., false if any conditions are barring it from constraint validation).

The setCustomValidity(message) method, when invoked, must set the custom validity error message to message.

In the following example, a script checks the value of a form control each time it is edited, and whenever it is not a valid value, uses the setCustomValidity() method to set an appropriate message.

<label>Feeling: <input name=f type="text" oninput="check(this)"></label>
<script>
 function check(input) {
   if (input.value == "good" ||
       input.value == "fine" ||
       input.value == "tired") {
     input.setCustomValidity('"' + input.value + '" is not a feeling.');
   } else {
     // input is fine -- reset the error message
     input.setCustomValidity('');
   }
 }
</script>
The validity attribute's getter must return a ValidityState object that represents the validity states of this element. This object is live.

[Exposed=Window]
interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean tooShort;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};
A ValidityState object has the following attributes. On getting, they must return true if the corresponding condition given in the following list is true, and false otherwise.

valueMissing
The control is suffering from being missing.

typeMismatch
The control is suffering from a type mismatch.

patternMismatch
The control is suffering from a pattern mismatch.

tooLong
The control is suffering from being too long.

tooShort
The control is suffering from being too short.

rangeUnderflow
The control is suffering from an underflow.

rangeOverflow
The control is suffering from an overflow.

stepMismatch
The control is suffering from a step mismatch.

badInput
The control is suffering from bad input.

customError
The control is suffering from a custom error.

valid
None of the other conditions are true.

The checkValidity() method, when invoked, must run these steps:

If this element is a candidate for constraint validation and does not satisfy its constraints, then:

Fire an event named invalid at this element, with the cancelable attribute initialized to true (though canceling has no effect).

Return false.

Return true.

The reportValidity() method, when invoked, must run these steps:

If this element is a candidate for constraint validation and does not satisfy its constraints, then:

Let report be the result of firing an event named invalid at this element, with the cancelable attribute initialized to true.

If report is true, then report the problems with the constraints of this element to the user. When reporting the problem with the constraints to the user, the user agent may run the focusing steps for this element, and may change the scrolling position of the document, or perform some other action that brings this element to the user's attention. User agents may report more than one constraint violation, if this element suffers from multiple problems at once. If this element is not being rendered, then the user agent may, instead of notifying the user, report the error for the running script.

Return false.

Return true.

The validationMessage attribute's getter must run these steps:

If this element is not a candidate for constraint validation or if this element satisfies its constraints, then return the empty string.

Return a suitably localized message that the user agent would show the user if this were the only form control with a validity constraint problem. If the user agent would not actually show a textual message in such a situation (e.g., it would show a graphical cue instead), then return a suitably localized message that expresses (one or more of) the validity constraint(s) that the control does not satisfy. If the element is a candidate for constraint validation and is suffering from a custom error, then the custom validity error message should be present in the return value.

4.10.20.4 Security
Servers should not rely on client-side validation. Client-side validation can be intentionally bypassed by hostile users, and unintentionally bypassed by users of older user agents or automated tools that do not implement these features. The constraint validation features are only intended to improve the user experience, not to provide any kind of security mechanism.

4.10.21 Form submission
4.10.21.1 Introduction
This section is non-normative.

When a form is submitted, the data in the form is converted into the structure specified by the enctype, and then sent to the destination specified by the action using the given method.

For example, take the following form:

<form action="/find.cgi" method=get>
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>
If the user types in "cats" in the first field and "fur" in the second, and then hits the submit button, then the user agent will load /find.cgi?t=cats&q=fur.

On the other hand, consider this form:

<form action="/find.cgi" method=post enctype="multipart/form-data">
 <input type=text name=t>
 <input type=search name=q>
 <input type=submit>
</form>
Given the same user input, the result on submission is quite different: the user agent instead does an HTTP POST to the given URL, with as the entity body something like the following text:

------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="t"

cats
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="q"

fur
------kYFrd4jNJEgCervE--
4.10.21.2 Implicit submission
A form element's default button is the first submit button in tree order whose form owner is that form element.

If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting the "enter" key while a text control is focused implicitly submits the form), then doing so for a form, whose default button has activation behavior and is not disabled, must cause the user agent to fire a click event at that default button.

There are pages on the Web that are only usable if there is a way to implicitly submit forms, so user agents are strongly encouraged to support this.

If the form has no submit button, then the implicit submission mechanism must do nothing if the form has more than one field that blocks implicit submission, and must submit the form element from the form element itself otherwise.

For the purpose of the previous paragraph, an element is a field that blocks implicit submission of a form element if it is an input element whose form owner is that form element and whose type attribute is in one of the following states: Text, Search, URL, Telephone, E-mail, Password, Date, Month, Week, Time, Local Date and Time, Number

4.10.21.3 Form submission algorithm
When a form element form is submitted from an element submitter (typically a button), optionally with a submitted from submit() method flag set, the user agent must run the following steps:

If form cannot navigate, then return.

Let form document be form's node document.

If form document's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.

Let form browsing context be the browsing context of form document.

If the submitted from submit() method flag is not set, and the submitter element's no-validate state is false, then interactively validate the constraints of form and examine the result: if the result is negative (the constraint validation concluded that there were invalid fields and probably informed the user of this) then fire an event named invalid at the form element and then return.

If the submitted from submit() method flag is not set, then:

Let continue be the result of firing an event named submit at form, with the bubbles attribute initialized to true and the cancelable attribute initialized to true.

If continue is false, then return.

If form cannot navigate, then return.

Cannot navigate is run again as dispatching the submit event could have changed the outcome.

Let form data set be the result of constructing the form data set for form in the context of submitter.

Let encoding be the result of picking an encoding for the form.

Let action be the submitter element's action.

If action is the empty string, let action be the URL of the form document.

Parse the URL action, relative to the submitter element's node document. If this fails, return.

Let parsed action be the resulting URL record.

Let scheme be the scheme of parsed action.

Let enctype be the submitter element's enctype.

Let method be the submitter element's method.

Let target be the submitter element's formtarget attribute value, if the element is a submit button and has such an attribute. Otherwise, let it be the result of getting an element's target given submitter's form owner.

Let target browsing context and replace be the result of applying the rules for choosing a browsing context using target and form browsing context.

If target browsing context is null, then return.

If form document has not yet completely loaded and the submitted from submit() method flag is set, then set replace to true.

If the value of method is dialog then jump to the submit dialog steps.

Otherwise, select the appropriate row in the table below based on the value of scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on the value of method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.

GET	POST
http	Mutate action URL	Submit as entity body
https	Mutate action URL	Submit as entity body
ftp	Get action URL	Get action URL
javascript	Get action URL	Get action URL
data	Mutate action URL	Get action URL
mailto	Mail with headers	Mail as body
If scheme is not one of those listed in this table, then the behavior is not defined by this specification. User agents should, in the absence of another specification defining this, act in a manner analogous to that defined in this specification for similar schemes.

Each form element has a planned navigation, which is either null or a task; when the form is first created, its planned navigation must be set to null. In the behaviors described below, when the user agent is required to plan to navigate to a particular resource destination, it must run the following steps:

If the form has a non-null planned navigation, remove it from its task queue.

Let the form's planned navigation be a new task that consists of running the following steps:

Let the form's planned navigation be null.

Navigate target browsing context to destination. If replace is true, then target browsing context must be navigated with replacement enabled.

For the purposes of this task, target browsing context and replace are the variables that were set up when the overall form submission algorithm was run, with their values as they stood when this planned navigation was queued.

Queue the task that is the form's new planned navigation.

The task source for this task is the DOM manipulation task source.

The behaviors are as follows:

Mutate action URL
Let query be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.

Set parsed action's query component to query.

Plan to navigate to parsed action.

Submit as entity body
Switch on enctype:

application/x-www-form-urlencoded
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.

Set body to the result of encoding body.

Let MIME type be "application/x-www-form-urlencoded".

multipart/form-data
Let body be the result of running the multipart/form-data encoding algorithm with form data set and encoding.

Let MIME type be the concatenation of the string "multipart/form-data;", a U+0020 SPACE character, the string "boundary=", and the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.

text/plain
Let body be the result of running the text/plain encoding algorithm with form data set and encoding.

Set body to the result of encoding body using encoding.

Let MIME type be "text/plain".

Plan to navigate to a new request whose url is parsed action, method is method, header list consists of `Content-Type`/MIME type, and body is body.

Get action URL
Plan to navigate to parsed action.

The form data set is discarded.

Mail with headers
Let headers be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.

Replace occurrences of U+002B PLUS SIGN characters (+) in headers with the string "%20".

Set parsed action's query to headers.

Plan to navigate to parsed action.

Mail as body
Switch on enctype:

text/plain
Let body be the result of running the text/plain encoding algorithm with form data set and encoding.

Set body to the result of concatenating the result of UTF-8 percent encoding each code point in body, using the default encode set. [URL]

Otherwise
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.

If parsed action's query is null, then set it to the empty string.

If parsed action's query is not the empty string, then append a single U+0026 AMPERSAND character (&) to it.

Append "body=" to parsed action's query.

Append body to parsed action's query.

Plan to navigate to parsed action.

Submit dialog
Let subject be the nearest ancestor dialog element of form, if any.

If there isn't one, or if it does not have an open attribute, do nothing. Otherwise, proceed as follows:

If submitter is an input element whose type attribute is in the Image Button state, then let result be the string formed by concatenating the selected coordinate's x-component, expressed as a base-ten number using ASCII digits, a U+002C COMMA character (,), and the selected coordinate's y-component, expressed in the same way as the x-component.

Otherwise, if submitter has a value, then let result be that value.

Otherwise, there is no result.

Then, close the dialog subject. If there is a result, let that be the return value.

4.10.21.4 Constructing the form data set
The algorithm to construct the form data set for a form form optionally in the context of a submitter submitter is as follows. If not specified otherwise, submitter is null.

Let controls be a list of all the submittable elements whose form owner is form, in tree order.

Let the form data set be a list of name-value-type tuples, initially empty.

For each element field in controls, in tree order:

If any of the following is true:

The field element has a datalist element ancestor.
The field element is disabled.
The field element is a button but it is not submitter.
The field element is an input element whose type attribute is in the Checkbox state and whose checkedness is false.
The field element is an input element whose type attribute is in the Radio Button state and whose checkedness is false.
The field element is not an input element whose type attribute is in the Image Button state, and either the field element does not have a name attribute specified, or its name attribute's value is the empty string.
The field element is an object element that is not using a plugin.
Then continue.

Let type be the value of the type IDL attribute of field.

If the field element is an input element whose type attribute is in the Image Button state, then:

If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by a single U+002E FULL STOP character (.). Otherwise, let name be the empty string.

Let namex be the string consisting of the concatenation of name and a single U+0078 LATIN SMALL LETTER X character (x).

Let namey be the string consisting of the concatenation of name and a single U+0079 LATIN SMALL LETTER Y character (y).

The field element is submitter, and before this algorithm was invoked the user indicated a coordinate. Let x be the x-component of the coordinate selected by the user, and let y be the y-component of the coordinate selected by the user.

Append an entry to the form data set with the name namex, the value x, and the type type.

Append an entry to the form data set with the name namey and the value y, and the type type.

Continue.

Let name be the value of the field element's name attribute.

If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled, append an entry to the form data set with the name as the name, the value of the option element as the value, and type as the type.

Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then:

If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".

Append an entry to the form data set with name as the name, value as the value, and type as the type.

Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then for each file selected in the input element, append an entry to the form data set with the name as the name, the file (consisting of the name, the type, and the body) as the value, and type as the type. If there are no selected files, then append an entry to the form data set with the name as the name, the empty string as the value, and application/octet-stream as the type.

Otherwise, if the field element is an object element: try to obtain a form submission value from the plugin, and if that is successful, append an entry to the form data set with name as the name, the returned form submission value as the value, and the string "object" as the type.

Otherwise, append an entry to the form data set with name as the name, the value of the field element as the value, and type as the type.

If the element has a dirname attribute, and that attribute's value is not the empty string, then:

Let dirname be the value of the element's dirname attribute.

Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e. when the directionality of the element is 'rtl').

Append an entry to the form data set with dirname as the name, dir as the value, and the string "direction" as the type.

An element can only have a dirname attribute if it is a textarea element or an input element whose type attribute is in either the Text state or the Search state.

For the name of each entry in the form data set, and for the value of each entry in the form data set whose type is not "file" or "textarea", replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR), by a string consisting of a U+000D (CR) and U+000A (LF).

In the case of the value of textarea elements, this newline normalization is already performed during the conversion of the control's raw value into the control's value (which also performs any necessary line wrapping). In the case of input elements type attributes in the File Upload state, the value is not normalized.

Replace the name of each entry in the form data set, and the value of each entry in the form data set whose type is not "file", with the results of converting to a sequence of Unicode scalar values.

Return the form data set.

4.10.21.5 Selecting a form submission encoding
If the user agent is to pick an encoding for a form, it must run the following steps:

Let encoding be the document's character encoding.

If the form element has an accept-charset attribute, set encoding to the return value of running these substeps:

Let input be the value of the form element's accept-charset attribute.

Let candidate encoding labels be the result of splitting input on ASCII whitespace.

Let candidate encodings be an empty list of character encodings.

For each token in candidate encoding labels in turn (in the order in which they were found in input), get an encoding for the token and, if this does not result in failure, append the encoding to candidate encodings.

If candidate encodings is empty, return UTF-8.

Return the first encoding in candidate encodings.

Return the result of getting an output encoding from encoding.

4.10.21.6 URL-encoded form data
See the WHATWG URL standard for details on application/x-www-form-urlencoded. [URL]

4.10.21.7 Multipart form data

Spec bugs: 16909

The multipart/form-data encoding algorithm, given a form data set and encoding, is as follows:

Let result be the empty string.

Let charset be the name of encoding.

For each entry in the form data set:

If the entry's name is "_charset_" and its type is "hidden", replace its value with charset.

For each character in the entry's name and value that cannot be expressed using the selected character encoding, replace the character by a string consisting of a U+0026 AMPERSAND character (&), a U+0023 NUMBER SIGN character (#), one or more ASCII digits representing the code point of the character in base ten, and finally a U+003B (;).

Encode the (now mutated) form data set using the rules described by RFC 7578, Returning Values from Forms: multipart/form-data, and return the resulting byte stream. [RFC7578]

Each entry in the form data set is a field, the name of the entry is the field name and the value of the entry is the field value.

The order of parts must be the same as the order of fields in the form data set. Multiple entries with the same name must be treated as distinct fields.

The parts of the generated multipart/form-data resource that correspond to non-file fields must not have a `Content-Type` header specified. Their names and values must be encoded using the character encoding selected above.

File names included in the generated multipart/form-data resource (as part of file fields) must use the character encoding selected above, though the precise name may be approximated if necessary (e.g. newlines could be removed from file names, quotes could be changed to "%22", and characters not expressible in the selected character encoding could be replaced by other characters).

The boundary used by the user agent in generating the return value of this algorithm is the multipart/form-data boundary string. (This value is used to generate the MIME type of the form submission payload generated by this algorithm.)

For details on how to interpret multipart/form-data payloads, see RFC 7578. [RFC7578]

4.10.21.8 Plain text form data
The text/plain encoding algorithm, given a form data set and encoding, is as follows:

Let result be the empty string.

Let charset be the name of encoding.

For each entry in the form data set:

If the entry's name is "_charset_" and its type is "hidden", replace its value with charset.

If the entry's type is "file", replace its value with the file's name only.

Append the entry's name to result.

Append a single U+003D EQUALS SIGN character (=) to result.

Append the entry's value to result.

Append a U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) character pair to result.

Return result.

Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value).

4.10.22 Resetting a form
When a form element form is reset, run these steps:

Let reset be the result of firing an event named reset at form, with the bubbles and cancelable attributes initialized to true.

If reset is true, then invoke the reset algorithm of each resettable element whose form owner is form.

Each resettable element defines its own reset algorithm. Changes made to form controls as part of these algorithms do not count as changes caused by the user (and thus, e.g., do not cause input events to fire).

4.11 Interactive elements
4.11.1 The details element

Support: details
Chrome for Android	64+
Chrome	12+
iOS Safari	6.0+
UC Browser for Android	11.8+
Firefox	49+
Samsung Internet	4+
IE	None
Safari	6+
Edge	None
Android Browser	4+
Opera	15+

Source: caniuse.com

Categories:
Flow content.
Sectioning root.
Interactive content.
Palpable content.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
One summary element followed by flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
open — Whether the details are visible
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDetailsElement : HTMLElement {
  [CEReactions] attribute boolean open;
};
The details element represents a disclosure widget from which the user can obtain additional information or controls.

The details element is not appropriate for footnotes. Please see the section on footnotes for details on how to mark up footnotes.

The first summary element child of the element, if any, represents the summary or legend of the details. If there is no child summary element, the user agent should provide its own legend (e.g. "Details").

The rest of the element's contents represents the additional information or controls.

The open content attribute is a boolean attribute. If present, it indicates that both the summary and the additional information is to be shown to the user. If the attribute is absent, only the summary is to be shown.

When the element is created, if the attribute is absent, the additional information should be hidden; if the attribute is present, that information should be shown. Subsequently, if the attribute is removed, then the information should be hidden; if the attribute is added, the information should be shown.

The user agent should allow the user to request that the additional information be shown or hidden. To honor a request for the details to be shown, the user agent must set the open attribute on the element to the empty string. To honor a request for the information to be hidden, the user agent must remove the open attribute from the element.

This ability to request that additional information be shown or hidden may simply be the activation behavior of the appropriate summary element, in the case such an element exists. However, if no such element exists, user agents can still provide this ability through some other user interface affordance.

Whenever the open attribute is added to or removed from a details element, the user agent must queue a task that runs the following steps, which are known as the details notification task steps, for this details element:

If another task has been queued to run the details notification task steps for this details element, then return.

When the open attribute is toggled several times in succession, these steps essentially get coalesced so that only one event is fired.

Fire an event named toggle at the details element.

The task source for this task must be the DOM manipulation task source.

The open IDL attribute must reflect the open content attribute.

The following example shows the details element being used to hide technical details in a progress report.

<section class="progress window">
 <h1>Copying "Really Achieving Your Childhood Dreams"</h1>
 <details>
  <summary>Copying... <progress max="375505392" value="97543282"></progress> 25%</summary>
  <dl>
   <dt>Transfer rate:</dt> <dd>452KB/s</dd>
   <dt>Local filename:</dt> <dd>/home/rpausch/raycd.m4v</dd>
   <dt>Remote filename:</dt> <dd>/var/www/lectures/raycd.m4v</dd>
   <dt>Duration:</dt> <dd>01:16:27</dd>
   <dt>Color profile:</dt> <dd>SD (6-1-6)</dd>
   <dt>Dimensions:</dt> <dd>320×240</dd>
  </dl>
 </details>
</section>
The following shows how a details element can be used to hide some controls by default:

<details>
 <summary><label for=fn>Name & Extension:</label></summary>
 <p><input type=text id=fn name=fn value="Pillar Magazine.pdf">
 <p><label><input type=checkbox name=ext checked> Hide extension</label>
</details>
One could use this in conjunction with other details in a list to allow the user to collapse a set of fields down to a small set of headings, with the ability to open each one.



In these examples, the summary really just summarizes what the controls can change, and not the actual values, which is less than ideal.

Because the open attribute is added and removed automatically as the user interacts with the control, it can be used in CSS to style the element differently based on its state. Here, a stylesheet is used to animate the color of the summary when the element is opened or closed:

<style>
 details > summary { transition: color 1s; color: black; }
 details[open] > summary { color: red; }
</style>
<details>
 <summary>Automated Status: Operational</summary>
 <p>Velocity: 12m/s</p>
 <p>Direction: North</p>
</details>
4.11.2 The summary element
Categories:
None.
Contexts in which this element can be used:
As the first child of a details element.
Content model:
Either: phrasing content.
Or: one element of heading content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The summary element represents a summary, caption, or legend for the rest of the contents of the summary element's parent details element, if any.

The activation behavior of summary elements is to run the following steps:

If this summary element has no parent node, then return.

Let parent be this summary element's parent node.

If parent is not a details element, then return.

If parent's first summary element child is not this summary element, then return.

If the open attribute is present on parent, then remove it. Otherwise, set parent's open attribute to the empty string.

This will then run the details notification task steps.

4.11.3 Commands
4.11.3.1 Facets
A command is the abstraction behind menu items, buttons, and links. Once a command is defined, other parts of the interface can refer to the same command, allowing many access points to a single feature to share facets such as the Disabled State.

Commands are defined to have the following facets:

Label
The name of the command as seen by the user.
Access Key
A key combination selected by the user agent that triggers the command. A command might not have an Access Key.
Hidden State
Whether the command is hidden or not (basically, whether it should be shown in menus).
Disabled State
Whether the command is relevant and can be triggered or not.
Action
The actual effect that triggering the command will have. This could be a scripted event handler, a URL to which to navigate, or a form submission.
User agents may expose the commands that match the following criteria:

The Hidden State facet is false (visible)
The element is in a document that has an associated browsing context.
Neither the element nor any of its ancestors has a hidden attribute specified.
User agents are encouraged to do this especially for commands that have Access Keys, as a way to advertise those keys to the user.

For example, such commands could be listed in the user agent's menu bar.

4.11.3.2 Using the a element to define a command
An a element with an href attribute defines a command.

The Label of the command is the string given by the element's textContent IDL attribute.

The AccessKey of the command is the element's assigned access key, if any.

The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The Disabled State facet of the command is true if the element or one of its ancestors is inert, and false otherwise.

The Action of the command is to fire a click event at the element.

4.11.3.3 Using the button element to define a command
A button element always defines a command.

The Label, Access Key, Hidden State, and Action facets of the command are determined as for a elements (see the previous section).

The Disabled State of the command is true if the element or one of its ancestors is inert, or if the element's disabled state is set, and false otherwise.

4.11.3.4 Using the input element to define a command
An input element whose type attribute is in one of the Submit Button, Reset Button, Image Button, Button, Radio Button, or Checkbox states defines a command.

The Label of the command is determined as follows:

If the type attribute is in one of the Submit Button, Reset Button, Image Button, or Button states, then the Label is the string given by the value attribute, if any, and a UA-dependent, locale-dependent value that the UA uses to label the button itself if the attribute is absent.

Otherwise, if the element is a labeled control, then the Label is the string given by the textContent of the first label element in tree order whose labeled control is the element in question. (In DOM terms, this is the string given by element.labels[0].textContent.)

Otherwise, if the value attribute is present, then the Label is the value of that attribute.

Otherwise, the Label is the empty string.

The AccessKey of the command is the element's assigned access key, if any.

The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The Disabled State of the command is true if the element or one of its ancestors is inert, or if the element's disabled state is set, and false otherwise.

The Action of the command is to fire a click event at the element.

4.11.3.5 Using the option element to define a command
An option element with an ancestor select element and either no value attribute or a value attribute that is not the empty string defines a command.

The Label of the command is the value of the option element's label attribute, if there is one, or else the value of option element's textContent IDL attribute, with ASCII whitespace stripped and collapsed.

The AccessKey of the command is the element's assigned access key, if any.

The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The Disabled State of the command is true if the element is disabled, or if its nearest ancestor select element is disabled, or if it or one of its ancestors is inert, and false otherwise.

If the option's nearest ancestor select element has a multiple attribute, the Action of the command is to toggle the option element. Otherwise, the Action is to pick the option element.

4.11.3.6 Using the accesskey attribute on a legend element to define a command
A legend element that has an assigned access key and is a child of a fieldset element that has a descendant that is not a descendant of the legend element and is neither a label element nor a legend element but that defines a command, itself defines a command.

The Label of the command is the string given by the element's textContent IDL attribute.

The AccessKey of the command is the element's assigned access key.

The Hidden State, Disabled State, and Action facets of the command are the same as the respective facets of the first element in tree order that is a descendant of the parent of the legend element that defines a command but is not a descendant of the legend element and is neither a label nor a legend element.

4.11.3.7 Using the accesskey attribute to define a command on other elements
An element that has an assigned access key defines a command.

If one of the earlier sections that define elements that define commands define that this element defines a command, then that section applies to this element, and this section does not. Otherwise, this section applies to that element.

The Label of the command depends on the element. If the element is a labeled control, the textContent of the first label element in tree order whose labeled control is the element in question is the Label (in DOM terms, this is the string given by element.labels[0].textContent). Otherwise, the Label is the textContent of the element itself.

The AccessKey of the command is the element's assigned access key.

The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The Disabled State of the command is true if the element or one of its ancestors is inert, and false otherwise.

The Action of the command is to run the following steps:

Run the focusing steps for the element.
Fire a click event at the element.
4.11.4 The dialog element

Support: dialog
Chrome for Android	64+
Chrome	37+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	None
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	62+
Opera	24+

Source: caniuse.com

Categories:
Flow content.
Sectioning root.
Contexts in which this element can be used:
Where flow content is expected.
Content model:
Flow content.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
open — Whether the dialog box is showing
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLDialogElement : HTMLElement {
  [CEReactions] attribute boolean open;
  attribute DOMString returnValue;
  [CEReactions] void show();
  [CEReactions] void showModal();
  [CEReactions] void close(optional DOMString returnValue);
};
The dialog element represents a part of an application that a user interacts with to perform a task, for example a dialog box, inspector, or window.

The open attribute is a boolean attribute. When specified, it indicates that the dialog element is active and that the user can interact with it.

A dialog element without an open attribute specified should not be shown to the user. This requirement may be implemented indirectly through the style layer. For example, user agents that support the suggested default rendering implement this requirement using the CSS rules described in the rendering section.

Removing the open attribute will usually hide the dialog. However, doing so has a number of strange additional consequences:

The close event will not be fired.

The close() method, and any user-agent provided cancelation interface, will no longer be able to close the dialog.

If the dialog was shown using its showModal() method, the Document will still be blocked.

For these reasons, it is generally better to never remove the open attribute manually. Instead, use the close() method to close the dialog, or the hidden attribute to hide it.

The tabindex attribute must not be specified on dialog elements.

dialog . show()
Displays the dialog element.

dialog . showModal()
Displays the dialog element and makes it the top-most modal dialog.

This method honors the autofocus attribute.

dialog . close( [ result ] )
Closes the dialog element.

The argument, if provided, provides a return value.

dialog . returnValue [ = result ]
Returns the dialog's return value.

Can be set, to update the return value.

When the show() method is invoked, the user agent must run the following steps:

If the element already has an open attribute, then return.

Add an open attribute to the dialog element, whose value is the empty string.

Set the dialog to the normal alignment mode.

Run the dialog focusing steps for the dialog element.

When the showModal() method is invoked, the user agent must run the following steps:

Let subject be the dialog element on which the method was invoked.

If subject already has an open attribute, then throw an "InvalidStateError" DOMException.

If subject is not connected, then throw an "InvalidStateError" DOMException.

Add an open attribute to subject, whose value is the empty string.

Set the dialog to the centered alignment mode.

Let subject's node document be blocked by the modal dialog subject.

If subject's node document's top layer does not already contain subject, then add subject to subject's node document's top layer.

Run the dialog focusing steps for subject.

The dialog focusing steps for a dialog element subject are as follows:

If for some reason subject is not a control group owner object at this point, or if it is inert, return.

Let control be the first non-inert focusable area in subject's control group whose DOM anchor has an autofocus attribute specified.

If there isn't one, then let control be the first non-inert focusable area in subject's control group.

If there isn't one of those either, then let control be subject.

Run the focusing steps for control.

If at any time a dialog element is removed from a Document, then if that dialog is in that Document's top layer, it must be removed from it.

When the close() method is invoked, the user agent must close the dialog that the method was invoked on. If the method was invoked with an argument, that argument must be used as the return value; otherwise, there is no return value.

When a dialog element subject is to be closed, optionally with a return value result, the user agent must run the following steps:

If subject does not have an open attribute, then return.

Remove subject's open attribute.

If the argument result was provided, then set the returnValue attribute to the value of result.

If subject is in its Document's top layer, then remove it.

Queue a task to fire an event named close at subject.

The returnValue IDL attribute, on getting, must return the last value to which it was set. On setting, it must be set to the new value. When the element is created, it must be set to the empty string.

Canceling dialogs: When Document is blocked by a modal dialog dialog, user agents may provide a user interface that, upon activation, queues a task to run these steps:

Let close be the result of firing an event named cancel at dialog, with the cancelable attribute initialized to true.

If close is true and dialog has an open attribute, then close the dialog with no return value.

An example of such a UI mechanism would be the user pressing the "Escape" key.

A dialog element is in one of two modes: normal alignment or centered alignment. When a dialog element is created, it must be placed in the normal alignment mode. In this mode, normal CSS requirements apply to the element. The centered alignment mode is only used for dialog elements that are in the top layer. [FULLSCREEN] [CSS]

When an element subject is placed in centered alignment mode, and when it is in that mode and has new rendering boxes created, the user agent must set up the element such that its static position of the edge that corresponds to subject's parent's block-start edge, for the purposes of calculating the used value of the appropriate box offset property ('top', 'right', 'bottom', or 'left'), is the value that would place the element's margin edge on the side that corresponds to subject's parent's block-start side as far from the same-side edge of the viewport as the element's opposing side margin edge from that same-side edge of the viewport, if the element's dimension ('width' or 'height') in subject's parent's block flow direction is less than the same-axis dimension of the viewport, and otherwise is the value that would place the element's margin edge on the side that corresponds to subject's parent's block-start side at the same-side edge of the viewport.

If there is a dialog element with centered alignment and that is being rendered when its browsing context changes viewport dimensions (as measured in CSS pixels), or when this dialog element's parent changes block flow direction, then the user agent must recreate the element's boxes, recalculating its edge that corresponds to this dialog element's parent's block-start edge as in the previous paragraph.

This static position of a dialog element's edge with centered alignment must remain the element's static position of that edge until its boxes are recreated. (The element's static position is only used in calculating the used value of the appropriate box offset property ('top', 'right', 'bottom', or 'left') in certain situations; it's not used, for instance, to position the element if its 'position' property is set to 'static'.)

User agents in visual interactive media should allow the user to pan the viewport to access all parts of a dialog element's border box, even if the element is larger than the viewport and the viewport would otherwise not have a scroll mechanism (e.g. because the viewport's 'overflow' property is set to 'hidden').

The open IDL attribute must reflect the open content attribute.

This dialog box has some small print. The strong element is used to draw the user's attention to the more important part.

<dialog>
 <h1>Add to Wallet</h1>
 <p><strong><label for=amt>How many gold coins do you want to add to your wallet?</label></strong></p>
 <p><input id=amt name=amt type=number min=0 step=0.01 value=100></p>
 <p><small>You add coins at your own risk.</small></p>
 <p><label><input name=round type=checkbox> Only add perfectly round coins </label></p>
 <p><input type=button onclick="submit()" value="Add Coins"></p>
</dialog>
4.12 Scripting
Scripts allow authors to add interactivity to their documents.

Authors are encouraged to use declarative alternatives to scripting where possible, as declarative mechanisms are often more maintainable, and many users disable scripting.

For example, instead of using script to show or hide a section to show more details, the details element could be used.

Authors are also encouraged to make their applications degrade gracefully in the absence of scripting support.

For example, if an author provides a link in a table header to dynamically resort the table, the link could also be made to function without scripts by requesting the sorted table from the server.

4.12.1 The script element
Categories:
Metadata content.
Flow content.
Phrasing content.
Script-supporting element.
Contexts in which this element can be used:
Where metadata content is expected.
Where phrasing content is expected.
Where script-supporting elements are expected.
Content model:
If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions.
If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
src — Address of the resource
type — Type of script
nomodule — Prevents execution in user agents that support module scripts
async — Execute script when available, without blocking
defer — Defer script execution
crossorigin — How the element handles crossorigin requests
integrity — Integrity metadata used in Subresource Integrity checks [SRI]
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLScriptElement : HTMLElement {
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute boolean noModule;
  [CEReactions] attribute boolean async;
  [CEReactions] attribute boolean defer;
  [CEReactions] attribute DOMString? crossOrigin;
  [CEReactions] attribute DOMString text;
  [CEReactions] attribute DOMString integrity;


  // also has obsolete members
};
The script element allows authors to include dynamic script and data blocks in their documents. The element does not represent content for the user.

The type attribute allows customization of the type of script represented:


Support: es6-module
Chrome for Android	64+
Chrome	61+
iOS Safari	11.0+
UC Browser for Android	None
Firefox	60+
Samsung Internet	None
IE	None
Opera Mini	None
Safari	11+
Edge	16+
Android Browser	None
Opera	None

Source: caniuse.com

Omitting the attribute, setting it to the empty string, or setting it to a JavaScript MIME type essence match, means that the script is a classic script, to be interpreted according to the JavaScript Script top-level production. Classic scripts are affected by the async and defer attributes, but only when the src attribute is set. Authors should omit the type attribute instead of redundantly setting it.

Setting the attribute to an ASCII case-insensitive match for the string "module" means that the script is a module script, to be interpreted according to the JavaScript Module top-level production. Module scripts are not affected by the defer attribute, but are affected by the async attribute (regardless of the state of the src attribute).

Setting the attribute to any other value means that the script is a data block, which is not processed. None of the script attributes (except type itself) have any effect on data blocks. Authors must use a valid MIME type string that is not a JavaScript MIME type essence match to denote data blocks.

The requirement that data blocks must be denoted using a valid MIME type string is in place to avoid potential future collisions. If this specification ever adds additional types of script, they will be triggered by setting the type attribute to something which is not a MIME type, like how the "module" value denotes module scripts. By using a valid MIME type string now, you ensure that your data block will not ever be reinterpreted as a different script type, even in future user agents.

Classic scripts and module scripts may either be embedded inline or may be imported from an external file using the src attribute, which if specified gives the URL of the external script resource to use. If src is specified, it must be a valid non-empty URL potentially surrounded by spaces. The contents of inline script elements, or the external script resource, must conform with the requirements of the JavaScript specification's Script or Module productions, for classic scripts and module scripts respectively. [JAVASCRIPT]

When used to include data blocks, the data must be embedded inline, the format of the data must be given using the type attribute, and the contents of the script element must conform to the requirements defined for the format used. The src, async, nomodule, defer, crossorigin, and integrity attributes must not be specified.

The nomodule attribute is a boolean attribute that prevents a script from being executed in user agents that support module scripts. This allows selective execution of module scripts in modern user agents and classic scripts in older user agents, as shown below. The nomodule attribute must not be specified on module scripts (and will be ignored if it is).

The async and defer attributes are boolean attributes that indicate how the script should be evaluated. Classic scripts may specify defer or async, but must not specify either unless the src attribute is present. Module scripts may specify the async attribute, but must not specify the defer attribute.


Support: script-defer
Chrome for Android	64+
Chrome	8+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	3.5+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	3+
Opera	15+

Source: caniuse.com

Support: script-async
Chrome for Android	64+
Chrome	8+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	3.6+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5.1+
Edge	12+
Android Browser	3+
Opera	15+

Source: caniuse.com

There are several possible modes that can be selected using these attributes, and depending on the script's type.

For classic scripts, if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes). If the async attribute is not present but the defer attribute is present, then the classic script will be fetched in parallel and evaluated when the page has finished parsing. If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.

For module scripts, if the async attribute is present, then the module script and all its dependencies will be fetched in parallel to parsing, and the module script will be evaluated as soon as it is available (potentially before parsing completes). Otherwise, the module script and its dependencies will be fetched in parallel to parsing and evaluated when the page has finished parsing. (The defer attribute has no effect on module scripts.)

This is all summarized in the following schematic diagram:



The exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The algorithms below (in this section) describe the core of this processing, but these algorithms reference and are referenced by the parsing rules for script start and end tags in HTML, in foreign content, and in XML, the rules for the document.write() method, the handling of scripting, etc.

The defer attribute may be specified even if the async attribute is specified, to cause legacy Web browsers that only support defer (and not async) to fall back to the defer behavior instead of the blocking behavior that is the default.

The crossorigin attribute is a CORS settings attribute. For classic scripts, it controls whether error information will be exposed, when the script is obtained from other origins. For module scripts, it controls the credentials mode used for cross-origin requests.

Unlike classic scripts, module scripts require the use of the CORS protocol for cross-origin fetching.

The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The integrity attribute must not be specified when embedding a module script or when the src attribute is not specified. [SRI]

Changing the src, type, nomodule, async, defer, crossorigin, and integrity attributes dynamically has no direct effect; these attributes are only used at specific times described below.

The IDL attributes src, type, defer, and integrity, must each reflect the respective content attributes of the same name.

The crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

The noModule IDL attribute must reflect the nomodule content attribute.

The async IDL attribute controls whether the element will execute asynchronously or not. If the element's "non-blocking" flag is set, then, on getting, the async IDL attribute must return true, and on setting, the "non-blocking" flag must first be unset, and then the content attribute must be removed if the IDL attribute's new value is false, and must be set to the empty string if the IDL attribute's new value is true. If the element's "non-blocking" flag is not set, the IDL attribute must reflect the async content attribute.

script . text [ = value ]
Returns the child text content of the element.

Can be set, to replace the element's children with the given value.

The IDL attribute text must return the child text content of the script element. On setting, it must act the same way as the textContent IDL attribute.

When inserted using the document.write() method, script elements usually execute (typically blocking further script execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.

In this example, two script elements are used. One embeds an external classic script, and the other includes some data as a data block.

<script src="game-engine.js"></script>
<script type="text/x-game-map">
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
</script>
The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way, though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the site's search engine to help users who are looking for particular features in their game maps.

The following sample shows how a script element can be used to define a function that is then used by other parts of the document, as part of a classic script. It also shows how a script element can be used to invoke script while the document is being parsed, in this case to initialize the form's output.

<script>
 function calculate(form) {
   var price = 52000;
   if (form.elements.brakes.checked)
     price += 1000;
   if (form.elements.radio.checked)
     price += 2500;
   if (form.elements.turbo.checked)
     price += 5000;
   if (form.elements.sticker.checked)
     price += 250;
   form.elements.result.value = price;
 }
</script>
<form name="pricecalc" onsubmit="return false" onchange="calculate(this)">
 <fieldset>
  <legend>Work out the price of your car</legend>
  <p>Base cost: £52000.</p>
  <p>Select additional options:</p>
  <ul>
   <li><label><input type=checkbox name=brakes> Ceramic brakes (£1000)</label></li>
   <li><label><input type=checkbox name=radio> Satellite radio (£2500)</label></li>
   <li><label><input type=checkbox name=turbo> Turbo charger (£5000)</label></li>
   <li><label><input type=checkbox name=sticker> "XZ" sticker (£250)</label></li>
  </ul>
  <p>Total: £<output name=result></output></p>
 </fieldset>
 <script>
  calculate(document.forms.pricecalc);
 </script>
</form>
The following sample shows how a script element can be used to include an external module script.

<script type="module" src="app.js"></script>
This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once the entire resulting module graph has been imported, and the document has finished parsing, the contents of app.js will be evaluated.

Additionally, if code from another script element in the same Window imports the module from app.js (e.g. via import "./app.js";), then the same module script created by the former script element will be imported.

This example shows how to include a module script for modern user agents, and a classic script for older user agents:

<script type="module" src="app.js"></script>
<script nomodule src="classic-app-bundle.js"></script>
In modern user agents that support module scripts, the script element with the nomodule attribute will be ignored, and the script element with a type of "module" will be fetched and evaluated (as a module script). Conversely, older user agents will ignore the script element with a type of "module", as that is an unknown script type for them — but they will have no problem fetching and evaluating the other script element (as a classic script), since they do not implement the nomodule attribute.

The following sample shows how a script element can be used to write an inline module script that performs a number of substitutions on the document's text, in order to make for a more interesting reading experience (e.g. on a news site): [XKCD1288]

<script type="module">
 import { walkAllTextNodeDescendants } from "./dom-utils.js";

 const substitutions = new Map([
   ["witnesses", "these dudes I know"]
   ["allegedly", "kinda probably"]
   ["new study", "Tumblr post"]
   ["rebuild", "avenge"]
   ["space", "spaaace"]
   ["Google glass", "Virtual Boy"]
   ["smartphone", "Pokédex"]
   ["electric", "atomic"]
   ["Senator", "Elf-Lord"]
   ["car", "cat"]
   ["election", "eating contest"]
   ["Congressional leaders", "river spirits"]
   ["homeland security", "Homestar Runner"]
   ["could not be reached for comment", "is guilty and everyone knows it"]
 ]);

 function substitute(textNode) {
   for (const [before, after] of substitutions.entries()) {
     textNode.data = textNode.data.replace(new RegExp(`\\b${before}\\b`, "ig"), after);
   }
 }

 walkAllTextNodeDescendants(document.body, substitute);
</script>
Some notable features gained by using a module script include the ability to import functions from other JavaScript modules, strict mode by default, and how top-level declarations do not introduce new properties onto the global object. Also note that no matter where this script element appears in the document, it will not be evaluated until both document parsing has complete and its dependency (dom-utils.js) has been fetched and evaluated.

4.12.1.1 Processing model
A script element has several associated pieces of state.

The first is a flag indicating whether or not the script block has been "already started". Initially, script elements must have this flag unset (script blocks, when created, are not "already started"). The cloning steps for script elements must set the "already started" flag on the copy if it is set on the element being cloned.

The second is a flag indicating whether the element was "parser-inserted". Initially, script elements must have this flag unset. It is set by the HTML parser and the XML parser on script elements they insert and affects the processing of those elements.

The third is a flag indicating whether the element will be "non-blocking". Initially, script elements must have this flag set. It is unset by the HTML parser and the XML parser on script elements they insert. In addition, whenever a script element whose "non-blocking" flag is set has an async content attribute added, the element's "non-blocking" flag must be unset.

The fourth is a flag indicating whether or not the script block is "ready to be parser-executed". Initially, script elements must have this flag unset (script blocks, when created, are not "ready to be parser-executed"). This flag is used only for elements that are also "parser-inserted", to let the parser know when to execute the script.

The fifth is the script's type, which is either "classic" or "module". It is determined when the script is prepared, based on the type attribute of the element at that time.

The sixth is a flag indicating whether or not the script is from an external file. It is determined when the script is prepared, based on the src attribute of the element at that time.

Finally, a script element has the script's script, which is a script resulting from preparing the element. This is set asynchronously after the classic script or module graph is fetched. Once it is set, either to a script in the case of success or to null in the case of failure, the fetching algorithms will note that the script is ready, which can trigger other actions. The user agent must delay the load event of the element's node document until the script is ready.

When a script element that is not marked as being "parser-inserted" experiences one of the events listed in the following list, the user agent must immediately prepare the script element:

The script element becomes connected.
The script element is connected and a node or document fragment is inserted into the script element, after any script elements inserted at that time.
The script element is connected and has a src attribute set where previously the element had no such attribute.
To prepare a script, the user agent must act as follows:

If the script element is marked as having "already started", then return. The script is not executed.

If the element has its "parser-inserted" flag set, then set was-parser-inserted to true and unset the element's "parser-inserted" flag. Otherwise, set was-parser-inserted to false.

This is done so that if parser-inserted script elements fail to run when the parser tries to run them, e.g. because they are empty or specify an unsupported scripting language, another script can later mutate them and cause them to run again.

If was-parser-inserted is true and the element does not have an async attribute, then set the element's "non-blocking" flag to true.

This is done so that if a parser-inserted script element fails to run when the parser tries to run it, but it is later executed after a script dynamically updates it, it will execute in a non-blocking fashion even if the async attribute isn't set.

Let source text be the element's child text content.

If the element has no src attribute, and source text is the empty string, then return. The script is not executed.

If the element is not connected, then return. The script is not executed.

If either:

the script element has a type attribute and its value is the empty string, or
the script element has no type attribute but it has a language attribute and that attribute's value is the empty string, or
the script element has neither a type attribute nor a language attribute, then
...let the script block's type string for this script element be "text/javascript".

Otherwise, if the script element has a type attribute, let the script block's type string for this script element be the value of that attribute with leading and trailing ASCII whitespace stripped.

Otherwise, the element has a non-empty language attribute; let the script block's type string for this script element be the concatenation of the string "text/" followed by the value of the language attribute.

The language attribute is never conforming, and is always ignored if there is a type attribute present.

Determine the script's type as follows:

If the script block's type string is a JavaScript MIME type essence match, the script's type is "classic".
If the script block's type string is an ASCII case-insensitive match for the string "module", the script's type is "module".
If neither of the above conditions are true, then return. No script is executed.
If was-parser-inserted is true, then flag the element as "parser-inserted" again, and set the element's "non-blocking" flag to false.

Set the element's "already started" flag.

If the element is flagged as "parser-inserted", but the element's node document is not the Document of the parser that created the element, then return.

If scripting is disabled for the script element, then return. The script is not executed.

The definition of scripting is disabled means that, amongst others, the following scripts will not execute: scripts in XMLHttpRequest's responseXML documents, scripts in DOMParser-created documents, scripts in documents created by XSLTProcessor's transformToDocument feature, and scripts that are first inserted by a script into a Document that was created using the createDocument() API. [XHR] [DOMPARSING] [XSLTP] [DOM]

If the script element has a nomodule content attribute and the script's type is "classic", then return. The script is not executed.

This means specifying nomodule on a module script has no effect; the algorithm continues onward.

If the script element does not have a src content attribute, and the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the script element, "script", and source text, then return. The script is not executed. [CSP]

If the script element has an event attribute and a for attribute, and the script's type is "classic", then:

Let for be the value of the for attribute.

Let event be the value of the event attribute.

Strip leading and trailing ASCII whitespace from event and for.

If for is not an ASCII case-insensitive match for the string "window", then return. The script is not executed.

If event is not an ASCII case-insensitive match for either the string "onload" or the string "onload()", then return. The script is not executed.

If the script element has a charset attribute, then let encoding be the result of getting an encoding from the value of the charset attribute.

If the script element does not have a charset attribute, or if getting an encoding failed, let encoding be the same as the encoding of the script element's node document.

If the script's type is "module", this encoding will be ignored.

Let classic script CORS setting be the current state of the element's crossorigin content attribute.

Let module script credentials mode be the module script credentials mode for the element's crossorigin content attribute.

Let cryptographic nonce be the element's [[CryptographicNonce]] internal slot's value.

If the script element has an integrity attribute, then let integrity metadata be that attribute's value.

Otherwise, let integrity metadata be the empty string.

Let parser metadata be "parser-inserted" if the script element has been flagged as "parser-inserted", and "not-parser-inserted" otherwise.

Let options be a script fetch options whose cryptographic nonce is cryptographic nonce, integrity metadata is integrity metadata, parser metadata is parser metadata, credentials mode is module script credentials mode, and referrer policy is the empty string.

See w3c/webappsec-referrer-policy#96 for future plans to add a referrerpolicy attribute to script elements.

Let settings object be the element's node document's Window object's environment settings object.

If the element has a src content attribute, then:

Let src be the value of the element's src attribute.

If src is the empty string, queue a task to fire an event named error at the element, and return.

Set the element's from an external file flag.

Parse src relative to the element's node document.

If the previous step failed, queue a task to fire an event named error at the element, and return. Otherwise, let url be the resulting URL record.

Switch on the script's type:

"classic"
Fetch a classic script given url, settings object, options, classic script CORS setting, and encoding.

"module"
Fetch a module script graph given url, settings object, "script", and options.

When the chosen algorithm asynchronously completes, set the script's script to the result. At that time, the script is ready.

For performance reasons, user agents may start fetching the classic script or module graph (as defined above) as soon as the src attribute is set, instead, in the hope that the element will be inserted into the document (and that the crossorigin attribute won't change value in the meantime). Either way, once the element is inserted into the document, the load must have started as described in this step. If the UA performs such prefetching, but the element is never inserted in the document, or the src attribute is dynamically changed, or the crossorigin attribute is dynamically changed, then the user agent will not execute the script so obtained, and the fetching process will have been effectively wasted.

If the element does not have a src content attribute, run these substeps:

Let base URL be the script element's node document's document base URL.

Switch on the script's type:

"classic"
Let script be the result of creating a classic script using source text, settings object, base URL, and options.

Set the script's script to script.

The script is ready.

"module"
Let script be the result of creating a module script using source text, settings object, base URL, and options.

If this returns null, set the script's script to null and return; the script is ready.

Fetch the descendants of and instantiate script, given the destination "script". When this asynchronously completes, set the script's script to the result. At that time, the script is ready.

Then, follow the first of the following options that describes the situation:

If the script's type is "classic", and the element has a src attribute, and the element has a defer attribute, and the element has been flagged as "parser-inserted", and the element does not have an async attribute
If the script's type is "module", and the element has been flagged as "parser-inserted", and the element does not have an async attribute
Add the element to the end of the list of scripts that will execute when the document has finished parsing associated with the Document of the parser that created the element.

When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.

If the script's type is "classic", and the element has a src attribute, and the element has been flagged as "parser-inserted", and the element does not have an async attribute
The element is the pending parsing-blocking script of the Document of the parser that created the element. (There can only be one such script per Document at a time.)

When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.

If the script's type is "classic", and the element has a src attribute, and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
If the script's type is "module", and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
Add the element to the end of the list of scripts that will execute in order as soon as possible associated with the node document of the script element at the time the prepare a script algorithm started.

When the script is ready, run the following steps:

If the element is not now the first element in the list of scripts that will execute in order as soon as possible to which it was added above, then mark the element as ready but return without executing the script yet.

Execution: Execute the script block corresponding to the first script element in this list of scripts that will execute in order as soon as possible.

Remove the first element from this list of scripts that will execute in order as soon as possible.

If this list of scripts that will execute in order as soon as possible is still not empty and the first entry has already been marked as ready, then jump back to the step labeled execution.

If the script's type is "classic", and the element has a src attribute
If the script's type is "module"
The element must be added to the set of scripts that will execute as soon as possible of the node document of the script element at the time the prepare a script algorithm started.

When the script is ready, execute the script block and then remove the element from the set of scripts that will execute as soon as possible.

If the element does not have a src attribute, and the element has been flagged as "parser-inserted", and either the parser that created the script is an XML parser or it's an HTML parser whose script nesting level is not greater than one, and the Document of the HTML parser or XML parser that created the script element has a style sheet that is blocking scripts
The element is the pending parsing-blocking script of the Document of the parser that created the element. (There can only be one such script per Document at a time.)

Set the element's "ready to be parser-executed" flag. The parser will handle executing the script.

Otherwise
Immediately execute the script block, even if other scripts are already executing.
The pending parsing-blocking script of a Document is used by the Document's parser(s).

If a script element that blocks a parser gets moved to another Document before it would normally have stopped blocking that parser, it nonetheless continues blocking that parser until the condition that causes it to be blocking the parser no longer applies (e.g. if the script is a pending parsing-blocking script because there was a style sheet that is blocking scripts when it was parsed, but then the script is moved to another Document before the style sheet loads, the script still blocks the parser until the style sheets are all loaded, at which time the script executes and the parser is unblocked).

When the user agent is required to execute a script block, it must run the following steps.

If the element is flagged as "parser-inserted", but the element's node document is not the Document of the parser that created the element, then return.

If the script's script is null, fire an event named error at the element, and return.

If the script is from an external file, or the script's type is "module", then increment the ignore-destructive-writes counter of the script element's node document. Let neutralized doc be that Document.

Let old script element be the value to which the script element's node document's currentScript object was most recently set.

Switch on the script's type:

"classic"
If the script element's root is not a shadow root, then set the script element's node document's currentScript attribute to the script element. Otherwise, set it to null.

This does not use the in a document tree check, as the script element could have been removed from the document prior to execution, and in that scenario currentScript still needs to point to it.

Run the classic script given by the script's script.

"module"
Set the script element's node document's currentScript attribute to null.

Run the module script given by the script's script.

Set the script element's node document's currentScript attribute to old script element.

Decrement the ignore-destructive-writes counter of neutralized doc, if it was incremented in the earlier step.

If the script is from an external file, then fire an event named load at the script element.

4.12.1.2 Scripting languages
User agents are not required to support JavaScript. This standard needs to be updated if a language other than JavaScript comes along and gets similar wide adoption by web browsers. Until such a time, implementing other languages is in conflict with this standard, given the processing model defined for the script element.

Servers should use text/javascript for JavaScript resources. Servers should not use other JavaScript MIME types for JavaScript resources, and must not use non-JavaScript MIME types.

For external JavaScript resources, MIME type parameters in `Content-Type` headers are generally ignored. (In some cases the `charset` parameter has an effect.) However, for the script element's type attribute they are significant; it uses the JavaScript MIME type essence match concept.

For example, scripts with their type attribute set to "text/javascript; charset=utf-8" will not be evaluated, even though that is a valid JavaScript MIME type when parsed.

Furthermore, again for external JavaScript resources, special considerations apply around `Content-Type` header processing as detailed in the prepare a script algorithm and the WHATWG Fetch standard. [FETCH]

4.12.1.3 Restrictions for contents of script elements
The easiest and safest way to avoid the rather strange restrictions described in this section is to always escape "<!--" as "<\!--", "<script" as "<\script", and "</script" as "<\/script" when these sequences appear in literals in scripts (e.g. in strings, regular expressions, or comments), and to avoid writing code that uses such constructs in expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to triggering: namely, that, for historical reasons, parsing of script blocks in HTML is a strange and exotic practice that acts unintuitively in the face of these sequences.

The textContent of a script element must match the script production in the following ABNF, the character set for which is Unicode. [ABNF]

script        = outer *( comment-open inner comment-close outer )

outer         = < any string that doesn't contain a substring that matches not-in-outer >
not-in-outer  = comment-open
inner         = < any string that doesn't contain a substring that matches not-in-inner >
not-in-inner  = comment-close / script-open

comment-open  = "<!--"
comment-close = "-->"
script-open   = "<" s c r i p t tag-end

s             =  %x0053 ; U+0053 LATIN CAPITAL LETTER S
s             =/ %x0073 ; U+0073 LATIN SMALL LETTER S
c             =  %x0043 ; U+0043 LATIN CAPITAL LETTER C
c             =/ %x0063 ; U+0063 LATIN SMALL LETTER C
r             =  %x0052 ; U+0052 LATIN CAPITAL LETTER R
r             =/ %x0072 ; U+0072 LATIN SMALL LETTER R
i             =  %x0049 ; U+0049 LATIN CAPITAL LETTER I
i             =/ %x0069 ; U+0069 LATIN SMALL LETTER I
p             =  %x0050 ; U+0050 LATIN CAPITAL LETTER P
p             =/ %x0070 ; U+0070 LATIN SMALL LETTER P
t             =  %x0054 ; U+0054 LATIN CAPITAL LETTER T
t             =/ %x0074 ; U+0074 LATIN SMALL LETTER T

tag-end       =  %x0009 ; U+0009 CHARACTER TABULATION (tab)
tag-end       =/ %x000A ; U+000A LINE FEED (LF)
tag-end       =/ %x000C ; U+000C FORM FEED (FF)
tag-end       =/ %x0020 ; U+0020 SPACE
tag-end       =/ %x002F ; U+002F SOLIDUS (/)
tag-end       =/ %x003E ; U+003E GREATER-THAN SIGN (>)
When a script element contains script documentation, there are further restrictions on the contents of the element, as described in the section below.

The following script illustrates this issue. Suppose you have a script that contains a string, as in:

var example = 'Consider this string: <!-- <script>';
console.log(example);
If one were to put this string directly in a script block, it would violate the restrictions above:

<script>
  var example = 'Consider this string: <!-- <script>';
  console.log(example);
</script>
The bigger problem, though, and the reason why it would violate those restrictions, is that actually the script would get parsed weirdly: the script block above is not terminated. That is, what looks like a "</script>" end tag in this snippet is actually still part of the script block. The script doesn't execute (since it's not terminated); if it somehow were to execute, as it might if the markup looked as follows, it would fail because the script (highlighted here) is not valid JavaScript:

<script>
  var example = 'Consider this string: <!-- <script>';
  console.log(example);
</script>
<!-- despite appearances, this is actually part of the script still! -->
<script>
 ... // this is the same script block still...
</script>
What is going on here is that for legacy reasons, "<!--" and "<script" strings in script elements in HTML need to be balanced in order for the parser to consider closing the block.

By escaping the problematic strings as mentioned at the top of this section, the problem is avoided entirely:

<script>
  var example = 'Consider this string: <\!-- <\script>';
  console.log(example);
</script>
<!-- this is just a comment between script blocks -->
<script>
 ... // this is a new script block
</script>
It is possible for these sequences to naturally occur in script expressions, as in the following examples:

if (x<!--y) { ... }
if ( player<script ) { ... }
In such cases the characters cannot be escaped, but the expressions can be rewritten so that the sequences don't occur, as in:

if (x < !--y) { ... }
if (!--y > x) { ... }
if (!(--y) > x) { ... }
if (player < script) { ... }
if (script > player) { ... }
Doing this also avoids a different pitfall as well: for related historical reasons, the string "<!--" in classic scripts is actually treated as a line comment start, just like "//".

4.12.1.4 Inline documentation for external scripts
If a script element's src attribute is specified, then the contents of the script element, if any, must be such that the value of the text IDL attribute, which is derived from the element's contents, matches the documentation production in the following ABNF, the character set for which is Unicode. [ABNF]

documentation = *( *( space / tab / comment ) [ line-comment ] newline )
comment       = slash star *( not-star / star not-slash ) 1*star slash
line-comment  = slash slash *not-newline

; characters
tab           = %x0009 ; U+0009 CHARACTER TABULATION (tab)
newline       = %x000A ; U+000A LINE FEED (LF)
space         = %x0020 ; U+0020 SPACE
star          = %x002A ; U+002A ASTERISK (*)
slash         = %x002F ; U+002F SOLIDUS (/)
not-newline   = %x0000-0009 / %x000B-10FFFF
                ; a scalar value other than U+000A LINE FEED (LF)
not-star      = %x0000-0029 / %x002B-10FFFF
                ; a scalar value other than U+002A ASTERISK (*)
not-slash     = %x0000-002E / %x0030-10FFFF
                ; a scalar value other than U+002F SOLIDUS (/)
This corresponds to putting the contents of the element in JavaScript comments.

This requirement is in addition to the earlier restrictions on the syntax of contents of script elements.

This allows authors to include documentation, such as license information or API information, inside their documents while still referring to external script files. The syntax is constrained so that authors don't accidentally include what looks like valid script while also providing a src attribute.

<script src="cool-effects.js">
 // create new instances using:
 //    var e = new Effect();
 // start the effect using .play, stop using .stop:
 //    e.play();
 //    e.stop();
</script>
4.12.1.5 Interaction of script elements and XSLT
This section is non-normative.

This specification does not define how XSLT interacts with the script element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, based on existing implementations:

When an XSLT transformation program is triggered by an <?xml-stylesheet?> processing instruction and the browser implements a direct-to-DOM transformation, script elements created by the XSLT processor need to be marked "parser-inserted" and run in document order (modulo scripts marked defer or async), immediately, as the transformation is occurring.

The XSLTProcessor.transformToDocument() method adds elements to a Document that does not have a browsing context, and, accordingly, any script elements they create need to have their "already started" flag set in the prepare a script algorithm and never get executed (scripting is disabled). Such script elements still need to be marked "parser-inserted", though, such that their async IDL attribute will return false in the absence of an async content attribute.

The XSLTProcessor.transformToFragment() method needs to create a fragment that is equivalent to one built manually by creating the elements using document.createElementNS(). For instance, it needs to create script elements that aren't "parser-inserted" and that don't have their "already started" flag set, so that they will execute when the fragment is inserted into a document.

The main distinction between the first two cases and the last case is that the first two operate on Documents and the last operates on a fragment.

4.12.2 The noscript element
Categories:
Metadata content.
Flow content.
Phrasing content.
Contexts in which this element can be used:
In a head element of an HTML document, if there are no ancestor noscript elements.
Where phrasing content is expected in HTML documents, if there are no ancestor noscript elements.
Content model:
When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.
When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.
Otherwise: text that conforms to the requirements given in the prose.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
Uses HTMLElement.
The noscript element represents nothing if scripting is enabled, and represents its children if scripting is disabled. It is used to present different markup to user agents that support scripting and those that don't support scripting, by affecting how the document is parsed.

When used in HTML documents, the allowed content model is as follows:

In a head element, if scripting is disabled for the noscript element
The noscript element must contain only link, style, and meta elements.

In a head element, if scripting is enabled for the noscript element
The noscript element must contain only text, except that invoking the HTML fragment parsing algorithm with the noscript element as the context element and the text contents as the input must result in a list of nodes that consists only of link, style, and meta elements that would be conforming if they were children of the noscript element, and no parse errors.

Outside of head elements, if scripting is disabled for the noscript element
The noscript element's content model is transparent, with the additional restriction that a noscript element must not have a noscript element as an ancestor (that is, noscript can't be nested).

Outside of head elements, if scripting is enabled for the noscript element
The noscript element must contain only text, except that the text must be such that running the following algorithm results in a conforming document with no noscript elements and no script elements, and such that no step in the algorithm throws an exception or causes an HTML parser to flag a parse error:

Remove every script element from the document.
Make a list of every noscript element in the document. For every noscript element in that list, perform the following steps:
Let s be the child text content of the noscript element.
Set the outerHTML attribute of the noscript element to the value of s. (This, as a side-effect, causes the noscript element to be removed from the document.) [DOMPARSING]
All these contortions are required because, for historical reasons, the noscript element is handled differently by the HTML parser based on whether scripting was enabled or not when the parser was invoked.

The noscript element must not be used in XML documents.

The noscript element is only effective in the HTML syntax, it has no effect in the XML syntax. This is because the way it works is by essentially "turning off" the parser when scripts are enabled, so that the contents of the element are treated as pure text and not as real elements. XML does not define a mechanism by which to do this.

The noscript element has no other requirements. In particular, children of the noscript element are not exempt from form submission, scripting, and so forth, even when scripting is enabled for the element.

In the following example, a noscript element is used to provide fallback for a script.

<form action="calcSquare.php">
 <p>
  <label for=x>Number</label>:
  <input id="x" name="x" type="number">
 </p>
 <script>
  var x = document.getElementById('x');
  var output = document.createElement('p');
  output.textContent = 'Type a number; it will be squared right then!';
  x.form.appendChild(output);
  x.form.onsubmit = function () { return false; }
  x.oninput = function () {
    var v = x.valueAsNumber;
    output.textContent = v + ' squared is ' + v * v;
  };
 </script>
 <noscript>
  <input type=submit value="Calculate Square">
 </noscript>
</form>
When script is disabled, a button appears to do the calculation on the server side. When script is enabled, the value is computed on-the-fly instead.

The noscript element is a blunt instrument. Sometimes, scripts might be enabled, but for some reason the page's script might fail. For this reason, it's generally better to avoid using noscript, and to instead design the script to change the page from being a scriptless page to a scripted page on the fly, as in the next example:

<form action="calcSquare.php">
 <p>
  <label for=x>Number</label>:
  <input id="x" name="x" type="number">
 </p>
 <input id="submit" type=submit value="Calculate Square">
 <script>
  var x = document.getElementById('x');
  var output = document.createElement('p');
  output.textContent = 'Type a number; it will be squared right then!';
  x.form.appendChild(output);
  x.form.onsubmit = function () { return false; }
  x.oninput = function () {
    var v = x.valueAsNumber;
    output.textContent = v + ' squared is ' + v * v;
  };
  var submit = document.getElementById('submit');
  submit.parentNode.removeChild(submit);
 </script>
</form>
The above technique is also useful in XML documents, since noscript is not allowed there.

4.12.3 The template element

Support: template
Chrome for Android	64+
Chrome	35+
iOS Safari	9.0+
UC Browser for Android	11.8+
Firefox	22+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	9+
Edge (limited)	13+
Android Browser	4.4+
Opera	22+

Source: caniuse.com

Categories:
Metadata content.
Flow content.
Phrasing content.
Script-supporting element.
Contexts in which this element can be used:
Where metadata content is expected.
Where phrasing content is expected.
Where script-supporting elements are expected.
As a child of a colgroup element that doesn't have a span attribute.
Content model:
Nothing (for clarification, see example).
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLTemplateElement : HTMLElement {
  readonly attribute DocumentFragment content;
};
The template element is used to declare fragments of HTML that can be cloned and inserted in the document by script.

In a rendering, the template element represents nothing.

The template contents of a template element are not children of the element itself.

It is also possible, as a result of DOM manipulation, for a template element to contain Text nodes and element nodes; however, having any is a violation of the template element's content model, since its content model is defined as nothing.

For example, consider the following document:

<!doctype html>
<html lang="en">
 <head>
  <title>Homework</title>
 <body>
  <template id="template"><p>Smile!</p></template>
  <script>
   let num = 3;
   const fragment = document.getElementById('template').content.cloneNode(true);
   while (num-- > 1) {
     fragment.firstChild.before(fragment.firstChild.cloneNode(true));
     fragment.firstChild.textContent += fragment.lastChild.textContent;
   }
   document.body.appendChild(fragment);
  </script>
</html>
The p element in the template is not a child of the template in the DOM; it is a child of the DocumentFragment returned by the template element's content IDL attribute.

If the script were to call appendChild() on the template element, that would add a child to the template element (as for any other element); however, doing so is a violation of the template element's content model.

template . content
Returns the template contents (a DocumentFragment).

Each template element has an associated DocumentFragment object that is its template contents. The template contents have no conformance requirements. When a template element is created, the user agent must run the following steps to establish the template contents:

Let doc be the template element's node document's appropriate template contents owner document.

Create a DocumentFragment object whose node document is doc and host is the template element.

Set the template element's template contents to the newly created DocumentFragment object.

A Document doc's appropriate template contents owner document is the Document returned by the following algorithm:

If doc is not a Document created by this algorithm, then:

If doc does not yet have an associated inert template document, then:

Let new doc be a new Document (that does not have a browsing context). This is "a Document created by this algorithm" for the purposes of the step above.

If doc is an HTML document, mark new doc as an HTML document also.

Let doc's associated inert template document be new doc.

Set doc to doc's associated inert template document.

Each Document not created by this algorithm thus gets a single Document to act as its proxy for owning the template contents of all its template elements, so that they aren't in a browsing context and thus remain inert (e.g. scripts do not run). Meanwhile, template elements inside Document objects that are created by this algorithm just reuse the same Document owner for their contents.

Return doc.

The adopting steps (with node and oldDocument as parameters) for template elements are the following:

Let doc be node's node document's appropriate template contents owner document.

node's node document is the Document object that node was just adopted into.

Adopt node's template contents (a DocumentFragment object) into doc.

The content IDL attribute must return the template element's template contents.

The cloning steps for a template element node being cloned to a copy copy must run the following steps:

If the clone children flag is not set in the calling clone algorithm, return.

Let copied contents be the result of cloning all the children of node's template contents, with document set to copy's template contents's node document, and with the clone children flag set.

Append copied contents to copy's template contents.

In this example, a script populates a table four-column with data from a data structure, using a template to provide the element structure instead of manually generating the structure from markup.

<!DOCTYPE html>
<html lang='en'>
<title>Cat data</title>
<script>
 // Data is hard-coded here, but could come from the server
 var data = [
   { name: 'Pillar', color: 'Ticked Tabby', sex: 'Female (neutered)', legs: 3 },
   { name: 'Hedral', color: 'Tuxedo', sex: 'Male (neutered)', legs: 4 },
 ];
</script>
<table>
 <thead>
  <tr>
   <th>Name <th>Color <th>Sex <th>Legs
 <tbody>
  <template id="row">
   <tr><td><td><td><td>
  </template>
</table>
<script>
 var template = document.querySelector('#row');
 for (var i = 0; i < data.length; i += 1) {
   var cat = data[i];
   var clone = template.content.cloneNode(true);
   var cells = clone.querySelectorAll('td');
   cells[0].textContent = cat.name;
   cells[1].textContent = cat.color;
   cells[2].textContent = cat.sex;
   cells[3].textContent = cat.legs;
   template.parentNode.appendChild(clone);
 }
</script>
This example uses cloneNode() on the template's contents; it could equivalently have used document.importNode(), which does the same thing. The only difference between these two APIs is when the node document is updated: with cloneNode() it is updated when the nodes are appended with appendChild(), with document.importNode() it is updated when the nodes are cloned.

4.12.3.1 Interaction of template elements with XSLT and XPath
This section is non-normative.

This specification does not define how XSLT and XPath interact with the template element. However, in the absence of another specification actually defining this, here are some guidelines for implementers, which are intended to be consistent with other processing described in this specification:

An XSLT processor based on an XML parser that acts as described in this specification needs to act as if template elements contain as descendants their template contents for the purposes of the transform.

An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a template element are instead placed into the element's template contents.

XPath evaluation using the XPath DOM API when applied to a Document parsed using the HTML parser or the XML parser described in this specification needs to ignore template contents.

4.12.4 The slot element
Categories:
Flow content.
Phrasing content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
name — Name of shadow tree slot
DOM interface:
[Exposed=Window,
 HTMLConstructor]
interface HTMLSlotElement : HTMLElement {
  [CEReactions] attribute DOMString name;
  sequence<Node> assignedNodes(optional AssignedNodesOptions options);
  sequence<Element> assignedElements(optional AssignedNodesOptions options);
};

dictionary AssignedNodesOptions {
  boolean flatten = false;
};
The slot element defines a slot. It is typically used in a shadow tree. A slot element represents its assigned nodes, if any, and its contents otherwise.

The name content attribute may contain any string value. It represents a slot's name.

The name attribute is used to assign slots to other elements: a slot element with a name attribute creates a named slot to which any element is assigned if that element has a slot attribute whose value matches that name attribute's value, and the slot element is a child of the shadow tree whose root's host has that corresponding slot attribute value.

slot . name
Can be used to get and set slot's name.
slot . assignedNodes()
Returns slot's assigned nodes.
slot . assignedNodes({ flatten: true })
Returns slot's assigned nodes, if any, and slot's children otherwise, and does the same for any slot elements encountered therein, recursively, until there are no slot elements left.
slot . assignedElements()
Returns slot's assigned nodes, limited to elements.
slot . assignedElements({ flatten: true })
Returns the same as assignedNodes({ flatten: true }), limited to elements.
The name IDL attribute must reflect the content attribute of the same name.

The assignedNodes(options) method, when invoked, must run these steps:

If the value of options's flatten member is false, then return this element's assigned nodes.

Return the result of finding flattened slotables with this element.

The assignedElements(options) method, when invoked, must run these steps:

If the value of options's flatten member is false, then return this element's assigned nodes, filtered to contain only Element nodes.

Return the result of finding flattened slotables with this element, filtered to contain only Element nodes.

4.12.5 The canvas element

Support: canvas
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	3.6+
Samsung Internet	4+
IE	9+
Opera Mini (limited)	all+
Safari	4+
Edge	12+
Android Browser	3+
Opera	9+

Source: caniuse.com

Categories:
Flow content.
Phrasing content.
Embedded content.
Palpable content.
Contexts in which this element can be used:
Where embedded content is expected.
Content model:
Transparent, but with no interactive content descendants except for a elements, img elements with usemap attributes, button elements, input elements whose type attribute are in the Checkbox or Radio Button states, input elements that are buttons, select elements with a multiple attribute or a display size greater than 1, and elements that would not be interactive content except for having the tabindex attribute specified.
Tag omission in text/html:
Neither tag is omissible.
Content attributes:
Global attributes
width — Horizontal dimension
height — Vertical dimension
DOM interface:
typedef (CanvasRenderingContext2D or ImageBitmapRenderingContext or WebGLRenderingContext) RenderingContext;

[Exposed=Window,
 HTMLConstructor]
interface HTMLCanvasElement : HTMLElement {
  [CEReactions] attribute unsigned long width;
  [CEReactions] attribute unsigned long height;

  RenderingContext? getContext(DOMString contextId, optional any options = null);

  USVString toDataURL(optional DOMString type, optional any quality);
  void toBlob(BlobCallback _callback, optional DOMString type, optional any quality);
  OffscreenCanvas transferControlToOffscreen();
};

callback BlobCallback = void (Blob? blob);
The canvas element provides scripts with a resolution-dependent bitmap canvas, which can be used for rendering graphs, game graphics, art, or other visual images on the fly.

Authors should not use the canvas element in a document when a more suitable element is available. For example, it is inappropriate to use a canvas element to render a page heading: if the desired presentation of the heading is graphically intense, it should be marked up using appropriate elements (typically h1) and then styled using CSS and supporting technologies such as shadow trees.

When authors use the canvas element, they must also provide content that, when presented to the user, conveys essentially the same function or purpose as the canvas's bitmap. This content may be placed as content of the canvas element. The contents of the canvas element, if any, are the element's fallback content.

In interactive visual media, if scripting is enabled for the canvas element, and if support for canvas elements has been enabled, then the canvas element represents embedded content consisting of a dynamically created image, the element's bitmap.

In non-interactive, static, visual media, if the canvas element has been previously associated with a rendering context (e.g. if the page was viewed in an interactive visual medium and is now being printed, or if some script that ran during the page layout process painted on the element), then the canvas element represents embedded content with the element's current bitmap and size. Otherwise, the element represents its fallback content instead.

In non-visual media, and in visual media if scripting is disabled for the canvas element or if support for canvas elements has been disabled, the canvas element represents its fallback content instead.

When a canvas element represents embedded content, the user can still focus descendants of the canvas element (in the fallback content). When an element is focused, it is the target of keyboard interaction events (even though the element itself is not visible). This allows authors to make an interactive canvas keyboard-accessible: authors should have a one-to-one mapping of interactive regions to focusable areas in the fallback content. (Focus has no effect on mouse interaction events.) [UIEVENTS]

An element whose nearest canvas element ancestor is being rendered and represents embedded content is an element that is being used as relevant canvas fallback content.

The canvas element has two attributes to control the size of the element's bitmap: width and height. These attributes, when specified, must have values that are valid non-negative integers. The rules for parsing non-negative integers must be used to obtain their numeric values. If an attribute is missing, or if parsing its value returns an error, then the default value must be used instead. The width attribute defaults to 300, and the height attribute defaults to 150.

When setting the value of the width or height attribute, if the context mode of the canvas element is set to placeholder, the user agent must throw an "InvalidStateError" DOMException and leave the attribute's value unchanged.

The intrinsic dimensions of the canvas element when it represents embedded content are equal to the dimensions of the element's bitmap.

The user agent must use a square pixel density consisting of one pixel of image data per coordinate space unit for the bitmaps of a canvas and its rendering contexts.

A canvas element can be sized arbitrarily by a style sheet, its bitmap is then subject to the 'object-fit' CSS property.

The bitmaps of canvas elements, the bitmaps of ImageBitmap objects, as well as some of the bitmaps of rendering contexts, such as those described in the sections on the CanvasRenderingContext2D and ImageBitmapRenderingContext objects below, have an origin-clean flag, which can be set to true or false. Initially, when the canvas element or ImageBitmap object is created, its bitmap's origin-clean flag must be set to true.

A canvas element can have a rendering context bound to it. Initially, it does not have a bound rendering context. To keep track of whether it has a rendering context or not, and what kind of rendering context it is, a canvas also has a canvas context mode, which is initially none but can be changed to either placeholder, 2d, bitmaprenderer, or webgl by algorithms defined in this specification.

When its canvas context mode is none, a canvas element has no rendering context, and its bitmap must be transparent black with an intrinsic width equal to the numeric value of the element's width attribute and an intrinsic height equal to the numeric value of the element's height attribute, those values being interpreted in CSS pixels, and being updated as the attributes are set, changed, or removed.

When its canvas context mode is placeholder, a canvas element has no rendering context. It serves as a placeholder for an OffscreenCanvas object, and the content of the canvas element is updated by calling the commit() method of the OffscreenCanvas object's rendering context.

When a canvas element represents embedded content, it provides a paint source whose width is the element's intrinsic width, whose height is the element's intrinsic height, and whose appearance is the element's bitmap.

Whenever the width and height content attributes are set, removed, changed, or redundantly set to the value they already have, then the user agent must perform the action from the row of the following table that corresponds to the canvas element's context mode.

Context Mode

Action

2d

Follow the steps to set bitmap dimensions to the numeric values of the width and height content attributes.

webgl

Follow the behavior defined in the WebGL specification. [WEBGL]

bitmaprenderer

If the context's bitmap mode is set to blank, run the steps to set an ImageBitmapRenderingContext's output bitmap, passing the canvas element's rendering context.

placeholder

Do nothing.

none

Do nothing.

The width and height IDL attributes must reflect the respective content attributes of the same name, with the same defaults.

context = canvas . getContext(contextId [, options ] )
Returns an object that exposes an API for drawing on the canvas. contextId specifies the desired API: "2d", "bitmaprenderer", or "webgl". options is handled by that API.

This specification defines the "2d" and "bitmaprenderer" contexts below. There is also a specification that defines a "webgl" context. [WEBGL]

Returns null if contextId is not supported, or if the canvas has already been initialized with another context type (e.g., trying to get a "2d" context after getting a "webgl" context).

The getContext(contextId, options) method of the canvas element, when invoked, must run these steps:

If options is not an object, then set options to null.

Set options to the result of converting options to a JavaScript value.

Run the steps in the cell of the following table whose column header matches this canvas element's canvas context mode and whose row header matches contextId:

none	2d	bitmaprenderer	webgl	placeholder
"2d"	Follow the 2D context creation algorithm defined in the section below, passing it this canvas element and options, to obtain a CanvasRenderingContext2D object; if this does not throw an exception, then set this canvas element's context mode to 2d, and return the CanvasRenderingContext2D object.	Return the same object as was returned the last time the method was invoked with this same first argument.	Return null.	Return null.	Throw an "InvalidStateError" DOMException.
"bitmaprenderer"	Follow the ImageBitmapRenderingContext creation algorithm defined in the section below, passing it this canvas element and options, to obtain an ImageBitmapRenderingContext object; then set this canvas element's context mode to bitmaprenderer, and return the ImageBitmapRenderingContext object.	Return null.	Return the same object as was returned the last time the method was invoked with this same first argument.	Return null.	Throw an "InvalidStateError" DOMException.
"webgl", if the user agent supports the WebGL feature in its current configuration	Follow the instructions given in the WebGL specification's Context Creation section to obtain either a WebGLRenderingContext or null; if the returned value is null, then return null; otherwise, set this canvas element's context mode to webgl, and return the WebGLRenderingContext object. [WEBGL]	Return null.	Return null.	Return the same object as was returned the last time the method was invoked with this same first argument.	Throw an "InvalidStateError" DOMException.
An unsupported value*	Return null.	Return null.	Return null.	Return null.	Throw an "InvalidStateError" DOMException.
* For example, the "webgl" value in the case of a user agent having exhausted the graphics hardware's abilities and having no software fallback implementation.

url = canvas . toDataURL( [ type [, quality ] ] )
Returns a data: URL for the image in the canvas.

The first argument, if provided, controls the type of the image to be returned (e.g. PNG or JPEG). The default is "image/png"; that type is also used if the given type isn't supported. The second argument applies if the type is an image format that supports variable quality (such as "image/jpeg"), and is a number in the range 0.0 to 1.0 inclusive indicating the desired quality level for the resulting image.

When trying to use types other than "image/png", authors can check if the image was really returned in the requested format by checking to see if the returned string starts with one of the exact strings "data:image/png," or "data:image/png;". If it does, the image is PNG, and thus the requested type was not supported. (The one exception to this is if the canvas has either no height or no width, in which case the result might simply be "data:,".)

canvas . toBlob(callback [, type [, quality ] ] )
Creates a Blob object representing a file containing the image in the canvas, and invokes a callback with a handle to that object.

The second argument, if provided, controls the type of the image to be returned (e.g. PNG or JPEG). The default is "image/png"; that type is also used if the given type isn't supported. The third argument applies if the type is an image format that supports variable quality (such as "image/jpeg"), and is a number in the range 0.0 to 1.0 inclusive indicating the desired quality level for the resulting image.

canvas . transferControlToOffscreen()
Returns a newly created OffscreenCanvas object that uses the canvas element as a placeholder. Once the canvas element has become a placeholder for an OffscreenCanvas object, its intrinsic size can no longer be changed, and it cannot have a rendering context. The content of the placeholder canvas is updated by calling the commit() method of the OffscreenCanvas object's rendering context.

The toDataURL(type, quality) method, when invoked, must run these steps:

If this canvas element's bitmap's origin-clean flag is set to false, then throw a "SecurityError" DOMException.

If this canvas element's bitmap has no pixels (i.e. either its horizontal dimension or its vertical dimension is zero) then return the string "data:,". (This is the shortest data: URL; it represents the empty string in a text/plain resource.)

Let file be a serialization of this canvas element's bitmap as a file, passing type and quality if they were given.

If file is null then return "data:,".

Return a data: URL representing file. [RFC2397]

The toBlob(callback, type, quality) method, when invoked, must run these steps:

If this canvas element's bitmap's origin-clean flag is set to false, then throw a "SecurityError" DOMException.

Let result be null.

If this canvas element's bitmap has pixels (i.e., neither its horizontal dimension nor its vertical dimension is zero), then set result to a copy of this canvas element's bitmap.

Run these steps in parallel:

If result is non-null, then set result to a serialization of result as a file, with type and quality if they were given.

Queue a task to run these steps:

If result is non-null, then set result to a new Blob object, created in the relevant Realm of this canvas element, representing result. [FILEAPI]

Invoke callback with « result ».

The task source for this task is the canvas blob serialization task source.

The transferControlToOffscreen() method, when invoked, must run these steps:

If this canvas element's context mode is not set to none, throw an "InvalidStateError" DOMException.

Let offscreenCanvas be a new OffscreenCanvas object with its width and height equal to the values of the width and height content attributes of this canvas element.

Set the placeholder canvas element of offscreenCanvas to be a weak reference to this canvas element.

Set this canvas element's context mode to placeholder.

Return offscreenCanvas.

4.12.5.1 The 2D rendering context
typedef (HTMLImageElement or
         SVGImageElement) HTMLOrSVGImageElement;

typedef (HTMLOrSVGImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         ImageBitmap or
         OffscreenCanvas) CanvasImageSource;

enum CanvasFillRule { "nonzero", "evenodd" };

dictionary CanvasRenderingContext2DSettings {
  boolean alpha = true;
};

enum ImageSmoothingQuality { "low", "medium", "high" };

[Exposed=Window]
interface CanvasRenderingContext2D {
  // back-reference to the canvas
  readonly attribute HTMLCanvasElement canvas;
};
CanvasRenderingContext2D includes CanvasState;
CanvasRenderingContext2D includes CanvasTransform;
CanvasRenderingContext2D includes CanvasCompositing;
CanvasRenderingContext2D includes CanvasImageSmoothing;
CanvasRenderingContext2D includes CanvasFillStrokeStyles;
CanvasRenderingContext2D includes CanvasShadowStyles;
CanvasRenderingContext2D includes CanvasFilters;
CanvasRenderingContext2D includes CanvasRect;
CanvasRenderingContext2D includes CanvasDrawPath;
CanvasRenderingContext2D includes CanvasUserInterface;
CanvasRenderingContext2D includes CanvasText;
CanvasRenderingContext2D includes CanvasDrawImage;
CanvasRenderingContext2D includes CanvasImageData;
CanvasRenderingContext2D includes CanvasPathDrawingStyles;
CanvasRenderingContext2D includes CanvasTextDrawingStyles;
CanvasRenderingContext2D includes CanvasPath;

interface mixin CanvasState {
  // state
  void save(); // push state on state stack
  void restore(); // pop state stack and restore state
};

interface mixin CanvasTransform {
  // transformations (default transform is the identity matrix)
  void scale(unrestricted double x, unrestricted double y);
  void rotate(unrestricted double angle);
  void translate(unrestricted double x, unrestricted double y);
  void transform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);

  [NewObject] DOMMatrix getTransform();
  void setTransform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void setTransform(optional DOMMatrix2DInit transform);
  void resetTransform();

};

interface mixin CanvasCompositing {
  // compositing
  attribute unrestricted double globalAlpha; // (default 1.0)
  attribute DOMString globalCompositeOperation; // (default source-over)
};

interface mixin CanvasImageSmoothing {
  // image smoothing
  attribute boolean imageSmoothingEnabled; // (default true)
  attribute ImageSmoothingQuality imageSmoothingQuality; // (default low)

};

interface mixin CanvasFillStrokeStyles {
  // colors and styles (see also the CanvasPathDrawingStyles and CanvasTextDrawingStyles interfaces)
  attribute (DOMString or CanvasGradient or CanvasPattern) strokeStyle; // (default black)
  attribute (DOMString or CanvasGradient or CanvasPattern) fillStyle; // (default black)
  CanvasGradient createLinearGradient(double x0, double y0, double x1, double y1);
  CanvasGradient createRadialGradient(double x0, double y0, double r0, double x1, double y1, double r1);
  CanvasPattern? createPattern(CanvasImageSource image, [TreatNullAs=EmptyString] DOMString repetition);

};

interface mixin CanvasShadowStyles {
  // shadows
  attribute unrestricted double shadowOffsetX; // (default 0)
  attribute unrestricted double shadowOffsetY; // (default 0)
  attribute unrestricted double shadowBlur; // (default 0)
  attribute DOMString shadowColor; // (default transparent black)
};

interface mixin CanvasFilters {
  // filters
  attribute DOMString filter; // (default "none")
};

interface mixin CanvasRect {
  // rects
  void clearRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void fillRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void strokeRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
};

interface mixin CanvasDrawPath {
  // path API (see also CanvasPath)
  void beginPath();
  void fill(optional CanvasFillRule fillRule = "nonzero");
  void fill(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void stroke();
  void stroke(Path2D path);
  void clip(optional CanvasFillRule fillRule = "nonzero");
  void clip(Path2D path, optional CanvasFillRule fillRule = "nonzero");
  void resetClip();
  boolean isPointInPath(unrestricted double x, unrestricted double y, optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInPath(Path2D path, unrestricted double x, unrestricted double y, optional CanvasFillRule fillRule = "nonzero");
  boolean isPointInStroke(unrestricted double x, unrestricted double y);
  boolean isPointInStroke(Path2D path, unrestricted double x, unrestricted double y);
};

interface mixin CanvasUserInterface {
  void drawFocusIfNeeded(Element element);
  void drawFocusIfNeeded(Path2D path, Element element);
  void scrollPathIntoView();
  void scrollPathIntoView(Path2D path);
};

interface mixin CanvasText {
  // text (see also the CanvasPathDrawingStyles and CanvasTextDrawingStyles interfaces)
  void fillText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void strokeText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  TextMetrics measureText(DOMString text);
};

interface mixin CanvasDrawImage {
  // drawing images
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy);
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void drawImage(CanvasImageSource image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
};

interface mixin CanvasImageData {
  // pixel manipulation
  ImageData createImageData(long sw, long sh);
  ImageData createImageData(ImageData imagedata);
  ImageData getImageData(long sx, long sy, long sw, long sh);
  void putImageData(ImageData imagedata, long dx, long dy);
  void putImageData(ImageData imagedata, long dx, long dy, long dirtyX, long dirtyY, long dirtyWidth, long dirtyHeight);
};

enum CanvasLineCap { "butt", "round", "square" };
enum CanvasLineJoin { "round", "bevel", "miter" };
enum CanvasTextAlign { "start", "end", "left", "right", "center" };
enum CanvasTextBaseline { "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" };
enum CanvasDirection { "ltr", "rtl", "inherit" };

interface mixin CanvasPathDrawingStyles {
  // line caps/joins
  attribute unrestricted double lineWidth; // (default 1)
  attribute CanvasLineCap lineCap; // (default "butt")
  attribute CanvasLineJoin lineJoin; // (default "miter")
  attribute unrestricted double miterLimit; // (default 10)

  // dashed lines
  void setLineDash(sequence<unrestricted double> segments); // default empty
  sequence<unrestricted double> getLineDash();
  attribute unrestricted double lineDashOffset;
};

interface mixin CanvasTextDrawingStyles {
  // text
  attribute DOMString font; // (default 10px sans-serif)
  attribute CanvasTextAlign textAlign; // (default: "start")
  attribute CanvasTextBaseline textBaseline; // (default: "alphabetic")
  attribute CanvasDirection direction; // (default: "inherit")
};

interface mixin CanvasPath {
  // shared path API methods
  void closePath();
  void moveTo(unrestricted double x, unrestricted double y);
  void lineTo(unrestricted double x, unrestricted double y);
  void quadraticCurveTo(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void bezierCurveTo(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void arcTo(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius);
  void rect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void arc(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false);
  void ellipse(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false);
};

[Exposed=(Window,Worker)]
interface CanvasGradient {
  // opaque object
  void addColorStop(double offset, DOMString color);
};

[Exposed=(Window,Worker)]
interface CanvasPattern {
  // opaque object
  void setTransform(optional DOMMatrix2DInit transform);
};

[Exposed=Window]
interface TextMetrics {
  // x-direction
  readonly attribute double width; // advance width
  readonly attribute double actualBoundingBoxLeft;
  readonly attribute double actualBoundingBoxRight;

  // y-direction
  readonly attribute double fontBoundingBoxAscent;
  readonly attribute double fontBoundingBoxDescent;
  readonly attribute double actualBoundingBoxAscent;
  readonly attribute double actualBoundingBoxDescent;
  readonly attribute double emHeightAscent;
  readonly attribute double emHeightDescent;
  readonly attribute double hangingBaseline;
  readonly attribute double alphabeticBaseline;
  readonly attribute double ideographicBaseline;
};

[Constructor(unsigned long sw, unsigned long sh),
 Constructor(Uint8ClampedArray data, unsigned long sw, optional unsigned long sh),
 Exposed=(Window,Worker),
 Serializable]
interface ImageData {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  readonly attribute Uint8ClampedArray data;
};

[Constructor(optional (Path2D or DOMString) path),
 Exposed=(Window,Worker)]
interface Path2D {
  void addPath(Path2D path, optional DOMMatrix2DInit transform);
};
Path2D includes CanvasPath;
To maintain compatibility with existing Web content, user agents need to enumerate methods defined in CanvasUserInterface immediately after the stroke() method on CanvasRenderingContext2D objects.

context = canvas . getContext('2d' [, { [ alpha: false ] } ] )
Returns a CanvasRenderingContext2D object that is permanently bound to a particular canvas element.

If the alpha setting is provided and set to false, then the canvas is forced to always be opaque.

context . canvas
Returns the canvas element.

A CanvasRenderingContext2D object has an output bitmap that is initialized when the object is created.

The output bitmap has an origin-clean flag, which can be set to true or false. Initially, when one of these bitmaps is created, its origin-clean flag must be set to true.

The CanvasRenderingContext2D object also has an alpha flag, which can be set to true or false. Initially, when the context is created, its alpha flag must be set to true. When a CanvasRenderingContext2D object has its alpha flag set to false, then its alpha channel must be fixed to 1.0 (fully opaque) for all pixels, and attempts to change the alpha component of any pixel must be silently ignored.

Thus, the bitmap of such a context starts off as opaque black instead of transparent black; clearRect() always results in opaque black pixels, every fourth byte from getImageData() is always 255, the putImageData() method effectively ignores every fourth byte in its input, and so on. However, the alpha component of styles and images drawn onto the canvas are still honoured up to the point where they would impact the output bitmap's alpha channel; for instance, drawing a 50% transparent white square on a freshly created output bitmap with its alpha flag set to false will result in a fully-opaque gray square.

The CanvasRenderingContext2D 2D rendering context represents a flat linear Cartesian surface whose origin (0,0) is at the top left corner, with the coordinate space having x values increasing when going right, and y values increasing when going down. The x-coordinate of the right-most edge is equal to the width of the rendering context's output bitmap in CSS pixels; similarly, the y-coordinate of the bottom-most edge is equal to the height of the rendering context's output bitmap in CSS pixels.

The size of the coordinate space does not necessarily represent the size of the actual bitmaps that the user agent will use internally or during rendering. On high-definition displays, for instance, the user agent may internally use bitmaps with four device pixels per unit in the coordinate space, so that the rendering remains at high quality throughout. Anti-aliasing can similarly be implemented using oversampling with bitmaps of a higher resolution than the final image on the display.

Using CSS pixels to describe the size of a rendering context's output bitmap does not mean that when rendered the canvas will cover an equivalent area in CSS pixels. CSS pixels are reused for ease of integration with CSS features, such as text layout.

In other words, the canvas element below's rendering context has a 200x200 output bitmap (which internally uses CSS pixels as a unit for ease of integration with CSS) and is rendered as 100x100 CSS pixels:

<canvas width=200 height=200 style=width:100px;height:100px>
The 2D context creation algorithm, which is passed a target (a canvas element) and options, consists of running these steps:

Let settings be the result of converting options to the dictionary type CanvasRenderingContext2DSettings. (This can throw an exception.).

Let context be a new CanvasRenderingContext2D object.

Initialize context's canvas attribute to point to target.

Set context's output bitmap to the same bitmap as target's bitmap (so that they are shared).

Set bitmap dimensions to the numeric values of target's width and height content attributes.

Process each of the members of settings as follows:

alpha
If false, then set context's alpha flag to false.
Return context.

When the user agent is to set bitmap dimensions to width and height, it must run these steps:

Reset the rendering context to its default state.

Resize the output bitmap to the new width and height and clear it to transparent black.

Let canvas be the canvas element to which the rendering context's canvas attribute was initialized.

If the numeric value of canvas's width content attribute differs from width, then set canvas's width content attribute to the shortest possible string representing width as a valid non-negative integer.

If the numeric value of canvas's height content attribute differs from height, then set canvas's height content attribute to the shortest possible string representing height as a valid non-negative integer.

Only one square appears to be drawn in the following example:

// canvas is a reference to a <canvas> element
var context = canvas.getContext('2d');
context.fillRect(0,0,50,50);
canvas.setAttribute('width', '300'); // clears the canvas
context.fillRect(0,100,50,50);
canvas.width = canvas.width; // clears the canvas
context.fillRect(100,0,50,50); // only this square remains
The canvas attribute must return the value it was initialized to when the object was created.

The CanvasFillRule enumeration is used to select the fill rule algorithm by which to determine if a point is inside or outside a path.

The value "nonzero" value indicates the nonzero winding rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight line drawn from that point crosses the shape's path going in one direction is equal to the number of times it crosses the path going in the other direction.

The "evenodd" value indicates the even-odd rule, wherein a point is considered to be outside a shape if the number of times a half-infinite straight line drawn from that point crosses the shape's path is even.

If a point is not outside a shape, it is inside the shape.

The ImageSmoothingQuality enumeration is used to express a preference for the interpolation quality to use when smoothing images.

The "low" value indicates a preference for a low level of image interpolation quality. Low-quality image interpolation may be more computationally efficient than higher settings.

The "medium" value indicates a preference for a medium level of image interpolation quality.

The "high" value indicates a preference for a high level of image interpolation quality. High-quality image interpolation may be more computationally expensive than lower settings.

Bilinear scaling is an example of a relatively fast, lower-quality image-smoothing algorithm. Bicubic or Lanczos scaling are examples of image-smoothing algorithms that produce higher-quality output. This specification does not mandate that specific interpolation algorithms be used.

4.12.5.1.1 Implementation notes
This section is non-normative.

The output bitmap, when it is not directly displayed by the user agent, implementations can, instead of updating this bitmap, merely remember the sequence of drawing operations that have been applied to it until such time as the bitmap's actual data is needed (for example because of a call to drawImage(), or the createImageBitmap() factory method). In many cases, this will be more memory efficient.

The bitmap of a canvas element is the one bitmap that's pretty much always going to be needed in practice. The output bitmap of a rendering context, when it has one, is always just an alias to a canvas element's bitmap.

Additional bitmaps are sometimes needed, e.g. to enable fast drawing when the canvas is being painted at a different size than its intrinsic size, or to enable double buffering so that graphics updates, like page scrolling for example, can be processed concurrently while canvas draw commands are being executed.

4.12.5.1.2 The canvas state
Objects that implement the CanvasState interface maintain a stack of drawing states. Drawing states consist of:

The current transformation matrix.
The current clipping region.
The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, filter, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled, imageSmoothingQuality.
The current dash list.
The current default path and the rendering context's bitmaps are not part of the drawing state. The current default path is persistent, and can only be reset using the beginPath() method. The bitmaps depend on whether and how the rendering context is bound to a canvas element.

context . save()
Pushes the current state onto the stack.

context . restore()
Pops the top state on the stack, restoring the context to that state.

The save() method, when invoked, must push a copy of the current drawing state onto the drawing state stack.

The restore() method, when invoked, must pop the top entry in the drawing state stack, and reset the drawing state it describes. If there is no saved state, then the method must do nothing.

When the user agent is to reset the rendering context to its default state, it must clear the drawing state stack and everything that drawing state consists of to initial values.

4.12.5.1.3 Line styles
context . lineWidth [ = value ]
styles . lineWidth [ = value ]
Returns the current line width.

Can be set, to change the line width. Values that are not finite values greater than zero are ignored.

context . lineCap [ = value ]
styles . lineCap [ = value ]
Returns the current line cap style.

Can be set, to change the line cap style.

The possible line cap styles are "butt", "round", and "square". Other values are ignored.

context . lineJoin [ = value ]
styles . lineJoin [ = value ]
Returns the current line join style.

Can be set, to change the line join style.

The possible line join styles are "bevel", "round", and "miter". Other values are ignored.

context . miterLimit [ = value ]
styles . miterLimit [ = value ]
Returns the current miter limit ratio.

Can be set, to change the miter limit ratio. Values that are not finite values greater than zero are ignored.

context . setLineDash(segments)
styles . setLineDash(segments)
Sets the current line dash pattern (as used when stroking). The argument is a list of distances for which to alternately have the line on and the line off.

segments = context . getLineDash()
segments = styles . getLineDash()
Returns a copy of the current line dash pattern. The array returned will always have an even number of entries (i.e. the pattern is normalized).

context . lineDashOffset
styles . lineDashOffset
Returns the phase offset (in the same units as the line dash pattern).

Can be set, to change the phase offset. Values that are not finite values are ignored.

Objects that implement the CanvasPathDrawingStyles interface have attributes and methods (defined in this section) that control how lines are treated by the object.

The lineWidth attribute gives the width of lines, in coordinate space units. On getting, it must return the current value. On setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value.

When the object implementing the CanvasPathDrawingStyles interface is created, the lineWidth attribute must initially have the value 1.0.

The lineCap attribute defines the type of endings that UAs will place on the end of lines. The three valid values are "butt", "round", and "square".

On getting, it must return the current value. On setting, the current value must be changed to the new value.

When the object implementing the CanvasPathDrawingStyles interface is created, the lineCap attribute must initially have the value "butt".

The lineJoin attribute defines the type of corners that UAs will place where two lines meet. The three valid values are "bevel", "round", and "miter".

On getting, it must return the current value. On setting, the current value must be changed to the new value.

When the object implementing the CanvasPathDrawingStyles interface is created, the lineJoin attribute must initially have the value "miter".

When the lineJoin attribute has the value "miter", strokes use the miter limit ratio to decide how to render joins. The miter limit ratio can be explicitly set using the miterLimit attribute. On getting, it must return the current value. On setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value.

When the object implementing the CanvasPathDrawingStyles interface is created, the miterLimit attribute must initially have the value 10.0.

Each CanvasPathDrawingStyles object has a dash list, which is either empty or consists of an even number of non-negative numbers. Initially, the dash list must be empty.

The setLineDash() method, when invoked, must run these steps:

Let a be the argument.

If any value in a is not finite (e.g. an Infinity or a NaN value), or if any value is negative (less than zero), then return (without throwing an exception; user agents could show a message on a developer console, though, as that would be helpful for debugging).

If the number of elements in a is odd, then let a be the concatenation of two copies of a.

Let the object's dash list be a.

When the getLineDash() method is invoked, it must return a sequence whose values are the values of the object's dash list, in the same order.

It is sometimes useful to change the "phase" of the dash pattern, e.g. to achieve a "marching ants" effect. The phase can be set using the lineDashOffset attribute. On getting, it must return the current value. On setting, infinite and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value.

When the object implementing the CanvasPathDrawingStyles interface is created, the lineDashOffset attribute must initially have the value 0.0.

When a user agent is to trace a path, given an object style that implements the CanvasPathDrawingStyles interface, it must run the following algorithm. This algorithm returns a new path.

Let path be a copy of the path being traced.

Prune all zero-length line segments from path.

Remove from path any subpaths containing no lines (i.e. subpaths with just one point).

Replace each point in each subpath of path other than the first point and the last point of each subpath by a join that joins the line leading to that point to the line leading out of that point, such that the subpaths all consist of two points (a starting point with a line leading out of it, and an ending point with a line leading into it), one or more lines (connecting the points and the joins), and zero or more joins (each connecting one line to another), connected together such that each subpath is a series of one or more lines with a join between each one and a point on each end.

Add a straight closing line to each closed subpath in path connecting the last point and the first point of that subpath; change the last point to a join (from the previously last line to the newly added closing line), and change the first point to a join (from the newly added closing line to the first line).

If style's dash list is empty, then jump to the step labeled convert.

Let pattern width be the concatenation of all the entries of style's dash list, in coordinate space units.

For each subpath subpath in path, run the following substeps. These substeps mutate the subpaths in path in vivo.

Let subpath width be the length of all the lines of subpath, in coordinate space units.

Let offset be the value of style's lineDashOffset, in coordinate space units.

While offset is greater than pattern width, decrement it by pattern width.

While offset is less than zero, increment it by pattern width.

Define L to be a linear coordinate line defined along all lines in subpath, such that the start of the first line in the subpath is defined as coordinate 0, and the end of the last line in the subpath is defined as coordinate subpath width.

Let position be zero minus offset.

Let index be 0.

Let current state be off (the other states being on and zero-on).

Dash on: Let segment length be the value of style's dash list's indexth entry.

Increment position by segment length.

If position is greater than subpath width, then end these substeps for this subpath and start them again for the next subpath; if there are no more subpaths, then jump to the step labeled convert instead.

If segment length is nonzero, then let current state be on.

Increment index by one.

Dash off: Let segment length be the value of style's dash list's indexth entry.

Let start be the offset position on L.

Increment position by segment length.

If position is less than zero, then jump to the step labeled post-cut.

If start is less than zero, then let start be zero.

If position is greater than subpath width, then let end be the offset subpath width on L. Otherwise, let end be the offset position on L.

Jump to the first appropriate step:

If segment length is zero and current state is off
Do nothing, just continue to the next step.

If current state is off
Cut the line on which end finds itself short at end and place a point there, cutting in two the subpath that it was in; remove all line segments, joins, points, and subpaths that are between start and end; and finally place a single point at start with no lines connecting to it.

The point has a directionality for the purposes of drawing line caps (see below). The directionality is the direction that the original line had at that point (i.e. when L was defined above).

Otherwise
Cut the line on which start finds itself into two at start and place a point there, cutting in two the subpath that it was in, and similarly cut the line on which end finds itself short at end and place a point there, cutting in two the subpath that it was in, and then remove all line segments, joins, points, and subpaths that are between start and end.

If start and end are the same point, then this results in just the line being cut in two and two points being inserted there, with nothing being removed, unless a join also happens to be at that point, in which case the join must be removed.

Post-cut: If position is greater than subpath width, then jump to the step labeled convert.

If segment length is greater than zero, then let positioned-at-on-dash be false.

Increment index by one. If it is equal to the number of entries in style's dash list, then let index be 0.

Return to the step labeled dash on.

Convert: This is the step that converts the path to a new path that represents its stroke.

Create a new path that describes the edge of the areas that would be covered if a straight line of length equal to style's lineWidth was swept along each subpath in path while being kept at an angle such that the line is orthogonal to the path being swept, replacing each point with the end cap necessary to satisfy style's lineCap attribute as described previously and elaborated below, and replacing each join with the join necessary to satisfy style's lineJoin type, as defined below.

Caps: Each point has a flat edge perpendicular to the direction of the line coming out of it. This is then augmented according to the value of style's lineCap. The "butt" value means that no additional line cap is added. The "round" value means that a semi-circle with the diameter equal to style's lineWidth width must additionally be placed on to the line coming out of each point. The "square" value means that a rectangle with the length of style's lineWidth width and the width of half style's lineWidth width, placed flat against the edge perpendicular to the direction of the line coming out of the point, must be added at each point.

Points with no lines coming out of them must have two caps placed back-to-back as if it was really two points connected to each other by an infinitesimally short straight line in the direction of the point's directionality (as defined above).

Joins: In addition to the point where a join occurs, two additional points are relevant to each join, one for each line: the two corners found half the line width away from the join point, one perpendicular to each line, each on the side furthest from the other line.

A triangle connecting these two opposite corners with a straight line, with the third point of the triangle being the join point, must be added at all joins. The lineJoin attribute controls whether anything else is rendered. The three aforementioned values have the following meanings:

The "bevel" value means that this is all that is rendered at joins.

The "round" value means that an arc connecting the two aforementioned corners of the join, abutting (and not overlapping) the aforementioned triangle, with the diameter equal to the line width and the origin at the point of the join, must be added at joins.

The "miter" value means that a second triangle must (if it can given the miter length) be added at the join, with one line being the line between the two aforementioned corners, abutting the first triangle, and the other two being continuations of the outside edges of the two joining lines, as long as required to intersect without going over the miter length.

The miter length is the distance from the point where the join occurs to the intersection of the line edges on the outside of the join. The miter limit ratio is the maximum allowed ratio of the miter length to half the line width. If the miter length would cause the miter limit ratio (as set by style's miterLimit attribute) to be exceeded, then this second triangle must not be added.

The subpaths in the newly created path must be oriented such that for any point, the number of times a half-infinite straight line drawn from that point crosses a subpath is even if and only if the number of times a half-infinite straight line drawn from that same point crosses a subpath going in one direction is equal to the number of times it crosses a subpath going in the other direction.

Return the newly created path.

4.12.5.1.4 Text styles
context . font [ = value ]
styles . font [ = value ]
Returns the current font settings.

Can be set, to change the font. The syntax is the same as for the CSS 'font' property; values that cannot be parsed as CSS font values are ignored.

Relative keywords and lengths are computed relative to the font of the canvas element.

context . textAlign [ = value ]
styles . textAlign [ = value ]
Returns the current text alignment settings.

Can be set, to change the alignment. The possible values are and their meanings are given below. Other values are ignored. The default is "start".

context . textBaseline [ = value ]
styles . textBaseline [ = value ]
Returns the current baseline alignment settings.

Can be set, to change the baseline alignment. The possible values and their meanings are given below. Other values are ignored. The default is "alphabetic".

context . direction [ = value ]
styles . direction [ = value ]
Returns the current directionality.

Can be set, to change the directionality. The possible values and their meanings are given below. Other values are ignored. The default is "inherit".

Objects that implement the CanvasTextDrawingStyles interface have attributes (defined in this section) that control how text is laid out (rasterized or outlined) by the object. Such objects can also have a font style source object. For CanvasRenderingContext2D objects, this is the canvas element referenced by the context's canvas property.

The font IDL attribute, on setting, must be parsed as a CSS <'font'> value (but without supporting property-independent style sheet syntax like 'inherit'), and the resulting font must be assigned to the context, with the 'line-height' component forced to 'normal', with the 'font-size' component converted to CSS pixels, and with system fonts being computed to explicit values. If the new value is syntactically incorrect (including using property-independent style sheet syntax like 'inherit' or 'initial'), then it must be ignored, without assigning a new font value. [CSS]

Font family names must be interpreted in the context of the font style source object when the font is to be used; any fonts embedded using @font-face or loaded using FontFace objects that are visible to the font style source object must therefore be available once they are loaded. (Each font style source object has a font source, which determines what fonts are available.) If a font is used before it is fully loaded, or if the font style source object does not have that font in scope at the time the font is to be used, then it must be treated as if it was an unknown font, falling back to another as described by the relevant CSS specifications. [CSSFONTS] [CSSFONTLOAD]

On getting, the font attribute must return the serialized form of the current font of the context (with no 'line-height' component). [CSSOM]

For example, after the following statement:

context.font = 'italic 400 12px/2 Unknown Font, sans-serif';
...the expression context.font would evaluate to the string "italic 12px "Unknown Font", sans-serif". The "400" font-weight doesn't appear because that is the default value. The line-height doesn't appear because it is forced to "normal", the default value.

When the object implementing the CanvasTextDrawingStyles interface is created, the font of the context must be set to 10px sans-serif. When the 'font-size' component is set to lengths using percentages, 'em' or 'ex' units, or the 'larger' or 'smaller' keywords, these must be interpreted relative to the computed value of the 'font-size' property of the font style source object at the time that the attribute is set, if it is an element. When the 'font-weight' component is set to the relative values 'bolder' and 'lighter', these must be interpreted relative to the computed value of the 'font-weight' property of the font style source object at the time that the attribute is set, if it is an element. If the computed values are undefined for a particular case (e.g. because the font style source object is not an element or is not being rendered), then the relative keywords must be interpreted relative to the normal-weight 10px sans-serif default.

The textAlign IDL attribute, on getting, must return the current value. On setting, the current value must be changed to the new value. When the object implementing the CanvasTextDrawingStyles interface is created, the textAlign attribute must initially have the value start.

The textBaseline IDL attribute, on getting, must return the current value. On setting, the current value must be changed to the new value. When the object implementing the CanvasTextDrawingStyles interface is created, the textBaseline attribute must initially have the value alphabetic.

The direction IDL attribute, on getting, must return the current value. On setting, the current value must be changed to the new value. When the object implementing the CanvasTextDrawingStyles interface is created, the direction attribute must initially have the value "inherit".

The textAlign attribute's allowed keywords are as follows:

start
Align to the start edge of the text (left side in left-to-right text, right side in right-to-left text).

end
Align to the end edge of the text (right side in left-to-right text, left side in right-to-left text).

left
Align to the left.

right
Align to the right.

center
Align to the center.

The textBaseline attribute's allowed keywords correspond to alignment points in the font:



The keywords map to these alignment points as follows:

top
The top of the em square
hanging
The hanging baseline
middle
The middle of the em square
alphabetic
The alphabetic baseline
ideographic
The ideographic baseline
bottom
The bottom of the em square
The direction attribute's allowed keywords are as follows:

ltr
Treat input to the text preparation algorithm as left-to-right text.

rtl
Treat input to the text preparation algorithm as right-to-left text.

inherit
Default to the directionality of the canvas element or Document as appropriate.

The text preparation algorithm is as follows. It takes as input a string text , a CanvasTextDrawingStyles object target, and an optional length maxWidth. It returns an array of glyph shapes, each positioned on a common coordinate space, a physical alignment whose value is one of left, right, and center, and an inline box. (Most callers of this algorithm ignore the physical alignment and the inline box.)

If maxWidth was provided but is less than or equal to zero or equal to NaN, then return an empty array.

Replace all ASCII whitespace in text with U+0020 SPACE characters.

Let font be the current font of target, as given by that object's font attribute.

Apply the appropriate step from the following list to determine the value of direction:

If the target object's direction attribute has the value "ltr"
Let direction be 'ltr'.
If the target object's direction attribute has the value "rtl"
Let direction be 'rtl'.
If the target object's font style source object is an element
Let direction be the directionality of the target object's font style source object.
If the target object's font style source object is a Document with a non-null document element
Let direction be the directionality of the target object's font style source object's document element.
Otherwise
Let direction be 'ltr'.
Form a hypothetical infinitely-wide CSS line box containing a single inline box containing the text text, with all the properties at their initial values except the 'font' property of the inline box set to font, the 'direction' property of the inline box set to direction, and the 'white-space' property set to 'pre'. [CSS]

If maxWidth was provided and the hypothetical width of the inline box in the hypothetical line box is greater than maxWidth CSS pixels, then change font to have a more condensed font (if one is available or if a reasonably readable one can be synthesized by applying a horizontal scale factor to the font) or a smaller font, and return to the previous step.

The anchor point is a point on the inline box, and the physical alignment is one of the values left, right, and center. These variables are determined by the textAlign and textBaseline values as follows:

Horizontal position:

If textAlign is left
If textAlign is start and direction is 'ltr'
If textAlign is end and direction is 'rtl'
Let the anchor point's horizontal position be the left edge of the inline box, and let physical alignment be left.
If textAlign is right
If textAlign is end and direction is 'ltr'
If textAlign is start and direction is 'rtl'
Let the anchor point's horizontal position be the right edge of the inline box, and let physical alignment be right.
If textAlign is center
Let the anchor point's horizontal position be half way between the left and right edges of the inline box, and let physical alignment be center.
Vertical position:

If textBaseline is top
Let the anchor point's vertical position be the top of the em box of the first available font of the inline box.
If textBaseline is hanging
Let the anchor point's vertical position be the hanging baseline of the first available font of the inline box.
If textBaseline is middle
Let the anchor point's vertical position be half way between the bottom and the top of the em box of the first available font of the inline box.
If textBaseline is alphabetic
Let the anchor point's vertical position be the alphabetic baseline of the first available font of the inline box.
If textBaseline is ideographic
Let the anchor point's vertical position be the ideographic baseline of the first available font of the inline box.
If textBaseline is bottom
Let the anchor point's vertical position be the bottom of the em box of the first available font of the inline box.
Let result be an array constructed by iterating over each glyph in the inline box from left to right (if any), adding to the array, for each glyph, the shape of the glyph as it is in the inline box, positioned on a coordinate space using CSS pixels with its origin is at the anchor point.

Return result, physical alignment, and the inline box.

4.12.5.1.5 Building paths
Objects that implement the CanvasPath interface have a path. A path has a list of zero or more subpaths. Each subpath consists of a list of one or more points, connected by straight or curved line segments, and a flag indicating whether the subpath is closed or not. A closed subpath is one where the last point of the subpath is connected to the first point of the subpath by a straight line. Subpaths with only one point are ignored when painting the path.

Paths have a need new subpath flag. When this flag is set, certain APIs create a new subpath rather than extending the previous one. When a path is created, its need new subpath flag must be set.

When an object implementing the CanvasPath interface is created, its path must be initialized to zero subpaths.

context . moveTo(x, y)
path . moveTo(x, y)
Creates a new subpath with the given point.

context . closePath()
path . closePath()
Marks the current subpath as closed, and starts a new subpath with a point the same as the start and end of the newly closed subpath.

context . lineTo(x, y)
path . lineTo(x, y)
Adds the given point to the current subpath, connected to the previous one by a straight line.

context . quadraticCurveTo(cpx, cpy, x, y)
path . quadraticCurveTo(cpx, cpy, x, y)
Adds the given point to the current subpath, connected to the previous one by a quadratic Bézier curve with the given control point.

context . bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
path . bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
Adds the given point to the current subpath, connected to the previous one by a cubic Bézier curve with the given control points.

context . arcTo(x1, y1, x2, y2, radius)
path . arcTo(x1, y1, x2, y2, radius)
Adds an arc with the given control points and radius to the current subpath, connected to the previous point by a straight line.

Throws an "IndexSizeError" DOMException if the given radius is negative.


context . arc(x, y, radius, startAngle, endAngle [, anticlockwise ] )
path . arc(x, y, radius, startAngle, endAngle [, anticlockwise ] )
Adds points to the subpath such that the arc described by the circumference of the circle described by the arguments, starting at the given start angle and ending at the given end angle, going in the given direction (defaulting to clockwise), is added to the path, connected to the previous point by a straight line.

Throws an "IndexSizeError" DOMException if the given radius is negative.


context . ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle [, anticlockwise] )
path . ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle [, anticlockwise] )
Adds points to the subpath such that the arc described by the circumference of the ellipse described by the arguments, starting at the given start angle and ending at the given end angle, going in the given direction (defaulting to clockwise), is added to the path, connected to the previous point by a straight line.

Throws an "IndexSizeError" DOMException if the given radius is negative.

context . rect(x, y, w, h)
path . rect(x, y, w, h)
Adds a new closed subpath to the path, representing the given rectangle.

The following methods allow authors to manipulate the paths of objects implementing the CanvasPath interface.

For objects implementing the CanvasDrawPath and CanvasTransform interfaces, the points passed to the methods, and the resulting lines added to current default path by these methods, must be transformed according to the current transformation matrix before being added to the path.

The moveTo(x, y) method, when invoked, must run these steps:

If either of the arguments are infinite or NaN, then return.

Create a new subpath with the specified point as its first (and only) point.

When the user agent is to ensure there is a subpath for a coordinate (x, y) on a path, the user agent must check to see if the path has its need new subpath flag set. If it does, then the user agent must create a new subpath with the point (x, y) as its first (and only) point, as if the moveTo() method had been called, and must then unset the path's need new subpath flag.

The closePath() method, when invoked, must do nothing if the object's path has no subpaths. Otherwise, it must mark the last subpath as closed, create a new subpath whose first point is the same as the previous subpath's first point, and finally add this new subpath to the path.

If the last subpath had more than one point in its list of points, then this is equivalent to adding a straight line connecting the last point back to the first point of the last subpath, thus "closing" the subpath.

New points and the lines connecting them are added to subpaths using the methods described below. In all cases, the methods only modify the last subpath in the object's path.

The lineTo(x, y) method, when invoked, must run these steps:

If either of the arguments are infinite or NaN, then return.

If the object's path has no subpaths, then ensure there is a subpath for (x, y).

Otherwise, connect the last point in the subpath to the given point (x, y) using a straight line, and then add the given point (x, y) to the subpath.

The quadraticCurveTo(cpx, cpy, x, y) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Ensure there is a subpath for (cpx, cpy)

Connect the last point in the subpath to the given point (x, y) using a quadratic Bézier curve with control point (cpx, cpy). [BEZIER]

Add the given point (x, y) to the subpath.

The bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Ensure there is a subpath for (cp1x, cp1y).

Connect the last point in the subpath to the given point (x, y) using a cubic Bézier curve with control points (cp1x, cp1y) and (cp2x, cp2y). [BEZIER]

Add the point (x, y) to the subpath.

The arcTo(x1, y1, x2, y2, radius) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Ensure there is a subpath for (x1, y1).

If radius is negative, then throw an "IndexSizeError" DOMException.

Let the point (x0, y0) be the last point in the subpath, transformed by the inverse of the current transformation matrix (so that it is in the same coordinate system as the points passed to the method).

If the point (x0, y0) is equal to the point (x1, y1), or if the point (x1, y1) is equal to the point (x2, y2), or if radius is zero, then add the point (x1, y1) to the subpath, and connect that point to the previous point (x0, y0) by a straight line.

Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line, then add the point (x1, y1) to the subpath, and connect that point to the previous point (x0, y0) by a straight line.

Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius, and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1), and that has a different point tangent to the half-infinite line that ends at the point (x1, y1) and crosses the point (x2, y2). The points at which this circle touches these two lines are called the start and end tangent points respectively. Connect the point (x0, y0) to the start tangent point by a straight line, adding the start tangent point to the subpath, and then connect the start tangent point to the end tangent point by The Arc, adding the end tangent point to the subpath.

The arc(x, y, radius, startAngle, endAngle, anticlockwise) method, when invoked, must run the ellipse method steps with this, x, y, radius, radius, 0, startAngle, endAngle, and anticlockwise.

This makes it equivalent to ellipse() except that both radii are equal and rotation is 0.

The ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) method, when invoked, must run the ellipse method steps with this, x, y, radiusX, radiusY, rotation, startAngle, endAngle, and anticlockwise.

The ellipse method steps, given canvasPath, x, y, radiusX, radiusY, rotation, startAngle, endAngle, and anticlockwise, are:

If any of the arguments are infinite or NaN, then return.

If either radiusX or radiusY are negative, then throw an "IndexSizeError" DOMException.

If canvasPath's path has any subpaths, then add a straight line from the last point in the subpath to the start point of the arc.

Add the start and end points of the arc to the subpath, and connect them with an arc. The arc and its start and end points are defined as follows:

Consider an ellipse that has its origin at (x, y), that has a major-axis radius radiusX and a minor-axis radius radiusY, and that is rotated about its origin such that its semi-major axis is inclined rotation radians clockwise from the x-axis.

If anticlockwise is false and endAngle-startAngle is equal to or greater than 2π, or, if anticlockwise is true and startAngle-endAngle is equal to or greater than 2π, then the arc is the whole circumference of this ellipse, and the point at startAngle along this circle's circumference, measured in radians clockwise from the ellipse's semi-major axis, acts as both the start point and the end point.

Otherwise, the points at startAngle and endAngle along this circle's circumference, measured in radians clockwise from the ellipse's semi-major axis, are the start and end points respectively, and the arc is the path along the circumference of this ellipse from the start point to the end point, going anti-clockwise if anticlockwise is true, and clockwise otherwise. Since the points are on the ellipse, as opposed to being simply angles from zero, the arc can never cover an angle greater than 2π radians.

Even if the arc covers the entire circumference of the ellipse and there are no other points in the subpath, the path is not closed unless the closePath() method is appropriately invoked.

The rect(x, y, w, h) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Create a new subpath containing just the four points (x, y), (x+w, y), (x+w, y+h), (x, y+h), in that order, with those four points connected by straight lines.

Mark the subpath as closed.

Create a new subpath with the point (x, y) as the only point in the subpath.

4.12.5.1.6 Path2D objects

Support: path2d
Chrome for Android (limited)	64+
Chrome	63+
iOS Safari	9.0+
UC Browser for Android (limited)	11.8+
Firefox	48+
Samsung Internet (limited)	4+
IE	None
Opera Mini	None
Safari	9.1+
Edge (limited)	14+
Android Browser (limited)	62+
Opera (limited)	23+

Source: caniuse.com

Path2D objects can be used to declare paths that are then later used on objects implementing the CanvasDrawPath interface. In addition to many of the APIs described in earlier sections, Path2D objects have methods to combine paths, and to add text to paths.

path = new Path2D()
Creates a new empty Path2D object.

path = new Path2D(path)
When path is a Path2D object, returns a copy.

When path is a string, creates the path described by the argument, interpreted as SVG path data. [SVG]

path . addPath(path [, transform ] )
Adds to the path the path given by the argument.

The Path2D(path) constructor, when invoked, must run these steps:

Let output be a new Path2D object.

If path is not given, then return output.

If path is a Path2D object, then add all subpaths of path to output and return output. (In other words, it returns a copy of the argument.)

Let svgPath be the result of parsing and interpreting path according to the SVG specification's rules for path data. [SVG]

The resulting path could be empty. SVG defines error handling rules for parsing and applying path data.

Let (x, y) be the last point in svgPath.

Add all the subpaths, if any, from svgPath to output.

Create a new subpath in output with (x, y) as the only point in the subpath.

Return output.

The addPath(b, transform) method, when invoked on a Path2D object a, must run these steps:

If the Path2D object b has no subpaths, then return.

Let matrix be the result of creating a DOMMatrix from the 2D dictionary transform.

If one or more of matrix's m11 element, m12 element, m21 element, m22 element, m41 element, or m42 element are infinite or NaN, then return.

Create a copy of all the subpaths in b. Let this copy be known as c.

Transform all the coordinates and lines in c by the transform matrix matrix.

Let (x, y) be the last point in the last subpath of c.

Add all the subpaths in c to a.

Create a new subpath in a with (x, y) as the only point in the subpath.

4.12.5.1.7 Transformations

Spec bugs: 28333

Objects that implement the CanvasTransform interface have a current transformation matrix, as well as methods (described in this section) to manipulate it. When an object implementing the CanvasTransform interface is created, its transformation matrix must be initialized to the identity matrix.

The current transformation matrix is applied to coordinates when creating the current default path, and when painting text, shapes, and Path2D objects, on objects implementing the CanvasTransform interface.

The transformations must be performed in reverse order.

For instance, if a scale transformation that doubles the width is applied to the canvas, followed by a rotation transformation that rotates drawing operations by a quarter turn, and a rectangle twice as wide as it is tall is then drawn on the canvas, the actual result will be a square.

context . scale(x, y)
Changes the current transformation matrix to apply a scaling transformation with the given characteristics.

context . rotate(angle)
Changes the current transformation matrix to apply a rotation transformation with the given characteristics. The angle is in radians.

context . translate(x, y)
Changes the current transformation matrix to apply a translation transformation with the given characteristics.

context . transform(a, b, c, d, e, f)
Changes the current transformation matrix to apply the matrix given by the arguments as described below.

matrix = context . getTransform()
Returns a copy of the current transformation matrix, as a newly created DOMMatrix object.

context . setTransform(a, b, c, d, e, f)
Changes the current transformation matrix to the matrix given by the arguments as described below.

context . setTransform(transform)
Changes the current transformation matrix to the matrix represented by the passed DOMMatrix2DInit dictionary.

context . resetTransform()
Changes the current transformation matrix to the identity matrix.

The scale(x, y) method, when invoked, must run these steps:

If either of the arguments are infinite or NaN, then return.

Add the scaling transformation described by the arguments to the current transformation matrix. The x argument represents the scale factor in the horizontal direction and the y argument represents the scale factor in the vertical direction. The factors are multiples.

The rotate(angle) method, when invoked, must run these steps:

If angle is infinite or NaN, then return.

Add the rotation transformation described by the argument to the current transformation matrix. The angle argument represents a clockwise rotation angle expressed in radians.

The translate(x, y) method, when invoked, must run these steps:

If either of the arguments are infinite or NaN, then return.

Add the translation transformation described by the arguments to the current transformation matrix. The x argument represents the translation distance in the horizontal direction and the y argument represents the translation distance in the vertical direction. The arguments are in coordinate space units.

The transform(a, b, c, d, e, f) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Replace the current transformation matrix with the result of multiplying the current transformation matrix with the matrix described by:

a	c	e
b	d	f
0	0	1
The arguments a, b, c, d, e, and f are sometimes called m11, m12, m21, m22, dx, and dy or m11, m21, m12, m22, dx, and dy. Care ought to be taken in particular with the order of the second and third arguments (b and c) as their order varies from API to API and APIs sometimes use the notation m12/m21 and sometimes m21/m12 for those positions.

The getTransform() method, when invoked, must return a newly created DOMMatrix representing a copy of the current transformation matrix matrix of the context.

This returned object is not live, so updating it will not affect the current transformation matrix, and updating the current transformation matrix will not affect an already returned DOMMatrix.

The setTransform(a, b, c, d, e, f) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Reset the current transformation matrix to the identity matrix.

Invoke the transform(a, b, c, d, e, f) method with the same arguments.

The setTransform(transform) method, when invoked, must run these steps:

Let matrix be the result of creating a DOMMatrix from the 2D dictionary transform.

If one or more of matrix's m11 element, m12 element, m21 element, m22 element, m41 element, or m42 element are infinite or NaN, then return.

Reset the current transformation matrix to matrix.

The resetTransform() method, when invoked, must reset the current transformation matrix to the identity matrix.

4.12.5.1.8 Image sources for 2D rendering contexts
Some methods on the CanvasDrawImage and CanvasFillStrokeStyles interfaces take the union type CanvasImageSource as an argument.

This union type allows objects implementing any of the following interfaces to be used as image sources:

HTMLOrSVGImageElement (img or SVG image elements)
HTMLVideoElement (video elements)
HTMLCanvasElement (canvas elements)
ImageBitmap
Although not formally specified as such, SVG image elements are expected to be implemented nearly identical to img elements. That is, SVG image elements share the fundamental concepts and features of img elements.

The ImageBitmap interface can be created from a number of other image-representing types, including ImageData.

To check the usability of the image argument, where image is a CanvasImageSource object, run these steps:

Switch on image:

HTMLOrSVGImageElement
If image's current request's state is broken, then throw an "InvalidStateError" DOMException.

If image is not fully decodable, then return bad.

If image has an intrinsic width or intrinsic height (or both) equal to zero, then return bad.

HTMLVideoElement
If image's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return bad.

HTMLCanvasElement
OffscreenCanvas
If image has either a horizontal dimension or a vertical dimension equal to zero, then throw an "InvalidStateError" DOMException.

ImageBitmap
If image's [[Detached]] internal slot value is set to true, then throw an "InvalidStateError" DOMException.

Return good.

When a CanvasImageSource object represents an HTMLOrSVGImageElement, the element's image must be used as the source image.

Specifically, when a CanvasImageSource object represents an animated image in an HTMLOrSVGImageElement, the user agent must use the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation, when rendering the image for CanvasRenderingContext2D APIs.

When a CanvasImageSource object represents an HTMLVideoElement, then the frame at the current playback position when the method with the argument is invoked must be used as the source image when rendering the image for CanvasRenderingContext2D APIs, and the source image's dimensions must be the intrinsic width and intrinsic height of the media resource (i.e. after any aspect-ratio correction has been applied).

When a CanvasImageSource object represents an HTMLCanvasElement, the element's bitmap must be used as the source image.

When a CanvasImageSource object represents an element that is being rendered and that element has been resized, the original image data of the source image must be used, not the image as it is rendered (e.g. width and height attributes on the source element have no effect on how the object is interpreted when rendering the image for CanvasRenderingContext2D APIs).

When a CanvasImageSource object represents an ImageBitmap, the object's bitmap image data must be used as the source image.

An object image is not origin-clean if, switching on image:

HTMLOrSVGImageElement
HTMLVideoElement
image's origin is not same origin with entry settings object's origin.

HTMLCanvasElement
ImageBitMap
image's bitmap's origin-clean flag is false.

4.12.5.1.9 Fill and stroke styles
context . fillStyle [ = value ]
Returns the current style used for filling shapes.

Can be set, to change the fill style.

The style can be either a string containing a CSS color, or a CanvasGradient or CanvasPattern object. Invalid values are ignored.

context . strokeStyle [ = value ]
Returns the current style used for stroking shapes.

Can be set, to change the stroke style.

The style can be either a string containing a CSS color, or a CanvasGradient or CanvasPattern object. Invalid values are ignored.

Objects that implement the CanvasFillStrokeStyles interface have attributes and methods (defined in this section) that control how shapes are treated by the object.

The fillStyle attribute represents the color or style to use inside shapes, and the strokeStyle attribute represents the color or style to use for the lines around the shapes.

Both attributes can be either strings, CanvasGradients, or CanvasPatterns. On setting, strings must be parsed with this canvas element and the color assigned, and CanvasGradient and CanvasPattern objects must be assigned themselves. If parsing the value results in failure, then it must be ignored, and the attribute must retain its previous value. If the new value is a CanvasPattern object that is marked as not origin-clean, then the CanvasRenderingContext2D's origin-clean flag must be set to false.

When set to a CanvasPattern or CanvasGradient object, the assignment is live, meaning that changes made to the object after the assignment do affect subsequent stroking or filling of shapes.

On getting, if the value is a color, then the serialization of the color must be returned. Otherwise, if it is not a color but a CanvasGradient or CanvasPattern, then the respective object must be returned. (Such objects are opaque and therefore only useful for assigning to other attributes or for comparison to other gradients or patterns.)

The serialization of a color for a color value is a string, computed as follows: if it has alpha equal to 1.0, then the string is a lowercase six-digit hex value, prefixed with a "#" character (U+0023 NUMBER SIGN), with the first two digits representing the red component, the next two digits representing the green component, and the last two digits representing the blue component, the digits being ASCII lower hex digits. Otherwise, the color value has alpha less than 1.0, and the string is the color value in the CSS rgba() functional-notation format: the literal string "rgba" (U+0072 U+0067 U+0062 U+0061) followed by a U+0028 LEFT PARENTHESIS, a base-ten integer in the range 0-255 representing the red component (using ASCII digits in the shortest form possible), a literal U+002C COMMA and U+0020 SPACE, an integer for the green component, a comma and a space, an integer for the blue component, another comma and space, a U+0030 DIGIT ZERO, if the alpha value is greater than zero then a U+002E FULL STOP (representing the decimal point), if the alpha value is greater than zero then one or more ASCII digits representing the fractional part of the alpha, and finally a U+0029 RIGHT PARENTHESIS. User agents must express the fractional part of the alpha value, if any, with the level of precision necessary for the alpha value, when reparsed, to be interpreted as the same alpha value.

When the context is created, the fillStyle and strokeStyle attributes must initially have the string value #000000.

When the value is a color, it must not be affected by the transformation matrix when used to draw on bitmaps.

There are two types of gradients, linear gradients and radial gradients, both represented by objects implementing the opaque CanvasGradient interface.

Once a gradient has been created (see below), stops are placed along it to define how the colors are distributed along the gradient. The color of the gradient at each stop is the color specified for that stop. Between each such stop, the colors and the alpha component must be linearly interpolated over the RGBA space without premultiplying the alpha value to find the color to use at that offset. Before the first stop, the color must be the color of the first stop. After the last stop, the color must be the color of the last stop. When there are no stops, the gradient is transparent black.

gradient . addColorStop(offset, color)
Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset at one end of the gradient, 1.0 is the offset at the other end.

Throws an "IndexSizeError" DOMException if the offset is out of range. Throws a "SyntaxError" DOMException if the color cannot be parsed.

gradient = context . createLinearGradient(x0, y0, x1, y1)
Returns a CanvasGradient object that represents a linear gradient that paints along the line given by the coordinates represented by the arguments.

gradient = context . createRadialGradient(x0, y0, r0, x1, y1, r1)
Returns a CanvasGradient object that represents a radial gradient that paints along the cone given by the circles represented by the arguments.

If either of the radii are negative, throws an "IndexSizeError" DOMException exception.

The addColorStop(offset, color) method on the CanvasGradient, when invoked, must run these steps:

If the offset is less than 0 or greater than 1, then throw an "IndexSizeError" DOMException.

Let parsed color be the result of parsing color.

No element is passed to the parser because CanvasGradient objects are canvas-neutral — a CanvasGradient object created by one canvas can be used by another, and there is therefore no way to know which is the "element in question" at the time that the color is specified.

If parsed color is failure, throw a "SyntaxError" DOMException.

Place a new stop on the gradient, at offset offset relative to the whole gradient, and with the color parsed color.

If multiple stops are added at the same offset on a gradient, then they must be placed in the order added, with the first one closest to the start of the gradient, and each subsequent one infinitesimally further along towards the end point (in effect causing all but the first and last stop added at each point to be ignored).

The createLinearGradient(x0, y0, x1, y1) method takes four arguments that represent the start point (x0, y0) and end point (x1, y1) of the gradient. The method, when invoked, must return a linear CanvasGradient initialized with the specified line.

Linear gradients must be rendered such that all points on a line perpendicular to the line that crosses the start and end points have the color at the point where those two lines cross (with the colors coming from the interpolation and extrapolation described above). The points in the linear gradient must be transformed as described by the current transformation matrix when rendering.

If x0 = x1 and y0 = y1, then the linear gradient must paint nothing.

The createRadialGradient(x0, y0, r0, x1, y1, r1) method takes six arguments, the first three representing the start circle with origin (x0, y0) and radius r0, and the last three representing the end circle with origin (x1, y1) and radius r1. The values are in coordinate space units. If either of r0 or r1 are negative, then an "IndexSizeError" DOMException must be thrown. Otherwise, the method, when invoked, must return a radial CanvasGradient initialized with the two specified circles.

Radial gradients must be rendered by following these steps:

If x0 = x1 and y0 = y1 and r0 = r1, then the radial gradient must paint nothing. Return.

Let x(ω) = (x1-x0)ω + x0

Let y(ω) = (y1-y0)ω + y0

Let r(ω) = (r1-r0)ω + r0

Let the color at ω be the color at that position on the gradient (with the colors coming from the interpolation and extrapolation described above).

For all values of ω where r(ω) > 0, starting with the value of ω nearest to positive infinity and ending with the value of ω nearest to negative infinity, draw the circumference of the circle with radius r(ω) at position (x(ω), y(ω)), with the color at ω, but only painting on the parts of the bitmap that have not yet been painted on by earlier circles in this step for this rendering of the gradient.

This effectively creates a cone, touched by the two circles defined in the creation of the gradient, with the part of the cone before the start circle (0.0) using the color of the first offset, the part of the cone after the end circle (1.0) using the color of the last offset, and areas outside the cone untouched by the gradient (transparent black).

The resulting radial gradient must then be transformed as described by the current transformation matrix when rendering.

Gradients must be painted only where the relevant stroking or filling effects requires that they be drawn.

Patterns are represented by objects implementing the opaque CanvasPattern interface.

pattern = context . createPattern(image, repetition)
Returns a CanvasPattern object that uses the given image and repeats in the direction(s) given by the repetition argument.

The allowed values for repetition are repeat (both directions), repeat-x (horizontal only), repeat-y (vertical only), and no-repeat (neither). If the repetition argument is empty, the value repeat is used.

If the image isn't yet fully decoded, then nothing is drawn. If the image is a canvas with no data, throws an "InvalidStateError" DOMException.

pattern . setTransform(transform)
Sets the transformation matrix that will be used when rendering the pattern during a fill or stroke painting operation.

The createPattern(image, repetition) method, when invoked, must run these steps:

Let usability be the result of checking the usability of image.

If result is bad, then return null.

Assert: result is good.

If repetition is the empty string, then set it to "repeat".

If repetition is not a case-sensitive match for one of "repeat", "repeat-x", "repeat-y", or "no-repeat", then throw a "SyntaxError" DOMException.

Let pattern be a new CanvasPattern object with the image image and the repetition behavior given by repetition.

If image is not origin-clean, then mark pattern as not origin-clean.

Return pattern.

Modifying the image used when creating a CanvasPattern object after calling the createPattern() method must not affect the pattern(s) rendered by the CanvasPattern object.

Patterns have a transformation matrix, which controls how the pattern is used when it is painted. Initially, a pattern's transformation matrix must be the identity matrix.

The setTransform(transform) method, when invoked, must run these steps:

Let matrix be the result of creating a DOMMatrix from the 2D dictionary transform.

If one or more of matrix's m11 element, m12 element, m21 element, m22 element, m41 element, or m42 element are infinite or NaN, then return.

Reset the pattern's transformation matrix to matrix.

When a pattern is to be rendered within an area, the user agent must run the following steps to determine what is rendered:

Create an infinite transparent black bitmap.

Place a copy of the image on the bitmap, anchored such that its top left corner is at the origin of the coordinate space, with one coordinate space unit per CSS pixel of the image, then place repeated copies of this image horizontally to the left and right, if the repetition behavior is "repeat-x", or vertically up and down, if the repetition behavior is "repeat-y", or in all four directions all over the bitmap, if the repetition behavior is "repeat".

If the original image data is a bitmap image, then the value painted at a point in the area of the repetitions is computed by filtering the original image data. When scaling up, if the imageSmoothingEnabled attribute is set to false, then the image must be rendered using nearest-neighbor interpolation. Otherwise, the user agent may use any filtering algorithm (for example bilinear interpolation or nearest-neighbor). User agents which support multiple filtering algorithms may use the value of the imageSmoothingQuality attribute to guide the choice of filtering algorithm. When such a filtering algorithm requires a pixel value from outside the original image data, it must instead use the value from wrapping the pixel's coordinates to the original image's dimensions. (That is, the filter uses 'repeat' behavior, regardless of the value of the pattern's repetition behavior.)

Transform the resulting bitmap according to the pattern's transformation matrix.

Transform the resulting bitmap again, this time according to the current transformation matrix.

Replace any part of the image outside the area in which the pattern is to be rendered with transparent black.

The resulting bitmap is what is to be rendered, with the same origin and same scale.

If a radial gradient or repeated pattern is used when the transformation matrix is singular, then the resulting style must be transparent black (otherwise the gradient or pattern would be collapsed to a point or line, leaving the other pixels undefined). Linear gradients and solid colors always define all points even with singular transformation matrices.

4.12.5.1.10 Drawing rectangles to the bitmap
Objects that implement the CanvasRect interface provide the following methods for immediately drawing rectangles to the bitmap. The methods each take four arguments; the first two give the x and y coordinates of the top left of the rectangle, and the second two give the width w and height h of the rectangle, respectively.

The current transformation matrix must be applied to the following four coordinates, which form the path that must then be closed to get the specified rectangle: (x, y), (x+w, y), (x+w, y+h), (x, y+h).

Shapes are painted without affecting the current default path, and are subject to the clipping region, and, with the exception of clearRect(), also shadow effects, global alpha, and global composition operators.

context . clearRect(x, y, w, h)
Clears all pixels on the bitmap in the given rectangle to transparent black.

context . fillRect(x, y, w, h)
Paints the given rectangle onto the bitmap, using the current fill style.

context . strokeRect(x, y, w, h)
Paints the box that outlines the given rectangle onto the bitmap, using the current stroke style.

The clearRect(x, y, w, h) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Let pixels be the set of pixels in the specified rectangle that also intersect the current clipping region.

Clear the pixels in pixels to a transparent black, erasing any previous image.

If either height or width are zero, this method has no effect, since the set of pixels would be empty.

The fillRect(x, y, w, h) method, when invoked, must must run these steps:

If any of the arguments are infinite or NaN, then return.

If either w or h are zero, then return.

Paint the specified rectangular area using the fillStyle.

The strokeRect(x, y, w, h) method, when invoked, must run these steps:

If any of the arguments are infinite or NaN, then return.

Take the result of tracing the path described below, using the CanvasPathDrawingStyles interface's line styles, and fill it with the strokeStyle.

If both w and h are zero, the path has a single subpath with just one point (x, y), and no lines, and this method thus has no effect (the trace a path algorithm returns an empty path in that case).

If just one of either w or h is zero, then the path has a single subpath consisting of two points, with coordinates (x, y) and (x+w, y+h), in that order, connected by a single straight line.

Otherwise, the path has a single subpath consisting of four points, with coordinates (x, y), (x+w, y), (x+w, y+h), and (x, y+h), connected to each other in that order by straight lines.

4.12.5.1.11 Drawing text to the bitmap

Support: canvas-text
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	3.5+
Samsung Internet	4+
IE	9+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.1+
Opera	10.5+

Source: caniuse.com

context . fillText(text, x, y [, maxWidth ] )
context . strokeText(text, x, y [, maxWidth ] )
Fills or strokes (respectively) the given text at the given position. If a maximum width is provided, the text will be scaled to fit that width if necessary.

metrics = context . measureText(text)
Returns a TextMetrics object with the metrics of the given text in the current font.

metrics . width
metrics . actualBoundingBoxLeft
metrics . actualBoundingBoxRight
metrics . fontBoundingBoxAscent
metrics . fontBoundingBoxDescent
metrics . actualBoundingBoxAscent
metrics . actualBoundingBoxDescent
metrics . emHeightAscent
metrics . emHeightDescent
metrics . hangingBaseline
metrics . alphabeticBaseline
metrics . ideographicBaseline
Returns the measurement described below.

Objects that implement the CanvasText interface provide the following methods for rendering text.

The fillText() and strokeText() methods take three or four arguments, text, x, y, and optionally maxWidth, and render the given text at the given (x, y) coordinates ensuring that the text isn't wider than maxWidth if specified, using the current font, textAlign, and textBaseline values. Specifically, when the methods are invoked, the user agent must run these steps:

If any of the arguments are infinite or NaN, then return.

Run the text preparation algorithm, passing it text, the object implementing the CanvasText interface, and, if the maxWidth argument was provided, that argument. Let glyphs be the result.

Move all the shapes in glyphs to the right by x CSS pixels and down by y CSS pixels.

Paint the shapes given in glyphs, as transformed by the current transformation matrix, with each CSS pixel in the coordinate space of glyphs mapped to one coordinate space unit.

For fillText(), fillStyle must be applied to the shapes and strokeStyle must be ignored. For strokeText(), the reverse holds: strokeStyle must be applied to the result of tracing the shapes using the object implementing the CanvasText interface for the line styles, and fillStyle must be ignored.

These shapes are painted without affecting the current path, and are subject to shadow effects, global alpha, the clipping region, and global composition operators.

The measureText() method takes one argument, text. When the method is invoked, the user agent must run the text preparation algorithm, passing it text and the object implementing the CanvasText interface, and then using the returned inline box must create a new TextMetrics object with its attributes set as described in the following list. If doing these measurements requires using a font that has an origin that is not the same as that of the Document object that owns the canvas element (even if "using a font" means just checking if that font has a particular glyph in it before falling back to another font), then the method, when invoked, must throw a "SecurityError" DOMException. Otherwise, it must return the new TextMetrics object. [CSS]
width attribute
The width of that inline box, in CSS pixels. (The text's advance width.)

actualBoundingBoxLeft attribute
The distance parallel to the baseline from the alignment point given by the textAlign attribute to the left side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going left from the given alignment point.

The sum of this value and the next (actualBoundingBoxRight) can be wider than the width of the inline box (width), in particular with slanted fonts where characters overhang their advance width.

actualBoundingBoxRight attribute
The distance parallel to the baseline from the alignment point given by the textAlign attribute to the right side of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going right from the given alignment point.

fontBoundingBoxAscent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the top of the highest bounding rectangle of all the fonts used to render the text, in CSS pixels; positive numbers indicating a distance going up from the given baseline.

This value and the next are useful when rendering a background that have to have a consistent height even if the exact text being rendered changes. The actualBoundingBoxAscent attribute (and its corresponding attribute for the descent) are useful when drawing a bounding box around specific text.

fontBoundingBoxDescent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the bottom of the lowest bounding rectangle of all the fonts used to render the text, in CSS pixels; positive numbers indicating a distance going down from the given baseline.

actualBoundingBoxAscent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the top of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going up from the given baseline.

This number can vary greatly based on the input text, even if the first font specified covers all the characters in the input. For example, the actualBoundingBoxAscent of a lowercase "o" from an alphabetic baseline would be less than that of an uppercase "F". The value can easily be negative; for example, the distance from the top of the em box (textBaseline value "top") to the top of the bounding rectangle when the given text is just a single comma "," would likely (unless the font is quite unusual) be negative.

actualBoundingBoxDescent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the bottom of the bounding rectangle of the given text, in CSS pixels; positive numbers indicating a distance going down from the given baseline.

emHeightAscent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the highest top of the em squares in the line box, in CSS pixels; positive numbers indicating that the given baseline is below the top of that em square (so this value will usually be positive). Zero if the given baseline is the top of that em square; half the font size if the given baseline is the middle of that em square.

emHeightDescent attribute
The distance from the horizontal line indicated by the textBaseline attribute to the lowest bottom of the em squares in the line box, in CSS pixels; positive numbers indicating that the given baseline is below the bottom of that em square (so this value will usually be negative). (Zero if the given baseline is the bottom of that em square.)

hangingBaseline attribute
The distance from the horizontal line indicated by the textBaseline attribute to the hanging baseline of the line box, in CSS pixels; positive numbers indicating that the given baseline is below the hanging baseline. (Zero if the given baseline is the hanging baseline.)

alphabeticBaseline attribute
The distance from the horizontal line indicated by the textBaseline attribute to the alphabetic baseline of the line box, in CSS pixels; positive numbers indicating that the given baseline is below the alphabetic baseline. (Zero if the given baseline is the alphabetic baseline.)

ideographicBaseline attribute
The distance from the horizontal line indicated by the textBaseline attribute to the ideographic baseline of the line box, in CSS pixels; positive numbers indicating that the given baseline is below the ideographic baseline. (Zero if the given baseline is the ideographic baseline.)

Glyphs rendered using fillText() and strokeText() can spill out of the box given by the font size (the em square size) and the width returned by measureText() (the text width). Authors are encouraged to use the bounding box values described above if this is an issue.

A future version of the 2D context API might provide a way to render fragments of documents, rendered using CSS, straight to the canvas. This would be provided in preference to a dedicated way of doing multiline layout.

4.12.5.1.12 Drawing paths to the canvas
Objects that implement the CanvasDrawPath interface have a current default path. There is only one current default path, it is not part of the drawing state. The current default path is a path, as described above.

context . beginPath()
Resets the current default path.

context . fill( [ fillRule ] )
context . fill(path [, fillRule ] )
Fills the subpaths of the current default path or the given path with the current fill style, obeying the given fill rule.

context . stroke()
context . stroke(path)
Strokes the subpaths of the current default path or the given path with the current stroke style.

context . clip( [ fillRule ] )
context . clip(path [, fillRule ] )
Further constrains the clipping region to the current default path or the given path, using the given fill rule to determine what points are in the path.

context . resetClip()
Unconstrains the clipping region.

context . isPointInPath(x, y [, fillRule ] )
context . isPointInPath(path, x, y [, fillRule ] )
Returns true if the given point is in the current default path or the given path, using the given fill rule to determine what points are in the path.

context . isPointInStroke(x, y)
context . isPointInStroke(path, x, y)
Returns true if the given point would be in the region covered by the stroke of the current default path or the given path, given the current stroke style.

The beginPath() method, when invoked, must empty the list of subpaths in the context's current default path so that the it once again has zero subpaths.

Where the following method definitions use the term intended path, it means the Path2D argument, if one was provided, or the current default path otherwise.

When the intended path is a Path2D object, the coordinates and lines of its subpaths must be transformed according to the current transformation matrix on the object implementing the CanvasTransform interface when used by these methods (without affecting the Path2D object itself). When the intended path is the current default path, it is not affected by the transform. (This is because transformations already affect the current default path when it is constructed, so applying it when it is painted as well would result in a double transformation.)

The fill() method, when invoked, must fill all the subpaths of the intended path, using fillStyle, and using the fill rule indicated by the fillRule argument. Open subpaths must be implicitly closed when being filled (without affecting the actual subpaths).


Spec bugs: 28217

The stroke() method, when invoked, must trace the intended path, using this CanvasPathDrawingStyles object for the line styles, and then fill the resulting path using the strokeStyle attribute, using the nonzero winding rule.

As a result of how the algorithm to trace a path is defined, overlapping parts of the paths in one stroke operation are treated as if their union was what was painted.

The stroke style is affected by the transformation during painting, even if the intended path is the current default path.

Paths, when filled or stroked, must be painted without affecting the current default path or any Path2D objects, and must be subject to shadow effects, global alpha, the clipping region, and global composition operators. (The effect of transformations is described above and varies based on which path is being used.)

The clip() method, when invoked, must create a new clipping region by calculating the intersection of the current clipping region and the area described by the intended path, using the fill rule indicated by the fillRule argument. Open subpaths must be implicitly closed when computing the clipping region, without affecting the actual subpaths. The new clipping region replaces the current clipping region.

When the context is initialized, the clipping region must be set to the largest infinite surface (i.e. by default, no clipping occurs).

The resetClip() method, when invoked, must create a new clipping region that is the largest infinite surface. The new clipping region replaces the current clipping region.

The isPointInPath() method, when invoked, must return true if the point given by the x and y coordinates passed to the method, when treated as coordinates in the canvas coordinate space unaffected by the current transformation, is inside the intended path as determined by the fill rule indicated by the fillRule argument; and must return false otherwise. Open subpaths must be implicitly closed when computing the area inside the path, without affecting the actual subpaths. Points on the path itself must be considered to be inside the path. If either of the arguments are infinite or NaN, then the method must return false.

The isPointInStroke() method, when invoked, must return true if the point given by the x and y coordinates passed to the method, when treated as coordinates in the canvas coordinate space unaffected by the current transformation, is inside the path that results from tracing the intended path, using the nonzero winding rule, and using the CanvasPathDrawingStyles interface for the line styles; and must return false otherwise. Points on the resulting path must be considered to be inside the path. If either of the arguments are infinite or NaN, then the method must return false.

This canvas element has a couple of checkboxes. The path-related commands are highlighted:

<canvas height=400 width=750>
 <label><input type=checkbox id=showA> Show As</label>
 <label><input type=checkbox id=showB> Show Bs</label>
 <!-- ... -->
</canvas>
<script>
 function drawCheckbox(context, element, x, y, paint) {
   context.save();
   context.font = '10px sans-serif';
   context.textAlign = 'left';
   context.textBaseline = 'middle';
   var metrics = context.measureText(element.labels[0].textContent);
   if (paint) {
     context.beginPath();
     context.strokeStyle = 'black';
     context.rect(x-5, y-5, 10, 10);
     context.stroke();
     if (element.checked) {
       context.fillStyle = 'black';
       context.fill();
     }
     context.fillText(element.labels[0].textContent, x+5, y);
   }
   context.beginPath();
   context.rect(x-7, y-7, 12 + metrics.width+2, 14);

   context.drawFocusIfNeeded(element);
   context.restore();
 }
 function drawBase() { /* ... */ }
 function drawAs() { /* ... */ }
 function drawBs() { /* ... */ }
 function redraw() {
   var canvas = document.getElementsByTagName('canvas')[0];
   var context = canvas.getContext('2d');
   context.clearRect(0, 0, canvas.width, canvas.height);
   drawCheckbox(context, document.getElementById('showA'), 20, 40, true);
   drawCheckbox(context, document.getElementById('showB'), 20, 60, true);
   drawBase();
   if (document.getElementById('showA').checked)
     drawAs();
   if (document.getElementById('showB').checked)
     drawBs();
 }
 function processClick(event) {
   var canvas = document.getElementsByTagName('canvas')[0];
   var context = canvas.getContext('2d');
   var x = event.clientX;
   var y = event.clientY;
   var node = event.target;
   while (node) {
     x -= node.offsetLeft - node.scrollLeft;
     y -= node.offsetTop - node.scrollTop;
     node = node.offsetParent;
   }
   drawCheckbox(context, document.getElementById('showA'), 20, 40, false);
   if (context.isPointInPath(x, y))
     document.getElementById('showA').checked = !(document.getElementById('showA').checked);
   drawCheckbox(context, document.getElementById('showB'), 20, 60, false);
   if (context.isPointInPath(x, y))
     document.getElementById('showB').checked = !(document.getElementById('showB').checked);
   redraw();
 }
 document.getElementsByTagName('canvas')[0].addEventListener('focus', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('blur', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('change', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('click', processClick, false);
 redraw();
</script>
4.12.5.1.13 Drawing focus rings and scrolling paths into view
context . drawFocusIfNeeded(element)
context . drawFocusIfNeeded(path, element)
If the given element is focused, draws a focus ring around the current default path or the given path, following the platform conventions for focus rings.

context . scrollPathIntoView()
context . scrollPathIntoView(path)
Scrolls the current default path or the given path into view. This is especially useful on devices with small screens, where the whole canvas might not be visible at once.

Objects that implement the CanvasUserInterface interface provide the following methods to control drawing focus rings and scrolling paths into view.
The drawFocusIfNeeded(element) method, when invoked, must run these steps:

If element is not focused or is not a descendant of the element with whose context the method is associated, then return.

Draw a focus ring of the appropriate style along the intended path, following platform conventions.

Some platforms only draw focus rings around elements that have been focused from the keyboard, and not those focused from the mouse. Other platforms simply don't draw focus rings around some elements at all unless relevant accessibility features are enabled. This API is intended to follow these conventions. User agents that implement distinctions based on the manner in which the element was focused are encouraged to classify focus driven by the focus() method based on the kind of user interaction event from which the call was triggered (if any).

The focus ring should not be subject to the shadow effects, the global alpha, the global composition operators, or any of the members in the CanvasFillStrokeStyles, CanvasPathDrawingStyles, CanvasTextDrawingStyles interfaces, but should be subject to the clipping region. (The effect of transformations is described above and varies based on which path is being used.)

Inform the user that the focus is at the location given by the intended path. User agents may wait until the next time the event loop reaches its update the rendering step to optionally inform the user.

User agents should not implicitly close open subpaths in the intended path when drawing the focus ring.

This might be a moot point, however. For example, if the focus ring is drawn as an axis-aligned bounding rectangle around the points in the intended path, then whether the subpaths are closed or not has no effect. This specification intentionally does not specify precisely how focus rings are to be drawn: user agents are expected to honor their platform's native conventions.

The scrollPathIntoView() method, when invoked, must run these steps:

Let the specified rectangle be the rectangle of the bounding box of the intended path.

Let notional child be a hypothetical element that is a rendered child of the canvas element whose dimensions are those of the specified rectangle.

Scroll notional child into view with the align to top flag set.

Optionally, inform the user that the caret or selection (or both) cover the specified rectangle of the canvas. The user agent may wait until the next time the event loop reaches its update the rendering step to optionally inform the user.

"Inform the user", as used in this section, does not imply any persistent state change. It could mean, for instance, calling a system accessibility API to notify assistive technologies such as magnification tools so that the user's magnifier moves to the given area of the canvas. However, it does not associate the path with the element, or provide a region for tactile feedback, etc.

4.12.5.1.14 Drawing images
Objects that implement the CanvasDrawImage interface have the drawImage method to draw images.

This method can be invoked with three different sets of arguments:

drawImage(image, dx, dy)
drawImage(image, dx, dy, dw, dh)
drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)
context . drawImage(image, dx, dy)
context . drawImage(image, dx, dy, dw, dh)
context . drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)
Draws the given image onto the canvas. The arguments are interpreted as follows:



If the image isn't yet fully decoded, then nothing is drawn. If the image is a canvas with no data, throws an "InvalidStateError" DOMException.

When the drawImage() method is invoked, the user agent must run these steps:

If any of the arguments are infinite or NaN, then return.

Let usability be the result of checking the usability of image.

If usability is bad, then return (without drawing anything).

Establish the source and destination rectangles as follows:

If not specified, the dw and dh arguments must default to the values of sw and sh, interpreted such that one CSS pixel in the image is treated as one unit in the output bitmap's coordinate space. If the sx, sy, sw, and sh arguments are omitted, then they must default to 0, 0, the image's intrinsic width in image pixels, and the image's intrinsic height in image pixels, respectively. If the image has no intrinsic dimensions, then the concrete object size must be used instead, as determined using the CSS "Concrete Object Size Resolution" algorithm, with the specified size having neither a definite width nor height, nor any additional constraints, the object's intrinsic properties being those of the image argument, and the default object size being the size of the output bitmap. [CSSIMAGES]

The source rectangle is the rectangle whose corners are the four points (sx, sy), (sx+sw, sy), (sx+sw, sy+sh), (sx, sy+sh).

The destination rectangle is the rectangle whose corners are the four points (dx, dy), (dx+dw, dy), (dx+dw, dy+dh), (dx, dy+dh).

When the source rectangle is outside the source image, the source rectangle must be clipped to the source image and the destination rectangle must be clipped in the same proportion.

When the destination rectangle is outside the destination image (the output bitmap), the pixels that land outside the output bitmap are discarded, as if the destination was an infinite canvas whose rendering was clipped to the dimensions of the output bitmap.

If one of the sw or sh arguments is zero, then return. Nothing is painted.

Paint the region of the image argument specified by the source rectangle on the region of the rendering context's output bitmap specified by the destination rectangle, after applying the current transformation matrix to the destination rectangle.

The image data must be processed in the original direction, even if the dimensions given are negative.

When scaling up, if the imageSmoothingEnabled attribute is set to true, the user agent should attempt to apply a smoothing algorithm to the image data when it is scaled. User agents which support multiple filtering algorithms may use the value of the imageSmoothingQuality attribute to guide the choice of filtering algorithm when the imageSmoothingEnabled attribute is set to true. Otherwise, the image must be rendered using nearest-neighbor interpolation.

This specification does not define the precise algorithm to use when scaling an image down, or when scaling an image up when the imageSmoothingEnabled attribute is set to true.

When a canvas element is drawn onto itself, the drawing model requires the source to be copied before the image is drawn, so it is possible to copy parts of a canvas element onto overlapping parts of itself.

If the original image data is a bitmap image, then the value painted at a point in the destination rectangle is computed by filtering the original image data. The user agent may use any filtering algorithm (for example bilinear interpolation or nearest-neighbor). When the filtering algorithm requires a pixel value from outside the original image data, it must instead use the value from the nearest edge pixel. (That is, the filter uses 'clamp-to-edge' behavior.) When the filtering algorithm requires a pixel value from outside the source rectangle but inside the original image data, then the value from the original image data must be used.

Thus, scaling an image in parts or in whole will have the same effect. This does mean that when sprites coming from a single sprite sheet are to be scaled, adjacent images in the sprite sheet can interfere. This can be avoided by ensuring each sprite in the sheet is surrounded by a border of transparent black, or by copying sprites to be scaled into temporary canvas elements and drawing the scaled sprites from there.

Images are painted without affecting the current path, and are subject to shadow effects, global alpha, the clipping region, and global composition operators.

If image is not origin-clean, then set the CanvasRenderingContext2D's origin-clean flag to false.

4.12.5.1.15 Pixel manipulation
imagedata = new ImageData(sw, sh)
imagedata = context . createImageData(sw, sh)
Returns an ImageData object with the given dimensions. All the pixels in the returned object are transparent black.

Throws an "IndexSizeError" DOMException if either of the width or height arguments are zero.

imagedata = context . createImageData(imagedata)
Returns an ImageData object with the same dimensions as the argument. All the pixels in the returned object are transparent black.

imagedata = new ImageData(data, sw [, sh ] )
Returns an ImageData object using the data provided in the Uint8ClampedArray argument, interpreted using the given dimensions.

As each pixel in the data is represented by four numbers, the length of the data needs to be a multiple of four times the given width. If the height is provided as well, then the length needs to be exactly the width times the height times 4.

Throws an "IndexSizeError" DOMException if the given data and dimensions can't be interpreted consistently, or if either dimension is zero.

imagedata = context . getImageData(sx, sy, sw, sh)
Returns an ImageData object containing the image data for the given rectangle of the bitmap.

Throws an "IndexSizeError" DOMException if the either of the width or height arguments are zero.

imagedata . width
imagedata . height
Returns the actual dimensions of the data in the ImageData object, in pixels.

imagedata . data
Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255.

context . putImageData(imagedata, dx, dy [, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] )
Paints the data from the given ImageData object onto the bitmap. If a dirty rectangle is provided, only the pixels from that rectangle are painted.

The globalAlpha and globalCompositeOperation attributes, as well as the shadow attributes, are ignored for the purposes of this method call; pixels in the canvas are replaced wholesale, with no composition, alpha blending, no shadows, etc.

Throws an "InvalidStateError" DOMException if the imagedata object's data attribute value's [[ViewedArrayBuffer]] internal slot is detached.

Objects that implement the CanvasImageData interface provide the following methods for reading and writing pixel data to the bitmap.

The ImageData() constructors and the createImageData() methods are used to instantiate new ImageData objects.

When the ImageData() constructor is invoked with two numeric arguments sw and sh, it must run these steps:

If one or both of sw and sh are zero, then throw an "IndexSizeError" DOMException.

Create an ImageData object with parameter pixelsPerRow set to sw, and rows set to sh.

Initialize the image data of the newly created ImageData object to transparent black.

Return the newly created ImageData object.

When the ImageData() constructor is invoked with its first argument being an Uint8ClampedArray source and its second and optional third arguments being numeric arguments sw and sh, it must run these steps:

Let length be the number of bytes in source.

If length is not a nonzero integral multiple of four, then throw an "InvalidStateError" DOMException.

Let length be length divided by four.

If length is not an integral multiple of sw, then throw an "IndexSizeError" DOMException.

At this step, the length is guaranteed to be greater than zero (otherwise the second step above would have aborted the steps), so if sw is zero, this step will throw the exception and return.

Let height be length divided by sw.

If the sh argument was not omitted, and its value is not equal to height, then throw an "IndexSizeError" DOMException.

Create an ImageData object, with parameter pixelsPerRow set to sw, rows set to sh, and using source. Return the newly created ImageData object.

The resulting object's data is not a copy of source, it's the actual Uint8ClampedArray object passed as the first argument to the constructor.

When the createImageData() method is invoked with two numeric arguments sw and sh, it must create an ImageData object, with parameter pixelsPerRow set to the absolute magnitude of sw, and parameter rows set to the absolute magnitude of sh. Initialize the image data of the new ImageData object to transparent black. If both sw and sh are nonzero, then return the new ImageData object. If one or both of sw and sh are zero, then throw an "IndexSizeError" DOMException instead.

When the createImageData() method is invoked with a single imagedata argument, it must create an ImageData object, with parameter pixelsPerRow set to the value of the width attribute of the ImageData object passed as the argument, and the rows parameter set to the value of the height attribute. Initialize the image data of the new ImageData object to transparent black. Return the newly created ImageData object.

The getImageData(sx, sy, sw, sh) method, when invoked, must, if either the sw or sh arguments are zero, throw an "IndexSizeError" DOMException; otherwise, if the CanvasRenderingContext2D's origin-clean flag is set to false, it must throw a "SecurityError" DOMException; otherwise, it must create an ImageData object, with parameter pixelsPerRow set to sw, and parameter rows set to sh. Set the pixel values of the image data of the newly created ImageData object to represent the output bitmap for the area of that bitmap denoted by the rectangle whose corners are the four points (sx, sy), (sx+sw, sy), (sx+sw, sy+sh), (sx, sy+sh), in the bitmap's coordinate space units. Pixels outside the output bitmap must be set to transparent black. Pixel values must not be premultiplied by alpha.

When the user agent is required to create an ImageData object, given a positive integer number of rows rows, a positive integer number of pixels per row pixelsPerRow, and an optional Uint8ClampedArray source, it must run these steps:

Let imageData be a new uninitialized ImageData object.

If source is specified, then assign the data attribute of imageData to source.

If source is not specified, then initialize the data attribute of imageData to a new Uint8ClampedArray object. The Uint8ClampedArray object must use a new Canvas Pixel ArrayBuffer for its storage, and must have a zero start offset and a length equal to the length of its storage, in bytes. The Canvas Pixel ArrayBuffer must have the correct size to store rows × pixelsPerRow pixels.

If the Canvas Pixel ArrayBuffer cannot be allocated, then rethrow the RangeError thrown by JavaScript, and return.

Initialize the width attribute of imageData to pixelsPerRow.

Initialize the height attribute of imageData to rows.

Return imageData.

ImageData objects are serializable objects. Their serialization steps, given value and serialized, are:

Set serialized.[[Data]] to the sub-serialization of the value of value's data attribute.

Set serialized.[[Width]] to the value of value's width attribute.

Set serialized.[[Height]] to the value of value's height attribute.

Their deserialization steps, given serialized and value, are:

Initialize value's data attribute to the sub-deserialization of serialized.[[Data]].

Initialize value's width attribute to serialized.[[Width]].

Initialize value's height attribute to serialized.[[Height]].

A Canvas Pixel ArrayBuffer is an ArrayBuffer whose data is represented in left-to-right order, row by row top to bottom, starting with the top left, with each pixel's red, green, blue, and alpha components being given in that order for each pixel. Each component of each pixel represented in this array must be in the range 0..255, representing the 8 bit value for that component. The components must be assigned consecutive indices starting with 0 for the top left pixel's red component.

The putImageData() method writes data from ImageData structures back to the rendering context's output bitmap. Its arguments are: imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, and dirtyHeight.

When the last four arguments to this method are omitted, they must be assumed to have the values 0, 0, the width member of the imagedata structure, and the height member of the imagedata structure, respectively.

The method, when invoked, must act as follows:

Let buffer be imagedata's data attribute value's [[ViewedArrayBuffer]] internal slot.

If IsDetachedBuffer(buffer) is true, then throw an "InvalidStateError" DOMException.

If dirtyWidth is negative, then let dirtyX be dirtyX+dirtyWidth, and let dirtyWidth be equal to the absolute magnitude of dirtyWidth.

If dirtyHeight is negative, then let dirtyY be dirtyY+dirtyHeight, and let dirtyHeight be equal to the absolute magnitude of dirtyHeight.

If dirtyX is negative, then let dirtyWidth be dirtyWidth+dirtyX, and let dirtyX be zero.

If dirtyY is negative, then let dirtyHeight be dirtyHeight+dirtyY, and let dirtyY be zero.

If dirtyX+dirtyWidth is greater than the width attribute of the imagedata argument, then let dirtyWidth be the value of that width attribute, minus the value of dirtyX.

If dirtyY+dirtyHeight is greater than the height attribute of the imagedata argument, then let dirtyHeight be the value of that height attribute, minus the value of dirtyY.

If, after those changes, either dirtyWidth or dirtyHeight are negative or zero, then return without affecting any bitmaps.

For all integer values of x and y where dirtyX ≤ x < dirtyX+dirtyWidth and dirtyY ≤ y < dirtyY+dirtyHeight, copy the four channels of the pixel with coordinate (x, y) in the imagedata data structure's Canvas Pixel ArrayBuffer to the pixel with coordinate (dx+x, dy+y) in the rendering context's output bitmap.

Due to the lossy nature of converting to and from premultiplied alpha color values, pixels that have just been set using putImageData() might be returned to an equivalent getImageData() as different values.

The current path, transformation matrix, shadow attributes, global alpha, the clipping region, and global composition operator must not affect the methods described in this section.

In the following example, the script generates an ImageData object so that it can draw onto it.

// canvas is a reference to a <canvas> element
var context = canvas.getContext('2d');

// create a blank slate
var data = context.createImageData(canvas.width, canvas.height);

// create some plasma
FillPlasma(data, 'green'); // green plasma

// add a cloud to the plasma
AddCloud(data, data.width/2, data.height/2); // put a cloud in the middle

// paint the plasma+cloud on the canvas
context.putImageData(data, 0, 0);

// support methods
function FillPlasma(data, color) { ... }
function AddCloud(data, x, y) { ... }
Here is an example of using getImageData() and putImageData() to implement an edge detection filter.

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Edge detection demo</title>
  <script>
   var image = new Image();
   function init() {
     image.onload = demo;
     image.src = "image.jpeg";
   }
   function demo() {
     var canvas = document.getElementsByTagName('canvas')[0];
     var context = canvas.getContext('2d');

     // draw the image onto the canvas
     context.drawImage(image, 0, 0);

     // get the image data to manipulate
     var input = context.getImageData(0, 0, canvas.width, canvas.height);

     // get an empty slate to put the data into
     var output = context.createImageData(canvas.width, canvas.height);

     // alias some variables for convenience
     // In this case input.width and input.height
     // match canvas.width and canvas.height
     // but we'll use the former to keep the code generic.
     var w = input.width, h = input.height;
     var inputData = input.data;
     var outputData = output.data;

     // edge detection
     for (var y = 1; y < h-1; y += 1) {
       for (var x = 1; x < w-1; x += 1) {
         for (var c = 0; c < 3; c += 1) {
           var i = (y*w + x)*4 + c;
           outputData[i] = 127 + -inputData[i - w*4 - 4] -   inputData[i - w*4] - inputData[i - w*4 + 4] +
                                 -inputData[i - 4]       + 8*inputData[i]       - inputData[i + 4] +
                                 -inputData[i + w*4 - 4] -   inputData[i + w*4] - inputData[i + w*4 + 4];
         }
         outputData[(y*w + x)*4 + 3] = 255; // alpha
       }
     }

     // put the image data back after manipulation
     context.putImageData(output, 0, 0);
   }
  </script>
 </head>
 <body onload="init()">
  <canvas></canvas>
 </body>
</html>
4.12.5.1.16 Compositing
context . globalAlpha [ = value ]
Returns the current alpha value applied to rendering operations.

Can be set, to change the alpha value. Values outside of the range 0.0 .. 1.0 are ignored.

context . globalCompositeOperation [ = value ]
Returns the current composition operation, from the values defined in the Compositing and Blending specification. [COMPOSITE].

Can be set, to change the composition operation. Unknown values are ignored.

All drawing operations on an object which implements the CanvasCompositing interface are affected by the global compositing attributes, globalAlpha and globalCompositeOperation.

The globalAlpha attribute gives an alpha value that is applied to shapes and images before they are composited onto the output bitmap. The value must be in the range from 0.0 (fully transparent) to 1.0 (no additional transparency). If an attempt is made to set the attribute to a value outside this range, including Infinity and Not-a-Number (NaN) values, then the attribute must retain its previous value. When the context is created, the globalAlpha attribute must initially have the value 1.0.

The globalCompositeOperation attribute sets the current composition operator, which controls how shapes and images are drawn onto the output bitmap, once they have had globalAlpha and the current transformation matrix applied. The possible values are those defined in the Compositing and Blending specification, and include the values source-over and copy. [COMPOSITE]


Spec bugs: 27313

These values are all case-sensitive — they must be used exactly as defined. User agents must not recognize values that are not a case-sensitive match for one of the values given in the Compositing and Blending specification. [COMPOSITE]

On setting, if the user agent does not recognize the specified value, it must be ignored, leaving the value of globalCompositeOperation unaffected. Otherwise, the attribute must be set to the given new value.

When the context is created, the globalCompositeOperation attribute must initially have the value source-over.

4.12.5.1.17 Image smoothing
context . imageSmoothingEnabled [ = value ]
Returns whether pattern fills and the drawImage() method will attempt to smooth images if their pixels don't line up exactly with the display, when scaling images up.

Can be set, to change whether images are smoothed (true) or not (false).

context . imageSmoothingQuality [ = value ]
Returns the current image-smoothing-quality preference.

Can be set, to change the preferred quality of image smoothing. The possible values are "low", "medium" and "high". Unknown values are ignored.

Objects that implement the CanvasImageSmoothing interface have attributes that control how image smoothing is performed.

The imageSmoothingEnabled attribute, on getting, must return the last value it was set to. On setting, it must be set to the new value. When the object implementing the CanvasImageSmoothing interface is created, the attribute must be set to true.

The imageSmoothingQuality attribute, on getting, must return the last value it was set to. On setting, it must be set to the new value. When the object implementing the CanvasImageSmoothing interface is created, the attribute must be set to "low".

4.12.5.1.18 Shadows
All drawing operations on an object which implements the CanvasShadowStyles interface are affected by the four global shadow attributes.

context . shadowColor [ = value ]
Returns the current shadow color.

Can be set, to change the shadow color. Values that cannot be parsed as CSS colors are ignored.

context . shadowOffsetX [ = value ]
context . shadowOffsetY [ = value ]
Returns the current shadow offset.

Can be set, to change the shadow offset. Values that are not finite numbers are ignored.

context . shadowBlur [ = value ]
Returns the current level of blur applied to shadows.

Can be set, to change the blur level. Values that are not finite numbers greater than or equal to zero are ignored.

The shadowColor attribute sets the color of the shadow.

When the context is created, the shadowColor attribute initially must be transparent black.

On getting, the serialization of the color must be returned.

On setting, the new value must be parsed with this canvas element and the color assigned. If parsing the value results in failure then it must be ignored, and the attribute must retain its previous value. [CSSCOLOR]

The shadowOffsetX and shadowOffsetY attributes specify the distance that the shadow will be offset in the positive horizontal and positive vertical distance respectively. Their values are in coordinate space units. They are not affected by the current transformation matrix.

When the context is created, the shadow offset attributes must initially have the value 0.

On getting, they must return their current value. On setting, the attribute being set must be set to the new value, except if the value is infinite or NaN, in which case the new value must be ignored.

The shadowBlur attribute specifies the level of the blurring effect. (The units do not map to coordinate space units, and are not affected by the current transformation matrix.)

When the context is created, the shadowBlur attribute must initially have the value 0.

On getting, the attribute must return its current value. On setting the attribute must be set to the new value, except if the value is negative, infinite or NaN, in which case the new value must be ignored.

Shadows are only drawn if the opacity component of the alpha component of the color of shadowColor is nonzero and either the shadowBlur is nonzero, or the shadowOffsetX is nonzero, or the shadowOffsetY is nonzero.

When shadows are drawn, they must be rendered as follows:

Let A be an infinite transparent black bitmap on which the source image for which a shadow is being created has been rendered.

Let B be an infinite transparent black bitmap, with a coordinate space and an origin identical to A.

Copy the alpha channel of A to B, offset by shadowOffsetX in the positive x direction, and shadowOffsetY in the positive y direction.

If shadowBlur is greater than 0:

Let σ be half the value of shadowBlur.

Perform a 2D Gaussian Blur on B, using σ as the standard deviation.

User agents may limit values of σ to an implementation-specific maximum value to avoid exceeding hardware limitations during the Gaussian blur operation.

Set the red, green, and blue components of every pixel in B to the red, green, and blue components (respectively) of the color of shadowColor.

Multiply the alpha component of every pixel in B by the alpha component of the color of shadowColor.

The shadow is in the bitmap B, and is rendered as part of the drawing model described below.

If the current composition operation is copy, then shadows effectively won't render (since the shape will overwrite the shadow).

4.12.5.1.19 Filters
All drawing operations on an object which implements the CanvasFilters interface are affected by the global filter attribute.

context . filter [ = value ]
Returns the current filter.

Can be set, to change the filter. Values that cannot be parsed as a <filter-function-list> value are ignored.

The filter attribute, on getting, must return the last value it was successfully set to. The value must not be re-serialized. On setting, if the new value is 'none' (not the empty string, null, or undefined), filters must be disabled for the context. Otherwise, the value must be parsed as a <filter-function-list> value. If the value cannot be parsed as a <filter-function-list> value, where using property-independent style sheet syntax like 'inherit' or 'initial' is considered an invalid value, then it must be ignored, and the attribute must retain its previous value. When creating the object implementing the CanvasFilters interface, the attribute must be set to 'none'.

A <filter-function-list> value consists of a sequence of one or more filter functions or references to SVG filters. The input to the filter is used as the input to the first item in the list. Subsequent items take the output of the previous item as their input. [FILTERS]

Coordinates used in the value of the filter attribute are interpreted such that one pixel is equivalent to one SVG user space unit and to one canvas coordinate space unit. Filter coordinates are not affected by the current transformation matrix. The current transformation matrix affects only the input to the filter. Filters are applied in the output bitmap's coordinate space.

When the value of the filter attribute defines lengths using percentages or using 'em' or 'ex' units, these must be interpreted relative to the computed value of the 'font-size' property of the font style source object at the time that the attribute is set, if it is an element. If the computed values are undefined for a particular case (e.g. because the font style source object is not an element or is not being rendered), then the relative keywords must be interpreted relative to the default value of the font attribute. The 'larger' and 'smaller' keywords are not supported.

If the value of the filter attribute refers to an SVG filter in the same document, and this SVG filter changes, then the changed filter is used for the next draw operation.

If the value of the filter attribute refers to an SVG filter in an external resource document and that document is not loaded when a drawing operation is invoked, then the drawing operation must proceed with no filtering.

4.12.5.1.20 Working with externally-defined SVG filters
This section is non-normative.

Since drawing is performed using filter value 'none' until an externally-defined filter has finished loading, authors might wish to determine whether such a filter has finished loading before proceeding with a drawing operation. One way to accomplish this is to load the externally-defined filter elsewhere within the same page in some element that sends a load event (for example, an SVG use element), and wait for the load event to be dispatched.

4.12.5.1.21 Drawing model
When a shape or image is painted, user agents must follow these steps, in the order given (or act as if they do):

Render the shape or image onto an infinite transparent black bitmap, creating image A, as described in the previous sections. For shapes, the current fill, stroke, and line styles must be honored, and the stroke must itself also be subjected to the current transformation matrix.

When the filter attribute is set to a value other than 'none' and all the externally-defined filters it references, if any, are in documents that are currently loaded, then use image A as the input to the filter, creating image B. Otherwise, let B be an alias for A.

When shadows are drawn, render the shadow from image B, using the current shadow styles, creating image C.

When shadows are drawn, multiply the alpha component of every pixel in C by globalAlpha.

When shadows are drawn, composite C within the clipping region over the current output bitmap using the current composition operator.

Multiply the alpha component of every pixel in B by globalAlpha.

Composite B within the clipping region over the current output bitmap using the current composition operator.

When compositing onto the output bitmap, pixels that would fall outside of the output bitmap must be discarded.

4.12.5.1.22 Best practices
When a canvas is interactive, authors should include focusable elements in the element's fallback content corresponding to each focusable part of the canvas, as in the example above.

When rendering focus rings, to ensure that focus rings have the appearance of native focus rings, authors should use the drawFocusIfNeeded() method, passing it the element for which a ring is being drawn. This method only draws the focus ring if the element is focused, so that it can simply be called whenever drawing the element, without checking whether the element is focused or not first.

In addition to drawing focus rings, authors should use the scrollPathIntoView() method when an element in the canvas is focused, to make sure it is visible on the screen (if applicable).

Authors should avoid implementing text editing controls using the canvas element. Doing so has a large number of disadvantages:

Mouse placement of the caret has to be reimplemented.
Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).
Scrolling of the text control has to be implemented (horizontally for long lines, vertically for multiline input).
Native features such as copy-and-paste have to be reimplemented.
Native features such as spell-checking have to be reimplemented.
Native features such as drag-and-drop have to be reimplemented.
Native features such as page-wide text search have to be reimplemented.
Native features specific to the user, for example custom text services, have to be reimplemented. This is close to impossible since each user might have different services installed, and there is an unbounded set of possible such services.
Bidirectional text editing has to be reimplemented.
For multiline text editing, line wrapping has to be implemented for all relevant languages.
Text selection has to be reimplemented.
Dragging of bidirectional text selections has to be reimplemented.
Platform-native keyboard shortcuts have to be reimplemented.
Platform-native input method editors (IMEs) have to be reimplemented.
Undo and redo functionality has to be reimplemented.
Accessibility features such as magnification following the caret or selection have to be reimplemented.
This is a huge amount of work, and authors are most strongly encouraged to avoid doing any of it by instead using the input element, the textarea element, or the contenteditable attribute.

4.12.5.1.23 Examples
This section is non-normative.

Here is an example of a script that uses canvas to draw pretty glowing lines.

<canvas width="800" height="450"></canvas>
<script>

 var context = document.getElementsByTagName('canvas')[0].getContext('2d');

 var lastX = context.canvas.width * Math.random();
 var lastY = context.canvas.height * Math.random();
 var hue = 0;
 function line() {
   context.save();
   context.translate(context.canvas.width/2, context.canvas.height/2);
   context.scale(0.9, 0.9);
   context.translate(-context.canvas.width/2, -context.canvas.height/2);
   context.beginPath();
   context.lineWidth = 5 + Math.random() * 10;
   context.moveTo(lastX, lastY);
   lastX = context.canvas.width * Math.random();
   lastY = context.canvas.height * Math.random();
   context.bezierCurveTo(context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         lastX, lastY);

   hue = hue + 10 * Math.random();
   context.strokeStyle = 'hsl(' + hue + ', 50%, 50%)';
   context.shadowColor = 'white';
   context.shadowBlur = 10;
   context.stroke();
   context.restore();
 }
 setInterval(line, 50);

 function blank() {
   context.fillStyle = 'rgba(0,0,0,0.1)';
   context.fillRect(0, 0, context.canvas.width, context.canvas.height);
 }
 setInterval(blank, 40);

</script>
The 2D rendering context for canvas is often used for sprite-based games. The following example demonstrates this:


Here is the source for this example:

<!DOCTYPE HTML>
<meta charset="utf-8">
<title>Blue Robot Demo</title>
<style>
  html { overflow: hidden; min-height: 200px; min-width: 380px; }
  body { height: 200px; position: relative; margin: 8px; }
  .buttons { position: absolute; bottom: 0px; left: 0px; margin: 4px; }
</style>
<canvas width="380" height="200"></canvas>
<script>
 var Landscape = function (context, width, height) {
   this.offset = 0;
   this.width = width;
   this.advance = function (dx) {
     this.offset += dx;
   };
   this.horizon = height * 0.7;
   // This creates the sky gradient (from a darker blue to white at the bottom)
   this.sky = context.createLinearGradient(0, 0, 0, this.horizon);
   this.sky.addColorStop(0.0, 'rgb(55,121,179)');
   this.sky.addColorStop(0.7, 'rgb(121,194,245)');
   this.sky.addColorStop(1.0, 'rgb(164,200,214)');
   // this creates the grass gradient (from a darker green to a lighter green)
   this.earth = context.createLinearGradient(0, this.horizon, 0, height);
   this.earth.addColorStop(0.0, 'rgb(81,140,20)');
   this.earth.addColorStop(1.0, 'rgb(123,177,57)');
   this.paintBackground = function (context, width, height) {
     // first, paint the sky and grass rectangles
     context.fillStyle = this.sky;
     context.fillRect(0, 0, width, this.horizon);
     context.fillStyle = this.earth;
     context.fillRect(0, this.horizon, width, height-this.horizon);
     // then, draw the cloudy banner
     // we make it cloudy by having the draw text off the top of the
     // canvas, and just having the blurred shadow shown on the canvas
     context.save();
     context.translate(width-((this.offset+(this.width*3.2)) % (this.width*4.0))+0, 0);
     context.shadowColor = 'white';
     context.shadowOffsetY = 30+this.horizon/3; // offset down on canvas
     context.shadowBlur = '5';
     context.fillStyle = 'white';
     context.textAlign = 'left';
     context.textBaseline = 'top';
     context.font = '20px sans-serif';
     context.fillText('WHATWG ROCKS', 10, -30); // text up above canvas
     context.restore();
     // then, draw the background tree
     context.save();
     context.translate(width-((this.offset+(this.width*0.2)) % (this.width*1.5))+30, 0);
     context.beginPath();
     context.fillStyle = 'rgb(143,89,2)';
     context.lineStyle = 'rgb(10,10,10)';
     context.lineWidth = 2;
     context.rect(0, this.horizon+5, 10, -50); // trunk
     context.fill();
     context.stroke();
     context.beginPath();
     context.fillStyle = 'rgb(78,154,6)';
     context.arc(5, this.horizon-60, 30, 0, Math.PI*2); // leaves
     context.fill();
     context.stroke();
     context.restore();
   };
   this.paintForeground = function (context, width, height) {
     // draw the box that goes in front
     context.save();
     context.translate(width-((this.offset+(this.width*0.7)) % (this.width*1.1))+0, 0);
     context.beginPath();
     context.rect(0, this.horizon - 5, 25, 25);
     context.fillStyle = 'rgb(220,154,94)';
     context.lineStyle = 'rgb(10,10,10)';
     context.lineWidth = 2;
     context.fill();
     context.stroke();
     context.restore();
   };
 };
</script>
<script>
 var BlueRobot = function () {
   this.sprites = new Image();
   this.sprites.src = 'blue-robot.png'; // this sprite sheet has 8 cells
   this.targetMode = 'idle';
   this.walk = function () {
     this.targetMode = 'walk';
   };
   this.stop = function () {
     this.targetMode = 'idle';
   };
   this.frameIndex = {
     'idle': [0], // first cell is the idle frame
     'walk': [1,2,3,4,5,6], // the walking animation is cells 1-6
     'stop': [7], // last cell is the stopping animation
   };
   this.mode = 'idle';
   this.frame = 0; // index into frameIndex
   this.tick = function () {
     // this advances the frame and the robot
     // the return value is how many pixels the robot has moved
     this.frame += 1;
     if (this.frame >= this.frameIndex[this.mode].length) {
       // we've reached the end of this animation cycle
       this.frame = 0;
       if (this.mode != this.targetMode) {
         // switch to next cycle
         if (this.mode == 'walk') {
           // we need to stop walking before we decide what to do next
           this.mode = 'stop';
         } else if (this.mode == 'stop') {
           if (this.targetMode == 'walk')
             this.mode = 'walk';
           else
             this.mode = 'idle';
         } else if (this.mode == 'idle') {
           if (this.targetMode == 'walk')
             this.mode = 'walk';
         }
       }
     }
     if (this.mode == 'walk')
       return 8;
     return 0;
   },
   this.paint = function (context, x, y) {
     if (!this.sprites.complete) return;
     // draw the right frame out of the sprite sheet onto the canvas
     // we assume each frame is as high as the sprite sheet
     // the x,y coordinates give the position of the bottom center of the sprite
     context.drawImage(this.sprites,
                       this.frameIndex[this.mode][this.frame] * this.sprites.height, 0, this.sprites.height, this.sprites.height,
                       x-this.sprites.height/2, y-this.sprites.height, this.sprites.height, this.sprites.height);
   };
 };
</script>
<script>
 var canvas = document.getElementsByTagName('canvas')[0];
 var context = canvas.getContext('2d');
 var landscape = new Landscape(context, canvas.width, canvas.height);
 var blueRobot = new BlueRobot();
 // paint when the browser wants us to, using requestAnimationFrame()
 function paint() {
   context.clearRect(0, 0, canvas.width, canvas.height);
   landscape.paintBackground(context, canvas.width, canvas.height);
   blueRobot.paint(context, canvas.width/2, landscape.horizon*1.1);
   landscape.paintForeground(context, canvas.width, canvas.height);
   requestAnimationFrame(paint);
 }
 paint();
 // but tick every 150ms, so that we don't slow down when we don't paint
 setInterval(function () {
   var dx = blueRobot.tick();
   landscape.advance(dx);
 }, 100);
</script>
<p class="buttons">
 <input type=button value="Walk" onclick="blueRobot.walk()">
 <input type=button value="Stop" onclick="blueRobot.stop()">
<footer>
 <small> Blue Robot Player Sprite by <a href="https://johncolburn.deviantart.com/">JohnColburn</a>.
 Licensed under the terms of the Creative Commons Attribution Share-Alike 3.0 Unported license.</small>
 <small> This work is itself licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative
 Commons Attribution-ShareAlike 3.0 Unported License</a>.</small>
</footer>
4.12.5.2 The ImageBitmap rendering context
4.12.5.2.1 Introduction
ImageBitmapRenderingContext is a performance-oriented interface that provides a low overhead method for displaying the contents of ImageBitmap objects. It uses transfer semantics to reduce overall memory consumption. It also streamlines performance by avoiding intermediate compositing, unlike the drawImage() method of CanvasRenderingContext2D.

Using an img element as an intermediate for getting an image resource into a canvas, for example, would result in two copies of the decoded image existing in memory at the same time: the img element's copy, and the one in the canvas's backing store. This memory cost can be prohibitive when dealing with extremely large images. This can be avoided by using ImageBitmapRenderingContext.

Using ImageBitmapRenderingContext, here is how to transcode an image to the JPEG format in a memory- and CPU-efficient way:

createImageBitmap(inputImageBlob).then(image => {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('bitmaprenderer');
  context.transferFromImageBitmap(image);

  canvas.toBlob(outputJPEGBlob => {
    // Do something with outputJPEGBlob.
  }, 'image/jpeg');
});
4.12.5.2.2 The ImageBitmapRenderingContext interface
[Exposed=Window]
interface ImageBitmapRenderingContext {
  readonly attribute HTMLCanvasElement canvas;
  void transferFromImageBitmap(ImageBitmap? bitmap);
};

dictionary ImageBitmapRenderingContextSettings {
  boolean alpha = true;
};
context = canvas . getContext('bitmaprenderer' [, { [ alpha: false ] } ] )
Returns an ImageBitmapRenderingContext object that is permanently bound to a particular canvas element.

If the alpha setting is provided and set to false, then the canvas is forced to always be opaque.

context . canvas
Returns the canvas element that the context is bound to.

context . transferFromImageBitmap(imageBitmap)
Transfers the underlying bitmap data from imageBitmap to context, and the bitmap becomes the contents of the canvas element to which context is bound.

context . transferFromImageBitmap( null)
Replaces contents of the canvas element to which context is bound with a transparent black bitmap whose size corresponds to the width and height content attributes of the canvas element.

The canvas attribute must return the value it was initialized to when the object was created.

An ImageBitmapRenderingContext object has an output bitmap, which is a reference to bitmap data.

An ImageBitmapRenderingContext object has a bitmap mode, which can be set to valid or blank. A value of valid indicates that the context's output bitmap refers to bitmap data that was acquired via transferFromImageBitmap(). A value blank indicates that the context's output bitmap is a default transparent bitmap.

An ImageBitmapRenderingContext object also has an alpha flag, which can be set to true or false. When an ImageBitmapRenderingContext object has its alpha flag set to false, the contents of the canvas element to which the context is bound are obtained by compositing the context's output bitmap onto an opaque black bitmap of the same size using the source-over composite operation. If the alpha flag is set to true, then the output bitmap is used as the contents of the canvas element to which the context is bound. [COMPOSITE]

The step of compositing over an opaque black bitmap ought to be elided whenever equivalent results can be obtained more efficiently by other means.

When a user agent is required to set an ImageBitmapRenderingContext's output bitmap, with a context argument that is an ImageBitmapRenderingContext object and an optional argument bitmap that refers to bitmap data, it must run these steps:

If a bitmap argument was not provided, then:

Set context's bitmap mode to blank.

Let canvas be the canvas element to which context is bound.

Set context's output bitmap to be transparent black with an intrinsic width equal to the numeric value of canvas's width attribute and an intrinsic height equal to the numeric value of canvas's height attribute, those values being interpreted in CSS pixels.

Set the output bitmap's origin-clean flag to true.

If a bitmap argument was provided, then:

Set context's bitmap mode to valid.

Set context's output bitmap to refer to the same underlying bitmap data as bitmap, without making a copy.

The origin-clean flag of bitmap is included in the bitmap data to be referenced by context's output bitmap.

The ImageBitmapRenderingContext creation algorithm, which is passed a target (a canvas element) and options, consists of running these steps:

Let settings be the result of converting options to the dictionary type ImageBitmapRenderingContextSettings. (This can throw an exception.)

Let context be a new ImageBitmapRenderingContext object.

Initialize context's canvas attribute to point to target.

Set context's output bitmap to the same bitmap as target's bitmap (so that they are shared).

Run the steps to set an ImageBitmapRenderingContext's output bitmap with context.

Initialize context's alpha flag to true.

Process each of the members of settings as follows:

alpha
If false, then set context's alpha flag to false.
Return context.

The transferFromImageBitmap(imageBitmap) method, when invoked, must run these steps:

Let bitmapContext be the ImageBitmapRenderingContext object on which the transferFromImageBitmap() method was called.

If imageBitmap is null, then run the steps to set an ImageBitmapRenderingContext's output bitmap, with bitmapContext as the context argument and no bitmap argument, then return.

If the value of imageBitmap's [[Detached]] internal slot is set to true, then throw an "InvalidStateError" DOMException.

Run the steps to set an ImageBitmapRenderingContext's output bitmap, with the context argument equal to bitmapContext, and the bitmap argument referring to imageBitmap's underlying bitmap data.

Set the value of imageBitmap's [[Detached]] internal slot to true.

Unset imageBitmap's bitmap data.

4.12.5.3 The OffscreenCanvas interface

Support: offscreencanvas
Chrome for Android	None
Chrome	None
iOS Safari	None
UC Browser for Android	None
Firefox	None
Samsung Internet	None
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	None
Opera	None

Source: caniuse.com

typedef (OffscreenCanvasRenderingContext2D or
        WebGLRenderingContext) OffscreenRenderingContext;

dictionary ImageEncodeOptions {
  DOMString type = "image/png";
  unrestricted double quality = 1.0;
};

enum OffscreenRenderingContextId { "2d", "webgl" };

[Constructor([EnforceRange] unsigned long long width, [EnforceRange] unsigned long long height), Exposed=(Window,Worker), Transferable]
interface OffscreenCanvas : EventTarget {
  attribute unsigned long long width;
  attribute unsigned long long height;

  OffscreenRenderingContext? getContext(OffscreenRenderingContextId contextId, optional any options = null);
  ImageBitmap transferToImageBitmap();
  Promise<Blob> convertToBlob(optional ImageEncodeOptions options);
};
OffscreenCanvas is an EventTarget so that WebGL can fire webglcontextlost and webglcontextrestored events at it. [WEBGL]

OffscreenCanvas objects are used to create rendering contexts, much like an HTMLCanvasElement, but with no connection to the DOM. This makes it possible to use canvas rendering contexts in workers.

An OffscreenCanvas object may hold a weak reference to a placeholder canvas element, which is typically in the DOM, whose embedded content is provided by the OffscreenCanvas object. The bitmap of the OffscreenCanvas object is pushed to the placeholder canvas element by calling the commit() method of the OffscreenCanvas object's rendering context. All rendering context types that can be created by an OffscreenCanvas object must implement a commit() method. The exact behavior of the commit method (e.g. whether it copies or transfers bitmaps) may vary, as defined by the rendering contexts' respective specifications. Only the 2D context for offscreen canvases is defined in this specification.

offscreenCanvas = new OffscreenCanvas(width, height)
Returns a new OffscreenCanvas object that is not linked to a placeholder canvas element, and whose bitmap's size is determined by the width and height arguments.

context = offscreenCanvas . getContext(contextId [, options ] )
Returns an object that exposes an API for drawing on the OffscreenCanvas object. contextId specifies the desired API: "2d" or "webgl". options is handled by that API.

This specification defines the "2d" context below, which is similar but distinct from the "2d" context that is created from a canvas element. There is also a specification that defines a "webgl" context. [WEBGL]

Returns null if the canvas has already been initialized with another context type (e.g., trying to get a "2d" context after getting a "webgl" context).

An OffscreenCanvas object has an internal bitmap that is initialized when the object is created. The width and height of the bitmap are equal to the values of the width and height attributes of the OffscreenCanvas object. Initially, all the bitmap's pixels are transparent black.

An OffscreenCanvas object can have a rendering context bound to it. Initially, it does not have a bound rendering context. To keep track of whether it has a rendering context or not, and what kind of rendering context it is, an OffscreenCanvas object also has a context mode, which is initially none but can be changed to either 2d, webgl or detached by algorithms defined in this specification.

The constructor OffscreenCanvas(width, height), when invoked, must create a new OffscreenCanvas object with its bitmap initialized to a rectangular array of transparent black pixels of the dimensions specified by width and height; and its width and height attributes initialized to width and height respectively.

OffscreenCanvas objects are transferable. Their transfer steps, given value and dataHolder, are as follows:

If value's context mode is not equal to none, then throw an "InvalidStateError" DOMException.

Set value's context mode to detached.

Let width and height be the dimensions of value's bitmap.

Unset value's bitmap.

Set dataHolder.[[Width]] to width and dataHolder.[[Height]] to height.

Set dataHolder.[[PlaceholderCanvas]] to be a weak reference to value's placeholder canvas element, if value has one, or null if it does not.

Their transfer-receiving steps, given dataHolder and value, are:

Initialize value's bitmap to a rectangular array of transparent black pixels with width given by dataHolder.[[Width]] and height given by dataHolder.[[Height]].

If dataHolder.[[PlaceholderCanvas]] is not null, set value's placeholder canvas element to dataHolder.[[PlaceholderCanvas]] (while maintaining the weak reference semantics).

The getContext(contextId, options) method of an OffscreenCanvas object, when invoked, must run these steps:

If options is not an object, then set options to null.

Set options to the result of converting options to a JavaScript value.

Run the steps in the cell of the following table whose column header matches this OffscreenCanvas object's context mode and whose row header matches contextId:

none	2d	webgl	detached
"2d"	Follow the steps to create an offscreen 2D context defined in the section below, passing it this OffscreenCanvas object and options, to obtain an OffscreenCanvasRenderingContext2D object; if this does not throw an exception, then set this OffscreenCanvas object's context mode to 2d, and return the new OffscreenCanvasRenderingContext2D object.	Return the same object as was returned the last time the method was invoked with this same first argument.	Return null.	Throw an "InvalidStateError" DOMException.
"webgl"	Follow the instructions given in the WebGL specification's Context Creation section to obtain either a WebGLRenderingContext or null; if the returned value is null, then return null; otherwise, set this OffscreenCanvas object's context mode to webgl, and return the WebGLRenderingContext object. [WEBGL]	Return null.	Return the same value as was returned the last time the method was invoked with this same first argument.	Throw an "InvalidStateError" DOMException.
offscreenCanvas . width [ = value ]
offscreenCanvas . height [ = value ]
These attributes return the dimensions of the OffscreenCanvas object's bitmap.

They can be set, to replace the bitmap with a new, transparent black bitmap of the specified dimensions (effectively resizing it).

If either the width or height attributes of an OffscreenCanvas object are set (to a new value or to the same value as before) and the OffscreenCanvas object's context mode is 2d, then replace the OffscreenCanvas object's bitmap with a new transparent black bitmap and reset the rendering context to its default state. The new bitmap's dimensions are equal to the new values of the width and height attributes.

The resizing behavior for "webgl" contexts is defined in the WebGL specification. [WEBGL]

If an OffscreenCanvas object whose dimensions were changed has a placeholder canvas element, then the placeholder canvas element's intrinsic size will only be updated via the commit() method of the OffscreenCanvas object's rendering context.

promise = offscreenCanvas . convertToBlob( [options] )
Returns a promise that will fulfill with a new Blob object representing a file containing the image in the OffscreenCanvas object.

The argument, if provided, is a dictionary that controls the encoding options of the image file to be created. The type field specifies the file format and has a default value of "image/png"; that type is also used if the requested type isn't supported. If the image format supports variable quality (such as "image/jpeg"), then the quality field is a number in the range 0.0 to 1.0 inclusive indicating the desired quality level for the resulting image.

canvas . transferToImageBitmap()
Returns a newly created ImageBitmap object with the image in the OffscreenCanvas object. The image in the OffscreenCanvas object is replaced with a new blank image.

The convertToBlob(options) method, when invoked, must run the following steps:

If the value of this OffscreenCanvas object's [[Detached]] internal slot is set to true, then return a promise rejected with an "InvalidStateError" DOMException.

If this OffscreenCanvas object's context mode is 2d and the rendering context's bitmap's origin-clean flag is set to false, then return a promise rejected with a "SecurityError" DOMException.

If this OffscreenCanvas object's bitmap has no pixels (i.e., either its horizontal dimension or its vertical dimension is zero) then return a promise rejected with an "IndexSizeError" DOMException.

Let bitmap be a copy of this OffscreenCanvas object's bitmap.

Let result be a new promise object.

Run these steps in parallel:

Let file be a serialization of bitmap as a file, with options's type and quality.

Queue a task to run these steps:

If file is null, then reject result with an "EncodingError" DOMException.

Otherwise, resolve result with a new Blob object, created in the relevant Realm of this OffscreenCanvas object, representing file. [FILEAPI]

The task source for this task is the canvas blob serialization task source.

Return result.

The transferToImageBitmap() method, when invoked, must run the following steps:

If the value of this OffscreenCanvas object's [[Detached]] internal slot is set to true, then throw an "InvalidStateError" DOMException.

If this OffscreenCanvas object's context mode is set to none, then throw an "InvalidStateError" DOMException.

Let image be a newly created ImageBitmap object that references the same underlying bitmap data as this OffscreenCanvas object's bitmap.

Set this OffscreenCanvas object's bitmap to reference a newly created bitmap of the same dimensions as the previous bitmap, and with its pixels initialized to transparent black, or opaque black if the rendering context's alpha flag is set to false.

Return image.

4.12.5.3.1 The offscreen 2D rendering context
[Exposed=(Window,Worker)]
interface OffscreenCanvasRenderingContext2D {
  void commit();
  readonly attribute OffscreenCanvas canvas;
};

OffscreenCanvasRenderingContext2D includes CanvasState;
OffscreenCanvasRenderingContext2D includes CanvasTransform;
OffscreenCanvasRenderingContext2D includes CanvasCompositing;
OffscreenCanvasRenderingContext2D includes CanvasImageSmoothing;
OffscreenCanvasRenderingContext2D includes CanvasFillStrokeStyles;
OffscreenCanvasRenderingContext2D includes CanvasShadowStyles;
OffscreenCanvasRenderingContext2D includes CanvasFilters;
OffscreenCanvasRenderingContext2D includes CanvasRect;
OffscreenCanvasRenderingContext2D includes CanvasDrawPath;
OffscreenCanvasRenderingContext2D includes CanvasDrawImage;
OffscreenCanvasRenderingContext2D includes CanvasImageData;
OffscreenCanvasRenderingContext2D includes CanvasPathDrawingStyles;
OffscreenCanvasRenderingContext2D includes CanvasPath;
The OffscreenCanvasRenderingContext2D object is a rendering context for drawing to the bitmap of an OffscreenCanvas object. It is similar to the CanvasRenderingContext2D object, with the following differences:

text rendering is not supported;

there is no support for user interface features;

its canvas attribute refers to an OffscreenCanvas object rather than a canvas element;

it has a commit() method for pushing the rendered image to the context's OffscreenCanvas object's placeholder canvas element.

An OffscreenCanvasRenderingContext2D object has a bitmap that is initialized when the object is created.

The bitmap has an origin-clean flag, which can be set to true or false. Initially, when one of these bitmaps is created, its origin-clean flag must be set to true.

An OffscreenCanvasRenderingContext2D object also has an alpha flag, which can be set to true or false. Initially, when the context is created, its alpha flag must be set to true. When an OffscreenCanvasRenderingContext2D object has its alpha flag set to false, then its alpha channel must be fixed to 1.0 (fully opaque) for all pixels, and attempts to change the alpha component of any pixel must be silently ignored.

An OffscreenCanvasRenderingContext2D object has an associated OffscreenCanvas object, which is the OffscreenCanvas object from which the OffscreenCanvasRenderingContext2D object was created.

offscreenCanvasRenderingContext2D . commit()
Copies the rendering context's bitmap to the bitmap of the placeholder canvas element of the associated OffscreenCanvas object. The copy operation is asynchronous.

offscreenCanvas = offscreenCanvasRenderingContext2D . canvas
Returns the associated OffscreenCanvas object.

The offscreen 2D context creation algorithm, which is passed a target (an OffscreenCanvas object) and optionally some arguments, consists of running the following steps:

If the algorithm was passed some arguments, let arg be the first such argument. Otherwise, let arg be undefined.

Let settings be the result of converting options to the dictionary type CanvasRenderingContext2DSettings. (This can throw an exception.).

Let context be a new OffscreenCanvasRenderingContext2D object.

Set context's associated OffscreenCanvas object to target.

Process each of the members of settings as follows:

alpha
If false, set context's alpha flag to false.
Set context's bitmap to a newly created bitmap with the dimensions specified by the width and height attributes of target, and set target's bitmap to the same bitmap (so that they are shared).

If context's alpha flag is set to true, initialize all the pixels of context's bitmap to transparent black. Otherwise, initialize the pixels to opaque black.

Return context.

The commit() method, when invoked, must run the following steps:

If this OffscreenCanvasRenderingContext2D's associated OffscreenCanvas object does not have a placeholder canvas element, then return.

Let image be a copy of this OffscreenCanvasRenderingContext2D's bitmap, including the value of its origin-clean flag.

Queue a task in the placeholder canvas element's relevant settings object's responsible event loop (which will be a browsing context event loop) to set the placeholder canvas element's output bitmap to be a reference to image.

If image has different dimensions than the bitmap previously referenced as the placeholder canvas element's output bitmap, then this task will result in a change in the placeholder canvas element's intrinsic size, which can affect document layout.

Implementations are encouraged to short-circuit the graphics update steps of the browsing context event loop for the purposes of updating the contents of a placeholder canvas element to the display. This could mean, for example, that the commit() method can copy the bitmap contents directly to a graphics buffer that is mapped to the physical display location of the placeholder canvas element. This or similar short-circuiting approaches can significantly reduce display latency, especially in cases where the commit() method is invoked from a worker and the event loop of the placeholder canvas element's browsing context is busy. However, such shortcuts can not have any script-observable side-effects. This means that the committed bitmap still needs to be sent to the placeholder canvas element, in case the element is used as a CanvasImageSource, as an ImageBitmapSource, or in case toDataURL() or toBlob() are called on it.

The canvas attribute, on getting, must return this OffscreenCanvasRenderingContext2D's associated OffscreenCanvas object.

4.12.5.4 Color spaces and color correction
The canvas APIs must perform color correction at only two points: when rendering images with their own gamma correction and color space information onto a bitmap, to convert the image to the color space used by the bitmaps (e.g. using the 2D Context's drawImage() method with an HTMLOrSVGImageElement object), and when rendering the actual canvas bitmap to the output device.

Thus, in the 2D context, colors used to draw shapes onto the canvas will exactly match colors obtained through the getImageData() method.

The toDataURL() method, when invoked, must not include color space information in the resources they return. Where the output format allows it, the color of pixels in resources created by toDataURL() must match those returned by the getImageData() method.

In user agents that support CSS, the color space used by a canvas element must match the color space used for processing any colors for that element in CSS.

The gamma correction and color space information of images must be handled in such a way that an image rendered directly using an img element would use the same colors as one painted on a canvas element that is then itself rendered. Furthermore, the rendering of images that have no color correction information (such as those returned by the toDataURL() method) must be rendered with no color correction.

Thus, in the 2D context, calling the drawImage() method to render the output of the toDataURL() method to the canvas, given the appropriate dimensions, has no visible effect.

4.12.5.5 Serializing bitmaps to a file
When a user agent is to create a serialization of the bitmap as a file, given an optional type and quality, it must create an image file in the format given by type, or if type was not supplied, in the PNG format. If an error occurs during the creation of the image file (e.g. an internal encoder error), then the result of the serialization is null. [PNG]

The image file's pixel data must be the bitmap's pixel data scaled to one image pixel per coordinate space unit, and if the file format used supports encoding resolution metadata, the resolution must be given as 96dpi (one image pixel per CSS pixel).

If type is supplied, then it must be interpreted as a MIME type giving the format to use. If the type has any parameters, then it must be treated as not supported.

For example, the value "image/png" would mean to generate a PNG image, the value "image/jpeg" would mean to generate a JPEG image, and the value "image/svg+xml" would mean to generate an SVG image (which would require that the user agent track how the bitmap was generated, an unlikely, though potentially awesome, feature).

User agents must support PNG ("image/png"). User agents may support other types. If the user agent does not support the requested type, then it must create the file using the PNG format. [PNG]

User agents must convert the provided type to ASCII lowercase before establishing if they support that type.

For image types that do not support an alpha channel, the serialized image must be the bitmap image composited onto an opaque black background using the source-over operator.

If type is an image format that supports variable quality (such as "image/jpeg") and quality is given, then, if Type(quality) is Number, and quality is in the range 0.0 to 1.0 inclusive, the user agent must treat quality as the desired quality level. If Type(quality) is not Number, or if quality is outside that range, the user agent must use its default quality value, as if the quality argument had not been given.

The use of type-testing here, instead of simply declaring quality as a Web IDL double, is a historical artifact.

4.12.5.6 Security with canvas elements
This section is non-normative.

Information leakage can occur if scripts from one origin can access information (e.g. read pixels) from images from another origin (one that isn't the same).

To mitigate this, bitmaps used with canvas elements and ImageBitmap objects are defined to have a flag indicating whether they are origin-clean. All bitmaps start with their origin-clean set to true. The flag is set to false when cross-origin images are used.

The toDataURL(), toBlob(), and getImageData() methods check the flag and will throw a "SecurityError" DOMException rather than leak cross-origin data.

The value of the origin-clean flag is propagated from a source canvas element's bitmap to a new ImageBitmap object by createImageBitmap(). Conversely, a destination canvas element's bitmap will have its origin-clean flags set to false by drawImage if the source image is an ImageBitmap object whose bitmap has its origin-clean flag set to false.

The flag can be reset in certain situations; for example, when changing the value of the width or the height content attribute of the canvas element to which a CanvasRenderingContext2D is bound, the bitmap is cleared and its origin-clean flag is reset.

When using an ImageBitmapRenderingContext, the value of the origin-clean flag is propagated from ImageBitmap objects when they are transferred to the canvas via transferFromImageBitmap().

4.13 Custom elements

Support: custom-elementsv1
Chrome for Android (limited)	64+
Chrome (limited)	54+
iOS Safari (limited)	10.3+
UC Browser for Android	11.8+
Firefox (limited)	59+
Samsung Internet	6.2+
IE	None
Opera Mini	None
Safari (limited)	10.1+
Android Browser (limited)	62+
Opera (limited)	41+

Source: caniuse.com

4.13.1 Introduction
This section is non-normative.

Custom elements provide a way for authors to build their own fully-featured DOM elements. Although authors could always use non-standard elements in their documents, with application-specific behavior added after the fact by scripting or similar, such elements have historically been non-conforming and not very functional. By defining a custom element, authors can inform the parser how to properly construct an element and how elements of that class should react to changes.

Custom elements are part of a larger effort to "rationalise the platform", by explaining existing platform features (like the elements of HTML) in terms of lower-level author-exposed extensibility points (like custom element definition). Although today there are many limitations on the capabilities of custom elements—both functionally and semantically—that prevent them from fully explaining the behaviors of HTML's existing elements, we hope to shrink this gap over time.

4.13.1.1 Creating an autonomous custom element
This section is non-normative.

For the purposes of illustrating how to create an autonomous custom element, let's define a custom element that encapsulates rendering a small icon for a country flag. Our goal is to be able to use it like so:

<flag-icon country="nl"></flag-icon>
To do this, we first declare a class for the custom element, extending HTMLElement:

class FlagIcon extends HTMLElement {
  constructor() {
    super();
    this._countryCode = null;
  }

  static get observedAttributes() { return ["country"]; }

  attributeChangedCallback(name, oldValue, newValue) {
    // name will always be "country" due to observedAttributes
    this._countryCode = newValue;
    this._updateRendering();
  }
  connectedCallback() {
    this._updateRendering();
  }

  get country() {
    return this._countryCode;
  }
  set country(v) {
    this.setAttribute("country", v);
  }

  _updateRendering() {
    // Left as an exercise for the reader. But, you'll probably want to
    // check this.ownerDocument.defaultView to see if we've been
    // inserted into a document with a browsing context, and avoid
    // doing any work if not.
  }
}
We then need to use this class to define the element:

customElements.define("flag-icon", FlagIcon);
At this point, our above code will work! The parser, whenever it sees the flag-icon tag, will construct a new instance of our FlagIcon class, and tell our code about its new country attribute, which we then use to set the element's internal state and update its rendering (when appropriate).

You can also create flag-icon elements using the DOM API:

const flagIcon = document.createElement("flag-icon")
flagIcon.country = "jp"
document.body.appendChild(flagIcon)
Finally, we can also use the custom element constructor itself. That is, the above code is equivalent to:

const flagIcon = new FlagIcon()
flagIcon.country = "jp"
document.body.appendChild(flagIcon)
4.13.1.2 Creating a customized built-in element
This section is non-normative.

Customized built-in elements are a distinct kind of custom element, which are defined slightly differently and used very differently compared to autonomous custom elements. They exist to allow reuse of behaviors from the existing elements of HTML, by extending those elements with new custom functionality. This is important since many of the existing behaviors of HTML elements can unfortunately not be duplicated by using purely autonomous custom elements. Instead, customized built-in elements allow the installation of custom construction behavior, lifecycle hooks, and prototype chain onto existing elements, essentially "mixing in" these capabilities on top of the already-existing element.

Customized built-in elements require a distinct syntax from autonomous custom elements because user agents and other software key off an element's local name in order to identify the element's semantics and behavior. That is, the concept of customized built-in elements building on top of existing behavior depends crucially on the extended elements retaining their original local name.

In this example, we'll be creating a customized built-in element named plastic-button, which behaves like a normal button but gets fancy animation effects added whenever you click on it. We start by defining a class, just like before, although this time we extend HTMLButtonElement instead of HTMLElement:

class PlasticButton extends HTMLButtonElement {
  constructor() {
    super();

    this.addEventListener("click", () => {
      // Draw some fancy animation effects!
    });
  }
}
When defining our custom element, we have to also specify the extends option:

customElements.define("plastic-button", PlasticButton, { extends: "button" });
In general, the name of the element being extended cannot be determined simply by looking at what element interface it extends, as many elements share the same interface (such as q and blockquote both sharing HTMLQuoteElement).

To construct our customized built-in element from parsed HTML source text, we use the is attribute on a button element:

<button is="plastic-button">Click Me!</button>
Trying to use a customized built-in element as an autonomous custom element will not work; that is, <plastic-button>Click me?</plastic-button> will simply create an HTMLElement with no special behavior.

If you need to create a customized built-in element programmatically, you can use the following form of createElement():

const plasticButton = document.createElement("button", { is: "plastic-button" });
plasticButton.textContent = "Click me!";
And as before, the constructor will also work:

const plasticButton2 = new PlasticButton();
console.log(plasticButton2.localName);  // will output "button"
console.assert(plasticButton2 instanceof PlasticButton);
console.assert(plasticButton2 instanceof HTMLButtonElement);
Note that when creating a customized built-in element programmatically, the is attribute will not be present in the DOM, since it was not explicitly set. However, it will be added to the output when serializing:

console.assert(!plasticButton.hasAttribute("is"));
console.log(plasticButton.outerHTML); // will output '<button is="plastic-button"></button>'
Regardless of how it is created, all the of the ways in which button is special apply to such "plastic buttons" as well: their focus behavior, ability to participate in form submission, the disabled attribute, and so on.

Customized built-in elements are designed to allow extension of existing HTML elements that have useful user-agent supplied behavior or APIs. As such, they can only extend existing HTML elements defined in this specification, and cannot extend legacy elements such as bgsound, blink, isindex, keygen, multicol, nextid, or spacer that have been defined to use HTMLUnknownElement as their element interface.

One reason for this requirement is future-compatibility: if a customized built-in element was defined that extended a currently-unknown element, for example combobox, this would prevent this specification from defining a combobox element in the future, as consumers of the derived customized built-in element would have come to depend on their base element having no interesting user-agent-supplied behavior.

4.13.1.3 Drawbacks of autonomous custom elements
This section is non-normative.

As specified below, and alluded to above, simply defining and using an element called taco-button does not mean that such elements represent buttons. That is, tools such as Web browsers, search engines, or accessibility technology will not automatically treat the resulting element as a button just based on its defined name.

To convey the desired button semantics to a variety of users, while still using an autonomous custom element, a number of techniques would need to be employed:

The addition of the tabindex attribute would make the taco-button interactive content, thus making it focusable. Note that if the taco-button were to become logically disabled, the tabindex attribute would need to be removed.

The addition of various ARIA attributes helps convey semantics to accessibility technology. For example, setting the role attribute to "button" will convey the semantics that this is a button, enabling users to successfully interact with the control using usual button-like interactions in their accessibility technology. Setting the aria-label attribute is necessary to give the button an accessible name, instead of having accessibility technology traverse its child text nodes and announce them. And setting aria-disabled to "true" when the button is logically disabled conveys to accessibility technology the button's disabled state.

The addition of event handlers to handle commonly-expected button behaviors helps convey the semantics of the button to Web browser users. In this case, the most relevant event handler would be one that proxies appropriate keydown events to become click events, so that you can activate the button both with keyboard and by clicking.

In addition to any default visual styling provided for taco-button elements, the visual styling will also need to be updated to reflect changes in logical state, such as becoming disabled; that is, whatever stylesheet has rules for taco-button will also need to have rules for taco-button[disabled].

With these points in mind, a full-featured taco-button that took on the responsibility of conveying button semantics (including the ability to be disabled) might look something like this:

class TacoButton extends HTMLElement {
  static get observedAttributes() { return ["disabled"]; }

  constructor() {
    super();

    this.addEventListener("keydown", e => {
      if (e.keyCode === 32 || e.keyCode === 13) {
        this.dispatchEvent(new MouseEvent("click", {
          bubbles: true,
          cancelable: true
        }));
      }
    });

    this.addEventListener("click", e => {
      if (this.disabled) {
        e.preventDefault();
        e.stopPropagation();
      }
    });

    this._observer = new MutationObserver(() => {
      this.setAttribute("aria-label", this.textContent);
    });
  }

  connectedCallback() {
    this.setAttribute("role", "button");
    this.setAttribute("tabindex", "0");

    this._observer.observe(this, {
      childList: true,
      characterData: true,
      subtree: true
    });
  }

  disconnectedCallback() {
    this._observer.disconnect();
  }

  get disabled() {
    return this.hasAttribute("disabled");
  }

  set disabled(v) {
    if (v) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }

  attributeChangedCallback() {
    // only is called for the disabled attribute due to observedAttributes
    if (this.disabled) {
      this.removeAttribute("tabindex");
      this.setAttribute("aria-disabled", "true");
    } else {
      this.setAttribute("tabindex", "0");
      this.setAttribute("aria-disabled", "false");
    }
  }
}
Even with this rather-complicated element definition, the element is not a pleasure to use for consumers: it will be continually "sprouting" tabindex and aria-* attributes of its own volition. This is because as of now there is no way to specify default accessibility semantics or focus behavior for custom elements, forcing the use of these attributes to do so (even though they are usually reserved for allowing the consumer to override default behavior).

In contrast, a simple customized built-in element, as shown in the previous section, would automatically inherit the semantics and behavior of the button element, with no need to implement these behaviors manually. In general, for any elements with nontrivial behavior and semantics that build on top of existing elements of HTML, customized built-in elements will be easier to develop, maintain, and consume.

4.13.1.4 Upgrading elements after their creation
This section is non-normative.

Because element definition can occur at any time, a non-custom element could be created, and then later become a custom element after an appropriate definition is registered. We call this process "upgrading" the element, from a normal element into a custom element.

Upgrades enable scenarios where it may be preferable for custom element definitions to be registered after relevant elements have been initially created, such as by the parser. They allow progressive enhancement of the content in the custom element. For example, in the following HTML document the element definition for img-viewer is loaded asynchronously:

<!DOCTYPE html>
<html lang="en">
<title>Image viewer example</title>

<img-viewer filter="Kelvin">
  <img src="images/tree.jpg" alt="A beautiful tree towering over an empty savannah">
</img-viewer>

<script src="js/elements/img-viewer.js" async></script>
The definition for the img-viewer element here is loaded using a script element marked with the async attribute, placed after the <img-viewer> tag in the markup. While the script is loading, the img-viewer element will be treated as an undefined element, similar to a span. Once the script loads, it will define the img-viewer element, and the existing img-viewer element on the page will be upgraded, applying the custom element's definition (which presumably includes applying an image filter identified by the string "Kelvin", enhancing the image's visual appearance).

Note that upgrades only apply to elements in the document tree. (Formally, elements that are connected.) An element that is not inserted into a document will stay un-upgraded. An example illustrates this point:

<!DOCTYPE html>
<html lang="en">
<title>Upgrade edge-cases example</title>

<example-element></example-element>

<script>
  "use strict";

  const inDocument = document.querySelector("example-element");
  const outOfDocument = document.createElement("example-element");

  // Before the element definition, both are HTMLElement:
  console.assert(inDocument instanceof HTMLElement);
  console.assert(outOfDocument instanceof HTMLElement);

  class ExampleElement extends HTMLElement {}
  customElements.define("example-element", ExampleElement);

  // After element definition, the in-document element was upgraded:
  console.assert(inDocument instanceof ExampleElement);
  console.assert(!(outOfDocument instanceof ExampleElement));

  document.body.appendChild(outOfDocument);

  // Now that we've moved the element into the document, it too was upgraded:
  console.assert(outOfDocument instanceof ExampleElement);
</script>
4.13.2 Requirements for custom element constructors
When authoring custom element constructors, authors are bound by the following conformance requirements:

A parameter-less call to super() must be the first statement in the constructor body, to establish the correct prototype chain and this value before any further code is run.

A return statement must not appear anywhere inside the constructor body, unless it is a simple early-return (return or return this).

The constructor must not use the document.write() or document.open() methods.

The element's attributes and children must not be inspected, as in the non-upgrade case none will be present, and relying on upgrades makes the element less usable.

The element must not gain any attributes or children, as this violates the expectations of consumers who use the createElement or createElementNS methods.

In general, work should be deferred to connectedCallback as much as possible—especially work involving fetching resources or rendering. However, note that connectedCallback can be called more than once, so any initialization work that is truly one-time will need a guard to prevent it from running twice.

In general, the constructor should be used to set up initial state and default values, and to set up event listeners and possibly a shadow root.

Several of these requirements are checked during element creation, either directly or indirectly, and failing to follow them will result in a custom element that cannot be instantiated by the parser or DOM APIs. This is true even if the work is done inside a constructor-initiated microtask, as a microtask checkpoint can occur immediately after construction.

4.13.3 Core concepts
A custom element is an element that is custom. Informally, this means that its constructor and prototype are defined by the author, instead of by the user agent. This author-supplied constructor function is called the custom element constructor.

Two distinct types of custom elements can be defined:

An autonomous custom element, which is defined with no extends option. These types of custom elements have a local name equal to their defined name.

A customized built-in element, which is defined with an extends option. These types of custom elements have a local name equal to the value passed in their extends option, and their defined name is used as the value of the is attribute, which therefore must be a valid custom element name.

After a custom element is created, changing the value of the is attribute does not change the element's behavior, as it is saved on the element as its is value.

Autonomous custom elements have the following element definition:

Categories:
Flow content.
Phrasing content.
Palpable content.
Contexts in which this element can be used:
Where phrasing content is expected.
Content model:
Transparent.
Content attributes:
Global attributes, except the is attribute
Any other attribute that has no namespace (see prose).
DOM interface:
Supplied by the element's author (inherits from HTMLElement)
An autonomous custom element does not have any special meaning: it represents its children. A customized built-in element inherits the semantics of the element that it extends.

Any namespace-less attribute that is relevant to the element's functioning, as determined by the element's author, may be specified on an autonomous custom element, so long as the attribute name is XML-compatible and contains no ASCII upper alphas. The exception is the is attribute, which must not be specified on an autonomous custom element (and which will have no effect if it is).

Customized built-in elements follow the normal requirements for attributes, based on the elements they extend. To add custom attribute-based behavior, use data-* attributes.

A valid custom element name is a sequence of characters name that meets all of the following requirements:

name must match the PotentialCustomElementName production:

PotentialCustomElementName ::=
[a-z] (PCENChar)* '-' (PCENChar)*
PCENChar ::=
"-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
This uses the EBNF notation from the XML specification. [XML]

name must not be any of the following:

annotation-xml
color-profile
font-face
font-face-src
font-face-uri
font-face-format
font-face-name
missing-glyph
The list of names above is the summary of all hyphen-containing element names from the applicable specifications, namely SVG and MathML. [SVG] [MATHML]

These requirements ensure a number of goals for valid custom element names:

They start with an ASCII lower alpha, ensuring that the HTML parser will treat them as tags instead of as text.

They do not contain any ASCII upper alphas, ensuring that the user agent can always treat HTML elements ASCII-case-insensitively.

They contain a hyphen, used for namespacing and to ensure forward compatibility (since no elements will be added to HTML, SVG, or MathML with hyphen-containing local names in the future).

They can always be created with createElement() and createElementNS(), which have restrictions that go beyond the parser's.

Apart from these restrictions, a large variety of names is allowed, to give maximum flexibility for use cases like <math-α> or <emotion-😍>.

A custom element definition describes a custom element and consists of:

A name
A valid custom element name
A local name
A local name
A constructor
A Web IDL Function callback function type value wrapping the custom element constructor
A list of observed attributes
A sequence<DOMString>
A collection of lifecycle callbacks
A map, whose four keys are the strings "connectedCallback", "disconnectedCallback", "adoptedCallback", and "attributeChangedCallback". The corresponding values are either a Web IDL Function callback function type value, or null. By default the value of each entry is null.
A construction stack
A list, initially empty, that is manipulated by the upgrade an element algorithm and the HTML element constructors. Each entry in the list will be either an element or an already constructed marker.
To look up a custom element definition, given a document, namespace, localName, and is, perform the following steps. They will return either a custom element definition or null:

If namespace is not the HTML namespace, return null.

If document does not have a browsing context, return null.

Let registry be document's browsing context's Window's CustomElementRegistry object.

If there is custom element definition in registry with name and local name both equal to localName, return that custom element definition.

If there is a custom element definition in registry with name equal to is and local name equal to localName, return that custom element definition.

Return null.

4.13.4 The CustomElementRegistry interface
Each Window object is associated with a unique instance of a CustomElementRegistry object, allocated when the Window object is created.

Custom element registries are associated with Window objects, instead of Document objects, since each custom element constructor inherits from the HTMLElement interface, and there is exactly one HTMLElement interface per Window object.

The customElements attribute of the Window interface must return the CustomElementRegistry object for that Window object.

[Exposed=Window]
interface CustomElementRegistry {
  [CEReactions] void define(DOMString name, Function constructor, optional ElementDefinitionOptions options);
  any get(DOMString name);
  Promise<void> whenDefined(DOMString name);
  [CEReactions] void upgrade(Node root);
};

dictionary ElementDefinitionOptions {
  DOMString extends;
};
Every CustomElementRegistry has a set of custom element definitions, initially empty. In general, algorithms in this specification look up elements in the registry by any of name, local name, or constructor.

Every CustomElementRegistry also has an element definition is running flag which is used to prevent reentrant invocations of element definition. It is initially unset.

Every CustomElementRegistry also has a when-defined promise map, mapping valid custom element names to promises. It is used to implement the whenDefined() method.

window . customElements . define(name, constructor)
Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
window . customElements . define(name, constructor, { extends: baseLocalName })
Defines a new custom element, mapping the given name to the given constructor as a customized built-in element for the element type identified by the supplied baseLocalName. A "NotSupportedError" DOMException will be thrown upon trying to extend a custom element or an unknown element.
window . customElements . get(name)
Retrieves the custom element constructor defined for the given name. Returns undefined if there is no custom element definition with the given name.
window . customElements . whenDefined(name)
Returns a promise that will be fulfilled when a custom element becomes defined with the given name. (If such a custom element is already defined, the returned promise will be immediately fulfilled.) Returns a promise rejected with a "SyntaxError" DOMException if not given a valid custom element name.
window . customElements . upgrade(root)
Tries to upgrade all shadow-including inclusive descendant elements of root, even if they are not connected.
Element definition is a process of adding a custom element definition to the CustomElementRegistry. This is accomplished by the define() method. When invoked, the define(name, constructor, options) method must run these steps:

If IsConstructor(constructor) is false, then throw a TypeError.

If name is not a valid custom element name, then throw a "SyntaxError" DOMException.

If this CustomElementRegistry contains an entry with name name, then throw a "NotSupportedError" DOMException.

If this CustomElementRegistry contains an entry with constructor constructor, then throw a "NotSupportedError" DOMException.

Let localName be name.

Let extends be the value of the extends member of options, or null if no such member exists.

If extends is not null, then:

If extends is a valid custom element name, then throw a "NotSupportedError" DOMException.

If the element interface for extends and the HTML namespace is HTMLUnknownElement (e.g., if extends does not indicate an element definition in this specification), then throw a "NotSupportedError" DOMException.

Set localName to extends.

If this CustomElementRegistry's element definition is running flag is set, then throw a "NotSupportedError" DOMException.

Set this CustomElementRegistry's element definition is running flag.

Run the following substeps while catching any exceptions:

Let prototype be Get(constructor, "prototype"). Rethrow any exceptions.

If Type(prototype) is not Object, then throw a TypeError exception.

Let lifecycleCallbacks be a map with the four keys "connectedCallback", "disconnectedCallback", "adoptedCallback", and "attributeChangedCallback", each of which belongs to an entry whose value is null.

For each of the four keys callbackName in lifecycleCallbacks, in the order listed in the previous step:

Let callbackValue be Get(prototype, callbackName). Rethrow any exceptions.

If callbackValue is not undefined, then set the value of the entry in lifecycleCallbacks with key callbackName to the result of converting callbackValue to the Web IDL Function callback type. Rethrow any exceptions from the conversion.

Let observedAttributes be an empty sequence<DOMString>.

If the value of the entry in lifecycleCallbacks with key "attributeChangedCallback" is not null, then:

Let observedAttributesIterable be Get(constructor, "observedAttributes"). Rethrow any exceptions.

If observedAttributesIterable is not undefined, then set observedAttributes to the result of converting observedAttributesIterable to a sequence<DOMString>. Rethrow any exceptions from the conversion.

Then, perform the following substep, regardless of whether the above steps threw an exception or not:

Unset this CustomElementRegistry's element definition is running flag.

Finally, if the first set of substeps threw an exception, then rethrow that exception (thus terminating this algorithm). Otherwise, continue onward.

Let definition be a new custom element definition with name name, local name localName, constructor constructor, observed attributes observedAttributes, and lifecycle callbacks lifecycleCallbacks.

Add definition to this CustomElementRegistry.

Let document be this CustomElementRegistry's relevant global object's associated Document.

Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.

For each element element in upgrade candidates, enqueue a custom element upgrade reaction given element and definition.

If this CustomElementRegistry's when-defined promise map contains an entry with key name:

Let promise be the value of that entry.

Resolve promise with undefined.

Delete the entry with key name from this CustomElementRegistry's when-defined promise map.

When invoked, the get(name) method must run these steps:

If this CustomElementRegistry contains an entry with name name, then return that entry's constructor.

Otherwise, return undefined.

When invoked, the whenDefined(name) method must run these steps:

If name is not a valid custom element name, then return a new promise rejected with a "SyntaxError" DOMException.

If this CustomElementRegistry contains an entry with name name, then return a new promise resolved with undefined.

Let map be this CustomElementRegistry's when-defined promise map.

If map does not contain an entry with key name, create an entry in map with key name and whose value is a new promise.

Let promise be the value of the entry in map with key name.

Return promise.

The whenDefined() method can be used to avoid performing an action until all appropriate custom elements are defined. In this example, we combine it with the :defined pseudo-class to hide a dynamically-loaded article's contents until we're sure that all of the autonomous custom elements it uses are defined.

articleContainer.hidden = true;

fetch(articleURL)
  .then(response => response.text())
  .then(text => {
    articleContainer.innerHTML = text;

    return Promise.all(
      [...articleContainer.querySelectorAll(":not(:defined)")]
        .map(el => customElements.whenDefined(el.localName))
    );
  })
  .then(() => {
    articleContainer.hidden = false;
  });
When invoked, the upgrade(root) method must run these steps:

Let candidates be a list of all of root's shadow-including inclusive descendant elements, in tree order.

For each candidate of candidates, try to upgrade candidate.

The upgrade() method allows upgrading of elements at will. Normally elements are automatically upgraded when they become connected, but this method can be used if you need to upgrade before you're ready to connect the element.

const el = document.createElement("spider-man");

class SpiderMan extends HTMLElement {}
customElements.define("spider-man", SpiderMan);

console.assert(!(el instanceof SpiderMan)); // not yet upgraded

customElements.upgrade(el);
console.assert(el instanceof SpiderMan);    // upgraded!
4.13.5 Upgrades
To upgrade an element, given as input a custom element definition definition and an element element, run the following steps:

If element is custom, then return.

This can occur due to reentrant invocation of this algorithm, as in the following example:

<!DOCTYPE html>
<x-foo id="a"></x-foo>
<x-foo id="b"></x-foo>

<script>
// Defining enqueues upgrade reactions for both "a" and "b"
customElements.define("x-foo", class extends HTMLElement {
  constructor() {
    super();

    const b = document.querySelector("#b");
    b.remove();

    // While this constructor is running for "a", "b" is still
    // undefined, and so inserting it into the document will enqueue a
    // second upgrade reaction for "b" in addition to the one enqueued
    // by defining x-foo.
    document.body.appendChild(b);
  }
})
</script>
This step will thus bail out the algorithm early when upgrade an element is invoked with "b" a second time.

If element's custom element state is "failed", then return.

Set element's custom element definition to definition.

For each attribute in element's attribute list, in order, enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute's local name, null, attribute's value, and attribute's namespace.

If element is connected, then enqueue a custom element callback reaction with element, callback name "connectedCallback", and an empty argument list.

Add element to the end of definition's construction stack.

Let C be definition's constructor.

Run the following substeps while catching any exceptions:

Let constructResult be the result of constructing C, with no arguments.

If C non-conformantly uses an API decorated with the [CEReactions] extended attribute, then the reactions enqueued at the beginning of this algorithm will execute during this step, before C finishes and control returns to this algorithm. Otherwise, they will execute after C and the rest of the upgrade process finishes.

If SameValue(constructResult, element) is false, then throw an "InvalidStateError" DOMException.

This can occur if C constructs another instance of the same custom element before calling super(), or if C uses JavaScript's return-override feature to return an arbitrary object from the constructor.

Then, perform the following substep, regardless of whether the above steps threw an exception or not:

Remove the last entry from the end of definition's construction stack.

Assuming C calls super() (as it will if it is conformant), and that the call succeeds, this will be the already constructed marker that replaced the element we pushed at the beginning of this algorithm. (The HTML element constructor carries out this replacement.)

If C does not call super() (i.e. it is not conformant), or if any step in the HTML element constructor throws, then this entry will still be element.

Finally, if the above steps threw an exception, then:

Set element's custom element state to "failed".

Set element's custom element definition to null.

Empty element's custom element reaction queue.

Rethrow the exception (thus terminating this algorithm).

Set element's custom element state to "custom".

To try to upgrade an element, given as input an element element, run the following steps:

Let definition be the result of looking up a custom element definition given element's node document, element's namespace, element's local name, and element's is value.

If definition is not null, then enqueue a custom element upgrade reaction given element and definition.

4.13.6 Custom element reactions
A custom element possesses the ability to respond to certain occurrences by running author code:

When upgraded, its constructor is run, with no arguments.

When it becomes connected, its connectedCallback is called, with no arguments.

When it becomes disconnected, its disconnectedCallback is called, with no arguments.

When it is adopted into a new document, its adoptedCallback is called, given the old document and new document as arguments.

When any of its attributes are changed, appended, removed, or replaced, its attributeChangedCallback is called, given the attribute's local name, old value, new value, and namespace as arguments. (An attribute's old or new value is considered to be null when the attribute is added or removed, respectively.)

We call these reactions collectively custom element reactions.

The way in which custom element reactions are invoked is done with special care, to avoid running author code during the middle of delicate operations. Effectively, they are delayed until "just before returning to user script". This means that for most purposes they appear to execute synchronously, but in the case of complicated composite operations (like cloning, or range manipulation), they will instead be delayed until after all the relevant user agent processing steps have completed, and then run together as a batch.

Additionally, the precise ordering of these reactions is managed via a somewhat-complicated stack-of-queues system, described below. The intention behind this system is to guarantee that custom element reactions always are invoked in the same order as their triggering actions, at least within the local context of a single custom element. (Because custom element reaction code can perform its own mutations, it is not possible to give a global ordering guarantee across multiple elements.)

Each unit of related similar-origin browsing contexts has a custom element reactions stack, which is initially empty. The current element queue is the element queue at the top of the custom element reactions stack. Each item in the stack is an element queue, which is initially empty as well. Each item in an element queue is an element. (The elements are not necessarily custom yet, since this queue is used for upgrades as well.)

Each custom element reactions stack has an associated backup element queue, which an initially-empty element queue. Elements are pushed onto the backup element queue during operations that affect the DOM without going through an API decorated with [CEReactions], or through the parser's create an element for the token algorithm. An example of this is a user-initiated editing operation which modifies the descendants or attributes of an editable element. To prevent reentrancy when processing the backup element queue, each custom element reactions stack also has a processing the backup element queue flag, initially unset.

All elements have an associated custom element reaction queue, initially empty. Each item in the custom element reaction queue is of one of two types:

An upgrade reaction, which will upgrade the custom element and contains a custom element definition; or

A callback reaction, which will call a lifecycle callback, and contains a callback function as well as a list of arguments.

This is all summarized in the following schematic diagram:



To enqueue an element on the appropriate element queue, given an element element, run the following steps:

If the custom element reactions stack is empty, then:

Add element to the backup element queue.

If the processing the backup element queue flag is set, then return.

Set the processing the backup element queue flag.

Queue a microtask to perform the following steps:

Invoke custom element reactions in the backup element queue.

Unset the processing the backup element queue flag.

Otherwise, add element to the current element queue.

To enqueue a custom element callback reaction, given a custom element element, a callback name callbackName, and a list of arguments args, run the following steps:

Let definition be element's custom element definition.

Let callback be the value of the entry in definition's lifecycle callbacks with key callbackName.

If callback is null, then return

If callbackName is "attributeChangedCallback", then:

Let attributeName be the first element of args.

If definition's observed attributes does not contain attributeName, then return.

Add a new callback reaction to element's custom element reaction queue, with callback function callback and arguments args.

Enqueue an element on the appropriate element queue given element.

To enqueue a custom element upgrade reaction, given an element element and custom element definition definition, run the following steps:

Add a new upgrade reaction to element's custom element reaction queue, with custom element definition definition.

Enqueue an element on the appropriate element queue given element.

To invoke custom element reactions in an element queue queue, run the following steps:

For each custom element element in queue:

Let reactions be element's custom element reaction queue.

Repeat until reactions is empty:

Remove the first element of reactions, and let reaction be that element. Switch on reaction's type:

upgrade reaction
Upgrade element using reaction's custom element definition.
callback reaction
Invoke reaction's callback function with reaction's arguments, and with element as the callback this value.
If this throws an exception, catch it, and report the exception.

To ensure custom element reactions are triggered appropriately, we introduce the [CEReactions] IDL extended attribute. It indicates that the relevant algorithm is to be supplemented with additional steps in order to appropriately track and invoke custom element reactions.

The [CEReactions] extended attribute must take no arguments, and must not appear on anything other than an operation, attribute, setter, or deleter. Additionally, it must not appear on readonly attributes.

Operations, attributes, setters, or deleters annotated with the [CEReactions] extended attribute must run the following steps in place of the ones specified in their description:

Push a new element queue onto the custom element reactions stack.

Run the originally-specified steps for this construct, catching any exceptions. If the steps return a value, let value be the returned value. If they throw an exception, let exception be the thrown exception.

Let queue be the result of popping from the custom element reactions stack.

Invoke custom element reactions in queue.

If an exception exception was thrown by the original steps, rethrow exception.

If a value value was returned from the original steps, return value.

The intent behind this extended attribute is somewhat subtle. One way of accomplishing its goals would be to say that every operation, attribute, setter, and deleter on the platform must have these steps inserted, and to allow implementers to optimize away unnecessary cases (where no DOM mutation is possible that could cause custom element reactions to occur).

However, in practice this imprecision could lead to non-interoperable implementations of custom element reactions, as some implementations might forget to invoke these steps in some cases. Instead, we settled on the approach of explicitly annotating all relevant IDL constructs, as a way of ensuring interoperable behavior and helping implementations easily pinpoint all cases where these steps are necessary.

Any nonstandard APIs introduced by the user agent that could modify the DOM in such a way as to cause enqueuing a custom element callback reaction or enqueuing a custom element upgrade reaction, for example by modifying any attributes or child elements, must also be decorated with the [CEReactions] attribute.

As of the time of this writing, the following nonstandard or not-yet-standardized APIs are known to fall into this category:

HTMLElement's outerText IDL attribute

HTMLInputElement's webkitdirectory and incremental IDL attributes

HTMLLinkElement's disabled and scope IDL attributes

ShadowRoot's innerHTML IDL attribute

4.14 Common idioms without dedicated elements
4.14.1 The main part of the content
The main content of a page — not including headers and footers, navigation links, sidebars, advertisements, and so forth — can be marked up in a variety of ways, depending on the needs of the author.

The simplest solution is to not mark up the main content at all, and just leave it as implicit. Another way to think of this is that the body elements marks up the main content of the page, and the bits that aren't main content are excluded through the use of more appropriate elements like aside and nav.

Here is a short Web page marked up along this minimalistic school of thought. The main content is highlighted. Notice how all the other content in the body is marked up with elements to indicate that it's not part of the main content, in this case header, nav, and footer.

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title> My Toys </title>
 </head>
 <body>
  <header>
   <h1>My toys</h1>
  </header>
  <nav>
   <p><a href="/">Home</a></p>
   <p><a href="/contact">Contact</a></p>
  </nav>
  <p>I really like my chained book and my telephone. I'm not such a
  fan of my big ball.</p>
  <p>Another toy I like is my mirror.</p>
  <footer>
   <p>© copyright 2010 by the boy</p>
  </footer>
 </body>
</html>
If the main content is an independent unit of content that one could imagine syndicating independently, then the article element would be appropriate to mark up the main content of the document.

The document in the previous example is here recast as a blog post:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title> The Boy Blog: My Toys </title>
 </head>
 <body>
  <header>
   <h1>The Boy Blog</h1>
  </header>
  <nav>
   <p><a href="/">Home</a></p>
   <p><a href="/contact">Contact</a></p>
  </nav>
  <article>
   <header>
    <h1>My toys</h1>
    <p>Published August 4th</p>
   </header>
   <p>I really like my chained book and my telephone. I'm not such a
   fan of my big ball.</p>
   <p>Another toy I like is my mirror.</p>
  </article>
  <footer>
   <p>© copyright 2010 by the boy</p>
  </footer>
 </body>
</html>
If the main content is not an independent unit of content so much as a section of a larger work, for instance a chapter, then the section element would be appropriate to mark up the main content of the document.

Here is the same document, but as a chapter in an online book:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title> Chapter 2: My Toys — The Book of the Boy </title>
 </head>
 <body>
  <header>
   <hgroup>
    <h1>The Book of the Boy</h1>
    <h2>A book about boy stuff</h2>
   </hgroup>
  </header>
  <nav>
   <p><a href="/">Front Page</a></p>
   <p><a href="/toc">Table of Contents</a></p>
   <p><a href="/c1">Chapter 1</a> — <a href="/c3">Chapter 3</a></p>
  </nav>
  <section>
   <h1>Chapter 2: My Toys</h1>
   <p>I really like my chained book and my telephone. I'm not such a
   fan of my big ball.</p>
   <p>Another toy I like is my mirror.</p>
  </section>
 </body>
</html>
If neither article nor section would be appropriate, but the main content still needs an explicit element, for example for styling purposes, then the main element can be used.

This is the same as the original example, but using main for the main content instead of leaving it implied:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title> My Toys </title>
  <style>
   body > main { background: navy; color: yellow; }
  </style>
 </head>
 <body>
  <header>
   <h1>My toys</h1>
  </header>
  <nav>
   <p><a href="/">Home</a></p>
   <p><a href="/contact">Contact</a></p>
  </nav>
  <main>
   <p>I really like my chained book and my telephone. I'm not such a
   fan of my big ball.</p>
   <p>Another toy I like is my mirror.</p>
  </main>
  <footer>
   <p>© copyright 2010 by the boy</p>
  </footer>
 </body>
</html>
4.14.2 Bread crumb navigation
This specification does not provide a machine-readable way of describing bread-crumb navigation menus. Authors are encouraged to just use a series of links in a paragraph. The nav element can be used to mark the section containing these paragraphs as being navigation blocks.

In the following example, the current page can be reached via two paths.

<nav>
 <p>
  <a href="/">Main</a> ▸
  <a href="/products/">Products</a> ▸
  <a href="/products/dishwashers/">Dishwashers</a> ▸
  <a>Second hand</a>
 </p>
 <p>
  <a href="/">Main</a> ▸
  <a href="/second-hand/">Second hand</a> ▸
  <a>Dishwashers</a>
 </p>
</nav>
4.14.3 Tag clouds
This specification does not define any markup specifically for marking up lists of keywords that apply to a group of pages (also known as tag clouds). In general, authors are encouraged to either mark up such lists using ul elements with explicit inline counts that are then hidden and turned into a presentational effect using a style sheet, or to use SVG.

Here, three tags are included in a short tag cloud:

<style>
.tag-cloud > li > span { display: none; }
.tag-cloud > li { display: inline; }
.tag-cloud-1 { font-size: 0.7em; }
.tag-cloud-2 { font-size: 0.9em; }
.tag-cloud-3 { font-size: 1.1em; }
.tag-cloud-4 { font-size: 1.3em; }
.tag-cloud-5 { font-size: 1.5em; }

@media speech {
  .tag-cloud > li > span { display:inline }
}
</style>
...
<ul class="tag-cloud">
 <li class="tag-cloud-4"><a title="28 instances" href="/t/apple">apple</a> <span>(popular)</span>
 <li class="tag-cloud-2"><a title="6 instances"  href="/t/kiwi">kiwi</a> <span>(rare)</span>
 <li class="tag-cloud-5"><a title="41 instances" href="/t/pear">pear</a> <span>(very popular)</span>
</ul>
The actual frequency of each tag is given using the title attribute. A CSS style sheet is provided to convert the markup into a cloud of differently-sized words, but for user agents that do not support CSS or are not visual, the markup contains annotations like "(popular)" or "(rare)" to categorize the various tags by frequency, thus enabling all users to benefit from the information.

The ul element is used (rather than ol) because the order is not particularly important: while the list is in fact ordered alphabetically, it would convey the same information if ordered by, say, the length of the tag.

The tag rel-keyword is not used on these a elements because they do not represent tags that apply to the page itself; they are just part of an index listing the tags themselves.

4.14.4 Conversations
This specification does not define a specific element for marking up conversations, meeting minutes, chat transcripts, dialogues in screenplays, instant message logs, and other situations where different players take turns in discourse.

Instead, authors are encouraged to mark up conversations using p elements and punctuation. Authors who need to mark the speaker for styling purposes are encouraged to use span or b. Paragraphs with their text wrapped in the i element can be used for marking up stage directions.

This example demonstrates this using an extract from Abbot and Costello's famous sketch, Who's on first:

<p> Costello: Look, you gotta first baseman?
<p> Abbott: Certainly.
<p> Costello: Who's playing first?
<p> Abbott: That's right.
<p> Costello becomes exasperated.
<p> Costello: When you pay off the first baseman every month, who gets the money?
<p> Abbott: Every dollar of it.
The following extract shows how an IM conversation log could be marked up, using the data element to provide Unix timestamps for each line. Note that the timestamps are provided in a format that the time element does not support, so the data element is used instead (namely, Unix time_t timestamps). Had the author wished to mark up the data using one of the date and time formats supported by the time element, that element could have been used instead of data. This could be advantageous as it would allow data analysis tools to detect the timestamps unambiguously, without coordination with the page author.

<p> <data value="1319898155">14:22</data> <b>egof</b> I'm not that nerdy, I've only seen 30% of the star trek episodes
<p> <data value="1319898192">14:23</data> <b>kaj</b> if you know what percentage of the star trek episodes you have seen, you are inarguably nerdy
<p> <data value="1319898200">14:23</data> <b>egof</b> it's unarguably
<p> <data value="1319898228">14:23</data> <i>* kaj blinks</i>
<p> <data value="1319898260">14:24</data> <b>kaj</b> you are not helping your case
HTML does not have a good way to mark up graphs, so descriptions of interactive conversations from games are more difficult to mark up. This example shows one possible convention using dl elements to list the possible responses at each point in the conversation. Another option to consider is describing the conversation in the form of a DOT file, and outputting the result as an SVG image to place in the document. [DOT]

<p> Next, you meet a fisher. You can say one of several greetings:
<dl>
 <dt> "Hello there!"
 <dd>
  <p> She responds with "Hello, how may I help you?"; you can respond with:
  <dl>
   <dt> "I would like to buy a fish."
   <dd> <p> She sells you a fish and the conversation finishes.
   <dt> "Can I borrow your boat?"
   <dd>
    <p> She is surprised and asks "What are you offering in return?".
    <dl>
     <dt> "Five gold." (if you have enough)
     <dt> "Ten gold." (if you have enough)
     <dt> "Fifteen gold." (if you have enough)
     <dd> <p> She lends you her boat. The conversation ends.
     <dt> "A fish." (if you have one)
     <dt> "A newspaper." (if you have one)
     <dt> "A pebble." (if you have one)
     <dd> <p> "No thanks", she replies. Your conversation options
     at this point are the same as they were after asking to borrow
     her boat, minus any options you've suggested before.
    </dl>
   </dd>
  </dl>
 </dd>
 <dt> "Vote for me in the next election!"
 <dd> <p> She turns away. The conversation finishes.
 <dt> "Madam, are you aware that your fish are running away?"
 <dd>
  <p> She looks at you skeptically and says "Fish cannot run, miss".
  <dl>
   <dt> "You got me!"
   <dd> <p> The fisher sighs and the conversation ends.
   <dt> "Only kidding."
   <dd> <p> "Good one!" she retorts. Your conversation options at this
   point are the same as those following "Hello there!" above.
   <dt> "Oh, then what are they doing?"
   <dd> <p> She looks at her fish, giving you an opportunity to steal
   her boat, which you do. The conversation ends.
  </dl>
 </dd>
</dl>
In some games, conversations are simpler: each character merely has a fixed set of lines that they say. In this example, a game FAQ/walkthrough lists some of the known possible responses for each character:

<section>
 <h1>Dialogue</h1>
 <p><small>Some characters repeat their lines in order each time you interact
 with them, others randomly pick from amongst their lines. Those who respond in
 order have numbered entries in the lists below.</small>
 <h2>The Shopkeeper</h2>
 <ul>
  <li>How may I help you?
  <li>Fresh apples!
  <li>A loaf of bread for madam?
 </ul>
 <h2>The pilot</h2>
 <p>Before the accident:
 <ul>
  <li>I'm about to fly out, sorry!
  <li>Sorry, I'm just waiting for flight clearance and then I'll be off!
 </ul>
 <p>After the accident:
 <ol>
  <li>I'm about to fly out, sorry!
  <li>Ok, I'm not leaving right now, my plane is being cleaned.
  <li>Ok, it's not being cleaned, it needs a minor repair first.
  <li>Ok, ok, stop bothering me! Truth is, I had a crash.
 </ol>
 <h2>Clan Leader</h2>
 <p>During the first clan meeting:
 <ul>
  <li>Hey, have you seen my daughter? I bet she's up to something nefarious again...
  <li>Nice weather we're having today, eh?
  <li>The name is Bailey, Jeff Bailey. How can I help you today?
  <li>A glass of water? Fresh from the well!
 </ul>
 <p>After the earthquake:
 <ol>
  <li>Everyone is safe in the shelter, we just have to put out the fire!
  <li>I'll go and tell the fire brigade, you keep hosing it down!
 </ol>
</section>
4.14.5 Footnotes
HTML does not have a dedicated mechanism for marking up footnotes. Here are the suggested alternatives.

For short inline annotations, the title attribute could be used.

In this example, two parts of a dialogue are annotated with footnote-like content using the title attribute.

<p> <b>Customer</b>: Hello! I wish to register a complaint. Hello. Miss?
<p> <b>Shopkeeper</b>: <span title="Colloquial pronunciation of 'What do you'"
>Watcha</span> mean, miss?
<p> <b>Customer</b>: Uh, I'm sorry, I have a cold. I wish to make a complaint.
<p> <b>Shopkeeper</b>: Sorry, <span title="This is, of course, a lie.">we're
closing for lunch</span>.
Unfortunately, relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g. requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).

If the title attribute is used, CSS can be used to draw the reader's attention to the elements with the attribute.

For example, the following CSS places a dashed line below elements that have a title attribute.

[title] { border-bottom: thin dashed; }
For longer annotations, the a element should be used, pointing to an element later in the document. The convention is that the contents of the link be a number in square brackets.

In this example, a footnote in the dialogue links to a paragraph below the dialogue. The paragraph then reciprocally links back to the dialogue, allowing the user to return to the location of the footnote.

<p> Announcer: Number 16: The <i>hand</i>.
<p> Interviewer: Good evening. I have with me in the studio tonight
Mr Norman St John Polevaulter, who for the past few years has been
contradicting people. Mr Polevaulter, why <em>do</em> you
contradict people?
<p> Norman: I don't. <sup><a href="#fn1" id="r1">[1]</a></sup>
<p> Interviewer: You told me you did!
...
<section>
 <p id="fn1"><a href="#r1">[1]</a> This is, naturally, a lie,
 but paradoxically if it were true he could not say so without
 contradicting the interviewer and thus making it false.</p>
</section>
For side notes, longer annotations that apply to entire sections of the text rather than just specific words or sentences, the aside element should be used.

In this example, a sidebar is given after a dialogue, giving it some context.

<p> <span class="speaker">Customer</span>: I will not buy this record, it is scratched.
<p> <span class="speaker">Shopkeeper</span>: I'm sorry?
<p> <span class="speaker">Customer</span>: I will not buy this record, it is scratched.
<p> <span class="speaker">Shopkeeper</span>: No no no, this's'a tobacconist's.
<aside>
 <p>In 1970, the British Empire lay in ruins, and foreign
 nationalists frequented the streets — many of them Hungarians
 (not the streets — the foreign nationals). Sadly, Alexander
 Yalt has been publishing incompetently-written phrase books.
</aside>
For figures or tables, footnotes can be included in the relevant figcaption or caption element, or in surrounding prose.

In this example, a table has cells with footnotes that are given in prose. A figure element is used to give a single legend to the combination of the table and its footnotes.

<figure>
 <figcaption>Table 1. Alternative activities for knights.</figcaption>
 <table>
  <tr>
   <th> Activity
   <th> Location
   <th> Cost
  <tr>
   <td> Dance
   <td> Wherever possible
   <td> £0<sup><a href="#fn1">1</a></sup>
  <tr>
   <td> Routines, chorus scenes<sup><a href="#fn2">2</a></sup>
   <td> Undisclosed
   <td> Undisclosed
  <tr>
   <td> Dining<sup><a href="#fn3">3</a></sup>
   <td> Camelot
   <td> Cost of ham, jam, and spam<sup><a href="#fn4">4</a></sup>
 </table>
 <p id="fn1">1. Assumed.</p>
 <p id="fn2">2. Footwork impeccable.</p>
 <p id="fn3">3. Quality described as "well".</p>
 <p id="fn4">4. A lot.</p>
</figure>
4.15 Disabled elements
An element is said to be actually disabled if it is one of the following:

a button element that is disabled
an input element that is disabled
a select element that is disabled
a textarea element that is disabled
an optgroup element that has a disabled attribute
an option element that is disabled
a fieldset element that is a disabled fieldset
This definition is used to determine what elements can be focused and which elements match the :enabled and :disabled pseudo-classes.

4.16 Matching HTML elements using selectors and CSS
4.16.1 Case-sensitivity of the CSS 'attr()' function
The CSS Values and Units specification leaves the case-sensitivity of attribute names for the purpose of the 'attr()' function to be defined by the host language. [CSSVALUES]

When comparing the attribute name part of a CSS 'attr()' function to the names of namespace-less attributes on HTML elements in HTML documents, the name part of the CSS 'attr()' function must first be converted to ASCII lowercase. The same function when compared to other attributes must be compared according to its original case. In both cases, the comparison is case-sensitive.

This is the same as comparing the name part of a CSS attribute selector, specified in the next section.

4.16.2 Case-sensitivity of selectors
The Selectors specification leaves the case-sensitivity of element names, attribute names, and attribute values to be defined by the host language. [SELECTORS]

When comparing a CSS element type selector to the names of HTML elements in HTML documents, the CSS element type selector must first be converted to ASCII lowercase. The same selector when compared to other elements must be compared according to its original case. In both cases, the comparison is case-sensitive.

When comparing the name part of a CSS attribute selector to the names of attributes on HTML elements in HTML documents, the name part of the CSS attribute selector must first be converted to ASCII lowercase. The same selector when compared to other attributes must be compared according to its original case. In both cases, the comparison is case-sensitive.

Attribute selectors on an HTML element in an HTML document must treat the values of attributes with the following names as ASCII case-insensitive, with one exception as noted in the rendering section:

accept
accept-charset
align
alink
axis
bgcolor
charset
checked
clear
codetype
color
compact
declare
defer
dir
direction
disabled
enctype
face
frame
hreflang
http-equiv
lang
language
link
media
method
multiple
nohref
noresize
noshade
nowrap
readonly
rel
rev
rules
scope
scrolling
selected
shape
target
text
type (except as specified in the rendering section)
valign
valuetype
vlink
For example, the selector [bgcolor="#ffffff"] will match any HTML element with a bgcolor attribute with values including #ffffff, #FFFFFF and #fffFFF. This happens even if bgcolor has no effect for a given element (e.g., div).

All other attribute values and everything else must be treated as entirely case-sensitive for the purposes of selector matching. This includes:

IDs and classes in no-quirks mode and limited-quirks mode
the names of elements not in the HTML namespace
the names of HTML elements in XML documents
the names of attributes of elements not in the HTML namespace
the names of attributes of HTML elements in XML documents
the names of attributes that themselves have namespaces
Selectors defines that ID and class selectors (such as #foo and .bar), when matched against elements in documents that are in quirks mode, will be matched in an ASCII case-insensitive manner. However, this does not apply for attribute selectors with "id" or "class" as the name part. The selector [class="foobar"] will treat its value as case-sensitive even in quirks mode.

4.16.3 Pseudo-classes
There are a number of dynamic selectors that can be used with HTML. This section defines when these selectors match HTML elements. [SELECTORS] [CSSUI]

:defined
The :defined pseudo-class must match any element that is defined.

:link
:visited
All a elements that have an href attribute, all area elements that have an href attribute, and all link elements that have an href attribute, must match one of :link and :visited.

Other specifications might apply more specific rules regarding how these elements are to match these pseudo-classes, to mitigate some privacy concerns that apply with straightforward implementations of this requirement.

:active
The :active pseudo-class is defined to match an element while an element is being activated by the user.

To determine whether a particular element is being activated for the purposes of defining the :active pseudo-class only, an HTML user agent must use the first relevant entry in the following list.

If the element has a descendant that is currently matching the :active pseudo-class
The element is being activated.

If the element is the labeled control of a label element that is currently matching :active
The element is being activated.

If the element is a button element
If the element is an input element whose type attribute is in the Submit Button, Image Button, Reset Button, or Button state
The element is being activated if it is in a formal activation state and it is not disabled.

For example, if the user is using a keyboard to push a button element by pressing the space bar, the element would match this pseudo-class in between the time that the element received the keydown event and the time the element received the keyup event.

If the element is an a element that has an href attribute
If the element is an area element that has an href attribute
If the element is a link element that has an href attribute
If the element has its tabindex focus flag set
The element is being activated if it is in a formal activation state.

If the element is being actively pointed at
The element is being activated.

An element is said to be in a formal activation state between the time the user begins to indicate an intent to trigger the element's activation behavior and either the time the user stops indicating an intent to trigger the element's activation behavior, or the time the element's activation behavior has finished running, which ever comes first.

An element is said to be being actively pointed at while the user indicates the element using a pointing device while that pointing device is in the "down" state (e.g. for a mouse, between the time the mouse button is pressed and the time it is depressed; for a finger in a multitouch environment, while the finger is touching the display surface).

:hover
The :hover pseudo-class is defined to match an element while the user designates an element with a pointing device. For the purposes of defining the :hover pseudo-class only, an HTML user agent must consider an element as being one that the user designates if it is:

An element that the user indicates using a pointing device.

An element that has a descendant that the user indicates using a pointing device.

An element that is the labeled control of a label element that is currently matching :hover.

Consider in particular a fragment such as:

<p> <label for=c> <input id=a> </label> <span id=b> <input id=c> </span> </p>
If the user designates the element with ID "a" with their pointing device, then the p element (and all its ancestors not shown in the snippet above), the label element, the element with ID "a", and the element with ID "c" will match the :hover pseudo-class. The element with ID "a" matches it from condition 1, the label and p elements match it because of condition 2 (one of their descendants is designated), and the element with ID "c" matches it through condition 3 (its label element matches :hover). However, the element with ID "b" does not match :hover: its descendant is not designated, even though it matches :hover.

:focus
For the purposes of the CSS :focus pseudo-class, an element has the focus when its top-level browsing context has the system focus, it is not itself a browsing context container, and it is one of the elements listed in the focus chain of the currently focused area of the top-level browsing context.

:target
For the purposes of the CSS :target pseudo-class, the Document's target elements are a list containing the Document's target element, if it is not null, or containing no elements, if it is. [SELECTORS]

:enabled
The :enabled pseudo-class must match any button, input, select, textarea, optgroup, option, or fieldset element that is not actually disabled.

:disabled
The :disabled pseudo-class must match any element that is actually disabled.

:checked
The :checked pseudo-class must match any element falling into one of the following categories:

input elements whose type attribute is in the Checkbox state and whose checkedness state is true
input elements whose type attribute is in the Radio Button state and whose checkedness state is true
option elements whose selectedness is true
:indeterminate
The :indeterminate pseudo-class must match any element falling into one of the following categories:

input elements whose type attribute is in the Checkbox state and whose indeterminate IDL attribute is set to true
input elements whose type attribute is in the Radio Button state and whose radio button group contains no input elements whose checkedness state is true.
progress elements with no value content attribute
:default
The :default pseudo-class must match any element falling into one of the following categories:

button elements that are their form's default button
input elements whose type attribute is in the Submit Button or Image Button state, and that are their form's default button
input elements to which the checked attribute applies and that have a checked attribute
option elements that have a selected attribute
:placeholder-shown
The :placeholder-shown pseudo-class must match any element falling into one of the following categories:

input elements that have a placeholder attribute whose value is currently being presented to the user.
textarea elements that have a placeholder attribute whose value is currently being presented to the user.
:valid
The :valid pseudo-class must match any element falling into one of the following categories:

elements that are candidates for constraint validation and that satisfy their constraints
form elements that are not the form owner of any elements that themselves are candidates for constraint validation but do not satisfy their constraints
fieldset elements that have no descendant elements that themselves are candidates for constraint validation but do not satisfy their constraints
:invalid
The :invalid pseudo-class must match any element falling into one of the following categories:

elements that are candidates for constraint validation but that do not satisfy their constraints
form elements that are the form owner of one or more elements that themselves are candidates for constraint validation but do not satisfy their constraints
fieldset elements that have of one or more descendant elements that themselves are candidates for constraint validation but do not satisfy their constraints
:in-range
The :in-range pseudo-class must match all elements that are candidates for constraint validation, have range limitations, and that are neither suffering from an underflow nor suffering from an overflow.

:out-of-range
The :out-of-range pseudo-class must match all elements that are candidates for constraint validation, have range limitations, and that are either suffering from an underflow or suffering from an overflow.

:required
The :required pseudo-class must match any element falling into one of the following categories:

input elements that are required
select elements that have a required attribute
textarea elements that have a required attribute
:optional
The :optional pseudo-class must match any element falling into one of the following categories:

input elements to which the required attribute applies that are not required
select elements that do not have a required attribute
textarea elements that do not have a required attribute
:read-only
:read-write
The :read-write pseudo-class must match any element falling into one of the following categories, which for the purposes of Selectors are thus considered user-alterable: [SELECTORS]

input elements to which the readonly attribute applies, and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled)
textarea elements that do not have a readonly attribute, and that are not disabled
elements that are editing hosts or editable and are neither input elements nor textarea elements
The :read-only pseudo-class must match all other HTML elements.

:dir(ltr)
The :dir(ltr) pseudo-class must match all elements whose directionality is 'ltr'.

:dir(rtl)
The :dir(rtl) pseudo-class must match all elements whose directionality is 'rtl'.


Support: css-read-only-write
Chrome for Android	64+
Chrome	36+
iOS Safari	9.0+
UC Browser for Android	11.8+
Firefox	None
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	9+
Edge	13+
Android Browser	62+
Opera	23+

Source: caniuse.com

This specification does not define when an element matches the :lang() dynamic pseudo-class, as it is defined in sufficient detail in a language-agnostic fashion in the Selectors specification. [SELECTORS]

5 Microdata
5.1 Introduction
5.1.1 Overview
This section is non-normative.

Sometimes, it is desirable to annotate content with specific machine-readable labels, e.g. to allow generic scripts to provide services that are customized to the page, or to enable content from a variety of cooperating authors to be processed by a single script in a consistent manner.

For this purpose, authors can use the microdata features described in this section. Microdata allows nested groups of name-value pairs to be added to documents, in parallel with the existing content.

5.1.2 The basic syntax
This section is non-normative.

At a high level, microdata consists of a group of name-value pairs. The groups are called items, and each name-value pair is a property. Items and properties are represented by regular elements.

To create an item, the itemscope attribute is used.

To add a property to an item, the itemprop attribute is used on one of the item's descendants.

Here there are two items, each of which has the property "name":

<div itemscope>
 <p>My name is <span itemprop="name">Elizabeth</span>.</p>
</div>

<div itemscope>
 <p>My name is <span itemprop="name">Daniel</span>.</p>
</div>
Markup without the microdata-related attributes does not have any effect on the microdata model.

These two examples are exactly equivalent, at a microdata level, as the previous two examples respectively:

<div itemscope>
 <p>My <em>name</em> is <span itemprop="name">E<strong>liz</strong>abeth</span>.</p>
</div>

<section>
 <div itemscope>
  <aside>
   <p>My name is <span itemprop="name"><a href="/?user=daniel">Daniel</a></span>.</p>
  </aside>
 </div>
</section>
Properties generally have values that are strings.

Here the item has three properties:

<div itemscope>
 <p>My name is <span itemprop="name">Neil</span>.</p>
 <p>My band is called <span itemprop="band">Four Parts Water</span>.</p>
 <p>I am <span itemprop="nationality">British</span>.</p>
</div>
When a string value is a URL, it is expressed using the a element and its href attribute, the img element and its src attribute, or other elements that link to or embed external resources.

In this example, the item has one property, "image", whose value is a URL:

<div itemscope>
 <img itemprop="image" src="google-logo.png" alt="Google">
</div>
When a string value is in some machine-readable format unsuitable for human consumption, it is expressed using the value attribute of the data element, with the human-readable version given in the element's contents.

Here, there is an item with a property whose value is a product ID. The ID is not human-friendly, so the product's name is used the human-visible text instead of the ID.

<h1 itemscope>
 <data itemprop="product-id" value="9678AOU879">The Instigator 2000</data>
</h1>
For numeric data, the meter element and its value attribute can be used instead.

Here a rating is given using a meter element.

<div itemscope itemtype="http://schema.org/Product">
 <span itemprop="name">Panasonic White 60L Refrigerator</span>
 <img src="panasonic-fridge-60l-white.jpg" alt="">
  <div itemprop="aggregateRating"
       itemscope itemtype="http://schema.org/AggregateRating">
   <meter itemprop="ratingValue" min=0 value=3.5 max=5>Rated 3.5/5</meter>
   (based on <span itemprop="reviewCount">11</span> customer reviews)
  </div>
</div>
Similarly, for date- and time-related data, the time element and its datetime attribute can be used instead.

In this example, the item has one property, "birthday", whose value is a date:

<div itemscope>
 I was born on <time itemprop="birthday" datetime="2009-05-10">May 10th 2009</time>.
</div>
Properties can also themselves be groups of name-value pairs, by putting the itemscope attribute on the element that declares the property.

Items that are not part of others are called top-level microdata items.

In this example, the outer item represents a person, and the inner one represents a band:

<div itemscope>
 <p>Name: <span itemprop="name">Amanda</span></p>
 <p>Band: <span itemprop="band" itemscope> <span itemprop="name">Jazz Band</span> (<span itemprop="size">12</span> players)</span></p>
</div>
The outer item here has two properties, "name" and "band". The "name" is "Amanda", and the "band" is an item in its own right, with two properties, "name" and "size". The "name" of the band is "Jazz Band", and the "size" is "12".

The outer item in this example is a top-level microdata item.

Properties that are not descendants of the element with the itemscope attribute can be associated with the item using the itemref attribute. This attribute takes a list of IDs of elements to crawl in addition to crawling the children of the element with the itemscope attribute.

This example is the same as the previous one, but all the properties are separated from their items:

<div itemscope id="amanda" itemref="a b"></div>
<p id="a">Name: <span itemprop="name">Amanda</span></p>
<div id="b" itemprop="band" itemscope itemref="c"></div>
<div id="c">
 <p>Band: <span itemprop="name">Jazz Band</span></p>
 <p>Size: <span itemprop="size">12</span> players</p>
</div>
This gives the same result as the previous example. The first item has two properties, "name", set to "Amanda", and "band", set to another item. That second item has two further properties, "name", set to "Jazz Band", and "size", set to "12".

An item can have multiple properties with the same name and different values.

This example describes an ice cream, with two flavors:

<div itemscope>
 <p>Flavors in my favorite ice cream:</p>
 <ul>
  <li itemprop="flavor">Lemon sorbet</li>
  <li itemprop="flavor">Apricot sorbet</li>
 </ul>
</div>
This thus results in an item with two properties, both "flavor", having the values "Lemon sorbet" and "Apricot sorbet".

An element introducing a property can also introduce multiple properties at once, to avoid duplication when some of the properties have the same value.

Here we see an item with two properties, "favorite-color" and "favorite-fruit", both set to the value "orange":

<div itemscope>
 <span itemprop="favorite-color favorite-fruit">orange</span>
</div>
It's important to note that there is no relationship between the microdata and the content of the document where the microdata is marked up.

There is no semantic difference, for instance, between the following two examples:

<figure>
 <img src="castle.jpeg">
 <figcaption><span itemscope><span itemprop="name">The Castle</span></span> (1986)</figcaption>
</figure>
<span itemscope><meta itemprop="name" content="The Castle"></span>
<figure>
 <img src="castle.jpeg">
 <figcaption>The Castle (1986)</figcaption>
</figure>
Both have a figure with a caption, and both, completely unrelated to the figure, have an item with a name-value pair with the name "name" and the value "The Castle". The only difference is that if the user drags the caption out of the document, in the former case, the item will be included in the drag-and-drop data. In neither case is the image in any way associated with the item.

5.1.3 Typed items
This section is non-normative.

The examples in the previous section show how information could be marked up on a page that doesn't expect its microdata to be re-used. Microdata is most useful, though, when it is used in contexts where other authors and readers are able to cooperate to make new uses of the markup.

For this purpose, it is necessary to give each item a type, such as "https://example.com/person", or "https://example.org/cat", or "https://band.example.net/". Types are identified as URLs.

The type for an item is given as the value of an itemtype attribute on the same element as the itemscope attribute.

Here, the item's type is "https://example.org/animals#cat":

<section itemscope itemtype="https://example.org/animals#cat">
 <h1 itemprop="name">Hedral</h1>
 <p itemprop="desc">Hedral is a male american domestic
 shorthair, with a fluffy black fur with white paws and belly.</p>
 <img itemprop="img" src="hedral.jpeg" alt="" title="Hedral, age 18 months">
</section>
In this example the "https://example.org/animals#cat" item has three properties, a "name" ("Hedral"), a "desc" ("Hedral is..."), and an "img" ("hedral.jpeg").

The type gives the context for the properties, thus selecting a vocabulary: a property named "class" given for an item with the type "https://census.example/person" might refer to the economic class of an individual, while a property named "class" given for an item with the type "https://example.com/school/teacher" might refer to the classroom a teacher has been assigned. Several types can share a vocabulary. For example, the types "https://example.org/people/teacher" and "https://example.org/people/engineer" could be defined to use the same vocabulary (though maybe some properties would not be especially useful in both cases, e.g. maybe the "https://example.org/people/engineer" type might not typically be used with the "classroom" property). Multiple types defined to use the same vocabulary can be given for a single item by listing the URLs as a space-separated list in the attribute' value. An item cannot be given two types if they do not use the same vocabulary, however.

5.1.4 Global identifiers for items
This section is non-normative.

Sometimes, an item gives information about a topic that has a global identifier. For example, books can be identified by their ISBN number.

Vocabularies (as identified by the itemtype attribute) can be designed such that items get associated with their global identifier in an unambiguous way by expressing the global identifiers as URLs given in an itemid attribute.

The exact meaning of the URLs given in itemid attributes depends on the vocabulary used.

Here, an item is talking about a particular book:

<dl itemscope
    itemtype="https://vocab.example.net/book"
    itemid="urn:isbn:0-330-34032-8">
 <dt>Title
 <dd itemprop="title">The Reality Dysfunction
 <dt>Author
 <dd itemprop="author">Peter F. Hamilton
 <dt>Publication date
 <dd><time itemprop="pubdate" datetime="1996-01-26">26 January 1996</time>
</dl>
The "https://vocab.example.net/book" vocabulary in this example would define that the itemid attribute takes a urn: URL pointing to the ISBN of the book.

5.1.5 Selecting names when defining vocabularies
This section is non-normative.

Using microdata means using a vocabulary. For some purposes, an ad-hoc vocabulary is adequate. For others, a vocabulary will need to be designed. Where possible, authors are encouraged to re-use existing vocabularies, as this makes content re-use easier.

When designing new vocabularies, identifiers can be created either using URLs, or, for properties, as plain words (with no dots or colons). For URLs, conflicts with other vocabularies can be avoided by only using identifiers that correspond to pages that the author has control over.

For instance, if Jon and Adam both write content at example.com, at https://example.com/~jon/... and https://example.com/~adam/... respectively, then they could select identifiers of the form "https://example.com/~jon/name" and "https://example.com/~adam/name" respectively.

Properties whose names are just plain words can only be used within the context of the types for which they are intended; properties named using URLs can be reused in items of any type. If an item has no type, and is not part of another item, then if its properties have names that are just plain words, they are not intended to be globally unique, and are instead only intended for limited use. Generally speaking, authors are encouraged to use either properties with globally unique names (URLs) or ensure that their items are typed.

Here, an item is an "https://example.org/animals#cat", and most of the properties have names that are words defined in the context of that type. There are also a few additional properties whose names come from other vocabularies.

<section itemscope itemtype="https://example.org/animals#cat">
 <h1 itemprop="name https://example.com/fn">Hedral</h1>
 <p itemprop="desc">Hedral is a male american domestic
 shorthair, with a fluffy <span
 itemprop="https://example.com/color">black</span> fur with <span
 itemprop="https://example.com/color">white</span> paws and belly.</p>
 <img itemprop="img" src="hedral.jpeg" alt="" title="Hedral, age 18 months">
</section>
This example has one item with the type "https://example.org/animals#cat" and the following properties:

Property	Value
name	Hedral
https://example.com/fn	Hedral
desc	Hedral is a male american domestic shorthair, with a fluffy black fur with white paws and belly.
https://example.com/color	black
https://example.com/color	white
img	.../hedral.jpeg
5.2 Encoding microdata
5.2.1 The microdata model
The microdata model consists of groups of name-value pairs known as items.

Each group is known as an item. Each item can have item types, a global identifier (if the vocabulary specified by the item types support global identifiers for items), and a list of name-value pairs. Each name in the name-value pair is known as a property, and each property has one or more values. Each value is either a string or itself a group of name-value pairs (an item). The names are unordered relative to each other, but if a particular name has multiple values, they do have a relative order.

5.2.2 Items
Every HTML element may have an itemscope attribute specified. The itemscope attribute is a boolean attribute.

An element with the itemscope attribute specified creates a new item, a group of name-value pairs.

Elements with an itemscope attribute may have an itemtype attribute specified, to give the item types of the item.

The itemtype attribute, if specified, must have a value that is an unordered set of unique space-separated tokens that are case-sensitive, each of which is a valid URL string that is an absolute URL, and all of which are defined to use the same vocabulary. The attribute's value must have at least one token.

The item types of an item are the tokens obtained by splitting the element's itemtype attribute's value on ASCII whitespace. If the itemtype attribute is missing or parsing it in this way finds no tokens, the item is said to have no item types.

The item types must all be types defined in applicable specifications and must all be defined to use the same vocabulary.

Except if otherwise specified by that specification, the URLs given as the item types should not be automatically dereferenced.

A specification could define that its item type can be dereferenced to provide the user with help information, for example. In fact, vocabulary authors are encouraged to provide useful information at the given URL.

Item types are opaque identifiers, and user agents must not dereference unknown item types, or otherwise deconstruct them, in order to determine how to process items that use them.

The itemtype attribute must not be specified on elements that do not have an itemscope attribute specified.

An item is said to be a typed item when either it has an item type, or it is the value of a property of a typed item. The relevant types for a typed item is the item's item types, if it has any, or else is the relevant types of the item for which it is a property's value.

Elements with an itemscope attribute and an itemtype attribute that references a vocabulary that is defined to support global identifiers for items may also have an itemid attribute specified, to give a global identifier for the item, so that it can be related to other items on pages elsewhere on the Web.

The itemid attribute, if specified, must have a value that is a valid URL potentially surrounded by spaces.

The global identifier of an item is the value of its element's itemid attribute, if it has one, parsed relative to the node document of the element on which the attribute is specified. If the itemid attribute is missing or if resolving it fails, it is said to have no global identifier.

The itemid attribute must not be specified on elements that do not have both an itemscope attribute and an itemtype attribute specified, and must not be specified on elements with an itemscope attribute whose itemtype attribute specifies a vocabulary that does not support global identifiers for items, as defined by that vocabulary's specification.

The exact meaning of a global identifier is determined by the vocabulary's specification. It is up to such specifications to define whether multiple items with the same global identifier (whether on the same page or on different pages) are allowed to exist, and what the processing rules for that vocabulary are with respect to handling the case of multiple items with the same ID.

Elements with an itemscope attribute may have an itemref attribute specified, to give a list of additional elements to crawl to find the name-value pairs of the item.

The itemref attribute, if specified, must have a value that is an unordered set of unique space-separated tokens that are case-sensitive, consisting of IDs of elements in the same tree.

The itemref attribute must not be specified on elements that do not have an itemscope attribute specified.

The itemref attribute is not part of the microdata data model. It is merely a syntactic construct to aid authors in adding annotations to pages where the data to be annotated does not follow a convenient tree structure. For example, it allows authors to mark up data in a table so that each column defines a separate item, while keeping the properties in the cells.

This example shows a simple vocabulary used to describe the products of a model railway manufacturer. The vocabulary has just five property names:

product-code
An integer that names the product in the manufacturer's catalog.
name
A brief description of the product.
scale
One of "HO", "1", or "Z" (potentially with leading or trailing whitespace), indicating the scale of the product.
digital
If present, one of "Digital", "Delta", or "Systems" (potentially with leading or trailing whitespace) indicating that the product has a digital decoder of the given type.
track-type
For track-specific products, one of "K", "M", "C" (potentially with leading or trailing whitespace) indicating the type of track for which the product is intended.
This vocabulary has four defined item types:

https://md.example.com/loco
Rolling stock with an engine
https://md.example.com/passengers
Passenger rolling stock
https://md.example.com/track
Track pieces
https://md.example.com/lighting
Equipment with lighting
Each item that uses this vocabulary can be given one or more of these types, depending on what the product is.

Thus, a locomotive might be marked up as:

<dl itemscope itemtype="https://md.example.com/loco
                        https://md.example.com/lighting">
 <dt>Name:
 <dd itemprop="name">Tank Locomotive (DB 80)
 <dt>Product code:
 <dd itemprop="product-code">33041
 <dt>Scale:
 <dd itemprop="scale">HO
 <dt>Digital:
 <dd itemprop="digital">Delta
</dl>
A turnout lantern retrofit kit might be marked up as:

<dl itemscope itemtype="https://md.example.com/track
                       https://md.example.com/lighting">
 <dt>Name:
 <dd itemprop="name">Turnout Lantern Kit
 <dt>Product code:
 <dd itemprop="product-code">74470
 <dt>Purpose:
 <dd>For retrofitting 2 <span itemprop="track-type">C</span> Track
 turnouts. <meta itemprop="scale" content="HO">
</dl>
A passenger car with no lighting might be marked up as:

<dl itemscope itemtype="https://md.example.com/passengers">
 <dt>Name:
 <dd itemprop="name">Express Train Passenger Car (DB Am 203)
 <dt>Product code:
 <dd itemprop="product-code">8710
 <dt>Scale:
 <dd itemprop="scale">Z
</dl>
Great care is necessary when creating new vocabularies. Often, a hierarchical approach to types can be taken that results in a vocabulary where each item only ever has a single type, which is generally much simpler to manage.

5.2.3 Names: the itemprop attribute
Every HTML element may have an itemprop attribute specified, if doing so adds one or more properties to one or more items (as defined below).

The itemprop attribute, if specified, must have a value that is an unordered set of unique space-separated tokens that are case-sensitive, representing the names of the name-value pairs that it adds. The attribute's value must have at least one token.

Each token must be either:

If the item is a typed item: a defined property name allowed in this situation according to the specification that defines the relevant types for the item, or
A valid URL string that is an absolute URL defined as an item property name allowed in this situation by a vocabulary specification, or
A valid URL string that is an absolute URL, used as a proprietary item property name (i.e. one used by the author for private purposes, not defined in a public specification), or
If the item is not a typed item: a string that contains no U+002E FULL STOP characters (.) and no U+003A COLON characters (:), used as a proprietary item property name (i.e. one used by the author for private purposes, not defined in a public specification).
Specifications that introduce defined property names must ensure all such property names contain no U+002E FULL STOP characters (.), no U+003A COLON characters (:), and no ASCII whitespace.

The rules above disallow U+003A COLON characters (:) in non-URL values because otherwise they could not be distinguished from URLs. Values with U+002E FULL STOP characters (.) are reserved for future extensions. ASCII whitespace are disallowed because otherwise the values would be parsed as multiple tokens.

When an element with an itemprop attribute adds a property to multiple items, the requirement above regarding the tokens applies for each item individually.

The property names of an element are the tokens that the element's itemprop attribute is found to contain when its value is split on ASCII whitespace, with the order preserved but with duplicates removed (leaving only the first occurrence of each name).

Within an item, the properties are unordered with respect to each other, except for properties with the same name, which are ordered in the order they are given by the algorithm that defines the properties of an item.

In the following example, the "a" property has the values "1" and "2", in that order, but whether the "a" property comes before the "b" property or not is not important:

<div itemscope>
 <p itemprop="a">1</p>
 <p itemprop="a">2</p>
 <p itemprop="b">test</p>
</div>
Thus, the following is equivalent:

<div itemscope>
 <p itemprop="b">test</p>
 <p itemprop="a">1</p>
 <p itemprop="a">2</p>
</div>
As is the following:

<div itemscope>
 <p itemprop="a">1</p>
 <p itemprop="b">test</p>
 <p itemprop="a">2</p>
</div>
And the following:

<div id="x">
 <p itemprop="a">1</p>
</div>
<div itemscope itemref="x">
 <p itemprop="b">test</p>
 <p itemprop="a">2</p>
</div>
5.2.4 Values
The property value of a name-value pair added by an element with an itemprop attribute is as given for the first matching case in the following list:

If the element also has an itemscope attribute
The value is the item created by the element.

If the element is a meta element
The value is the value of the element's content attribute, if any, or the empty string if there is no such attribute.

If the element is an audio, embed, iframe, img, source, track, or video element
The value is the resulting URL string that results from parsing the value of the element's src attribute relative to the node document of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

If the element is an a, area, or link element
The value is the resulting URL string that results from parsing the value of the element's href attribute relative to the node document of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

If the element is an object element
The value is the resulting URL string that results from parsing the value of the element's data attribute relative to the node document of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

If the element is a data element
The value is the value of the element's value attribute, if it has one, or the empty string otherwise.

If the element is a meter element
The value is the value of the element's value attribute, if it has one, or the empty string otherwise.

If the element is a time element
The value is the element's datetime value.

Otherwise
The value is the element's textContent.

The URL property elements are the a, area, audio, embed, iframe, img, link, object, source, track, and video elements.

If a property's value, as defined by the property's definition, is an absolute URL, the property must be specified using a URL property element.

These requirements do not apply just because a property value happens to match the syntax for a URL. They only apply if the property is explicitly defined as taking such a value.

For example, a book about the first moon landing could be called "mission:moon". A "title" property from a vocabulary that defines a title as being a string would not expect the title to be given in an a element, even though it looks like a URL. On the other hand, if there was a (rather narrowly scoped!) vocabulary for "books whose titles look like URLs" which had a "title" property defined to take a URL, then the property would expect the title to be given in an a element (or one of the other URL property elements), because of the requirement above.

5.2.5 Associating names with items
To find the properties of an item defined by the element root, the user agent must run the following steps. These steps are also used to flag microdata errors.

Let results, memory, and pending be empty lists of elements.

Add the element root to memory.

Add the child elements of root, if any, to pending.

If root has an itemref attribute, split the value of that itemref attribute on ASCII whitespace. For each resulting token ID, if there is an element in the tree of root with the ID ID, then add the first such element to pending.

While pending is not empty:

Remove an element from pending and let current be that element.

If current is already in memory, there is a microdata error; continue.

Add current to memory.

If current does not have an itemscope attribute, then: add all the child elements of current to pending.

If current has an itemprop attribute specified and has one or more property names, then add current to results.

Sort results in tree order.

Return results.

A document must not contain any items for which the algorithm to find the properties of an item finds any microdata errors.

An item is a top-level microdata item if its element does not have an itemprop attribute.

All itemref attributes in a Document must be such that there are no cycles in the graph formed from representing each item in the Document as a node in the graph and each property of an item whose value is another item as an edge in the graph connecting those two items.

A document must not contain any elements that have an itemprop attribute that would not be found to be a property of any of the items in that document were their properties all to be determined.

In this example, a single license statement is applied to two works, using itemref from the items representing the works:

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Photo gallery</title>
 </head>
 <body>
  <h1>My photos</h1>
  <figure itemscope itemtype="http://n.whatwg.org/work" itemref="licenses">
   <img itemprop="work" src="images/house.jpeg" alt="A white house, boarded up, sits in a forest.">
   <figcaption itemprop="title">The house I found.</figcaption>
  </figure>
  <figure itemscope itemtype="http://n.whatwg.org/work" itemref="licenses">
   <img itemprop="work" src="images/mailbox.jpeg" alt="Outside the house is a mailbox. It has a leaflet inside.">
   <figcaption itemprop="title">The mailbox.</figcaption>
  </figure>
  <footer>
   <p id="licenses">All images licensed under the <a itemprop="license"
   href="http://www.opensource.org/licenses/mit-license.php">MIT
   license</a>.</p>
  </footer>
 </body>
</html>
The above results in two items with the type "http://n.whatwg.org/work", one with:

work
images/house.jpeg
title
The house I found.
license
http://www.opensource.org/licenses/mit-license.php
...and one with:

work
images/mailbox.jpeg
title
The mailbox.
license
http://www.opensource.org/licenses/mit-license.php
5.2.6 Microdata and other namespaces
Currently, the itemscope, itemprop, and other microdata attributes are only defined for HTML elements. This means that attributes with the literal names "itemscope", "itemprop", etc, do not cause microdata processing to occur on elements in other namespaces, such as SVG.

Thus, in the following example there is only one item, not two.

<p itemscope></p> <!-- this is an item (with no properties and no type) -->
<svg itemscope></svg> <!-- this is not, it's just an SVG svg element with an invalid unknown attribute -->
5.3 Sample microdata vocabularies
The vocabularies in this section are primarily intended to demonstrate how a vocabulary is specified, though they are also usable in their own right.

5.3.1 vCard
An item with the item type http://microformats.org/profile/hcard represents a person's or organization's contact information.

This vocabulary does not support global identifiers for items.

The following are the type's defined property names. They are based on the vocabulary defined in the vCard 4.0 specification and its extensions, where more information on how to interpret the values can be found. [RFC6350]

kind
Describes what kind of contact the item represents.

The value must be text that, when compared in a case-sensitive manner, is equal to one of the kind strings.

A single property with the name kind may be present within each item with the type http://microformats.org/profile/hcard.

fn
Gives the formatted text corresponding to the name of the person or organization.

The value must be text.

Exactly one property with the name fn must be present within each item with the type http://microformats.org/profile/hcard.

n
Gives the structured name of the person or organization.

The value must be an item with zero or more of each of the family-name, given-name, additional-name, honorific-prefix, and honorific-suffix properties.

Exactly one property with the name n must be present within each item with the type http://microformats.org/profile/hcard.

family-name (inside n)
Gives the family name of the person, or the full name of the organization.

The value must be text.

Any number of properties with the name family-name may be present within the item that forms the value of the n property of an item with the type http://microformats.org/profile/hcard.

given-name (inside n)
Gives the given-name of the person.

The value must be text.

Any number of properties with the name given-name may be present within the item that forms the value of the n property of an item with the type http://microformats.org/profile/hcard.

additional-name (inside n)
Gives the any additional names of the person.

The value must be text.

Any number of properties with the name additional-name may be present within the item that forms the value of the n property of an item with the type http://microformats.org/profile/hcard.

honorific-prefix (inside n)
Gives the honorific prefix of the person.

The value must be text.

Any number of properties with the name honorific-prefix may be present within the item that forms the value of the n property of an item with the type http://microformats.org/profile/hcard.

honorific-suffix (inside n)
Gives the honorific suffix of the person.

The value must be text.

Any number of properties with the name honorific-suffix may be present within the item that forms the value of the n property of an item with the type http://microformats.org/profile/hcard.

nickname
Gives the nickname of the person or organization.

The nickname is the descriptive name given instead of or in addition to the one belonging to a person, place, or thing. It can also be used to specify a familiar form of a proper name specified by the fn or n properties.

The value must be text.

Any number of properties with the name nickname may be present within each item with the type http://microformats.org/profile/hcard.

photo
Gives a photograph of the person or organization.

The value must be an absolute URL.

Any number of properties with the name photo may be present within each item with the type http://microformats.org/profile/hcard.

bday
Gives the birth date of the person or organization.

The value must be a valid date string.

A single property with the name bday may be present within each item with the type http://microformats.org/profile/hcard.

anniversary
Gives the birth date of the person or organization.

The value must be a valid date string.

A single property with the name anniversary may be present within each item with the type http://microformats.org/profile/hcard.

sex
Gives the biological sex of the person.

The value must be one of F, meaning "female", M, meaning "male", N, meaning "none or not applicable", O, meaning "other", or U, meaning "unknown".

A single property with the name sex may be present within each item with the type http://microformats.org/profile/hcard.

gender-identity
Gives the gender identity of the person.

The value must be text.

A single property with the name gender-identity may be present within each item with the type http://microformats.org/profile/hcard.

adr
Gives the delivery address of the person or organization.

The value must be an item with zero or more type, post-office-box, extended-address, and street-address properties, and optionally a locality property, optionally a region property, optionally a postal-code property, and optionally a country-name property.

If no type properties are present within an item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard, then the address type string work is implied.

Any number of properties with the name adr may be present within each item with the type http://microformats.org/profile/hcard.

type (inside adr)
Gives the type of delivery address.

The value must be text that, when compared in a case-sensitive manner, is equal to one of the address type strings.

Any number of properties with the name type may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard, but within each such adr property item there must only be one type property per distinct value.

post-office-box (inside adr)
Gives the post office box component of the delivery address of the person or organization.

The value must be text.

Any number of properties with the name post-office-box may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

The vCard specification urges authors not to use this field.

extended-address (inside adr)
Gives an additional component of the delivery address of the person or organization.

The value must be text.

Any number of properties with the name extended-address may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

The vCard specification urges authors not to use this field.

street-address (inside adr)
Gives the street address component of the delivery address of the person or organization.

The value must be text.

Any number of properties with the name street-address may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

locality (inside adr)
Gives the locality component (e.g. city) of the delivery address of the person or organization.

The value must be text.

A single property with the name locality may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

region (inside adr)
Gives the region component (e.g. state or province) of the delivery address of the person or organization.

The value must be text.

A single property with the name region may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

postal-code (inside adr)
Gives the postal code component of the delivery address of the person or organization.

The value must be text.

A single property with the name postal-code may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

country-name (inside adr)
Gives the country name component of the delivery address of the person or organization.

The value must be text.

A single property with the name country-name may be present within the item that forms the value of an adr property of an item with the type http://microformats.org/profile/hcard.

tel
Gives the telephone number of the person or organization.

The value must be either text that can be interpreted as a telephone number as defined in the CCITT specifications E.163 and X.121, or an item with zero or more type properties and exactly one value property. [E163] [X121]

If no type properties are present within an item that forms the value of a tel property of an item with the type http://microformats.org/profile/hcard, or if the value of such a tel property is text, then the telephone type string voice is implied.

Any number of properties with the name tel may be present within each item with the type http://microformats.org/profile/hcard.

type (inside tel)
Gives the type of telephone number.

The value must be text that, when compared in a case-sensitive manner, is equal to one of the telephone type strings.

Any number of properties with the name type may be present within the item that forms the value of a tel property of an item with the type http://microformats.org/profile/hcard, but within each such tel property item there must only be one type property per distinct value.

value (inside tel)
Gives the actual telephone number of the person or organization.

The value must be text that can be interpreted as a telephone number as defined in the CCITT specifications E.163 and X.121. [E163] [X121]

Exactly one property with the name value must be present within the item that forms the value of a tel property of an item with the type http://microformats.org/profile/hcard.

email
Gives the e-mail address of the person or organization.

The value must be text.

Any number of properties with the name email may be present within each item with the type http://microformats.org/profile/hcard.

impp
Gives a URL for instant messaging and presence protocol communications with the person or organization.

The value must be an absolute URL.

Any number of properties with the name impp may be present within each item with the type http://microformats.org/profile/hcard.

lang
Gives a language understood by the person or organization.

The value must be a valid BCP 47 language tag. [BCP47].

Any number of properties with the name lang may be present within each item with the type http://microformats.org/profile/hcard.

tz
Gives the time zone of the person or organization.

The value must be text and must match the following syntax:

Either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).
A valid non-negative integer that is exactly two digits long and that represents a number in the range 00..23.
A U+003A COLON character (:).
A valid non-negative integer that is exactly two digits long and that represents a number in the range 00..59.
Any number of properties with the name tz may be present within each item with the type http://microformats.org/profile/hcard.

geo
Gives the geographical position of the person or organization.

The value must be text and must match the following syntax:

Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).
One or more ASCII digits.
Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.
A U+003B SEMICOLON character (;).
Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).
One or more ASCII digits.
Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.
The optional components marked with an asterisk (*) should be included, and should have six digits each.

The value specifies latitude and longitude, in that order (i.e., "LAT LON" ordering), in decimal degrees. The longitude represents the location east and west of the prime meridian as a positive or negative real number, respectively. The latitude represents the location north and south of the equator as a positive or negative real number, respectively.

Any number of properties with the name geo may be present within each item with the type http://microformats.org/profile/hcard.

title
Gives the job title, functional position or function of the person or organization.

The value must be text.

Any number of properties with the name title may be present within each item with the type http://microformats.org/profile/hcard.

role
Gives the role, occupation, or business category of the person or organization.

The value must be text.

Any number of properties with the name role may be present within each item with the type http://microformats.org/profile/hcard.

logo
Gives the logo of the person or organization.

The value must be an absolute URL.

Any number of properties with the name logo may be present within each item with the type http://microformats.org/profile/hcard.

agent
Gives the contact information of another person who will act on behalf of the person or organization.

The value must be either an item with the type http://microformats.org/profile/hcard, or an absolute URL, or text.

Any number of properties with the name agent may be present within each item with the type http://microformats.org/profile/hcard.

org
Gives the name and units of the organization.

The value must be either text or an item with one organization-name property and zero or more organization-unit properties.

Any number of properties with the name org may be present within each item with the type http://microformats.org/profile/hcard.

organization-name (inside org)
Gives the name of the organization.

The value must be text.

Exactly one property with the name organization-name must be present within the item that forms the value of an org property of an item with the type http://microformats.org/profile/hcard.

organization-unit (inside org)
Gives the name of the organization unit.

The value must be text.

Any number of properties with the name organization-unit may be present within the item that forms the value of the org property of an item with the type http://microformats.org/profile/hcard.

member
Gives a URL that represents a member of the group.

The value must be an absolute URL.

Any number of properties with the name member may be present within each item with the type http://microformats.org/profile/hcard if the item also has a property with the name kind whose value is "group".

related
Gives a relationship to another entity.

The value must be an item with one url property and one rel properties.

Any number of properties with the name related may be present within each item with the type http://microformats.org/profile/hcard.

url (inside related)
Gives the URL for the related entity.

The value must be an absolute URL.

Exactly one property with the name url must be present within the item that forms the value of a related property of an item with the type http://microformats.org/profile/hcard.

rel (inside related)
Gives the relationship between the entity and the related entity.

The value must be text that, when compared in a case-sensitive manner, is equal to one of the relationship strings.

Exactly one property with the name rel must be present within the item that forms the value of a related property of an item with the type http://microformats.org/profile/hcard.

categories
Gives the name of a category or tag that the person or organization could be classified as.

The value must be text.

Any number of properties with the name categories may be present within each item with the type http://microformats.org/profile/hcard.

note
Gives supplemental information or a comment about the person or organization.

The value must be text.

Any number of properties with the name note may be present within each item with the type http://microformats.org/profile/hcard.

rev
Gives the revision date and time of the contact information.

The value must be text that is a valid global date and time string.

The value distinguishes the current revision of the information for other renditions of the information.

Any number of properties with the name rev may be present within each item with the type http://microformats.org/profile/hcard.

sound
Gives a sound file relating to the person or organization.

The value must be an absolute URL.

Any number of properties with the name sound may be present within each item with the type http://microformats.org/profile/hcard.

uid
Gives a globally unique identifier corresponding to the person or organization.

The value must be text.

A single property with the name uid may be present within each item with the type http://microformats.org/profile/hcard.

url
Gives a URL relating to the person or organization.

The value must be an absolute URL.

Any number of properties with the name url may be present within each item with the type http://microformats.org/profile/hcard.

The kind strings are:

individual
Indicates a single entity (e.g. a person).

group
Indicates multiple entities (e.g. a mailing list).

org
Indicates a single entity that is not a person (e.g. a company).

location
Indicates a geographical place (e.g. an office building).

The address type strings are:

home
Indicates a delivery address for a residence.

work
Indicates a delivery address for a place of work.

The telephone type strings are:

home
Indicates a residential number.

work
Indicates a telephone number for a place of work.

text
Indicates that the telephone number supports text messages (SMS).

voice
Indicates a voice telephone number.

fax
Indicates a facsimile telephone number.

cell
Indicates a cellular telephone number.

video
Indicates a video conferencing telephone number.

pager
Indicates a paging device telephone number.

textphone
Indicates a telecommunication device for people with hearing or speech difficulties.

The relationship strings are:

emergency
An emergency contact.

agent
Another entity that acts on behalf of this entity.

contact
acquaintance
friend
met
worker
colleague
resident
neighbor
child
parent
sibling
spouse
kin
muse
crush
date
sweetheart
me
Has the meaning defined in XFN. [XFN]

5.3.1.1 Conversion to vCard
Given a list of nodes nodes in a Document, a user agent must run the following algorithm to extract any vCard data represented by those nodes (only the first vCard is returned):

If none of the nodes in nodes are items with the item type http://microformats.org/profile/hcard, then there is no vCard. Abort the algorithm, returning nothing.

Let node be the first node in nodes that is an item with the item type http://microformats.org/profile/hcard.

Let output be an empty string.

Add a vCard line with the type "BEGIN" and the value "VCARD" to output.

Add a vCard line with the type "PROFILE" and the value "VCARD" to output.

Add a vCard line with the type "VERSION" and the value "4.0" to output.

Add a vCard line with the type "SOURCE" and the result of escaping the vCard text string that is the document's URL as the value to output.

If the title element is not null, add a vCard line with the type "NAME" and with the result of escaping the vCard text string obtained from the textContent of the title element as the value to output.

Let sex be the empty string.

Let gender-identity be the empty string.

For each element element that is a property of the item node: for each name name in element's property names, run the following substeps:

Let parameters be an empty set of name-value pairs.

Run the appropriate set of substeps from the following list. The steps will set a variable value, which is used in the next step.

If the property's value is an item subitem and name is n
Let value be the empty string.

Append to value the result of collecting the first vCard subproperty named family-name in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named given-name in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named additional-name in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named honorific-prefix in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named honorific-suffix in subitem.

If the property's value is an item subitem and name is adr
Let value be the empty string.

Append to value the result of collecting vCard subproperties named post-office-box in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting vCard subproperties named extended-address in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting vCard subproperties named street-address in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named locality in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named region in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named postal-code in subitem.

Append a U+003B SEMICOLON character (;) to value.
Append to value the result of collecting the first vCard subproperty named country-name in subitem.

If there is a property named type in subitem, and the first such property has a value that is not an item and whose value consists only of ASCII alphanumerics, then add a parameter named "TYPE" whose value is the value of that property to parameters.

If the property's value is an item subitem and name is org
Let value be the empty string.

Append to value the result of collecting the first vCard subproperty named organization-name in subitem.

For each property named organization-unit in subitem, run the following steps:

If the value of the property is an item, then skip this property.

Append a U+003B SEMICOLON character (;) to value.

Append the result of escaping the vCard text string given by the value of the property to value.

If the property's value is an item subitem with the item type http://microformats.org/profile/hcard and name is related
Let value be the empty string.

If there is a property named url in subitem, and its element is a URL property element, then append the result of escaping the vCard text string given by the value of the first such property to value, and add a parameter with the name "VALUE" and the value "URI" to parameters.

If there is a property named rel in subitem, and the first such property has a value that is not an item and whose value consists only of ASCII alphanumerics, then add a parameter named "RELATION" whose value is the value of that property to parameters.

If the property's value is an item and name is none of the above
Let value be the result of collecting the first vCard subproperty named value in subitem.

If there is a property named type in subitem, and the first such property has a value that is not an item and whose value consists only of ASCII alphanumeric, then add a parameter named "TYPE" whose value is the value of that property to parameters.

If the property's value is not an item and its name is sex
If this is the first such property to be found, set sex to the property's value.

If the property's value is not an item and its name is gender-identity
If this is the first such property to be found, set gender-identity to the property's value.

Otherwise (the property's value is not an item)
Let value be the property's value.

If element is one of the URL property elements, add a parameter with the name "VALUE" and the value "URI" to parameters.

Otherwise, if name is bday or anniversary and the value is a valid date string, add a parameter with the name "VALUE" and the value "DATE" to parameters.

Otherwise, if name is rev and the value is a valid global date and time string, add a parameter with the name "VALUE" and the value "DATE-TIME" to parameters.

Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE SOLIDUS character (\).

Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

Unless name is geo, prefix every U+003B SEMICOLON character (;) in value with a U+005C REVERSE SOLIDUS character (\).

Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Add a vCard line with the type name, the parameters parameters, and the value value to output.

If either sex or gender-identity has a value that is not the empty string, add a vCard line with the type "GENDER" and the value consisting of the concatenation of sex, a U+003B SEMICOLON character (;), and gender-identity to output.

Add a vCard line with the type "END" and the value "VCARD" to output.

When the above algorithm says that the user agent is to add a vCard line consisting of a type type, optionally some parameters, and a value value to a string output, it must run the following steps:

Let line be an empty string.

Append type, converted to ASCII uppercase, to line.

If there are any parameters, then for each parameter, in the order that they were added, run these substeps:

Append a U+003B SEMICOLON character (;) to line.

Append the parameter's name to line.

Append a U+003D EQUALS SIGN character (=) to line.

Append the parameter's value to line.

Append a U+003A COLON character (:) to line.

Append value to line.

Let maximum length be 75.

While line's length is greater than maximum length:

Append the first maximum length code points of line to output.

Remove the first maximum length code points from line.

Append a U+000D CARRIAGE RETURN character (CR) to output.

Append a U+000A LINE FEED character (LF) to output.

Append a U+0020 SPACE character to output.

Let maximum length be 74.

Append (what remains of) line to output.

Append a U+000D CARRIAGE RETURN character (CR) to output.

Append a U+000A LINE FEED character (LF) to output.

When the steps above require the user agent to obtain the result of collecting vCard subproperties named subname in subitem, the user agent must run the following steps:

Let value be the empty string.

For each property named subname in the item subitem, run the following substeps:

If the value of the property is itself an item, then skip this property.

If this is not the first property named subname in subitem (ignoring any that were skipped by the previous step), then append a U+002C COMMA character (,) to value.

Append the result of escaping the vCard text string given by the value of the property to value.

Return value.

When the steps above require the user agent to obtain the result of collecting the first vCard subproperty named subname in subitem, the user agent must run the following steps:

If there are no properties named subname in subitem, then return the empty string.

If the value of the first property named subname in subitem is an item, then return the empty string.

Return the result of escaping the vCard text string given by the value of the first property named subname in subitem.

When the above algorithms say the user agent is to escape the vCard text string value, the user agent must use the following steps:

Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE SOLIDUS character (\).

Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

Prefix every U+003B SEMICOLON character (;) in value with a U+005C REVERSE SOLIDUS character (\).

Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Return the mutated value.

This algorithm can generate invalid vCard output, if the input does not conform to the rules described for the http://microformats.org/profile/hcard item type and defined property names.

5.3.1.2 Examples
This section is non-normative.

Here is a long example vCard for a fictional character called "Jack Bauer":

<section id="jack" itemscope itemtype="http://microformats.org/profile/hcard">
 <h1 itemprop="fn">
  <span itemprop="n" itemscope>
   <span itemprop="given-name">Jack</span>
   <span itemprop="family-name">Bauer</span>
  </span>
 </h1>
 <img itemprop="photo" alt="" src="jack-bauer.jpg">
 <p itemprop="org" itemscope>
  <span itemprop="organization-name">Counter-Terrorist Unit</span>
  (<span itemprop="organization-unit">Los Angeles Division</span>)
 </p>
 <p>
  <span itemprop="adr" itemscope>
   <span itemprop="street-address">10201 W. Pico Blvd.</span><br>
   <span itemprop="locality">Los Angeles</span>,
   <span itemprop="region">CA</span>
   <span itemprop="postal-code">90064</span><br>
   <span itemprop="country-name">United States</span><br>
  </span>
  <span itemprop="geo">34.052339;-118.410623</span>
 </p>
 <h2>Assorted Contact Methods</h2>
 <ul>
  <li itemprop="tel" itemscope>
   <span itemprop="value">+1 (310) 597 3781</span> <span itemprop="type">work</span>
   <meta itemprop="type" content="voice">
  </li>
  <li><a itemprop="url" href="https://en.wikipedia.org/wiki/Jack_Bauer">I'm on Wikipedia</a>
  so you can leave a message on my user talk page.</li>
  <li><a itemprop="url" href="http://www.jackbauerfacts.com/">Jack Bauer Facts</a></li>
  <li itemprop="email"><a href="mailto:j.bauer@la.ctu.gov.invalid">j.bauer@la.ctu.gov.invalid</a></li>
  <li itemprop="tel" itemscope>
   <span itemprop="value">+1 (310) 555 3781</span> <span>
   <meta itemprop="type" content="cell">mobile phone</span>
  </li>
 </ul>
 <ins datetime="2008-07-20 21:00:00+01:00">
  <meta itemprop="rev" content="2008-07-20 21:00:00+01:00">
  <p itemprop="tel" itemscope><strong>Update!</strong>
  My new <span itemprop="type">home</span> phone number is
  <span itemprop="value">01632 960 123</span>.</p>
 </ins>
</section>
The odd line wrapping is needed because newlines are meaningful in microdata: newlines would be preserved in a conversion to, for example, the vCard format.

This example shows a site's contact details (using the address element) containing an address with two street components:

<address itemscope itemtype="http://microformats.org/profile/hcard">
 <strong itemprop="fn"><span itemprop="n" itemscope><span itemprop="given-name">Alfred</span>
 <span itemprop="family-name">Person</span></span></strong> <br>
 <span itemprop="adr" itemscope>
  <span itemprop="street-address">1600 Amphitheatre Parkway</span> <br>
  <span itemprop="street-address">Building 43, Second Floor</span> <br>
  <span itemprop="locality">Mountain View</span>,
   <span itemprop="region">CA</span> <span itemprop="postal-code">94043</span>
 </span>
</address>
The vCard vocabulary can be used to just mark up people's names:

<span itemscope itemtype="http://microformats.org/profile/hcard"
><span itemprop=fn><span itemprop="n" itemscope><span itemprop="given-name"
>George</span> <span itemprop="family-name">Washington</span></span
></span></span>
This creates a single item with a two name-value pairs, one with the name "fn" and the value "George Washington", and the other with the name "n" and a second item as its value, the second item having the two name-value pairs "given-name" and "family-name" with the values "George" and "Washington" respectively. This is defined to map to the following vCard:

BEGIN:VCARD
PROFILE:VCARD
VERSION:4.0
SOURCE:document's address
FN:George Washington
N:Washington;George;;;
END:VCARD
5.3.2 vEvent
An item with the item type http://microformats.org/profile/hcalendar#vevent represents an event.

This vocabulary does not support global identifiers for items.

The following are the type's defined property names. They are based on the vocabulary defined in the iCalendar specification, where more information on how to interpret the values can be found. [RFC5545]

Only the parts of the iCalendar vocabulary relating to events are used here; this vocabulary cannot express a complete iCalendar instance.

attach
Gives the address of an associated document for the event.

The value must be an absolute URL.

Any number of properties with the name attach may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

categories
Gives the name of a category or tag that the event could be classified as.

The value must be text.

Any number of properties with the name categories may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

class
Gives the access classification of the information regarding the event.

The value must be text with one of the following values:

public
private
confidential
This is merely advisory and cannot be considered a confidentiality measure.

A single property with the name class may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

comment
Gives a comment regarding the event.

The value must be text.

Any number of properties with the name comment may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

description
Gives a detailed description of the event.

The value must be text.

A single property with the name description may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

geo
Gives the geographical position of the event.

The value must be text and must match the following syntax:

Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).
One or more ASCII digits.
Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.
A U+003B SEMICOLON character (;).
Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).
One or more ASCII digits.
Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.
The optional components marked with an asterisk (*) should be included, and should have six digits each.

The value specifies latitude and longitude, in that order (i.e., "LAT LON" ordering), in decimal degrees. The longitude represents the location east and west of the prime meridian as a positive or negative real number, respectively. The latitude represents the location north and south of the equator as a positive or negative real number, respectively.

A single property with the name geo may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

location
Gives the location of the event.

The value must be text.

A single property with the name location may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

resources
Gives a resource that will be needed for the event.

The value must be text.

Any number of properties with the name resources may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

status
Gives the confirmation status of the event.

The value must be text with one of the following values:

tentative
confirmed
cancelled
A single property with the name status may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

summary
Gives a short summary of the event.

The value must be text.

User agents should replace U+000A LINE FEED (LF) characters in the value by U+0020 SPACE characters when using the value.

A single property with the name summary may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

dtend
Gives the date and time by which the event ends.

If the property with the name dtend is present within an item with the type http://microformats.org/profile/hcalendar#vevent that has a property with the name dtstart whose value is a valid date string, then the value of the property with the name dtend must be text that is a valid date string also. Otherwise, the value of the property must be text that is a valid global date and time string.

In either case, the value be later in time than the value of the dtstart property of the same item.

The time given by the dtend property is not inclusive. For day-long events, therefore, the dtend property's value will be the day after the end of the event.

A single property with the name dtend may be present within each item with the type http://microformats.org/profile/hcalendar#vevent, so long as that http://microformats.org/profile/hcalendar#vevent does not have a property with the name duration.

dtstart
Gives the date and time at which the event starts.

The value must be text that is either a valid date string or a valid global date and time string.

Exactly one property with the name dtstart must be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

duration
Gives the duration of the event.

The value must be text that is a valid vevent duration string.

The duration represented is the sum of all the durations represented by integers in the value.

A single property with the name duration may be present within each item with the type http://microformats.org/profile/hcalendar#vevent, so long as that http://microformats.org/profile/hcalendar#vevent does not have a property with the name dtend.

transp
Gives whether the event is to be considered as consuming time on a calendar, for the purpose of free-busy time searches.

The value must be text with one of the following values:

opaque
transparent
A single property with the name transp may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

contact
Gives the contact information for the event.

The value must be text.

Any number of properties with the name contact may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

url
Gives a URL for the event.

The value must be an absolute URL.

A single property with the name url may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

uid
Gives a globally unique identifier corresponding to the event.

The value must be text.

A single property with the name uid may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

exdate
Gives a date and time at which the event does not occur despite the recurrence rules.

The value must be text that is either a valid date string or a valid global date and time string.

Any number of properties with the name exdate may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

rdate
Gives a date and time at which the event recurs.

The value must be text that is one of the following:

A valid date string.
A valid global date and time string.
A valid global date and time string followed by a U+002F SOLIDUS character (/) followed by a second valid global date and time string representing a later time.
A valid global date and time string followed by a U+002F SOLIDUS character (/) followed by a valid vevent duration string.
Any number of properties with the name rdate may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

rrule
Gives a rule for finding dates and times at which the event occurs.

The value must be text that matches the RECUR value type defined in the iCalendar specification. [RFC5545]

A single property with the name rrule may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

created
Gives the date and time at which the event information was first created in a calendaring system.

The value must be text that is a valid global date and time string.

A single property with the name created may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

last-modified
Gives the date and time at which the event information was last modified in a calendaring system.

The value must be text that is a valid global date and time string.

A single property with the name last-modified may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

sequence
Gives a revision number for the event information.

The value must be text that is a valid non-negative integer.

A single property with the name sequence may be present within each item with the type http://microformats.org/profile/hcalendar#vevent.

A string is a valid vevent duration string if it matches the following pattern:

A U+0050 LATIN CAPITAL LETTER P character (P).
One of the following:
A valid non-negative integer followed by a U+0057 LATIN CAPITAL LETTER W character (W). The integer represents a duration of that number of weeks.
At least one, and possible both in this order, of the following:
A valid non-negative integer followed by a U+0044 LATIN CAPITAL LETTER D character (D). The integer represents a duration of that number of days.
A U+0054 LATIN CAPITAL LETTER T character (T) followed by any one of the following, or the first and second of the following in that order, or the second and third of the following in that order, or all three of the following in this order:
A valid non-negative integer followed by a U+0048 LATIN CAPITAL LETTER H character (H). The integer represents a duration of that number of hours.
A valid non-negative integer followed by a U+004D LATIN CAPITAL LETTER M character (M). The integer represents a duration of that number of minutes.
A valid non-negative integer followed by a U+0053 LATIN CAPITAL LETTER S character (S). The integer represents a duration of that number of seconds.
5.3.2.1 Conversion to iCalendar
Given a list of nodes nodes in a Document, a user agent must run the following algorithm to extract any vEvent data represented by those nodes:

If none of the nodes in nodes are items with the type http://microformats.org/profile/hcalendar#vevent, then there is no vEvent data. Abort the algorithm, returning nothing.

Let output be an empty string.

Add an iCalendar line with the type "BEGIN" and the value "VCALENDAR" to output.

Add an iCalendar line with the type "PRODID" and the value equal to a user-agent-specific string representing the user agent to output.

Add an iCalendar line with the type "VERSION" and the value "2.0" to output.

For each node node in nodes that is an item with the type http://microformats.org/profile/hcalendar#vevent, run the following steps:

Add an iCalendar line with the type "BEGIN" and the value "VEVENT" to output.

Add an iCalendar line with the type "DTSTAMP" and a value consisting of an iCalendar DATE-TIME string representing the current date and time, with the annotation "VALUE=DATE-TIME", to output. [RFC5545]

For each element element that is a property of the item node: for each name name in element's property names, run the appropriate set of substeps from the following list:

If the property's value is an item
Skip the property.

If the property is dtend
If the property is dtstart
If the property is exdate
If the property is rdate
If the property is created
If the property is last-modified
Let value be the result of stripping all U+002D HYPHEN-MINUS (-) and U+003A COLON (:) characters from the property's value.

If the property's value is a valid date string then add an iCalendar line with the type name and the value value to output, with the annotation "VALUE=DATE".

Otherwise, if the property's value is a valid global date and time string then add an iCalendar line with the type name and the value value to output, with the annotation "VALUE=DATE-TIME".

Otherwise skip the property.

Otherwise
Add an iCalendar line with the type name and the property's value to output.

Add an iCalendar line with the type "END" and the value "VEVENT" to output.

Add an iCalendar line with the type "END" and the value "VCALENDAR" to output.

When the above algorithm says that the user agent is to add an iCalendar line consisting of a type type, a value value, and optionally an annotation, to a string output, it must run the following steps:

Let line be an empty string.

Append type, converted to ASCII uppercase, to line.

If there is an annotation:

Append a U+003B SEMICOLON character (;) to line.

Append the annotation to line.

Append a U+003A COLON character (:) to line.

Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE SOLIDUS character (\).

Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

Prefix every U+003B SEMICOLON character (;) in value with a U+005C REVERSE SOLIDUS character (\).

Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

Append value to line.

Let maximum length be 75.

While line's length is greater than maximum length:

Append the first maximum length code points of line to output.

Remove the first maximum length code points from line.

Append a U+000D CARRIAGE RETURN character (CR) to output.

Append a U+000A LINE FEED character (LF) to output.

Append a U+0020 SPACE character to output.

Let maximum length be 74.

Append (what remains of) line to output.

Append a U+000D CARRIAGE RETURN character (CR) to output.

Append a U+000A LINE FEED character (LF) to output.

This algorithm can generate invalid iCalendar output, if the input does not conform to the rules described for the http://microformats.org/profile/hcalendar#vevent item type and defined property names.

5.3.2.2 Examples
This section is non-normative.

Here is an example of a page that uses the vEvent vocabulary to mark up an event:

<body itemscope itemtype="http://microformats.org/profile/hcalendar#vevent">
 ...
 <h1 itemprop="summary">Bluesday Tuesday: Money Road</h1>
 ...
 <time itemprop="dtstart" datetime="2009-05-05T19:00:00Z">May 5th @ 7pm</time>
 (until <time itemprop="dtend" datetime="2009-05-05T21:00:00Z">9pm</time>)
 ...
 <a href="http://livebrum.co.uk/2009/05/05/bluesday-tuesday-money-road"
    rel="bookmark" itemprop="url">Link to this page</a>
 ...
 <p>Location: <span itemprop="location">The RoadHouse</span></p>
 ...
 <p><input type=button value="Add to Calendar"
           onclick="location = getCalendar(this)"></p>
 ...
 <meta itemprop="description" content="via livebrum.co.uk">
</body>
The getCalendar() function is left as an exercise for the reader.

The same page could offer some markup, such as the following, for copy-and-pasting into blogs:

<div itemscope itemtype="http://microformats.org/profile/hcalendar#vevent">
 <p>I'm going to
 <strong itemprop="summary">Bluesday Tuesday: Money Road</strong>,
 <time itemprop="dtstart" datetime="2009-05-05T19:00:00Z">May 5th at 7pm</time>
 to <time itemprop="dtend" datetime="2009-05-05T21:00:00Z">9pm</time>,
 at <span itemprop="location">The RoadHouse</span>!</p>
 <p><a href="http://livebrum.co.uk/2009/05/05/bluesday-tuesday-money-road"
       itemprop="url">See this event on livebrum.co.uk</a>.</p>
 <meta itemprop="description" content="via livebrum.co.uk">
</div>
5.3.3 Licensing works
An item with the item type http://n.whatwg.org/work represents a work (e.g. an article, an image, a video, a song, etc). This type is primarily intended to allow authors to include licensing information for works.

The following are the type's defined property names.

work
Identifies the work being described.

The value must be an absolute URL.

Exactly one property with the name work must be present within each item with the type http://n.whatwg.org/work.

title
Gives the name of the work.

A single property with the name title may be present within each item with the type http://n.whatwg.org/work.

author
Gives the name or contact information of one of the authors or creators of the work.

The value must be either an item with the type http://microformats.org/profile/hcard, or text.

Any number of properties with the name author may be present within each item with the type http://n.whatwg.org/work.

license
Identifies one of the licenses under which the work is available.

The value must be an absolute URL.

Any number of properties with the name license may be present within each item with the type http://n.whatwg.org/work.

5.3.3.1 Examples
This section is non-normative.

This example shows an embedded image entitled My Pond, licensed under the Creative Commons Attribution-Share Alike 4.0 International License and the MIT license simultaneously.

<figure itemscope itemtype="http://n.whatwg.org/work">
 <img itemprop="work" src="mypond.jpeg">
 <figcaption>
  <p><cite itemprop="title">My Pond</cite></p>
  <p><small>Licensed under the <a itemprop="license"
  href="https://creativecommons.org/licenses/by-sa/4.0/">Creative
  Commons Attribution-Share Alike 4.0 International License</a>
  and the <a itemprop="license"
  href="http://www.opensource.org/licenses/mit-license.php">MIT
  license</a>.</small>
 </figcaption>
</figure>
5.4 Converting HTML to other formats
5.4.1 JSON
Given a list of nodes nodes in a Document, a user agent must run the following algorithm to extract the microdata from those nodes into a JSON form:

Let result be an empty object.

Let items be an empty array.

For each node in nodes, check if the element is a top-level microdata item, and if it is then get the object for that element and add it to items.

Add an entry to result called "items" whose value is the array items.

Return the result of serializing result to JSON in the shortest possible way (meaning no whitespace between tokens, no unnecessary zero digits in numbers, and only using Unicode escapes in strings for characters that do not have a dedicated escape sequence), and with a lowercase "e" used, when appropriate, in the representation of any numbers. [JSON]

This algorithm returns an object with a single property that is an array, instead of just returning an array, so that it is possible to extend the algorithm in the future if necessary.

When the user agent is to get the object for an item item, optionally with a list of elements memory, it must run the following substeps:

Let result be an empty object.

If no memory was passed to the algorithm, let memory be an empty list.

Add item to memory.

If the item has any item types, add an entry to result called "type" whose value is an array listing the item types of item, in the order they were specified on the itemtype attribute.

If the item has a global identifier, add an entry to result called "id" whose value is the global identifier of item.

Let properties be an empty object.

For each element element that has one or more property names and is one of the properties of the item item, in the order those elements are given by the algorithm that returns the properties of an item, run the following substeps:

Let value be the property value of element.

If value is an item, then: If value is in memory, then let value be the string "ERROR". Otherwise, get the object for value, passing a copy of memory, and then replace value with the object returned from those steps.

For each name name in element's property names, run the following substeps:

If there is no entry named name in properties, then add an entry named name to properties whose value is an empty array.

Append value to the entry named name in properties.

Add an entry to result called "properties" whose value is the object properties.

Return result.

For example, take this markup:

<!DOCTYPE HTML>
<html lang="en">
<title>My Blog</title>
<article itemscope itemtype="http://schema.org/BlogPosting">
 <header>
  <h1 itemprop="headline">Progress report</h1>
  <p><time itemprop="datePublished" datetime="2013-08-29">today</time></p>
  <link itemprop="url" href="?comments=0">
 </header>
 <p>All in all, he's doing well with his swim lessons. The biggest thing was he had trouble
 putting his head in, but we got it down.</p>
 <section>
  <h1>Comments</h1>
  <article itemprop="comment" itemscope itemtype="http://schema.org/UserComments" id="c1">
   <link itemprop="url" href="#c1">
   <footer>
    <p>Posted by: <span itemprop="creator" itemscope itemtype="http://schema.org/Person">
     <span itemprop="name">Greg</span>
    </span></p>
    <p><time itemprop="commentTime" datetime="2013-08-29">15 minutes ago</time></p>
   </footer>
   <p>Ha!</p>
  </article>
  <article itemprop="comment" itemscope itemtype="http://schema.org/UserComments" id="c2">
   <link itemprop="url" href="#c2">
   <footer>
    <p>Posted by: <span itemprop="creator" itemscope itemtype="http://schema.org/Person">
     <span itemprop="name">Charlotte</span>
    </span></p>
    <p><time itemprop="commentTime" datetime="2013-08-29">5 minutes ago</time></p>
   </footer>
   <p>When you say "we got it down"...</p>
  </article>
 </section>
</article>
It would be turned into the following JSON by the algorithm above (supposing that the page's URL was https://blog.example.com/progress-report):

{
  "items": [
    {
      "type": [ "http://schema.org/BlogPosting" ],
      "properties": {
        "headline": [ "Progress report" ],
        "datePublished": [ "2013-08-29" ],
        "url": [ "https://blog.example.com/progress-report?comments=0" ],
        "comment": [
          {
            "type": [ "http://schema.org/UserComments" ],
            "properties": {
              "url": [ "https://blog.example.com/progress-report#c1" ],
              "creator": [
                {
                  "type": [ "http://schema.org/Person" ],
                  "properties": {
                    "name": [ "Greg" ]
                  }
                }
              ],
              "commentTime": [ "2013-08-29" ]
            }
          },
          {
            "type": [ "http://schema.org/UserComments" ],
            "properties": {
              "url": [ "https://blog.example.com/progress-report#c2" ],
              "creator": [
                {
                  "type": [ "http://schema.org/Person" ],
                  "properties": {
                    "name": [ "Charlotte" ]
                  }
                }
              ],
              "commentTime": [ "2013-08-29" ]
            }
          }
        ]
      }
    }
  ]
}
6 User interaction
6.1 The hidden attribute

Support: hidden
Chrome for Android	64+
Chrome	6+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	11+
Opera Mini	all+
Safari	5.1+
Edge	12+
Android Browser	4+
Opera	11.1+

Source: caniuse.com

All HTML elements may have the hidden content attribute set. The hidden attribute is a boolean attribute. When specified on an element, it indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user. User agents should not render elements that have the hidden attribute specified. This requirement may be implemented indirectly through the style layer. For example, an HTML+CSS user agent could implement these requirements using the rules suggested in the Rendering section.

Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the hidden attribute. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected.

In the following skeletal example, the attribute is used to hide the Web game's main screen until the user logs in:

  <h1>The Example Game</h1>
  <section id="login">
   <h2>Login</h2>
   <form>
    ...
    <!-- calls login() once the user's credentials have been checked -->
   </form>
   <script>
    function login() {
      // switch screens
      document.getElementById('login').hidden = true;
      document.getElementById('game').hidden = false;
    }
   </script>
  </section>
  <section id="game" hidden>
   ...
  </section>
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.

Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.

Elements and scripts may, however, refer to elements that are hidden in other contexts.

For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.

It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the images that they describe.

Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.

Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.

The hidden IDL attribute must reflect the content attribute of the same name.

6.2 Inert subtrees
This section does not define or create any content attribute named "inert". This section merely defines an abstract concept of inertness.

A node (in particular elements and text nodes) can be marked as inert. When a node is inert, then the user agent must act as if the node was absent for the purposes of targeting user interaction events, may ignore the node for the purposes of text search user interfaces (commonly known as "find in page"), and may prevent the user from selecting text in that node. User agents should allow the user to override the restrictions on search and text selection, however.

For example, consider a page that consists of just a single inert paragraph positioned in the middle of a body. If a user moves their pointing device from the body over to the inert paragraph and clicks on the paragraph, no mouseover event would be fired, and the mousemove and click events would be fired on the body element rather than the paragraph.

When a node is inert, it generally cannot be focused. Inert nodes that are commands will also get disabled.

While a browsing context container is marked as inert, its nested browsing context's active document, and all nodes in that Document, must be marked as inert.

A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer. While document is so blocked, every node that is connected to document, with the exception of the subject element and its shadow-including descendants, must be marked inert. (The elements excepted by this paragraph can additionally be marked inert through other means; being part of a modal dialog does not "protect" a node from being marked inert.)

The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node document's top layer.

6.3 Activation
Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.

The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.

An algorithm is triggered by user activation if any of the following conditions is true:

The task in which the algorithm is running is currently processing an activation behavior whose click event's isTrusted attribute is true.

The task in which the algorithm is running is currently running the event listener for an event whose isTrusted attribute is true and whose type is one of:

change
click
dblclick
mouseup
pointerup
reset
submit
touchend
The task in which the algorithm is running was queued by an algorithm that was triggered by user activation, and the chain of such algorithms started within a user-agent defined timeframe.

For example, if a user clicked a button, it might be acceptable for a popup to result from that after 4 seconds, but it would likely not be acceptable for a popup to result from that after 4 hours.

element . click()
Acts as if the element was clicked.

Each element has an associated click in progress flag, which is initially unset.

The click() method must run the following steps:

If this element is a form control that is disabled, then return.

If this element's click in progress flag is set, then return.

Set this element's click in progress flag.

Fire a synthetic mouse event at this element, with the not trusted flag set.

Unset this element's click in progress flag.

6.4 Focus
6.4.1 Introduction
This section is non-normative.

An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).

When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.

Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.

The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as well as the dialog. The dialog itself would have as its children the text control and the button.



If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the graphical system to ① the Web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.

Keyboard events are always targeted at this focused element.

6.4.2 Data model
The term focusable area is used to refer to regions of the interface that can become the target of keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.

Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.

The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)

Focusable area	DOM anchor
Examples
Elements that have their tabindex focus flag set, that are not actually disabled, that are not expressly inert, and that are either being rendered or being used as relevant canvas fallback content.	The element itself.
iframe, <input type=text>, sometimes <a href=""> (depending on platform conventions).

The shapes of area elements in an image map associated with an img element that is being rendered and is not expressly inert.	The img element.
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.

<map id=wallmap><area alt="Enter Door" coords="10,10,100,200" href="door.html"></map>
...
<img src="images/innerwall.jpeg" alt="There is a white wall here, with a door." usemap="#wallmap">
...
<img src="images/outerwall.jpeg" alt="There is a red wall here, with a door." usemap="#wallmap">
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or expressly inert.	The element for which the focusable area is a subwidget.
The controls in the user interface that is exposed to the user for a video element, the up and down buttons in a spin-control version of <input type=number>, the two range control widgets in a <input type=range multiple>, the part of a details element's rendering that enabled the element to be opened or closed using keyboard input.

The scrollable regions of elements that are being rendered and are not expressly inert.	The element for which the box that the scrollable region scrolls was created.
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.

The viewport of a Document that has a browsing context and is not inert.	The Document for which the viewport was created.
The contents of an iframe.

Any other element or part of an element, especially to aid with accessibility or to better match platform conventions.	The element.
A user agent could make all list item bullets focusable, so that a user can more easily navigate lists.

Similarly, a user agent could make all elements with title attributes focusable, so that their advisory information can be accessed.

A browsing context container (e.g. an iframe) is a focusable area, but key events routed to a browsing context container get immediately routed to the nested browsing context's active document. Similarly, in sequential focus navigation a browsing context container essentially acts merely as a placeholder for its nested browsing context's active document.

The following create control groups:

Document object that have browsing contexts.
dialog elements that have an open attribute specified and that are being rendered.
The corresponding Document object or dialog element is the created control group's owner object. (There is always a 1-to-1 mapping of control groups to control group owner objects.)

Each focusable area belongs to a single control group as follows. If the DOM anchor of a focusable area is a control group owner object, then that focusable area belongs to that control group owner object's control group. Otherwise, the focusable area belongs to its DOM anchor's nearest ancestor control group owner object's control group.

Thus:

A viewport always belongs to the control group of the Document for which the viewport was created.

An input control belongs to the control group of its nearest ancestor dialog or Document.

An image map's shapes belong to the nearest ancestor dialog or Document of the img elements (not the area elements — this means one area element might create multiple shapes in different control groups).

It is possible for a control group to be empty, i.e. for it to have no focusable areas.

An element is expressly inert if it is inert and its nearest ancestor control group owner object is not inert.

In a page with no dialog elements, all elements that are inert are expressly inert, and vice-versa.

Inside an inert dialog element, all descendant elements are not expressly inert, even if they are inert.

A dialog element is expressly inert if it is inert and not nested inside another inert dialog.

One focusable area in each non-empty control group is designated the focused area of the control group. Which control is so designated changes over time, based on algorithms in this specification. If a control group is empty, it has no focused area.

Focusable areas in control groups are ordered relative to the tree order of their DOM anchors. Focusable areas with the same DOM anchor in a control group are ordered relative to their CSS box's relative positions in a pre-order, depth-first traversal of the box tree. [CSS]

The currently focused area of a top-level browsing context at any particular time is the focusable area or dialog returned by this algorithm:

Let candidate be the Document of the top-level browsing context.

If candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.

Otherwise, if candidate has a non-empty control group, let candidate be the designated focused area of the control group.

Return candidate.

An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level browsing context. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level browsing context, it is focused.

The focus chain of a focusable area or control group owner object subject is the ordered list constructed as follows:

Let current object be subject.

Let output be an empty list.

Loop: Append current object to output.

If current object is an area element's shape, append that area element to output.

Otherwise, if current object is a focusable area whose DOM anchor is an element that is not current object itself, append that DOM anchor element to output.

If current object is a focusable area, let current object be that focusable area's control group's owner object, and return to the step labeled loop.

Otherwise, if current object is a Document in a nested browsing context, let current object be its browsing context container, and return to the step labeled loop.

Return output.

The chain starts with subject and (if subject is or can be the currently focused area of a top-level browsing context) continues up the focus hierarchy up to the Document of the top-level browsing context.

6.4.3 The tabindex attribute
The tabindex content attribute allows authors to indicate that an element is supposed to be focusable, and whether it is supposed to be reachable using sequential focus navigation and, if so, what is to be the relative order of the element for the purposes of sequential focus navigation. The name "tab index" comes from the common use of the "tab" key to navigate through the focusable elements. The term "tabbing" refers to moving forward through the focusable elements that can be reached using sequential focus navigation.


Support: tabindex-attr
Chrome for Android	64+
Chrome	15+
iOS Safari	3.2+
Firefox	4+
IE	7+
Safari	5.1+
Edge	12+
Opera	9.5+

Source: caniuse.com

When the attribute is omitted, the user agent applies defaults. (There is no way to make an element that is being rendered be not focusable at all without disabling it or making it inert.)

The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is to be unreachable by sequential focus navigation.

Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.

Each element can have a tabindex focus flag set, as defined below. This flag is a factor that contributes towards determining whether an element is a focusable area, as described in the previous section.

If the tabindex attribute is specified on an element, it must be parsed using the rules for parsing integers. The attribute's values, or lack thereof, must be interpreted as follows:

If the attribute is omitted or parsing the value returns an error
The user agent should follow platform conventions to determine if the element's tabindex focus flag is set and, if so, whether the element and any focusable areas that have the element as their DOM anchor can be reached using sequential focus navigation, and if so, what their relative position in the sequential focus navigation order is to be.

Modulo platform conventions, it is suggested that for the following elements, the tabindex focus flag be set:

a elements that have an href attribute
link elements that have an href attribute
button elements
input elements whose type attribute are not in the Hidden state
select elements
textarea elements
summary elements that are the first summary element child of a details element
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin a drag operations for those elements without the use of a pointing device
Editing hosts
Browsing context containers
If the value is a negative integer
The user agent must set the element's tabindex focus flag, but should omit the element from the sequential focus navigation order.

One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.

If the value is a zero
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, following platform conventions to determine the element's relative position in the sequential focus navigation order.

If the value is greater than zero
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, and should place the element — referenced as candidate below — and the aforementioned focusable areas in the sequential focus navigation order so that, relative to other focusable areas in the sequential focus navigation order, they are:

before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or less than zero,
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is earlier in the document in tree order than candidate,
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is later in the document in tree order than candidate, and
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
An element with the tabindex attribute specified is interactive content.

The tabIndex IDL attribute must reflect the value of the tabindex content attribute. Its default value is 0 for elements that are focusable and −1 for elements that are not focusable.

6.4.4 Processing model
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a browsing context, are as follows. They can optionally be run with a fallback target.

If new focus target is neither a dialog element that has an open attribute specified and that is being rendered (i.e. that is a control group owner object), nor a focusable area, then run the first matching set of steps from the following list:

If new focus target is an area element with one or more shapes that are focusable areas
Let new focus target be the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.

If new focus target is an element with one or more scrollable regions that are focusable areas
Let new focus target be the element's first scrollable region, according to a pre-order, depth-first traversal of the box tree. [CSS]

If new focus target is the document element of its Document
Let new focus target be the Document's viewport.

If new focus target is a browsing context
Let new focus target be the browsing context's active document.

If new focus target is a browsing context container with a non-null nested browsing context
Let new focus target be the browsing context container's nested browsing context's active document.

Otherwise
If no fallback target was specified, abort the focusing steps.

Otherwise, let new focus target be the fallback target.

If new focus target is a control group owner object that is not a focusable area, and its control group is not empty, then designate new focus target as the focused area of the control group, and redo this step.

Otherwise, if new focus target is a browsing context container with non-null nested browsing context, then let new focus target be the nested browsing context's active document, and redo this step.

A dialog element can be both a control group owner object and a focusable area, if it has both an open attribute specified and a tabindex attribute specified and is being rendered.

If new focus target is a focusable area and its DOM anchor is inert, then return.

If new focus target is the currently focused area of a top-level browsing context, then return.

Let old chain be the focus chain of the currently focused area of the top-level browsing context in which new focus target finds itself.

Let new chain be the focus chain of new focus target.

Run the focus update steps with old chain, new chain, and new focus target respectively.

User agents must immediately run the focusing steps for a focusable area, dialog, or browsing context candidate whenever the user attempts to move the focus to candidate.

The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:

If old focus target is inert, then return.

If old focus target is an area element and one of its shapes is the currently focused area of a top-level browsing context, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level browsing context, then let old focus target be that currently focused area of a top-level browsing context.

Let old chain be the focus chain of the currently focused area of a top-level browsing context.

If old focus target is not one of the entries in old chain, then return.

If old focus target is a focusable area, then let new focus target be the first focusable area of its control group (if the control group owner object is a Document, this will always be a viewport).

Otherwise, let new focus target be null.

If new focus target is not null, then run the focusing steps for new focus target.

When the currently focused area of a top-level browsing context is somehow unfocused without another element being explicitly focused in its stead, the user agent must immediately run the unfocusing steps for that object.

The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level browsing context. For example, if the currently focused area of a top-level browsing context is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.

When a focusable area is added to an empty control group, it must be designated the focused area of the control group.

Focus fixup rule: When the designated focused area of a control group is removed from that control group in some way (e.g. it stops being a focusable area, it is removed from the DOM, it becomes expressly inert, etc), and the control group is still not empty: designate the first non-inert focusable area in that control group to be the new focused area of the control group, if any; if they are all inert, then designate the first focusable area in that control group to be the new focused area of the control group regardless of inertness. If such a removal instead results in the control group being empty, then there is simply no longer a focused area of the control group.

For example, this might happen because an element is removed from its Document, or has a hidden attribute added. It might also happen to an input element when the element gets disabled.

In a Document without dialog elements, whose focused area is a button element, removing, disabling, or hiding that button would cause the page's new focused area to be the viewport of the Document. This would, in turn, be reflected through the activeElement API as the body element.

The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:

If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.

For each entry entry in old chain, in order, run these substeps:

If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behavior, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then fire an event named change at the element, with the bubbles attribute initialized to true.

If entry is an element, let blur event target be entry.

If entry is a Document object, let blur event target be that Document object's Window object.

Otherwise, let blur event target be null.

If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.

If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.

In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.

Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text control when that control is focused.)

For each entry entry in new chain, in reverse order, run these substeps:

If entry is a focusable area: designate entry as the focused area of the control group.

It is possible for entry to be both a dialog element and a focusable area, in which case it is its own control group owner object.

If entry is an element, let focus event target be entry.

If entry is a Document object, let focus event target be that Document object's Window object.

Otherwise, let focus event target be null.

If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.

If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.

In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.

To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the relatedTarget attribute initialized to r, the view attribute initialized to t's node document's Window object, and the composed flag set.

When a key event is to be routed in a top-level browsing context, the user agent must run the following steps:

Let target area be the currently focused area of the top-level browsing context.

If target area is a focusable area, let target node be target area's DOM anchor. Otherwise, target area is a dialog; let target node be target area.

If target node is a Document that has a body element, then let target node be the body element of that Document.

Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.

If target node is not inert, then:

It is possible for the currently focused area of a top-level browsing context to be inert, for example if a modal dialog is shown, and then that dialog element is made inert. It is likely to be the result of a logic error in the application, though.

Let canHandle be the result of dispatching the key event at target node.

If canHandle is true, then let target area handle the key event. This might include firing a click event at target node.

The has focus steps, given a Document object target, are as follows:

Let candidate be the Document of the top-level browsing context.

If candidate is target, return true.

If candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, and the active document of that browsing context container's nested browsing context is target, then return true.

Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.

Otherwise, return false.

6.4.5 Sequential focus navigation
Each control group has a sequential focus navigation order, which orders some or all of the focusable areas in the control group relative to each other. The order in the sequential focus navigation order does not have to be related to the order in the control group itself. If a focusable area is omitted from the sequential focus navigation order of its control group, then it is unreachable via sequential focus navigation.

There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.

For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.

When the user requests that focus move from the currently focused area of a top-level browsing context to the next or previous focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level browsing context in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:

Let starting point be the currently focused area of a top-level browsing context, if the user requested to move focus sequentially from there, or else the top-level browsing context itself, if the user instead requested to move focus from outside the top-level browsing context.

If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.

Let direction be forward if the user requested the next control, and backward if the user requested the previous control.

Typically, pressing tab requests the next control, and pressing shift+tab requests the previous control.

Loop: Let selection mechanism be sequential if the starting point is a browsing context or if starting point is in its control group's sequential focus navigation order.

Otherwise, starting point is not in its control group's sequential focus navigation order; let selection mechanism be DOM.

Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism as the arguments.

If candidate is not null, then run the focusing steps for candidate and return.

Otherwise, unset the sequential focus navigation starting point.

If starting point is the top-level browsing context, or a focusable area in the top-level browsing context, the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.

For example, if direction is backward, then the last focusable control before the browser's rendering area would be the control to focus.

If the user agent has no focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level browsing context itself.

Otherwise, starting point is a focusable area in a nested browsing context. Let starting point be that nested browsing context's browsing context container, and return to the step labeled loop.

The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.

Pick the appropriate cell from the following table, and follow the instructions in that cell.

The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.

direction is forward	direction is backward
starting point is a browsing context	Let candidate be the first suitable sequentially focusable area in starting point's active document's control group, if any; or else null	Let candidate be the last suitable sequentially focusable area in starting point's active document's control group, if any; or else null
selection mechanism is DOM	Let candidate be the first suitable sequentially focusable area in the home control group following starting point, if any; or else null	Let candidate be the last suitable sequentially focusable area in the home control group preceding starting point, if any; or else null
selection mechanism is sequential	Let candidate be the first suitable sequentially focusable area in the home sequential focus navigation order following starting point, if any; or else null	Let candidate be the last suitable sequentially focusable area in the home sequential focus navigation order preceding starting point, if any; or else null
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and that is in its control group's sequential focus navigation order.

The home control group is the control group to which starting point belongs.

The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.

The home sequential focus navigation order is the home control group's sequential focus navigation order, but is only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).

If candidate is a browsing context container with a non-null nested browsing context, then let new candidate be the result of running the sequential navigation search algorithm with candidate's nested browsing context as the first argument, direction as the second, and sequential as the third.

If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.

Return candidate.

6.4.6 Focus management APIs
dictionary FocusOptions {
  boolean preventScroll = false;
};
document . activeElement
Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.

For the purposes of this API, when a child browsing context is focused, its browsing context container is focused in the parent browsing context. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.

document . hasFocus()
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.

window . focus()
Moves the focus to the window's browsing context, if any.

element . focus([ { preventScroll: true } ])
Moves the focus to the element.

If the element is a browsing context container, moves the focus to the nested browsing context instead.

By default, this method also scrolls the element into view. Providing the preventScroll option and setting it to true prevents this behavior.

element . blur()
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.

Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use a CSS rule to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.

For example, to hide the outline from links and instead use a yellow background to indicate focus, you could use:

:link:focus, :visited:focus { outline: none; background: yellow; color: black; }
The activeElement attribute's getter must run these steps:

Let candidate be this Document object.

If candidate has a non-empty control group, then set candidate to the designated focused area of the control group.

If candidate is a focusable area, then set candidate to candidate's DOM anchor.

If candidate is not a Document object, then return candidate.

If candidate has a body element, then return that body element.

If candidate's document element is non-null, then return that document element.

Return null.

The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the Document object as the argument.

The focus() method on the Window object, when invoked, must run the focusing steps with the Window object's browsing context. Additionally, if this browsing context is a top-level browsing context, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.

The blur() method on the Window object, when invoked, provides a hint to the user agent that the script believes the user probably is not currently interested in the contents of the browsing context of the Window object on which the method was invoked, but that the contents might become interesting again in the future.

User agents are encouraged to ignore calls to this blur() method entirely.

Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g. tab or window) that contained the browsing context, but hostile sites widely abuse this behavior to the user's detriment.

The focus(options) method on elements, when invoked, must run the following steps:

If the element is marked as locked for focus, then return.

Mark the element as locked for focus.

Run the focusing steps for the element.

If the value of the preventScroll dictionary member of options is false, then scroll the element into view with scroll behavior "auto", block flow direction position set to a UA-defined value, and inline base direction position set to a UA-defined value.

Unmark the element as locked for focus.

The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called. User agents may selectively or uniformly ignore calls to this method for usability reasons.

For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.

6.5 Assigning keyboard shortcuts
6.5.1 Introduction
This section is non-normative.

Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.

The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.

In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.

Each alternative consists of a single character, such as a letter or digit.

User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.

In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possibly key.

<input type=button value=Collect onclick="collect()"
       accesskey="C 1" id=c>
To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's label:

function addShortcutKeyLabel(button) {
  if (button.accessKeyLabel != '')
    button.value += ' (' + button.accessKeyLabel + ')';
}
addShortcutKeyLabel(document.getElementById('c'));
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".

In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.

6.5.2 The accesskey attribute
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.

If specified, the value must be an ordered set of unique space-separated tokens that are case-sensitive, each of which must be exactly one code point in length.

In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:

<nav>
 <p>
  <a title="Consortium Activities" accesskey="A" href="/Consortium/activities">Activities</a> |
  <a title="Technical Reports and Recommendations" accesskey="T" href="/TR/">Technical Reports</a> |
  <a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex">Site Index</a> |
  <a title="About This Site" accesskey="B" href="/Consortium/">About Consortium</a> |
  <a title="Contact Consortium" accesskey="C" href="/Consortium/contact">Contact</a>
 </p>
</nav>
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:

<form action="/search">
 <label>Search: <input type="search" name="q" accesskey="s 0"></label>
 <input type="submit">
</form>
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.

<input type=submit accesskey="N @ 1" value="Compose">
...
<script>
 function labelButton(button) {
   if (button.accessKeyLabel)
     button.value += ' (' + button.accessKeyLabel + ')';
 }
 var inputs = document.getElementsByTagName('input');
 for (var i = 0; i < inputs.length; i += 1) {
   if (inputs[i].type == "submit")
     labelButton(inputs[i]);
 }
</script>
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.

6.5.3 Processing model
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.

Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:

If the element has no accesskey attribute, then skip to the fallback step below.

Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.

For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:

If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.

If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.

If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and return.
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then return.

If this step is reached, the element has no assigned access key.

Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.

When the user presses the key combination corresponding to the assigned access key for an element, if the element defines a command, the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a document that has a browsing context, and neither the element nor any of its ancestors has a hidden attribute specified, then the user agent must trigger the Action of the command.

User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.

The accessKey IDL attribute must reflect the accesskey content attribute.

The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.

6.6 Editing
6.6.1 Making document regions editable: The contenteditable content attribute

Support: contenteditable
Chrome for Android	64+
Chrome	4+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	3.5+
Samsung Internet	4+
IE	5.5+
Opera Mini	None
Safari	3.1+
Edge	12+
Android Browser	3+
Opera	9+

Source: caniuse.com

interface mixin ElementContentEditable {
  [CEReactions] attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
  [CEReactions] attribute DOMString inputMode;
};
The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true, and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid value default.

The true state indicates that the element is editable. The inherit state indicates that the element is editable if its parent is. The false state indicates that the element is not editable.

For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:

<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
 </fieldset>
 <p><button>Publish</button></p>
</form>
When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the contenteditable attribute:

<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea id=textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
  <div id=div style="white-space: pre-wrap" hidden><p>Hello world.</p></div>
  <script>
   let textarea = document.getElementById("textarea");
   let div = document.getElementById("div");
   textarea.hidden = true;
   div.hidden = false;
   div.contentEditable = "true";
   div.oninput = (e) => {
     textarea.value = div.innerHTML;
   };
  </script>
 </fieldset>
 <p><button>Publish</button></p>
</form>
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]

The contenteditable attribute can also be used to great effect:

<!doctype html>
<html lang=en>
<title>Live CSS editing!</title>
<style style=white-space:pre contenteditable>
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
</style>
element . contentEditable [ = value ]
Returns "true", "false", or "inherit", based on the state of the contenteditable attribute.

Can be set, to change that state.

Throws a "SyntaxError" DOMException if the new value isn't one of those strings.

element . isContentEditable
Returns true if the element is editable; otherwise, returns false.

The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "false" if the content attribute is set to the false state, and "inherit" otherwise. On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" DOMException.

The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.

6.6.2 Making entire documents editable: the designMode IDL attribute
Documents have a designMode, which can be either enabled or disabled.

document . designMode [ = value ]
Returns "on" if the document is editable, and "off" if it isn't.

Can be set, to change the document's current state. This focuses the document and resets the selection in that document.

The designMode IDL attribute on the Document object takes two values, "on" and "off". On setting, the new value must be compared in an ASCII case-insensitive manner to these two values; if it matches the "on" value, then designMode must be enabled, and if it matches the "off" value, then designMode must be disabled. Other values must be ignored.

On getting, if designMode is enabled, the IDL attribute must return the value "on"; otherwise it is disabled, and the attribute must return the value "off".

The last state set must persist until the document is destroyed or the state is changed. Initially, documents must have their designMode disabled.

When the designMode changes from being disabled to being enabled, the user agent must immediately reset the document's active range's start and end boundary points to be at the start of the Document and then run the focusing steps for the document element of the Document, if non-null.

6.6.3 Best practices for in-page editors
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.

As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&nbsp; ball" or "yellow &nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.

In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.

When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.

6.6.4 Editing APIs
The definition of the terms active range, editing host, editing host of, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand. [EXECCOMMAND]

6.6.5 Spelling and grammar checking

Support: spellcheck-attribute
Chrome for Android (limited)	64+
Chrome	9+
iOS Safari (limited)	3.2+
UC Browser for Android (limited)	11.8+
Firefox	2+
Samsung Internet (limited)	4+
IE	10+
Opera Mini (limited)	all+
Safari	5.1+
Edge	12+
Android Browser (limited)	2.1+
Opera	10.5+

Source: caniuse.com

User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).

For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:

true-by-default
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
false-by-default
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
inherit-by-default
The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.
The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the default state, which is the missing value default and the invalid value default.

The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The false state indicates that the element is not to be checked.

element . spellcheck [ = value ]
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.

Can be set, to override the default and set the spellcheck content attribute.

The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behavior is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behavior is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.

The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.

On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".

User agents must only consider the following pieces of text as checkable for the purposes of this feature:

The value of input elements whose type attributes are in the Text, Search, URL, or E-mail states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
The value of textarea elements that do not have a readonly attribute and that are not disabled.
Text in Text nodes that are children of editing hosts or editable elements.
Text in attributes of editable elements.
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.

To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:

If the user has disabled the checking for this text, then the checking is disabled.
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.
Otherwise, if the element's default behavior is true-by-default, then checking is enabled.
Otherwise, if the element's default behavior is false-by-default, then checking is disabled.
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
Otherwise, checking is disabled.
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections. User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings. UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.

If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.

The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.

<div contenteditable="true">
 <span spellcheck="false" id="a">Hell</span><em>o!</em>
</div>
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).

<p spellcheck="true">
 <label>Name: <input spellcheck=" false" id="b"></label>
</p>
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.

6.6.6 Autocapitalization
Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.

The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.)

The autocapitalize attribute can be used on an editing host to control autocapitalization behavior for the hosted editable region, on an input or textarea element to control the behavior for inputting text into that element, or on a form element to control the default behavior for all autocapitalize-inheriting elements associated with the form element.

The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL, E-mail, or Password states. (This behavior is included in the used autocapitalization hint algorithm below.)

The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:

default
The user agent and input method should use make their own determination of whether or not to enable autocapitalization.

none
No autocapitalization should be applied (all letters should default to lowercase).

sentences
The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.

words
The first letter of each word should default to a capital letter; all other letters should default to lowercase.

characters
All letters should default to uppercase.

The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization hint, which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:

Keyword	State
off	none
none
on	sentences
sentences
words	words
characters	characters
The invalid value default is the sentences state. The missing value default is the default state.

element . autocapitalize [ = value ]
Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this element is, in fact, the editing host).

Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).

To compute the own autocapitalization hint of an element element, run the following steps:

If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of the attribute.

If element is an autocapitalize-inheriting element and has a non-null form owner, return the own autocapitalization hint of element's form owner.

Return default.

The autocapitalize IDL attribute, on getting, must return the string value corresponding to own autocapitalization hint of the element, with the exception that the default state maps to the empty string. On setting, it must set the autocapitalize content attribute to the given new value.

User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.

User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.

The used autocapitalization hint for an element element is computed using the following algorithm:

If element is an input element whose type attribute is in one of the URL, E-mail, or Password states, then return default.

If element is an input element or a textarea element, then return element's own autocapitalization hint.

If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of element.

Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.

6.6.7 Input modalities: the inputmode attribute

Support: input-inputmode
Chrome for Android	None
Chrome	66+
iOS Safari	None
UC Browser for Android	None
Firefox	None
Samsung Internet	None
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	None
Opera	None

Source: caniuse.com

User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).

The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.

Keyword	Description
none	The user agent should not display a virtual keyboard. This keyword is useful for content that renders its own keyboard control.
text	The user agent should display a virtual keyboard capable of text input in the user's locale.
tel	The user agent should display a virtual keyboard capable of telephone number input. This should including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g., in the US, the key labeled "2" is historically also labeled with the letters A, B, and C).
url	The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".com".
email	The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of e-mail addresses, such as that for the "@" character and the "." character.
numeric	The user agent should display a virtual keyboard capable of numeric input. This keyword is useful for PIN entry.
decimal	The user agent should display a virtual keyboard capable of fractional numeric input. Numeric keys and the format separator for the locale should be shown.
search	The user agent should display a virtual keyboard optimized for search.
The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.

When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.

6.7 Drag and drop

Support: dragndrop
Chrome for Android	None
Chrome	4+
iOS Safari	11.0+
UC Browser for Android	None
Firefox	3.5+
Samsung Internet	None
IE (limited)	5.5+
Opera Mini	None
Safari	3.1+
Edge (limited)	12+
Android Browser	None
Opera	12+

Source: caniuse.com

This section defines an event-based drag-and-drop mechanism.

This specification does not define exactly what a drag-and-drop operation actually is.

On a visual medium with a pointing device, a drag operation could be the default action of a mousedown event that is followed by a series of mousemove events, and the drop could be triggered by the mouse being released.

When using an input modality other than a pointing device, users would probably have to explicitly indicate their intention to perform a drag-and-drop operation, stating what they wish to drag and where they wish to drop it, respectively.

However it is implemented, drag-and-drop operations must have a starting point (e.g. where the mouse was clicked, or the start of the selection or element that was selected for the drag), may have any number of intermediate steps (elements that the mouse moves over during a drag, or elements that the user picks as possible drop points as they cycle through possibilities), and must either have an end point (the element above which the mouse button was released, or the element that was finally selected), or be canceled. The end point must be the last element selected as a possible drop point before the drop occurs (so if the operation is not canceled, there must be at least one element in the middle step).

6.7.1 Introduction
This section is non-normative.

To make an element draggable, give the element a draggable attribute, and set an event listener for dragstart that stores the data being dragged.

The event handler typically needs to check that it's not a text selection that is being dragged, and then needs to store data into the DataTransfer object and set the allowed effects (copy, move, link, or some combination).

For example:

<p>What fruits do you like?</p>
<ol ondragstart="dragStartHandler(event)">
 <li draggable="true" data-value="fruit-apple">Apples</li>
 <li draggable="true" data-value="fruit-orange">Oranges</li>
 <li draggable="true" data-value="fruit-pear">Pears</li>
</ol>
<script>
  var internalDNDType = 'text/x-example'; // set this to something specific to your site
  function dragStartHandler(event) {
    if (event.target instanceof HTMLLIElement) {
      // use the element's data-value="" attribute as the value to be moving:
      event.dataTransfer.setData(internalDNDType, event.target.dataset.value);
      event.dataTransfer.effectAllowed = 'move'; // only allow moves
    } else {
      event.preventDefault(); // don't allow selection to be dragged
    }
  }
</script>
To accept a drop, the drop target has to listen to the following events:

The dragenter event handler reports whether or not the drop target is potentially willing to accept the drop, by canceling the event.
The dragover event handler specifies what feedback will be shown to the user, by setting the dropEffect attribute of the DataTransfer associated with the event. This event also needs to be canceled.
The drop event handler has a final chance to accept or reject the drop. If the drop is accepted, the event handler must perform the drop operation on the target. This event needs to be canceled, so that the dropEffect attribute's value can be used by the source. Otherwise, the drop operation is rejected.
For example:

<p>Drop your favorite fruits below:</p>
<ol ondragenter="dragEnterHandler(event)" ondragover="dragOverHandler(event)"
    ondrop="dropHandler(event)">
</ol>
<script>
  var internalDNDType = 'text/x-example'; // set this to something specific to your site
  function dragEnterHandler(event) {
    var items = event.dataTransfer.items;
    for (var i = 0; i < items.length; ++i) {
      var item = items[i];
      if (item.kind == 'string' && item.type == internalDNDType) {
        event.preventDefault();
        return;
      }
    }
  }
  function dragOverHandler(event) {
    event.dataTransfer.dropEffect = 'move';
    event.preventDefault();
  }
  function dropHandler(event) {
    var li = document.createElement('li');
    var data = event.dataTransfer.getData(internalDNDType);
    if (data == 'fruit-apple') {
      li.textContent = 'Apples';
    } else if (data == 'fruit-orange') {
      li.textContent = 'Oranges';
    } else if (data == 'fruit-pear') {
      li.textContent = 'Pears';
    } else {
      li.textContent = 'Unknown Fruit';
    }
    event.target.appendChild(li);
  }
</script>
To remove the original element (the one that was dragged) from the display, the dragend event can be used.

For our example here, that means updating the original markup to handle that event:

<p>What fruits do you like?</p>
<ol ondragstart="dragStartHandler(event)" ondragend="dragEndHandler(event)">
 ...as before...
</ol>
<script>
  function dragStartHandler(event) {
    // ...as before...
  }
  function dragEndHandler(event) {
    if (event.dataTransfer.dropEffect == 'move') {
      // remove the dragged element
      event.target.parentNode.removeChild(event.target);
    }
  }
</script>
6.7.2 The drag data store
The data that underlies a drag-and-drop operation, known as the drag data store, consists of the following information:

A drag data store item list, which is a list of items representing the dragged data, each consisting of the following information:

The drag data item kind
The kind of data:

Plain Unicode string
Text.

File
Binary data with a file name.

The drag data item type string
A Unicode string giving the type or format of the data, generally given by a MIME type. Some values that are not MIME types are special-cased for legacy reasons. The API does not enforce the use of MIME types; other values can be used as well. In all cases, however, the values are all converted to ASCII lowercase by the API.

There is a limit of one Plain Unicode string item per item type string.

The actual data
A Unicode or binary string, in some cases with a file name (itself a Unicode string), as per the drag data item kind.

The drag data store item list is ordered in the order that the items were added to the list; most recently added last.

The following information, used to generate the UI feedback during the drag:

User-agent-defined default feedback information, known as the drag data store default feedback.
Optionally, a bitmap image and the coordinate of a point within that image, known as the drag data store bitmap and drag data store hot spot coordinate.
A drag data store mode, which is one of the following:

Read/write mode
For the dragstart event. New data can be added to the drag data store.

Read-only mode
For the drop event. The list of items representing dragged data can be read, including the data. No new data can be added.

Protected mode
For all other events. The formats and kinds in the drag data store list of items representing dragged data can be enumerated, but the data itself is unavailable and no new data can be added.

A drag data store allowed effects state, which is a string.

When a drag data store is created, it must be initialized such that its drag data store item list is empty, it has no drag data store default feedback, it has no drag data store bitmap and drag data store hot spot coordinate, its drag data store mode is protected mode, and its drag data store allowed effects state is the string "uninitialized".

6.7.3 The DataTransfer interface
DataTransfer objects are used to expose the drag data store that underlies a drag-and-drop operation.

[Exposed=Window,
 Constructor]
  interface DataTransfer {
  attribute DOMString dropEffect;
  attribute DOMString effectAllowed;

  [SameObject] readonly attribute DataTransferItemList items;

  void setDragImage(Element image, long x, long y);

  /* old interface */
  readonly attribute FrozenArray<DOMString> types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  [SameObject] readonly attribute FileList files;
};
dataTransfer = new DataTransfer()
Creates a new DataTransfer object with an empty drag data store.

dataTransfer . dropEffect [ = value ]
Returns the kind of operation that is currently selected. If the kind of operation isn't one of those that is allowed by the effectAllowed attribute, then the operation will fail.

Can be set, to change the selected operation.

The possible values are "none", "copy", "link", and "move".

dataTransfer . effectAllowed [ = value ]
Returns the kinds of operations that are to be allowed.

Can be set (during the dragstart event), to change the allowed operations.

The possible values are "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", and "uninitialized",

dataTransfer . items
Returns a DataTransferItemList object, with the drag data.

dataTransfer . setDragImage(element, x, y)
Uses the given element to update the drag feedback, replacing any previously specified feedback.

dataTransfer . types
Returns a frozen array listing the formats that were set in the dragstart event. In addition, if any files are being dragged, then one of the types will be the string "Files".

data = dataTransfer . getData(format)
Returns the specified data. If there is no such data, returns the empty string.

dataTransfer . setData(format, data)
Adds the specified data.

dataTransfer . clearData( [ format ] )
Removes the data of the specified formats. Removes all data if the argument is omitted.

dataTransfer . files
Returns a FileList of the files being dragged, if any.

DataTransfer objects that are created as part of drag-and-drop events are only valid while those events are being fired.

A DataTransfer object is associated with a drag data store while it is valid.

A DataTransfer object has an associated types array, which is a FrozenArray<DOMString>, initially empty. When the contents of the DataTransfer object's drag data store item list change, or when the DataTransfer object becomes no longer associated with a drag data store, run the following steps:

Let L be an empty sequence.

If the DataTransfer object is still associated with a drag data store, then:

For each item in the DataTransfer object's drag data store item list whose kind is Plain Unicode string, add an entry to L consisting of the item's type string.

If there are any items in the DataTransfer object's drag data store item list whose kind is File, then add an entry to L consisting of the string "Files". (This value can be distinguished from the other values because it is not lowercase.)

Set the DataTransfer object's types array to the result of creating a frozen array from L.

The DataTransfer() constructor, when invoked, must return a newly created DataTransfer object initialized as follows:

Set the drag data store's item list to be an empty list.

Set the drag data store's mode to read/write mode.

Set the dropEffect and effectAllowed to "none".

The dropEffect attribute controls the drag-and-drop feedback that the user is given during a drag-and-drop operation. When the DataTransfer object is created, the dropEffect attribute is set to a string value. On getting, it must return its current value. On setting, if the new value is one of "none", "copy", "link", or "move", then the attribute's current value must be set to the new value. Other values must be ignored.

The effectAllowed attribute is used in the drag-and-drop processing model to initialize the dropEffect attribute during the dragenter and dragover events. When the DataTransfer object is created, the effectAllowed attribute is set to a string value. On getting, it must return its current value. On setting, if drag data store's mode is the read/write mode and the new value is one of "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", or "uninitialized", then the attribute's current value must be set to the new value. Otherwise it must be left unchanged.

The items attribute must return a DataTransferItemList object associated with the DataTransfer object.

The setDragImage(element, x, y) method must run the following steps:

If the DataTransfer object is no longer associated with a drag data store, return. Nothing happens.

If the drag data store's mode is not the read/write mode, return. Nothing happens.

If element is an img element, then set the drag data store bitmap to the element's image (at its intrinsic size); otherwise, set the drag data store bitmap to an image generated from the given element (the exact mechanism for doing so is not currently specified).

Set the drag data store hot spot coordinate to the given x, y coordinate.

The types attribute must return this DataTransfer object's types array.

The getData(format) method must run the following steps:

If the DataTransfer object is no longer associated with a drag data store, then return the empty string.

If the drag data store's mode is the protected mode, then return the empty string.

Let format be the first argument, converted to ASCII lowercase.

Let convert-to-URL be false.

If format equals "text", change it to "text/plain".

If format equals "url", change it to "text/uri-list" and set convert-to-URL to true.

If there is no item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, return the empty string.

Let result be the data of the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format.

If convert-to-URL is true, then parse result as appropriate for text/uri-list data, and then set result to the first URL from the list, if any, or the empty string otherwise. [RFC2483]

Return result.

The setData(format, data) method must run the following steps:

If the DataTransfer object is no longer associated with a drag data store, return. Nothing happens.

If the drag data store's mode is not the read/write mode, return. Nothing happens.

Let format be the first argument, converted to ASCII lowercase.

If format equals "text", change it to "text/plain".

If format equals "url", change it to "text/uri-list".

Remove the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, if there is one.

Add an item to the drag data store item list whose kind is Plain Unicode string, whose type string is equal to format, and whose data is the string given by the method's second argument.

The clearData() method must run the following steps:

If the DataTransfer object is no longer associated with a drag data store, return. Nothing happens.

If the drag data store's mode is not the read/write mode, return. Nothing happens.

If the method was called with no arguments, remove each item in the drag data store item list whose kind is Plain Unicode string, and return.

Let format be the first argument, converted to ASCII lowercase.

If format equals "text", change it to "text/plain".

If format equals "url", change it to "text/uri-list".

Remove the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, if there is one.

The clearData() method does not affect whether any files were included in the drag, so the types attribute's list might still not be empty after calling clearData() (it would still contain the "Files" string if any files were included in the drag).

The files attribute must return a live FileList sequence consisting of File objects representing the files found by the following steps. Furthermore, for a given FileList object and a given underlying file, the same File object must be used each time.

Start with an empty list L.

If the DataTransfer object is no longer associated with a drag data store, the FileList is empty. Return the empty list L.

If the drag data store's mode is the protected mode, Return the empty list L.

For each item in the drag data store item list whose kind is File , add the item's data (the file, in particular its name and contents, as well as its type) to the list L.

The files found by these steps are those in the list L.

This version of the API does not expose the types of the files during the drag.

6.7.3.1 The DataTransferItemList interface
Each DataTransfer object is associated with a DataTransferItemList object.

[Exposed=Window]
interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter DataTransferItem (unsigned long index);
  DataTransferItem? add(DOMString data, DOMString type);
  DataTransferItem? add(File data);
  void remove(unsigned long index);
  void clear();
};
items . length
Returns the number of items in the drag data store.

items[index]
Returns the DataTransferItem object representing the indexth entry in the drag data store.

items . remove(index)
Removes the indexth entry in the drag data store.

items . clear()
Removes all the entries in the drag data store.

items . add(data)
items . add(data, type)
Adds a new entry for the given data to the drag data store. If the data is plain text then a type string has to be provided also.

While the DataTransferItemList object's DataTransfer object is associated with a drag data store, the DataTransferItemList object's mode is the same as the drag data store mode. When the DataTransferItemList object's DataTransfer object is not associated with a drag data store, the DataTransferItemList object's mode is the disabled mode. The drag data store referenced in this section (which is used only when the DataTransferItemList object is not in the disabled mode) is the drag data store with which the DataTransferItemList object's DataTransfer object is associated.

The length attribute must return zero if the object is in the disabled mode; otherwise it must return the number of items in the drag data store item list.

When a DataTransferItemList object is not in the disabled mode, its supported property indices are the numbers in the range 0 .. n-1, where n is the number of items in the drag data store item list.

To determine the value of an indexed property i of a DataTransferItemList object, the user agent must return a DataTransferItem object representing the ith item in the drag data store. The same object must be returned each time a particular item is obtained from this DataTransferItemList object. The DataTransferItem object must be associated with the same DataTransfer object as the DataTransferItemList object when it is first created.

The add() method must run the following steps:

If the DataTransferItemList object is not in the read/write mode, return null.

Jump to the appropriate set of steps from the following list:

If the first argument to the method is a string
If there is already an item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to the value of the method's second argument, converted to ASCII lowercase, then throw a "NotSupportedError" DOMException.

Otherwise, add an item to the drag data store item list whose kind is Plain Unicode string, whose type string is equal to the value of the method's second argument, converted to ASCII lowercase, and whose data is the string given by the method's first argument.

If the first argument to the method is a File
Add an item to the drag data store item list whose kind is File, whose type string is the type of the File, converted to ASCII lowercase, and whose data is the same as the File's data.

Determine the value of the indexed property corresponding to the newly added item, and return that value (a newly created DataTransferItem object).

The remove() method, when invoked with the argument i, must run these steps:

If the DataTransferItemList object is not in the read/write mode, throw an "InvalidStateError" DOMException.

Remove the ith item from the drag data store.

The clear() method, if the DataTransferItemList object is in the read/write mode, must remove all the items from the drag data store. Otherwise, it must do nothing.

6.7.3.2 The DataTransferItem interface
Each DataTransferItem object is associated with a DataTransfer object.

[Exposed=Window]
interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(FunctionStringCallback? _callback);
  File? getAsFile();
};

callback FunctionStringCallback = void (DOMString data);
item . kind
Returns the drag data item kind, one of: "string", "file".

item . type
Returns the drag data item type string.

item . getAsString(callback)
Invokes the callback with the string data as the argument, if the drag data item kind is Plain Unicode string.

file = item . getAsFile()
Returns a File object, if the drag data item kind is File.

While the DataTransferItem object's DataTransfer object is associated with a drag data store and that drag data store's drag data store item list still contains the item that the DataTransferItem object represents, the DataTransferItem object's mode is the same as the drag data store mode. When the DataTransferItem object's DataTransfer object is not associated with a drag data store, or if the item that the DataTransferItem object represents has been removed from the relevant drag data store item list, the DataTransferItem object's mode is the disabled mode. The drag data store referenced in this section (which is used only when the DataTransferItem object is not in the disabled mode) is the drag data store with which the DataTransferItem object's DataTransfer object is associated.

The kind attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return the string given in the cell from the second column of the following table from the row whose cell in the first column contains the drag data item kind of the item represented by the DataTransferItem object:

Kind	String
Plain Unicode string	"string"
File	"file"
The type attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return the drag data item type string of the item represented by the DataTransferItem object.

The getAsString(callback) method must run the following steps:

If the callback is null, return.

If the DataTransferItem object is not in the read/write mode or the read-only mode, return. The callback is never invoked.

If the drag data item kind is not Plain Unicode string, then return. The callback is never invoked.

Otherwise, queue a task to invoke callback, passing the actual data of the item represented by the DataTransferItem object as the argument.

The getAsFile() method must run the following steps:

If the DataTransferItem object is not in the read/write mode or the read-only mode, then return null.

If the drag data item kind is not File, then return null.

Return a new File object representing the actual data of the item represented by the DataTransferItem object.

6.7.4 The DragEvent interface
The drag-and-drop processing model involves several events. They all use the DragEvent interface.

[Exposed=Window,
 Constructor(DOMString type, optional DragEventInit eventInitDict)]
interface DragEvent : MouseEvent {
  readonly attribute DataTransfer? dataTransfer;
};

dictionary DragEventInit : MouseEventInit {
  DataTransfer? dataTransfer = null;
};
event . dataTransfer
Returns the DataTransfer object for the event.

Although, for consistency with other event interfaces, the DragEvent interface has a constructor, it is not particularly useful. In particular, there's no way to create a useful DataTransfer object from script, as DataTransfer objects have a processing and security model that is coordinated by the browser during drag-and-drops.

The dataTransfer attribute of the DragEvent interface must return the value it was initialized to. It represents the context information for the event.

When a user agent is required to fire a DND event named e at an element, using a particular drag data store, and optionally with a specific related target, the user agent must run the following steps:

Let dataDragStoreWasChanged be false.
If no specific related target was provided, set related target to null.

Let window be the Window object of the Document object of the specified target element.

If e is dragstart, then set the drag data store mode to the read/write mode and set dataDragStoreWasChanged to true.

If e is drop, set the drag data store mode to the read-only mode.

Let dataTransfer be a newly created DataTransfer object associated with the given drag data store.

Set the effectAllowed attribute to the drag data store's drag data store allowed effects state.

Set the dropEffect attribute to "none" if e is dragstart, drag, dragexit, or dragleave; to the value corresponding to the current drag operation if e is drop or dragend; and to a value based on the effectAllowed attribute's value and the drag-and-drop source, as given by the following table, otherwise (i.e. if e is dragenter or dragover):

effectAllowed	dropEffect
"none"	"none"
"copy"	"copy"
"copyLink"	"copy", or, if appropriate, "link"
"copyMove"	"copy", or, if appropriate, "move"
"all"	"copy", or, if appropriate, either "link" or "move"
"link"	"link"
"linkMove"	"link", or, if appropriate, "move"
"move"	"move"
"uninitialized" when what is being dragged is a selection from a text control	"move", or, if appropriate, either "copy" or "link"
"uninitialized" when what is being dragged is a selection	"copy", or, if appropriate, either "link" or "move"
"uninitialized" when what is being dragged is an a element with an href attribute	"link", or, if appropriate, either "copy" or "move"
Any other case	"copy", or, if appropriate, either "link" or "move"
Where the table above provides possibly appropriate alternatives, user agents may instead use the listed alternative values if platform conventions dictate that the user has requested those alternate effects.

For example, Windows platform conventions are such that dragging while holding the "alt" key indicates a preference for linking the data, rather than moving or copying it. Therefore, on a Windows system, if "link" is an option according to the table above while the "alt" key is depressed, the user agent could select that instead of "copy" or "move".

Let event be the result of creating an event using DragEvent.

Initialize event's type attribute to e, its bubbles attribute to true, its view attribute to window, its relatedTarget attribute to related target, and its dataTransfer attribute to dataTransfer.

If e is not dragexit, dragleave, or dragend, then initialize event's cancelable attribute to true.

Initialize event's mouse and key attributes initialized according to the state of the input devices as they would be for user interaction events.

If there is no relevant pointing device, then initialize event's screenX, screenY, clientX, clientY, and button attributes to 0.

Dispatch event at the specified target element.

Set the drag data store allowed effects state to the current value of dataTransfer's effectAllowed attribute. (It can only have changed value if e is dragstart.)

If dataDragStoreWasChanged is true, then set the drag data store mode back to the protected mode.

Break the association between dataTransfer and the drag data store.

6.7.5 Processing model
When the user attempts to begin a drag operation, the user agent must run the following steps. User agents must act as if these steps were run even if the drag actually started in another document or application and the user agent was not aware that the drag was occurring until it intersected with a document under the user agent's purview.

Determine what is being dragged, as follows:

If the drag operation was invoked on a selection, then it is the selection that is being dragged.

Otherwise, if the drag operation was invoked on a Document, it is the first element, going up the ancestor chain, starting at the node that the user tried to drag, that has the IDL attribute draggable set to true. If there is no such element, then nothing is being dragged; return, the drag-and-drop operation is never started.

Otherwise, the drag operation was invoked outside the user agent's purview. What is being dragged is defined by the document or application where the drag was started.

img elements and a elements with an href attribute have their draggable attribute set to true by default.

Create a drag data store. All the DND events fired subsequently by the steps in this section must use this drag data store.

Establish which DOM node is the source node, as follows:

If it is a selection that is being dragged, then the source node is the Text node that the user started the drag on (typically the Text node that the user originally clicked). If the user did not specify a particular node, for example if the user just told the user agent to begin a drag of "the selection", then the source node is the first Text node containing a part of the selection.

Otherwise, if it is an element that is being dragged, then the source node is the element that is being dragged.

Otherwise, the source node is part of another document or application. When this specification requires that an event be dispatched at the source node in this case, the user agent must instead follow the platform-specific conventions relevant to that situation.

Multiple events are fired on the source node during the course of the drag-and-drop operation.

Determine the list of dragged nodes, as follows:

If it is a selection that is being dragged, then the list of dragged nodes contains, in tree order, every node that is partially or completely included in the selection (including all their ancestors).

Otherwise, the list of dragged nodes contains only the source node, if any.

If it is a selection that is being dragged, then add an item to the drag data store item list, with its properties set as follows:

The drag data item type string
"text/plain"
The drag data item kind
Plain Unicode string
The actual data
The text of the selection
Otherwise, if any files are being dragged, then add one item per file to the drag data store item list, with their properties set as follows:

The drag data item type string
The MIME type of the file, if known, or "application/octet-stream" otherwise.
The drag data item kind
File
The actual data
The file's contents and name.
Dragging files can currently only happen from outside a browsing context, for example from a file system manager application.

If the drag initiated outside of the application, the user agent must add items to the drag data store item list as appropriate for the data being dragged, honoring platform conventions where appropriate; however, if the platform conventions do not use MIME types to label dragged data, the user agent must make a best-effort attempt to map the types to MIME types, and, in any case, all the drag data item type strings must be converted to ASCII lowercase.

User agents may also add one or more items representing the selection or dragged element(s) in other forms, e.g. as HTML.

If the list of dragged nodes is not empty, then extract the microdata from those nodes into a JSON form, and add one item to the drag data store item list, with its properties set as follows:

The drag data item type string
application/microdata+json
The drag data item kind
Plain Unicode string
The actual data
The resulting JSON string.
Run the following substeps:

Let urls be an empty list of absolute URLs.

For each node in the list of dragged nodes:

If the node is an a element with an href attribute
Add to urls the result of parsing the element's href content attribute relative to the element's node document.
If the node is an img element with a src attribute
Add to urls the result of parsing the element's src content attribute relative to the element's node document.
If urls is still empty, then return.

Let url string be the result of concatenating the strings in urls, in the order they were added, separated by a U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).

Add one item to the drag data store item list, with its properties set as follows:

The drag data item type string
text/uri-list
The drag data item kind
Plain Unicode string
The actual data
url string
Update the drag data store default feedback as appropriate for the user agent (if the user is dragging the selection, then the selection would likely be the basis for this feedback; if the user is dragging an element, then that element's rendering would be used; if the drag began outside the user agent, then the platform conventions for determining the drag feedback should be used).

Fire a DND event named dragstart at the source node.

If the event is canceled, then the drag-and-drop operation should not occur; return.

Since events with no event listeners registered are, almost by definition, never canceled, drag-and-drop is always available to the user if the author does not specifically prevent it.

Initiate the drag-and-drop operation in a manner consistent with platform conventions, and as described below.

The drag-and-drop feedback must be generated from the first of the following sources that is available:

The drag data store bitmap, if any. In this case, the drag data store hot spot coordinate should be used as hints for where to put the cursor relative to the resulting image. The values are expressed as distances in CSS pixels from the left side and from the top side of the image respectively. [CSS]
The drag data store default feedback.
From the moment that the user agent is to initiate the drag-and-drop operation, until the end of the drag-and-drop operation, device input events (e.g. mouse and keyboard events) must be suppressed.

During the drag operation, the element directly indicated by the user as the drop target is called the immediate user selection. (Only elements can be selected by the user; other nodes must not be made available as drop targets.) However, the immediate user selection is not necessarily the current target element, which is the element currently selected for the drop part of the drag-and-drop operation.

The immediate user selection changes as the user selects different elements (either by pointing at them with a pointing device, or by selecting them in some other way). The current target element changes when the immediate user selection changes, based on the results of event listeners in the document, as described below.

Both the current target element and the immediate user selection can be null, which means no target element is selected. They can also both be elements in other (DOM-based) documents, or other (non-Web) programs altogether. (For example, a user could drag text to a word-processor.) The current target element is initially null.

In addition, there is also a current drag operation, which can take on the values "none", "copy", "link", and "move". Initially, it has the value "none". It is updated by the user agent as described in the steps below.

User agents must, as soon as the drag operation is initiated and every 350ms (±200ms) thereafter for as long as the drag operation is ongoing, queue a task to perform the following steps in sequence:

If the user agent is still performing the previous iteration of the sequence (if any) when the next iteration becomes due, return for this iteration (effectively "skipping missed frames" of the drag-and-drop operation).

Fire a DND event named drag at the source node. If this event is canceled, the user agent must set the current drag operation to "none" (no drag operation).

If the drag event was not canceled and the user has not ended the drag-and-drop operation, check the state of the drag-and-drop operation, as follows:

If the user is indicating a different immediate user selection than during the last iteration (or if this is the first iteration), and if this immediate user selection is not the same as the current target element, then fire a DND event named dragexit at the current target element, and then update the current target element as follows:

If the new immediate user selection is null
Set the current target element to null also.

If the new immediate user selection is in a non-DOM document or application
Set the current target element to the immediate user selection.

Otherwise
Fire a DND event named dragenter at the immediate user selection.

If the event is canceled, then set the current target element to the immediate user selection.

Otherwise, run the appropriate step from the following list:

If the immediate user selection is a text control (e.g., textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
Set the current target element to the immediate user selection anyway.

If the immediate user selection is the body element
Leave the current target element unchanged.

Otherwise
Fire a DND event named dragenter at the body element, if there is one, or at the Document object, if not. Then, set the current target element to the body element, regardless of whether that event was canceled or not.

If the previous step caused the current target element to change, and if the previous target element was not null or a part of a non-DOM document, then fire a DND event named dragleave at the previous target element, with the new current target element as the specific related target.

If the current target element is a DOM element, then fire a DND event named dragover at this current target element.

If the dragover event is not canceled, run the appropriate step from the following list:

If the current target element is a text control (e.g., textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
Set the current drag operation to either "copy" or "move", as appropriate given the platform conventions.

Otherwise
Reset the current drag operation to "none".

Otherwise (if the dragover event is canceled), set the current drag operation based on the values of the effectAllowed and dropEffect attributes of the DragEvent object's dataTransfer object as they stood after the event dispatch finished, as per the following table:

effectAllowed	dropEffect	Drag operation
"uninitialized", "copy", "copyLink", "copyMove", or "all"	"copy"	"copy"
"uninitialized", "link", "copyLink", "linkMove", or "all"	"link"	"link"
"uninitialized", "move", "copyMove", "linkMove", or "all"	"move"	"move"
Any other case	"none"
Otherwise, if the current target element is not a DOM element, use platform-specific mechanisms to determine what drag operation is being performed (none, copy, link, or move), and set the current drag operation accordingly.

Update the drag feedback (e.g. the mouse cursor) to match the current drag operation, as follows:

Drag operation	Feedback
"copy"	Data will be copied if dropped here.
"link"	Data will be linked if dropped here.
"move"	Data will be moved if dropped here.
"none"	No operation allowed, dropping here will cancel the drag-and-drop operation.
Otherwise, if the user ended the drag-and-drop operation (e.g. by releasing the mouse button in a mouse-driven drag-and-drop interface), or if the drag event was canceled, then this will be the last iteration. Run the following steps, then stop the drag-and-drop operation:

If the current drag operation is "none" (no drag operation), or, if the user ended the drag-and-drop operation by canceling it (e.g. by hitting the Escape key), or if the current target element is null, then the drag operation failed. Run these substeps:

Let dropped be false.

If the current target element is a DOM element, fire a DND event named dragleave at it; otherwise, if it is not null, use platform-specific conventions for drag cancelation.

Set the current drag operation to "none".

Otherwise, the drag operation might be a success; run these substeps:

Let dropped be true.

If the current target element is a DOM element, fire a DND event named drop at it; otherwise, use platform-specific conventions for indicating a drop.

If the event is canceled, set the current drag operation to the value of the dropEffect attribute of the DragEvent object's dataTransfer object as it stood after the event dispatch finished.

Otherwise, the event is not canceled; perform the event's default action, which depends on the exact target as follows:

If the current target element is a text control (e.g., textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
Insert the actual data of the first item in the drag data store item list to have a drag data item type string of "text/plain" and a drag data item kind that is Plain Unicode string into the text control or editing host or editable element in a manner consistent with platform-specific conventions (e.g. inserting it at the current mouse cursor position, or inserting it at the end of the field).

Otherwise
Reset the current drag operation to "none".

Fire a DND event named dragend at the source node.

Run the appropriate steps from the following list as the default action of the dragend event:

If dropped is true, the current target element is a text control (see below), the current drag operation is "move", and the source of the drag-and-drop operation is a selection in the DOM that is entirely contained within an editing host
Delete the selection.

If dropped is true, the current target element is a text control (see below), the current drag operation is "move", and the source of the drag-and-drop operation is a selection in a text control
The user agent should delete the dragged selection from the relevant text control.

If dropped is false or if the current drag operation is "none"
The drag was canceled. If the platform conventions dictate that this be represented to the user (e.g. by animating the dragged selection going back to the source of the drag-and-drop operation), then do so.

Otherwise
The event has no default action.

For the purposes of this step, a text control is a textarea element or an input element whose type attribute is in one of the Text, Search, Tel, URL, E-mail, Password, or Number states.

User agents are encouraged to consider how to react to drags near the edge of scrollable regions. For example, if a user drags a link to the bottom of the viewport on a long page, it might make sense to scroll the page so that the user can drop the link lower on the page.

This model is independent of which Document object the nodes involved are from; the events are fired as described above and the rest of the processing model runs as described above, irrespective of how many documents are involved in the operation.

6.7.6 Events summary
This section is non-normative.

The following events are involved in the drag-and-drop model.

Event name	Target	Cancelable?	Drag data store mode	dropEffect	Default Action
dragstart	Source node	✓ Cancelable	Read/write mode	"none"	Initiate the drag-and-drop operation
drag	Source node	✓ Cancelable	Protected mode	"none"	Continue the drag-and-drop operation
dragenter	Immediate user selection or the body element	✓ Cancelable	Protected mode	Based on effectAllowed value	Reject immediate user selection as potential target element
dragexit	Previous target element	—	Protected mode	"none"	None
dragleave	Previous target element	—	Protected mode	"none"	None
dragover	Current target element	✓ Cancelable	Protected mode	Based on effectAllowed value	Reset the current drag operation to "none"
drop	Current target element	✓ Cancelable	Read-only mode	Current drag operation	Varies
dragend	Source node	—	Protected mode	Current drag operation	Varies
Not shown in the above table: all these events bubble, are composed, and the effectAllowed attribute always has the value it had after the dragstart event, defaulting to "uninitialized" in the dragstart event.

6.7.7 The draggable attribute

Spec bugs: 26024

All HTML elements may have the draggable content attribute set. The draggable attribute is an enumerated attribute. It has three states. The first state is true and it has the keyword true. The second state is false and it has the keyword false. The third state is auto; it has no keywords but it is the missing value default and the invalid value default.

The true state means the element is draggable; the false state means that it is not. The auto state uses the default behavior of the user agent.

An element with a draggable attribute should also have a title attribute that names the element for the purpose of non-visual interactions.

element . draggable [ = value ]
Returns true if the element is draggable; otherwise, returns false.

Can be set, to override the default and set the draggable content attribute.

The draggable IDL attribute, whose value depends on the content attribute's in the way described below, controls whether or not the element is draggable. Generally, only text selections are draggable, but elements whose draggable IDL attribute is true become draggable as well.

If an element's draggable content attribute has the state true, the draggable IDL attribute must return true.

Otherwise, if the element's draggable content attribute has the state false, the draggable IDL attribute must return false.

Otherwise, the element's draggable content attribute has the state auto. If the element is an img element, an object element that represents an image, or an a element with an href content attribute, the draggable IDL attribute must return true; otherwise, the draggable IDL attribute must return false.

If the draggable IDL attribute is set to the value false, the draggable content attribute must be set to the literal value "false". If the draggable IDL attribute is set to the value true, the draggable content attribute must be set to the literal value "true".

6.7.8 Security risks in the drag-and-drop model
User agents must not make the data added to the DataTransfer object during the dragstart event available to scripts until the drop event, because otherwise, if a user were to drag sensitive information from one document to a second document, crossing a hostile third document in the process, the hostile document could intercept the data.

For the same reason, user agents must consider a drop to be successful only if the user specifically ended the drag operation — if any scripts end the drag operation, it must be considered unsuccessful (canceled) and the drop event must not be fired.

User agents should take care to not start drag-and-drop operations in response to script actions. For example, in a mouse-and-window environment, if a script moves a window while the user has their mouse button depressed, the UA would not consider that to start a drag. This is important because otherwise UAs could cause data to be dragged from sensitive sources and dropped into hostile documents without the user's consent.

User agents should filter potentially active (scripted) content (e.g. HTML) when it is dragged and when it is dropped, using a safelist of known-safe features. Similarly, relative URLs should be turned into absolute URLs to avoid references changing in unexpected ways. This specification does not specify how this is performed.

Consider a hostile page providing some content and getting the user to select and drag and drop (or indeed, copy and paste) that content to a victim page's contenteditable region. If the browser does not ensure that only safe content is dragged, potentially unsafe content such as scripts and event handlers in the selection, once dropped (or pasted) into the victim site, get the privileges of the victim site. This would thus enable a cross-site scripting attack.

7 Loading Web pages
This section describes features that apply most directly to Web browsers. Having said that, except where specified otherwise, the requirements defined in this section do apply to all user agents, whether they are Web browsers or not.

7.1 Browsing contexts
A browsing context is an environment in which Document objects are presented to the user.

A tab or window in a Web browser typically contains a browsing context, as does an iframe or frames in a frameset.

A browsing context has a corresponding WindowProxy object.

A browsing context has a session history, which lists the Document objects that the browsing context has presented, is presenting, or will present. A browsing context's active document is its WindowProxy object's [[Window]] internal slot value's associated Document. A Document's browsing context is the browsing context whose session history contains the Document, if any such browsing context exists and has not been discarded.

In general, there is a 1-to-1 mapping from the Window object to the Document object, as long as the Document object has a browsing context. There are two exceptions. First, a Window can be reused for the presentation of a second Document in the same browsing context, such that the mapping is then 1-to-2. This occurs when a browsing context is navigated from the initial about:blank Document to another, with replacement enabled. Second, a Document can end up being reused for several Window objects when the document.open() method is used, such that the mapping is then many-to-1.

A Document does not necessarily have a browsing context associated with it. In particular, data mining tools are likely to never instantiate browsing contexts. A Document created using an API such as createDocument() never has a browsing context. And the Document originally created for an iframe element, which has since been removed from the document, has no associated browsing context, since that browsing context was discarded.

To set the active document of a browsing context browsingContext to a Document object document, optionally with a Window object window, run these steps:

If window is not given, let window be document's relevant global object.

Per this standard document can be created before window, which does not make much sense. See issue #2688.

Set browsingContext's WindowProxy object's [[Window]] internal slot value to window.

Set window's associated Document to document.

Set window's relevant settings object's execution ready flag.

A browsing context can have a creator browsing context, the browsing context that was responsible for its creation. If a browsing context has a parent browsing context, then that is its creator browsing context. Otherwise, if the browsing context has an opener browsing context, then that is its creator browsing context. Otherwise, the browsing context has no creator browsing context.

If a browsing context context has a creator browsing context creator, it also has the following properties. In what follows, let creator document be creator's active document at the time context is created:

creator origin
creator document's origin
creator URL
creator document's URL
creator base URL
creator document's base URL
creator referrer policy
creator document's referrer policy
To create a new browsing context, optionally given noopener:

If noopener was not given, let it be false.

Let browsingContext be a new browsing context.

Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:

For the global object, create a new Window object window.

For the global this value, use browsingContext's WindowProxy object.

Let realm execution context be the running JavaScript execution context.

This is the JavaScript execution context created in the previous step.

Set up a window environment settings object with realm execution context, and let settingsObject be the result.

Let document be a new Document, marked as an HTML document in quirks mode, whose content type is "text/html", and which is both ready for post-load tasks and completely loaded immediately.

Ensure that document has a single child html node, which itself has two empty child nodes: a head element, and a body element.

Set the active document of browsingContext to document.

Set the origin of document:

If browsingContext has a creator browsing context, then the origin of document is the creator origin.

Otherwise, the origin of document is a unique opaque origin.

If browsingContext has a creator browsing context, then set document's referrer to the serialization of creator URL.

If browsingContext has a creator browsing context, then set document's referrer policy to the creator referrer policy.

Implement the sandboxing for document.

Set the allow* flags for document.

Add document to browsingContext's session history.

If noopener is false, browsingContext is a top-level browsing context, and creator origin is same origin with document's origin, then copy the sessionStorage storage area of the creator origin from the creator browsing context into browsingContext's set of session storage areas. These areas must be considered separate, not affecting each other in any way.

Return browsingContext.

7.1.1 Nested browsing contexts
Certain elements (for example, iframe elements) can instantiate further browsing contexts. These elements are called browsing context containers.

Each browsing context container has a nested browsing context, which is either a browsing context or null.

If a browsing context is the nested browsing context of a browsing context container, then the browsing context is said to be nested through the browsing context container's node document.

A browsing context child is said to be a child browsing context of another browsing context parent, if all of the following conditions hold:

child is a nested browsing context of a browsing context container element

element is connected

element's shadow-including root's browsing context is parent

A browsing context child is then a document-tree child browsing context of parent if it is a child browsing context and its browsing context container is not just connected, but also in a document tree.

A browsing context child may have a parent browsing context. This is the unique browsing context that has child as a child browsing context, if any such browsing context exists. Otherwise, the browsing context has no parent browsing context.

A browsing context A is said to be an ancestor of a browsing context B if there exists a browsing context A' that is a child browsing context of A and that is itself an ancestor of B, or if the browsing context A is the parent browsing context of B.

A browsing context that is not a nested browsing context has no parent browsing context, and is the top-level browsing context of all the browsing contexts for which it is an ancestor browsing context.

The transitive closure of parent browsing contexts for a browsing context that is a nested browsing context gives the list of ancestor browsing contexts.

The list of the descendant browsing contexts of a Document d is the (ordered) list returned by the following algorithm:

Let list be an empty list.

For each child browsing context of d that is nested through an element that is in the Document d, in the tree order of the elements nesting those browsing contexts, run these substeps:

Append that child browsing context to the list list.

Append the list of the descendant browsing contexts of the active document of that child browsing context to the list list.

Return the constructed list.

A Document is said to be fully active when it has a browsing context and it is the active document of that browsing context, and either its browsing context is a top-level browsing context, or it has a parent browsing context and the Document through which it is nested is itself fully active.

Because they are associated with an element, child browsing contexts are always tied to a specific Document in their parent browsing context. User agents must not allow the user to interact with child browsing contexts of elements that are in Documents that are not themselves fully active.

A browsing context that is a nested browsing context can be put into a delaying load events mode. This is used when it is navigated, to delay the load event of its browsing context container before the new Document is created.

The document family of a browsing context consists of the union of all the Document objects in that browsing context's session history and the document families of all those Document objects. The document family of a Document object consists of the union of all the document families of the browsing contexts that are nested through the Document object.

The content document of a browsing context container container is the result of the following algorithm:

If container's nested browsing context is null, then return null.

Let context be container's nested browsing context.

Let document be context's active document.

If document's origin and the origin specified by the current settings object are not same origin-domain, then return null.

Return document.

7.1.1.1 Navigating nested browsing contexts in the DOM
window . top
Returns the WindowProxy for the top-level browsing context.

window . parent
Returns the WindowProxy for the parent browsing context.

window . frameElement
Returns the Element for the browsing context container.

Returns null if there isn't one, and in cross-origin situations.

The top IDL attribute, on getting, must run the following algorithm:

Let windowProxy be this Window object's WindowProxy object.

If there is no browsing context with windowProxy as its WindowProxy object, then return null.

Let context be that browsing context.

If context is a top-level browsing context, then return context's WindowProxy object.

Otherwise, context must have a top-level browsing context (i.e. an ancestor browsing context with no parent browsing context). Return that top-level browsing context's WindowProxy object.

The parent IDL attribute, on getting, must run the following algorithm:

Let windowProxy be this Window object's WindowProxy object.

If there is no browsing context with windowProxy as its WindowProxy object, then return null.

Let context be that browsing context.

If context is a child browsing context of another browsing context parent, then return parent's WindowProxy object.

Otherwise, context must be a top-level browsing context. Return context's WindowProxy object.

The frameElement IDL attribute, on getting, must run the following algorithm:

Let windowProxy be this Window object's WindowProxy object.

If there is no browsing context with windowProxy as its WindowProxy object, then return null.

Let context be that browsing context.

If context is not a nested browsing context, then return null.

Let container be context's browsing context container.

If container's node document's origin is not same origin-domain with the current settings object's origin, then return null.

Return container.

An example of when these IDL attributes can return null is as follows:

<!DOCTYPE html>
<iframe></iframe>

<script>
"use strict";
const element = document.querySelector("iframe");
const iframeWindow = element.contentWindow;
element.remove();

console.assert(iframeWindow.top === null);
console.assert(iframeWindow.parent === null);
console.assert(iframeWindow.frameElement === null);
</script>
Here the browsing context corresponding to iframeWindow was discarded when element was removed from the document.

7.1.2 Auxiliary browsing contexts
It is possible to create new browsing contexts that are related to a top-level browsing context without being nested through an element. Such browsing contexts are called auxiliary browsing contexts. Auxiliary browsing contexts are always top-level browsing contexts.

An auxiliary browsing context has an opener browsing context, which is the browsing context from which the auxiliary browsing context was created.

7.1.2.1 Navigating auxiliary browsing contexts in the DOM
An auxiliary browsing context can be disowned.

The opener attribute's getter must run these steps:

If the current browsing context is disowned, then return null.

If the current browsing context has no opener browsing context, then return null.

Return the current browsing context's opener browsing context's WindowProxy object.

The opener attribute's setter, must run these steps:

If the given value is null, then disown the current browsing context and return.

Return the result of calling OrdinaryDefineOwnProperty(this Window object, "opener", { [[Value]]: the given value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }). Rethrow any exceptions.

If a browsing context is disowned, its window.opener attribute is null. That prevents scripts in the browsing context from changing any properties of its opener browsing context's Window object (i.e., the Window object from which the browsing context was created).

Otherwise, if a browsing context is not disowned, then scripts in that browsing context can use window.opener to change properties of its opener browsing context's Window object. For example, a script running in the browsing context can change the value of window.opener.location, causing the opener browsing context to navigate to a completely different document.

7.1.3 Security
A browsing context A is familiar with a second browsing context B if one of the following conditions is true:

Either the origin of the active document of A is the same as the origin of the active document of B, or
The browsing context A is a nested browsing context with a top-level browsing context, and its top-level browsing context is B, or
The browsing context B is an auxiliary browsing context and A is familiar with B's opener browsing context, or
The browsing context B is not a top-level browsing context, but there exists an ancestor browsing context of B whose active document has the same origin as the active document of A (possibly in fact being A itself).
A browsing context A is allowed to navigate a second browsing context B if the following algorithm returns true:

If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A's active document's active sandboxing flag set has its sandboxed navigation browsing context flag set, then return false.

Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:

If this algorithm is triggered by user activation and A's active document's active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then return false.

Otherwise, if this algorithm is not triggered by user activation and A's active document's active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then return false.

Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A's Document's active sandboxing flag set has its sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then return false.

Return true.

An element has a browsing context scope origin if its Document's browsing context is a top-level browsing context or if all of its Document's ancestor browsing contexts all have active documents whose origin are the same origin as the element's node document's origin. If an element has a browsing context scope origin, then its value is the origin of the element's node document.

7.1.4 Groupings of browsing contexts
Each browsing context is defined as having a list of one or more directly reachable browsing contexts. These are:

The browsing context itself.
All the browsing context's child browsing contexts.
The browsing context's parent browsing context.
All the browsing contexts that have the browsing context as their opener browsing context.
The browsing context's opener browsing context.
The transitive closure of all the browsing contexts that are directly reachable browsing contexts forms a unit of related browsing contexts.

Each unit of related browsing contexts is then further divided into the smallest number of groups such that every member of each group has an active document with an origin that, through appropriate manipulation of the document.domain attribute, could be made to be same origin-domain with other members of the group, but could not be made the same as members of any other group. Each such group is a unit of related similar-origin browsing contexts.

There is also at most one event loop per unit of related similar-origin browsing contexts (though several units of related similar-origin browsing contexts can have a shared event loop).

7.1.5 Browsing context names
Browsing contexts can have a browsing context name. Unless stated otherwise, it is the empty string.

A valid browsing context name is any string with at least one character that does not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for special keywords.)

A valid browsing context name or keyword is any string that is either a valid browsing context name or that is an ASCII case-insensitive match for one of: _blank, _self, _parent, or _top.

These values have different meanings based on whether the page is sandboxed or not, as summarized in the following (non-normative) table. In this table, "current" means the browsing context that the link or script is in, "parent" means the parent browsing context of the one the link or script is in, "top" means the top-level browsing context of the one the link or script is in, "new" means a new top-level browsing context or auxiliary browsing context is to be created, subject to various user preferences and user agent policies, "none" means that nothing will happen, and "maybe new" means the same as "new" if the "allow-popups" keyword is also specified on the sandbox attribute (or if the user overrode the sandboxing), and the same as "none" otherwise.

Keyword	Ordinary effect	Effect in an iframe with...
sandbox=""	sandbox="allow-top-navigation"
none specified, for links and form submissions	current	current	current
empty string	current	current	current
_blank	new	maybe new	maybe new
_self	current	current	current
_parent if there isn't a parent	current	current	current
_parent if parent is also top	parent/top	none	parent/top
_parent if there is one and it's not top	parent	none	none
_top if top is current	current	current	current
_top if top is not current	top	none	top
name that doesn't exist	new	maybe new	maybe new
name that exists and is a descendant	specified descendant	specified descendant	specified descendant
name that exists and is current	current	current	current
name that exists and is an ancestor that is top	specified ancestor	none	specified ancestor/top
name that exists and is an ancestor that is not top	specified ancestor	none	none
other name that exists with common top	specified	none	none
name that exists with different top, if familiar and one permitted sandboxed navigator	specified	specified	specified
name that exists with different top, if familiar but not one permitted sandboxed navigator	specified	none	none
name that exists with different top, not familiar	new	maybe new	maybe new
Most of the restrictions on sandboxed browsing contexts are applied by other algorithms, e.g. the navigation algorithm, not the rules for choosing a browsing context given below.

The rules for choosing a browsing context, given a browsing context name name, a browsing context current, and a boolean noopener are as follows:

Let chosen be null.

Let new be false.

If name is the empty string or an ASCII case-insensitive match for "_self", then set chosen to current.

If name is an ASCII case-insensitive match for "_parent", then set chosen to current's parent browsing context, if any, and current otherwise.

If name is an ASCII case-insensitive match for "_top", then set chosen to current's top-level browsing context, if any, and current otherwise.

If name is not an ASCII case-insensitive match for "_blank" and there exists a browsing context whose name is the same as name, and current is familiar with that browsing context, and the user agent determines that the two browsing contexts are related enough that it is ok if they reach each other, then set chosen to that browsing context. If there are multiple matching browsing contexts, the user agent should set chosen to one in some arbitrary consistent manner, such as the most recently opened, most recently focused, or more closely related.

This will be made more precise in issue #1440.

Otherwise, a new browsing context is being requested, and what happens depends on the user agent's configuration and abilities — it is determined by the rules given for the first applicable option from the following list:

If the algorithm is not triggered by user activation and the user agent has been configured to not show popups (i.e. the user agent has a "popup blocker" enabled)
The user agent may inform the user that a popup has been blocked.

If current's active document's active sandboxing flag set has the sandboxed auxiliary navigation browsing context flag set.
The user agent may offer the user one of:

Set chosen to a new top-level browsing context given noopener, and set new to true.

Set chosen to an existing top-level browsing context.

If this case occurs, it means that an author has explicitly sandboxed the document that is trying to open a link.

If the user declines or the user agent doesn't offer the above, the variables remain unchanged.

If the user agent has been configured such that in this instance it will create a new browsing context:
Set chosen to a new auxiliary browsing context given noopener with the opener browsing context being current, and set new to true. If name is not an ASCII case-insensitive match for "_blank", then chosen's name must be set to name.

If the newly created browsing context is immediately navigated, then the navigation will be done with replacement enabled.

If the user agent has been configured such that in this instance it will reuse current
Set chosen to current.

If the user agent has been configured such that in this instance it will not find a browsing context
Do nothing.

User agents are encouraged to provide a way for users to configure the user agent to always reuse current.

If new is true, then:

Let flagSet be current's active document's active sandboxing flag set.

If flagSet's sandboxed navigation browsing context flag is set, then current must be set as chosen's one permitted sandboxed navigator.

If flagSet's sandbox propagates to auxiliary browsing contexts flag is set, then all the flags that are set in flagSet must be set in chosen's popup sandboxing flag set.

Return chosen and new.

7.2 Security infrastructure for Window, WindowProxy, and Location objects
Although typically objects cannot be accessed across origins, the web platform would not be true to itself if it did not have some legacy exceptions to that rule that the web depends upon.

7.2.1 Integration with IDL
When perform a security check is invoked, with a platformObject, identifier, and type, run these steps:

If platformObject is a Window or Location object, then:

Repeat for each e that is an element of ! CrossOriginProperties(platformObject):

If SameValue(e.[[Property]], identifier) is true, then:

If type is "method" and e has neither [[NeedsGet]] nor [[NeedsSet]], then return.

Otherwise, if type is "getter" and e.[[NeedsGet]] is true, then return.

Otherwise, if type is "setter" and e.[[NeedsSet]] is true, then return.

If ! IsPlatformObjectSameOrigin(platformObject) is false, then throw a "SecurityError" DOMException.

7.2.2 Shared internal slot: [[CrossOriginPropertyDescriptorMap]]
Window and Location objects both have a [[CrossOriginPropertyDescriptorMap]] internal slot, whose value is initially an empty map.

The [[CrossOriginPropertyDescriptorMap]] internal slot contains a map with entries whose keys are (currentGlobal, objectGlobal, propertyKey)-tuples and values are property descriptors, as a memoization of what is visible to scripts when currentGlobal inspects a Window or Location object from objectGlobal. It is filled lazily by CrossOriginGetOwnPropertyHelper, which consults it on future lookups.

User agents should allow a value held in the map to be garbage collected along with its corresponding key when nothing holds a reference to any part of the value. That is, as long as garbage collection is not observable.

For example, with const href = Object.getOwnPropertyDescriptor(crossOriginLocation, "href").set the value and its corresponding key in the map cannot be garbage collected as that would be observable.

User agents may have an optimization whereby they remove key-value pairs from the map when document.domain is set. This is not observable as document.domain cannot revisit an earlier value.

For example, setting document.domain to "example.com" on www.example.com means user agents can remove all key-value pairs from the map where part of the key is www.example.com, as that can never be part of the origin again and therefore the corresponding value could never be retrieved from the map.

7.2.3 Shared abstract operations
7.2.3.1 CrossOriginProperties ( O )
Assert: O is a Location or Window object.

If O is a Location object, then return « { [[Property]]: "href", [[NeedsGet]]: false, [[NeedsSet]]: true }, { [[Property]]: "replace" } ».

Let crossOriginWindowProperties be « { [[Property]]: "window", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "self", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "location", [[NeedsGet]]: true, [[NeedsSet]]: true }, { [[Property]]: "close" }, { [[Property]]: "closed", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "focus" }, { [[Property]]: "blur" }, { [[Property]]: "frames", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "length", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "top", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "opener", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "parent", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "postMessage" } ».

Repeat for each e that is an element of O's document-tree child browsing context name property set:

Add { [[Property]]: e, [[HideFromKeys]]: true } as the last element of crossOriginWindowProperties.

Return crossOriginWindowProperties.

Indexed properties do not need to be safelisted as they are handled directly by the WindowProxy object.

7.2.3.2 IsPlatformObjectSameOrigin ( O )
Return true if the current settings object's origin is same origin-domain with O's relevant settings object's origin, and false otherwise.

7.2.3.3 CrossOriginGetOwnPropertyHelper ( O, P )
If this abstract operation returns undefined and there is no custom behavior, the caller needs to throw a "SecurityError" DOMException.

Let crossOriginKey be a tuple consisting of the current settings object, O's relevant settings object, and P.

Repeat for each e that is an element of ! CrossOriginProperties(O):

If SameValue(e.[[Property]], P) is true, then:

If the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O contains an entry whose key is crossOriginKey, then return that entry's value.

Let originalDesc be OrdinaryGetOwnProperty(O, P).

Let crossOriginDesc be undefined.

If e.[[NeedsGet]] and e.[[NeedsSet]] are absent, then:

Let value be originalDesc.[[Value]].

If ! IsCallable(value) is true, then set value to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the IDL operation P on object O.

Set crossOriginDesc to PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]: false, [[Configurable]]: true }.

Otherwise:

Let crossOriginGet be undefined.

If e.[[NeedsGet]] is true, then set crossOriginGet to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the getter of the IDL attribute P on object O.

Let crossOriginSet be undefined.

If e.[[NeedsSet]] is true, then set crossOriginSet to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the setter of the IDL attribute P on object O.

Set crossOriginDesc to PropertyDescriptor{ [[Get]]: crossOriginGet, [[Set]]: crossOriginSet, [[Enumerable]]: false, [[Configurable]]: true }.

Create an entry in the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O with key crossOriginKey and value crossOriginDesc.

Return crossOriginDesc.

If P is "then", @@toStringTag, @@hasInstance, or @@isConcatSpreadable, then return PropertyDescriptor{ [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.

Return undefined.

The reason that the property descriptors produced here are configurable is to preserve the invariants of the essential internal methods required by the JavaScript specification. In particular, since the value of the property can change as a consequence of navigation, it is required that the property be configurable. (However, see tc39/ecma262 issue #672 and references to it elsewhere in this specification for cases where we are not able to preserve these invariants, for compatibility with existing Web content.) [JAVASCRIPT]

The reason the property descriptors are non-enumerable, despite this mismatching the same-origin behavior, is for compatibility with existing Web content. See issue #3183 for details.

7.2.3.4 CrossOriginGet ( O, P, Receiver )
Let desc be ? O.[[GetOwnProperty]](P).

Assert: desc is not undefined.

If ! IsDataDescriptor(desc) is true, then return desc.[[Value]].

Assert: IsAccessorDescriptor(desc) is true.

Let getter be desc.[[Get]].

If getter is undefined, then throw a "SecurityError" DOMException.

Return ? Call(getter, Receiver).

7.2.3.5 CrossOriginSet ( O, P, V, Receiver )
Let desc be ? O.[[GetOwnProperty]](P).

Assert: desc is not undefined.

If desc.[[Set]] is present and its value is not undefined, then:

Perform ? Call(setter, Receiver, «V»).

Return true.

Throw a "SecurityError" DOMException.

7.2.3.6 CrossOriginOwnPropertyKeys ( O )
Let keys be a new empty List.

Repeat for each e that is an element of ! CrossOriginProperties(O):

If e.[[HideFromKeys]] is not true, append e.[[Property]] to keys.

If keys does not contain "then", then append "then" to keys.

Return the concatenation of keys and « @@toStringTag, @@hasInstance, @@isConcatSpreadable ».

7.3 The Window object
[Global=Window,
 Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface Window : EventTarget {
  // the current browsing context
  [Unforgeable] readonly attribute WindowProxy window;
  [Replaceable] readonly attribute WindowProxy self;
  [Unforgeable] readonly attribute Document document;
  attribute DOMString name;
  [PutForwards=href, Unforgeable] readonly attribute Location location;
  readonly attribute History history;
  readonly attribute CustomElementRegistry customElements;
  [Replaceable] readonly attribute BarProp locationbar;
  [Replaceable] readonly attribute BarProp menubar;
  [Replaceable] readonly attribute BarProp personalbar;
  [Replaceable] readonly attribute BarProp scrollbars;
  [Replaceable] readonly attribute BarProp statusbar;
  [Replaceable] readonly attribute BarProp toolbar;
  attribute DOMString status;
  void close();
  readonly attribute boolean closed;
  void stop();
  void focus();
  void blur();

  // other browsing contexts
  [Replaceable] readonly attribute WindowProxy frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute WindowProxy? top;
  attribute any opener;
  [Replaceable] readonly attribute WindowProxy? parent;
  readonly attribute Element? frameElement;
  WindowProxy? open(optional USVString url = "about:blank", optional DOMString target = "_blank", optional [TreatNullAs=EmptyString] DOMString features = "");
  getter object (DOMString name);
  // Since this is the global object, the IDL named getter adds a NamedPropertiesObject exotic
  // object on the prototype chain. Indeed, this does not make the global object an exotic object.
  // Indexed access is taken care of by the WindowProxy exotic object.

  // the user agent
  readonly attribute Navigator navigator;
  readonly attribute ApplicationCache applicationCache;

  // user prompts
  void alert();
  void alert(DOMString message);
  boolean confirm(optional DOMString message = "");
  DOMString? prompt(optional DOMString message = "", optional DOMString default = "");
  void print();

  unsigned long requestAnimationFrame(FrameRequestCallback callback);
  void cancelAnimationFrame(unsigned long handle);

  void postMessage(any message, USVString targetOrigin, optional sequence<object> transfer = []);

  // also has obsolete members
};
Window includes GlobalEventHandlers;
Window includes WindowEventHandlers;

callback FrameRequestCallback = void (DOMHighResTimeStamp time);
window . window
window . frames
window . self
These attributes all return window.

window . document
Returns the Document associated with window.

document . defaultView
Returns the Window object of the active document.

The Window has an associated Document, which is a Document object. It is set when the Window object is created, and only ever changed during navigation from the initial about:blank Document.

The window, frames, and self IDL attributes, on getting, must all return this Window object's browsing context's WindowProxy object.

The document IDL attribute, on getting, must return this Window object's associated Document.

The Document object associated with a Window object can change in exactly one case: when the navigate algorithm initializes a new Document object for the first page loaded in a browsing context. In that specific case, the Window object of the original about:blank page is reused and gets a new Document object.

The defaultView IDL attribute of the Document interface, on getting, must return this Document's browsing context's WindowProxy object, if this Document has an associated browsing context, or null otherwise.

For historical reasons, Window objects must also have a writable, configurable, non-enumerable property named HTMLDocument whose value is the Document interface object.

7.3.1 APIs for creating and navigating browsing contexts by name
window = window . open( [ url [, target [, features ] ] ] )
Opens a window to show url (defaults to about:blank), and returns it. The target argument gives the name of the new window. If a window exists with that name already, it is reused. The features argument can be used to influence the rendering of the new window.

window . name [ = value ]
Returns the name of the window.

Can be set, to change the name.

window . close()
Closes the window.

window . closed
Returns true if the window has been closed, false otherwise.

window . stop()
Cancels the document load.

The window open steps, given a string url, a string target, and a string features, are as follows:

Let entry settings be the entry settings object.

Let source browsing context be the responsible browsing context specified by entry settings.

If target is the empty string, then set target to "_blank".

Let tokenizedFeatures be the result of tokenizing features.

Let noopener be true if tokenizedFeatures contains an entry with the key "noopener"

Let target browsing context and new be the result of applying the rules for choosing a browsing context given target, source browsing context, and noopener.

If there is a user agent that supports control-clicking a link to open it in a new tab, and the user control-clicks on an element whose onclick handler uses the window.open() API to open a page in an iframe element, the user agent could override the selection of the target browsing context to instead target a new tab.

If target browsing context is null, then return null.

If new is true, then set up browsing context features for target browsing context given tokenizedFeatures. [CSSOMVIEW]

Let resource be the URL "about:blank".

If url is not the empty string or new is true, then:

If url is not the empty string, then parse url relative to entry settings, and set resource to the resulting URL record, if any. If the parse a URL algorithm failed, then throw a "SyntaxError" DOMException.

If resource is "about:blank" and new is true, then queue a task to fire an event named load at target browsing context's Window object, with the legacy target override flag set.

Otherwise, navigate target browsing context to resource, with the exceptions enabled flag set. If new is true, then replacement must be enabled. The source browsing context is source browsing context. Rethrow any exceptions.

If noopener is true, then disown target browsing context and return null.

Return target browsing context's WindowProxy object.

The open(url, target, features) method on Window objects provides a mechanism for navigating an existing browsing context or opening and navigating an auxiliary browsing context.

When the method is invoked, the user agent must run the window open steps with url, target, and features.

To tokenize the features argument:

Let tokenizedFeatures be a new ordered map.

Let position point at the first code point of features.

While position is not past the end of features:

Let name be the empty string.

Let value be the empty string.

Collect a sequence of code points that are feature separators from features given position. This skips past leading separators before the name.

Collect a sequence of code points that are not feature separators from features given position. Set name to the collected characters, converted to ASCII lowercase.

Set name to the result of normalizing the feature name name.

While position is not past the end of features and the code point at position in features is not U+003D (=):

If the code point at position in features is U+002C (,), or if it is not a feature separator, then break.

Advance position by 1.

This skips to the first U+003D (=) but does not skip past a U+002C (,) or a non-separator.

If the code point at position in features is a feature separator:

While position is not past the end of features and the code point at position in features is a feature separator:

If the code point at position in features is U+002C (,), then break.

Advance position by 1.

This skips to the first non-separator but does not skip past a U+002C (,).

Collect a sequence of code points that are not feature separators code points from features given position. Set value to the collected code points, converted to ASCII lowercase.

If name is not the empty string, then set tokenizedFeatures[name] to value.

Return tokenizedFeatures.

A code point is a feature separator if it is ASCII whitespace, U+003D (=), or U+002C (,).

For legacy reasons, there are some aliases of some feature names. To normalize a feature name name, switch on name:

"screenx"
Return "left".
"screeny"
Return "top".
"innerwidth"
Return "width".
"innerheight"
Return "height".
Anything else
Return name.
The name attribute of the Window object must, on getting, return the current name of the browsing context; and, on setting, set the name of the browsing context to the new value.

The name gets reset when the browsing context is navigated to another origin.

The close() method on Window objects should, if all the following conditions are met, close the browsing context A:

The corresponding browsing context A is script-closable.
The responsible browsing context specified by the incumbent settings object is familiar with the browsing context A.
The responsible browsing context specified by the incumbent settings object is allowed to navigate the browsing context A.
A browsing context is script-closable if it is an auxiliary browsing context that was created by a script (as opposed to by an action of the user), or if it is a top-level browsing context whose session history contains only one Document.

The closed attribute on Window objects must return true if the Window object's browsing context has been discarded, and false otherwise.

The stop() method on Window objects should, if there is an existing attempt to navigate the browsing context and that attempt is not currently running the unload a document algorithm, cancel that navigation; then, it must abort the active document of the browsing context of the Window object on which it was invoked.

7.3.2 Accessing other browsing contexts
window . length
Returns the number of document-tree child browsing contexts.

window[index]
Returns the indicated document-tree child browsing context.

The number of document-tree child browsing contexts of a Window object W is the number of document-tree child browsing contexts of W's associated Document's browsing context.

The length IDL attribute's getter must return the number of document-tree child browsing contexts of this Window object.

Indexed access to document-tree child browsing contexts is defined through the [[GetOwnProperty]] internal method of the WindowProxy object.

7.3.3 Named access on the Window object
window[name]
Returns the indicated element or collection of elements.

As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the Web platform, for example. Instead of this, use document.getElementById() or document.querySelector().

The document-tree child browsing context name property set of a Window object window is the return value of running these steps:

Let activeDocument be window's browsing context's active document.

Let childBrowsingContexts be all document-tree child browsing contexts of activeDocument's browsing context whose browsing context name is not the empty string, in order, and including only the first document-tree child browsing context with a given name if multiple document-tree child browsing contexts have the same one.

Remove each browsing context from childBrowsingContexts whose active document's origin is not same origin with activeDocument's origin and whose browsing context name does not match the name of its browsing context container's name content attribute value.

Return the browsing context names of childBrowsingContexts, in the same order.

This means that in the following example, hosted on https://example.org/, assuming https://elsewhere.example/ sets window.name to "spices", evaluating window.spices after everything has loaded will yield undefined:

<iframe src=https://elsewhere.example.com/></iframe>
<iframe name=spices></iframe>
The Window object supports named properties. The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates:

window's document-tree child browsing context name property set;

the value of the name content attribute for all embed, form, frameset, img, and object elements that have a non-empty name content attribute and are in a document tree with window's browsing context's active document as their root; and

the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a document tree with window's browsing context's active document as their root.

To determine the value of a named property name in a Window, the user agent must return the value obtained using the following steps:

Let objects be the list of named objects with the name name.

There will be at least one such object, by definition.

If objects contains a nested browsing context, then return the WindowProxy object of the nested browsing context corresponding to the first browsing context container in tree order whose nested browsing context is in objects.

Otherwise, if objects has only one element, return that element.

Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named objects with the name name. (By definition, these will all be elements.)

Named objects with the name name, for the purposes of the above algorithm, consist of the following:

document-tree child browsing contexts of the active document whose name is name;

embed, form, frameset, img, or object elements that have a name content attribute whose value is name and are in a document tree with the active document as their root; and

HTML elements that have an id content attribute whose value is name and are in a document tree with the active document as their root.

7.3.4 Garbage collection and browsing contexts
A browsing context has a strong reference to each of its Documents and its WindowProxy object, and the user agent itself has a strong reference to its top-level browsing contexts.

A Document has a strong reference to its Window object.

A Window object has a strong reference to its Document object through its document attribute. Thus, references from other scripts to either of those objects will keep both alive. Similarly, both Document and Window objects have implied strong references to the WindowProxy object.

Each script has a strong reference to its settings object, and each environment settings object has strong references to its global object, responsible browsing context, and responsible document (if any).

When a browsing context is to discard a Document, the user agent must run the following steps:

Set the Document's salvageable state to false.

Run any unloading document cleanup steps for the Document that are defined by this specification and other applicable specifications.

Abort the Document.

Remove any tasks associated with the Document in any task source, without running those tasks.

Discard all the child browsing contexts of the Document.

Lose the strong reference from the Document's browsing context to the Document.

Remove the Document object from the owner set of each WorkerGlobalScope object whose set contains that Document object.

When a browsing context is discarded, the strong reference from the user agent itself to the browsing context must be severed, and all the Document objects for all the entries in the browsing context's session history must be discarded as well.

User agents may discard top-level browsing contexts at any time (typically, in response to user requests, e.g. when a user force-closes a window containing one or more top-level browsing contexts). Other browsing contexts must be discarded once their WindowProxy object is eligible for garbage collection, in addition to the other places where this specification requires them to be discarded.

A WindowProxy does not have a strong reference to the browsing context it was created alongside. In particular, it is possible for a nested browsing context to be discarded even if JavaScript code holds a reference to its WindowProxy object.

7.3.5 Closing browsing contexts
To close a browsing context browsingContext, run these steps:

Prompt to unload browsingContext's active document. If the user refused to allow the document to be unloaded, then return.

Unload browsingContext's active document with the recycle parameter set to false.

Remove browsingContext from the user interface (e.g., close or hide its tab in a tabbed browser).

Discard browsingContext.

User agents should offer users the ability to arbitrarily close any top-level browsing context.

7.3.6 Browser interface elements
To allow Web pages to integrate with Web browsers, certain Web browser interface elements are exposed in a limited way to scripts in Web pages.

Each interface element is represented by a BarProp object:

[Exposed=Window]
interface BarProp {
  readonly attribute boolean visible;
};
window . locationbar . visible
Returns true if the location bar is visible; otherwise, returns false.

window . menubar . visible
Returns true if the menu bar is visible; otherwise, returns false.

window . personalbar . visible
Returns true if the personal bar is visible; otherwise, returns false.

window . scrollbars . visible
Returns true if the scroll bars are visible; otherwise, returns false.

window . statusbar . visible
Returns true if the status bar is visible; otherwise, returns false.

window . toolbar . visible
Returns true if the toolbar is visible; otherwise, returns false.

The visible attribute, on getting, must return either true or a value determined by the user agent to most accurately represent the visibility state of the user interface element that the object represents, as described below.

The following BarProp objects exist for each Document object in a browsing context. Some of the user interface elements represented by these objects might have no equivalent in some user agents; for those user agents, except when otherwise specified, the object must act as if it was present and visible (i.e. its visible attribute must return true).

The location bar BarProp object
Represents the user interface element that contains a control that displays the URL of the active document, or some similar interface concept.
The menu bar BarProp object
Represents the user interface element that contains a list of commands in menu form, or some similar interface concept.
The personal bar BarProp object
Represents the user interface element that contains links to the user's favorite pages, or some similar interface concept.
The scrollbar BarProp object
Represents the user interface element that contains a scrolling mechanism, or some similar interface concept.
The status bar BarProp object
Represents a user interface element found immediately below or after the document, as appropriate for the user's media, which typically provides information about ongoing network activity or information about elements that the user's pointing device is current indicating. If the user agent has no such user interface element, then the object may act as if the corresponding user interface element was absent (i.e. its visible attribute may return false).
The toolbar BarProp object
Represents the user interface element found immediately above or before the document, as appropriate for the user's media, which typically provides session history traversal controls (back and forward buttons, reload buttons, etc). If the user agent has no such user interface element, then the object may act as if the corresponding user interface element was absent (i.e. its visible attribute may return false).
The locationbar attribute must return the location bar BarProp object.

The menubar attribute must return the menu bar BarProp object.

The personalbar attribute must return the personal bar BarProp object.

The scrollbars attribute must return the scrollbar BarProp object.

The statusbar attribute must return the status bar BarProp object.

The toolbar attribute must return the toolbar BarProp object.

For historical reasons, the status attribute on the Window object must, on getting, return the last string it was set to, and on setting, must set itself to the new value. When the Window object is created, the attribute must be set to the empty string. It does not do anything else.

7.3.7 Script settings for Window objects
When the user agent is required to set up a window environment settings object, given a JavaScript execution context execution context and an optional environment reserved environment, it must run the following steps:

Let realm be the value of execution context's Realm component.

Let window be realm's global object.

Let url be a copy of the URL of window's associated Document.

Let settings object be a new environment settings object whose algorithms are defined as follows:

The realm execution context
Return execution context.

The module map
Return the module map of window's associated Document.

The responsible browsing context
Return the browsing context with which window is associated.

The responsible event loop
Return the event loop that is associated with the unit of related similar-origin browsing contexts to which window's browsing context belongs.

The responsible document
Return window's associated Document.

The API URL character encoding
Return the current character encoding of window's associated Document.

The API base URL
Return the current base URL of window's associated Document.

The origin
Return the origin of window's associated Document.

The HTTPS state
Return the HTTPS state of window's associated Document.

The referrer policy
Let document be the Document with which window is currently associated.

While document is an iframe srcdoc document and document's referrer policy is the empty string, set document to document's browsing context's browsing context container's node document.

Return document's referrer policy.

If reserved environment is given, then:

Set settings object's id to reserved environment's id, settings object's creation URL to reserved environment's creation URL, settings object's target browsing context to reserved environment's target browsing context, and settings object's active service worker to reserved environment's active service worker.

Set reserved environment's id to the empty string.

The identity of the reserved environment is considered to be fully transferred to the created environment settings object. The reserved environment is not searchable by the environment’s id from this point on.

Otherwise, set settings object's id to a new unique opaque string, settings object's creation URL to url, settings object's target browsing context to null, and settings object's active service worker to null.

Set realm's [[HostDefined]] field to settings object.

Return settings object.

7.4 The WindowProxy exotic object
A WindowProxy is an exotic object that wraps a Window ordinary object, indirecting most operations through to the wrapped object. Each browsing context has an associated WindowProxy object. When the browsing context is navigated, the Window object wrapped by the browsing context's associated WindowProxy object is changed.

There is no WindowProxy interface object.

Every WindowProxy object has a [[Window]] internal slot representing the wrapped Window object.

The WindowProxy object internal methods are described in the subsections below.

Although WindowProxy is named as a "proxy", it does not do polymorphic dispatch on its target's internal methods as a real proxy would, due to a desire to reuse machinery between WindowProxy and Location objects. As long as the Window object remains an ordinary object this is unobservable and can be implemented either way.

7.4.1 [[GetPrototypeOf]] ( )
Let W be the value of the [[Window]] internal slot of this.

If ! IsPlatformObjectSameOrigin(W) is true, then return ! OrdinaryGetPrototypeOf(W).

Return null.

7.4.2 [[SetPrototypeOf]] ( V )
Return ! SetImmutablePrototype(this, V).

7.4.3 [[IsExtensible]] ( )
Return true.

7.4.4 [[PreventExtensions]] ( )
Return false.

7.4.5 [[GetOwnProperty]] ( P )
Let W be the value of the [[Window]] internal slot of this.

If P is an array index property name, then:

Let index be ! ToUint32(P).

Let maxProperties be the number of document-tree child browsing contexts of W.

Let value be undefined.

If maxProperties is greater than 0 and index is less than maxProperties, then:

Let document be W's associated Document.

Set value to the WindowProxy object of the indexth document-tree child browsing context of document's browsing context, sorted in the order that their browsing context container elements were most recently inserted into document, the WindowProxy object of the most recently inserted browsing context container's nested browsing context being last.

If value is undefined, then return undefined.

Return PropertyDescriptor{ [[Value]]: value, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: true }.

If ! IsPlatformObjectSameOrigin(W) is true, then return ! OrdinaryGetOwnProperty(W, P).

This is a willful violation of the JavaScript specification's invariants of the essential internal methods to maintain compatibility with existing Web content. See tc39/ecma262 issue #672 for more information. [JAVASCRIPT]

Let property be ! CrossOriginGetOwnPropertyHelper(W, P).

If property is not undefined, then return property.

If property is undefined and P is in W's document-tree child browsing context name property set, then:

Let value be the WindowProxy object of the named object with the name P.

Return PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]: false, [[Configurable]]: true }.

The reason the property descriptors are non-enumerable, despite this mismatching the same-origin behavior, is for compatibility with existing Web content. See issue #3183 for details.

Throw a "SecurityError" DOMException.

7.4.6 [[DefineOwnProperty]] ( P, Desc )
Let W be the value of the [[Window]] internal slot of this.

If ! IsPlatformObjectSameOrigin(W) is true, then:

If P is an array index property name, return false.

Return ? OrdinaryDefineOwnProperty(W, P, Desc).

This is a willful violation of the JavaScript specification's invariants of the essential internal methods to maintain compatibility with existing Web content. See tc39/ecma262 issue #672 for more information. [JAVASCRIPT]

Throw a "SecurityError" DOMException.

7.4.7 [[Get]] ( P, Receiver )
Let W be the value of the [[Window]] internal slot of this.

If ! IsPlatformObjectSameOrigin(W) is true, then return ? OrdinaryGet(this, P, Receiver).

Return ? CrossOriginGet(this, P, Receiver).

7.4.8 [[Set]] ( P, V, Receiver )
Let W be the value of the [[Window]] internal slot of this.

If ! IsPlatformObjectSameOrigin(W) is true, then return ? OrdinarySet(W, this, Receiver).

Return ? CrossOriginSet(this, P, V, Receiver).

7.4.9 [[Delete]] ( P )
Let W be the value of the [[Window]] internal slot of this.

If ! IsPlatformObjectSameOrigin(W) is true, then:

If P is an array index property name, then:

Let desc be ! this.[[GetOwnProperty]](P).

If desc is undefined, then return true.

Return false.

Return ? OrdinaryDelete(W, P).

Throw a "SecurityError" DOMException.

7.4.10 [[OwnPropertyKeys]] ( )
Let W be the value of the [[Window]] internal slot of this.

Let keys be a new empty List.

Let maxProperties be the number of document-tree child browsing contexts of W.

Let index be 0.

Repeat while index < maxProperties,

Add ! ToString(index) as the last element of keys.

Increment index by 1.

If ! IsPlatformObjectSameOrigin(W) is true, then return the concatenation of keys and ! OrdinaryOwnPropertyKeys(W).

Return the concatenation of keys and ! CrossOriginOwnPropertyKeys(W).

7.5 Origin

Spec bugs: 28374

Origins are the fundamental currency of the Web's security model. Two actors in the Web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.

For example, if Example Bank's Web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's Web site, hosted at charity.example.org, a "SecurityError" DOMException will be raised.

An origin is one of the following:

An opaque origin
An internal value, with no serialization it can be recreated from (it is serialized as "null" per serialization of an origin), for which the only meaningful operation is testing for equality.

A tuple origin
A tuple consists of:

A scheme (a scheme).
A host (a host).
A port (a port).
A domain (null or a domain). Null unless stated otherwise.
Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the domain of a tuple origin can be changed, and only through the document.domain API.

The effective domain of an origin origin is computed as follows:

If origin is an opaque origin, then return null.

If origin's domain is non-null, then return origin's domain.

Return origin's host.

Various specification objects are defined to have an origin. These origins are determined as follows:

For Document objects
If the Document's active sandboxing flag set has its sandboxed origin browsing context flag set
If the Document was generated from a data: URL
A unique opaque origin assigned when the Document is created.

If the Document's URL's scheme is a network scheme
A copy of the Document's URL's origin assigned when the Document is created.

The document.open() method can change the Document's URL to "about:blank". Therefore the origin is assigned when the Document is created.

If the Document is the initial "about:blank" document
The one it was assigned when its browsing context was created.

If the Document is a non-initial "about:blank" document
The origin of the incumbent settings object when the navigate algorithm was invoked, or, if no script was involved, the origin of the node document of the element that initiated the navigation to that URL.

If the Document was created as part of the processing for javascript: URLs
The origin of the active document of the browsing context being navigated when the navigate algorithm was invoked.

If the Document is an iframe srcdoc document
The origin of the Document's browsing context's browsing context container's node document.

If the Document was obtained in some other manner (e.g. a Document created using the createDocument() API, etc)
The default behavior as defined in the WHATWG DOM standard applies. [DOM].

The origin is a unique opaque origin assigned when the Document is created.

For images of img elements
If the image data is CORS-cross-origin
A unique opaque origin assigned when the image is created.

If the image data is CORS-same-origin
The img element's node document's origin.

For audio and video elements
If the media data is CORS-cross-origin
A unique opaque origin assigned when the media data is fetched.

If the media data is CORS-same-origin
The media element's node document's origin.

Other specifications can override the above definitions by themselves specifying the origin of a particular Document object, image, or media element.

The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:

If origin is an opaque origin, then return "null".

Otherwise, let result be origin's scheme.

Append "://" to result.

Append origin's host, serialized, to result.

If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.

Return result.

The serialization of ("https", "xn--maraa-rta.example", null, null) is "https://xn--maraa-rta.example".

There used to also be a Unicode serialization of an origin. However, it was never widely adopted.

Two origins, A and B, are said to be same origin if the following algorithm returns true:

If A and B are the same opaque origin, then return true.

If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true.

Return false.

Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:

If A and B are the same opaque origin, then return true.

If A and B are both tuple origins, run these substeps:

If A and B's schemes are identical, and their domains are identical and non-null, then return true.

Otherwise, if A and B are same origin and their domains are identical and null, then return true.

Return false.

A	B	same origin	same origin-domain
("https", "example.org", null, null)	("https", "example.org", null, null)	✅	✅
("https", "example.org", 314, null)	("https", "example.org", 420, null)	❌	❌
("https", "example.org", 314, "example.org")	("https", "example.org", 420, "example.org")	❌	✅
("https", "example.org", null, null)	("https", "example.org", null, "example.org")	✅	❌
("https", "example.org", null, "example.org")	("http", "example.org", null, "example.org")	❌	❌
7.5.1 Relaxing the same-origin restriction
document . domain [ = domain ]
Returns the current domain used for security checks.

Can be set to a value that removes subdomains, to change the origin's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. (Can't be set in sandboxed iframes.)

To determine if a string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost, run these steps:

If hostSuffixString is the empty string, then return false.

Let host be the result of parsing hostSuffixString.

If host is failure, then return false.

If host is not equal to originalHost, then run these substeps:

If host or originalHost is not a domain, then return false.

This is meant to exclude hosts that are an IPv4 address or an IPv6 address.

If host, prefixed by a U+002E FULL STOP (.), does not exactly match the end of originalHost, then return false.

If host matches a suffix in the Public Suffix List, or, if host, prefixed by a U+002E FULL STOP (.), matches the end of a suffix in the Public Suffix List, then return false. [PSL]

Suffixes must be compared after applying the host parser algorithm.

Return true.

The domain attribute's getter must run these steps:

If this Document object does not have a browsing context, then return the empty string.

Let effectiveDomain be this Document's origin's effective domain.

If effectiveDomain is null, then return the empty string.

Return effectiveDomain, serialized.

The domain attribute's setter must run these steps:

If this Document object has no browsing context, then throw a "SecurityError" DOMException.

If this Document object's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a "SecurityError" DOMException.

Let effectiveDomain be this Document's origin's effective domain.

If effectiveDomain is null, then throw a "SecurityError" DOMException.

If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError" DOMException.

Set this Document object's origin's domain to the result of parsing the given value.

The document.domain attribute is used to enable pages on different hosts of a domain to access each other's DOMs.

Do not use the document.domain attribute when using shared hosting. If an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will fail, as the ports are ignored when comparing origins after the document.domain attribute has been used.

7.6 Sandboxing
A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have:

The sandboxed navigation browsing context flag
This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing context flag defined below).

If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow popups (new top-level browsing contexts) to be opened. These browsing contexts always have one permitted sandboxed navigator, set when the browsing context is created, which allows the browsing context that created them to actually navigate them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.)

The sandboxed auxiliary navigation browsing context flag
This flag prevents content from creating new auxiliary browsing contexts, e.g. using the target attribute or the window.open() method.

The sandboxed top-level navigation without user activation browsing context flag
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only from algorithms that are not triggered by user activation.

When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-level browsing context, but other browsing contexts are still protected by the sandboxed navigation browsing context flag and possibly the sandboxed auxiliary navigation browsing context flag.

The sandboxed top-level navigation with user activation browsing context flag
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only from algorithms that are triggered by user activation.

As with the sandboxed top-level navigation without user activation browsing context flag, this flag only affects the top-level browsing context; if it is not set, other browsing contexts might still be protected by other flags.

The sandboxed plugins browsing context flag
This flag prevents content from instantiating plugins, whether using the embed element, the object element, or through navigation of a nested browsing context, unless those plugins can be secured.

The sandboxed origin browsing context flag
This flag forces content into a unique origin, thus preventing it from accessing other content from the same origin.

This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to localStorage.

The sandboxed forms browsing context flag
This flag blocks form submission.

The sandboxed pointer lock browsing context flag
This flag disables the Pointer Lock API. [POINTERLOCK]

The sandboxed scripts browsing context flag
This flag blocks script execution.

The sandboxed automatic features browsing context flag
This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form control.

The sandboxed storage area URLs flag
This flag prevents URL schemes that use storage areas from being able to access the origin's data.

The sandboxed document.domain browsing context flag
This flag prevents content from using the document.domain setter.

The sandbox propagates to auxiliary browsing contexts flag
This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the content's active sandboxing flag set.

The sandboxed modals flag
This flag prevents content from using any of the following features to produce modal dialogs:

window.alert()
window.confirm()
window.print()
window.prompt()
the beforeunload event
The sandboxed orientation lock browsing context flag
This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]

The sandboxed presentation browsing context flag
This flag disables the Presentation API. [PRESENTATION]

When the user agent is to parse a sandboxing directive, given a string input, a sandboxing flag set output, it must run the following steps:

Split input on ASCII whitespace, to obtain tokens.

Let output be empty.

Add the following flags to output:

The sandboxed navigation browsing context flag.

The sandboxed auxiliary navigation browsing context flag, unless tokens contains the allow-popups keyword.

The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the allow-top-navigation keyword.

The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.

This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-activation keyword will have no effect. For this reason, specifying both is a document conformance error.

The sandboxed plugins browsing context flag.

The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.

The allow-same-origin keyword is intended for two cases.

First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.

Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening pop-up windows, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.

The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.

The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.

The sandboxed scripts browsing context flag, unless tokens contains the allow-scripts keyword.

The sandboxed automatic features browsing context flag, unless tokens contains the allow-scripts keyword (defined above).

This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.

The sandboxed storage area URLs flag.

The sandboxed document.domain browsing context flag.

The sandbox propagates to auxiliary browsing contexts flag, unless tokens contains the allow-popups-to-escape-sandbox keyword.

The sandboxed modals flag, unless tokens contains the allow-modals keyword.

The sandboxed orientation lock browsing context flag, unless tokens contains the allow-orientation-lock keyword.

The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.

Every top-level browsing context has a popup sandboxing flag set, which is a sandboxing flag set. When a browsing context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a browsing context.

Every browsing context that is a nested browsing context has an iframe sandboxing flag set, which is a sandboxing flag set. Which flags in a nested browsing context's iframe sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.

Every Document has an active sandboxing flag set, which is a sandboxing flag set. When the Document is created, its active sandboxing flag set must be empty. It is populated by the navigation algorithm.

Every resource that is obtained by the navigation algorithm has a forced sandboxing flag set, which is a sandboxing flag set. A resource by default has no flags set in its forced sandboxing flag set, but other specifications can define that certain flags are set.

In particular, the forced sandboxing flag set is used by Content Security Policy. [CSP]

To implement the sandboxing for a Document object document, populate document's active sandboxing flag set with the union of the flags that are present in the following sandboxing flag sets:

If document's browsing context is a top-level browsing context, then: the flags set on the browsing context's popup sandboxing flag set.

If document's browsing context is a nested browsing context, then: the flags set on the browsing context's iframe sandboxing flag set.

If document's browsing context is a nested browsing context, then: the flags set on the browsing context's parent browsing context's active document's active sandboxing flag set.

The flags set on document's resource's forced sandboxing flag set, if it has one.

7.7 Session history and navigation
7.7.1 The session history of browsing contexts
The sequence of Documents in a browsing context is its session history. Each browsing context, including nested browsing contexts, has a distinct session history. A browsing context's session history consists of a flat list of session history entries. Each session history entry consists, at a minimum, of a URL, and each entry may in addition have serialized state, a title, a Document object, form data, a scroll restoration mode, a scroll position, a browsing context name, and other information associated with it.

Each entry, when first created, has a Document. However, when a Document is not active, it's possible for it to be discarded to free resources. The URL and other data in a session history entry is then used to bring a new Document into being to take the place of the original, in case the user agent finds itself having to reactivate that Document.

Titles associated with session history entries need not have any relation with the current title of the Document. The title of a session history entry is intended to explain the state of the document at that point, so that the user can navigate the document's history.

URLs without associated serialized state are added to the session history as the user (or script) navigates from page to page.

Each Document object in a browsing context's session history is associated with a unique History object which must all model the same underlying session history.

The history attribute of the Window interface must return the object implementing the History interface for this Window object's associated Document.

Serialized state is a serialization (via StructuredSerializeForStorage) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.

Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.

Serialized state is intended to be used for two main purposes: first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization). Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.

An example of the latter would be something like keeping track of the precise coordinate from which a pop-up div was made to animate, so that if the user goes back, it can be made to animate to the same location. Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.

At any point, one of the entries in the session history is the current entry. This is the entry representing the active document of the browsing context. Which entry is the current entry is changed by the algorithms defined in this specification, e.g. during session history traversal.

The current entry is usually an entry for the URL of the Document. However, it can also be one of the entries for serialized state added to the history by that document.

An entry with persisted user state is one that also has user-agent defined state. This specification does not specify what kind of state can be stored.

For example, some user agents might want to persist the scroll position, or the values of form controls.

User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.

An entry's scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to it. The scroll restoration mode may be one of the following:

"auto"
The user agent is responsible for restoring the scroll position upon navigation.
"manual"
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
If unspecified, the scroll restoration mode of a new entry must be set to "auto".

Entries that contain serialized state share the same Document as the entry for the page that was active when they were added.

Contiguous entries that differ just by their URLs' fragments also share the same Document.

All entries that share the same Document (and that are therefore merely different states of one particular document) are contiguous by definition.

Each Document in a browsing context can also have a latest entry. This is the entry for that Document to which the browsing context's session history was most recently traversed. When a Document is created, it initially has no latest entry.

User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them.

Entries that have had their Document objects discarded must, for the purposes of the algorithms given below, act as if they had not. When the user or script navigates back or forwards to a page which has no in-memory DOM objects, any other entries that shared the same Document object with it must share the new object as well.

7.7.2 The History interface
enum ScrollRestoration { "auto", "manual" };

[Exposed=Window]
interface History {
  readonly attribute unsigned long length;
  attribute ScrollRestoration scrollRestoration;
  readonly attribute any state;
  void go(optional long delta = 0);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional USVString? url = null);
  void replaceState(any data, DOMString title, optional USVString? url = null);
};
window . history . length
Returns the number of entries in the joint session history.

window . history . scrollRestoration [ = value ]
Returns the scroll restoration mode of the current entry in the session history.

Can be set, to change the scroll restoration mode of the current entry in the session history.

window . history . state
Returns the current serialized state, deserialized into an object.

window . history . go( [ delta ] )
Goes back or forward the specified number of steps in the joint session history.

A zero delta will reload the current page.

If the delta is out of range, does nothing.

window . history . back()
Goes back one step in the joint session history.

If there is no previous page, does nothing.

window . history . forward()
Goes forward one step in the joint session history.

If there is no next page, does nothing.

window . history . pushState(data, title [, url ] )
Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.

window . history . replaceState(data, title [, url ] )
Updates the current entry in the session history to have the given data, title, and, if provided and not null, URL.

The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of all the fully active Document objects that share that top-level browsing context, with all the entries that are current entries in their respective session histories removed except for the current entry of the joint session history.

The current entry of the joint session history is the entry that most recently became a current entry in its session history.

Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories. Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc).

Since each Document in a browsing context might have a different event loop, the actual state of the joint session history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about each other later, they might disagree about the length of the joint session history.

The length attribute of the History interface, on getting, must return the number of entries in the top-level browsing context's joint session history. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.

The actual entries are not accessible from script.

The scrollRestoration attribute of the History interface, on getting, must return the scroll restoration mode of the current entry in the session history. On setting, the scroll restoration mode of the current entry in the session history must be set to the new value. If this History object is associated with a Document that is not fully active, both getting and setting must instead throw a "SecurityError" DOMException.

The state attribute of the History interface, on getting, must return the last value it was set to by the user agent. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException. Initially, its value must be null.

When the go(delta) method is invoked, if delta is zero, the user agent must act as if the location.reload() method was called instead. Otherwise, the user agent must traverse the history by a delta whose value is delta. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.

When the back() method is invoked, the user agent must traverse the history by a delta −1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.

When the forward() method is invoked, the user agent must traverse the history by a delta +1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.

Each top-level browsing context has a session history traversal queue, initially empty, to which tasks can be added.

Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context, in parallel:

Wait until this top-level browsing context's session history traversal queue is not empty.

Pull the first task from this top-level browsing context's session history traversal queue, and execute it.

Return to the first step of this algorithm.

The session history event loop helps coordinate cross-browsing-context transitions of the joint session history: since each browsing context might, at any particular time, have a different event loop (this can happen if the user agent has more than one event loop per unit of related browsing contexts), transitions would otherwise have to involve cross-event-loop synchronization.

To traverse the history by a delta delta, the user agent must append a task to this top-level browsing context's session history traversal queue, the task consisting of running the following steps:

If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the number of items in the joint session history, then return.

Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current entry of the joint session history.

Let specified browsing context be the browsing context of the specified entry.

If the specified browsing context's active document's unload a document algorithm is currently running, return.

Queue a task that consists of running the following substeps. The relevant event loop is that of the specified browsing context's active document. The task source for the queued task is the history traversal task source.

If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not passed the point of making its Document the active document), then cancel that attempt to navigate the browsing context.

If the specified browsing context's active document is not the same Document as the Document of the specified entry, then run these substeps:

Prompt to unload the active document of the specified browsing context. If the user refused to allow the document to be unloaded, then return.

Unload the active document of the specified browsing context with the recycle parameter set to false.

Traverse the history of the specified browsing context to the specified entry.

When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must traverse the history by a delta equivalent to the action specified by the user.

The pushState(data, title, url) method adds a state object entry to the history.


Support: history
Chrome for Android	64+
Chrome	5+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	4+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	6+
Edge	12+
Android Browser	4.2+
Opera	11.5+

Source: caniuse.com

The replaceState(data, title, url) method updates the state object, title, and optionally the URL of the current entry in the history.

When either of these methods is invoked, the user agent must run the following steps:

Let document be the unique Document object this History object is associated with.

If document is not fully active, throw a "SecurityError" DOMException.

Optionally, return. (For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)

Let targetRealm be this History object's relevant Realm.

Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.

If the third argument is not null, run these substeps:

Parse the value of the third argument, relative to the relevant settings object of this History object.
If that fails, throw a "SecurityError" DOMException.
Let new URL be the resulting URL record.

Compare new URL to document's URL. If any component of these two URL records differ other than the path, query, and fragment components, then throw a "SecurityError" DOMException.
If the origin of new URL is not same origin with the origin of document, and either the path or query components of the two URL records compared in the previous step differ, throw a "SecurityError" DOMException.(This prevents sandboxed content from spoofing other pages on the same origin.)
If the third argument is null, then let new URL be the URL of the current entry.

If the method invoked was the pushState() method:

Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.

This doesn't necessarily have to affect the user agent's user interface.

Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.

If appropriate, update the current entry to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.

Add a session history entry entry to the session history, after the current entry, with serializedData as the serialized state, the given title as the title, new URL as the URL of the entry, and the scroll restoration mode of the current entry in the session history as the scroll restoration mode.

Update the current entry to be this newly added entry.

Otherwise, if the method invoked was the replaceState() method:

Update the current entry in the session history so that serializedData is the entry's new serialized state, the given title is the new title, and new URL is the entry's new URL.

If the current entry in the session history represents a non-GET request (e.g. it was the result of a POST submission) then update it to instead represent a GET request.

Set document's URL to new URL.

Since this is neither a navigation of the browsing context nor a history traversal, it does not cause a hashchange event to be fired.

Let state be StructuredDeserialize(serializedData, targetRealm). If this throws an exception, catch it, ignore the exception, and set state to null.

Set history.state to state.

Set the current entry's Document object's latest entry to the current entry.

The title is purely advisory. User agents might use the title in the user interface.

User agents may limit the number of state objects added to the session history per page. If a page hits the UA-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)

Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.

A static page implementing the x=5 position in such a game could look like the following:

<!DOCTYPE HTML>
<!-- this is https://example.com/line?x=5 -->
<html lang="en">
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:

<!DOCTYPE HTML>
<!-- this starts off as https://example.com/line?x=5 -->
<html lang="en">
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server
 function go(d) {
   setupPage(currentPage + d);
   history.pushState(currentPage, document.title, '?x=' + currentPage);
 }
 onpopstate = function(event) {
   setupPage(event.state);
 }
 function setupPage(page) {
   currentPage = page;
   document.title = 'Line Game - ' + currentPage;
   document.getElementById('coord').textContent = currentPage;
   document.links[0].href = '?x=' + (currentPage+1);
   document.links[0].textContent = 'Advance to ' + (currentPage+1);
   document.links[1].href = '?x=' + (currentPage-1);
   document.links[1].textContent = 'retreat to ' + (currentPage-1);
 }
</script>
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.

In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.

Applications might not use the same title for a session history entry as the value of the document's title element at that time. For example, here is a simple page that shows a block in the title element. Clearly, when navigating backwards to a previous state the user does not go back in time, and therefore it would be inappropriate to put the time in the session history title.

<!DOCTYPE HTML>
<HTML LANG=EN>
<TITLE>Line</TITLE>
<SCRIPT>
 setInterval(function () { document.title = 'Line - ' + new Date(); }, 1000);
 var i = 1;
 function inc() {
   set(i+1);
   history.pushState(i, 'Line - ' + i);
 }
 function set(newI) {
   i = newI;
   document.forms.F.I.value = newI;
 }
</SCRIPT>
<BODY ONPOPSTATE="set(event.state)">
<FORM NAME=F>
State: <OUTPUT NAME=I>1</OUTPUT> <INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()">
</FORM>
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.

<head>
  <script>
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  </script>
</head>

7.7.3 Implementation notes for session history
This section is non-normative.

The History interface is not meant to place restrictions on how implementations represent the session history to the user.

For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the history object are derived from the actual session history as seen from the user's perspective.

Similarly, a page containing two iframes has a history object distinct from the iframes' history objects, despite the fact that typical Web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.

Security: It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.

For both pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.

7.7.4 The Location interface
Each Window object is associated with a unique instance of a Location object, allocated when the Window object is created.

The Location exotic object is defined through a mishmash of IDL, invocation of JavaScript internal methods post-creation, and overridden JavaScript internal methods. Coupled with its scary security policy, please take extra care while implementing this excrescence.

To create a Location object, run these steps:

Let location be a new Location platform object.

Perform ! location.[[DefineOwnProperty]]("valueOf", { [[Value]]: %ObjProto_valueOf%, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

Perform ! location.[[DefineOwnProperty]](@@toPrimitive, { [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

Set the value of the [[DefaultProperties]] internal slot of location to location.[[OwnPropertyKeys]]().

Return location.

The addition of valueOf and @@toPrimitive own data properties, as well as the fact that all of Location's IDL attributes are marked [Unforgeable], is required by legacy code that consulted the Location interface, or stringified it, to determine the document URL, and then used it in a security-sensitive way. In particular, the valueOf, @@toPrimitive, and [Unforgeable] stringifier mitigations ensure that code such as foo[location] = bar or location + "" cannot be misdirected.

document . location [ = value ]
window . location [ = value ]
Returns a Location object with the current page's location.

Can be set, to navigate to another page.

The Document object's location attribute's getter must return this Document object's relevant global object's Location object, if this Document object is fully active, and null otherwise.

The Window object's location attribute's getter must return this Window object's Location object.

Location objects provide a representation of the URL of the active document of their Document's browsing context, and allow the current entry of the browsing context's session history to be changed, by adding or replacing entries in the history object.

[Exposed=Window]
interface Location { // but see also additional creation steps and overridden internal methods
  [Unforgeable] stringifier attribute USVString href;
  [Unforgeable] readonly attribute USVString origin;
  [Unforgeable] attribute USVString protocol;
  [Unforgeable] attribute USVString host;
  [Unforgeable] attribute USVString hostname;
  [Unforgeable] attribute USVString port;
  [Unforgeable] attribute USVString pathname;
  [Unforgeable] attribute USVString search;
  [Unforgeable] attribute USVString hash;

  [Unforgeable] void assign(USVString url);
  [Unforgeable] void replace(USVString url);
  [Unforgeable] void reload();

  [Unforgeable, SameObject] readonly attribute DOMStringList ancestorOrigins;
};
location . toString()
location . href
Returns the Location object's URL.

Can be set, to navigate to the given URL.

location . origin
Returns the Location object's URL's origin.

location . protocol
Returns the Location object's URL's scheme.

Can be set, to navigate to the same URL with a changed scheme.

location . host
Returns the Location object's URL's host and port (if different from the default port for the scheme).

Can be set, to navigate to the same URL with a changed host and port.

location . hostname
Returns the Location object's URL's host.

Can be set, to navigate to the same URL with a changed host.

location . port
Returns the Location object's URL's port.

Can be set, to navigate to the same URL with a changed port.

location . pathname
Returns the Location object's URL's path.

Can be set, to navigate to the same URL with a changed path.

location . search
Returns the Location object's URL's query (includes leading "?" if non-empty).

Can be set, to navigate to the same URL with a changed query (ignores leading "?").

location . hash
Returns the Location object's URL's fragment (includes leading "#" if non-empty).

Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").

location . assign(url)
Navigates to the given URL.

location . replace(url)
Removes the current page from the session history and navigates to the given URL.

location . reload()
Reloads the current page.

location . ancestorOrigins
Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context.

A Location object has an associated relevant Document, which is this Location object's associated Document object's browsing context's active document.

A Location object has an associated url, which is this Location object's relevant Document's URL.

A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:

Let output be a new list of strings.

Let current be the browsing context of the Document with which this Location object is associated.

Loop: If current has no parent browsing context, jump to the step labeled end.

Let current be current's parent browsing context.

Append the serialization of current's active document's origin to output.

Return to the step labeled loop.

End: Return output.

A Location object has an associated Location-object-setter navigate algorithm, which given a url, runs these steps:

If any of the following conditions are met, let replacement flag be unset; otherwise, let it be set:

This Location object's relevant Document has completely loaded, or
In the task in which the algorithm is running, an activation behavior is currently being processed whose click event's isTrusted attribute is true, or
In the task in which the algorithm is running, the event listener for a click event, whose isTrusted attribute is true, is being handled.
Location-object navigate, given url and replacement flag.

To Location-object navigate, given a url and replacement flag, run these steps:

The source browsing context is the responsible browsing context specified by the incumbent settings object.

Navigate the browsing context to url, with the exceptions enabled flag set. Rethrow any exceptions.

If the replacement flag is set or the browsing context's session history contains only one Document, and that was the about:blank Document created when the browsing context was created, then the navigation must be done with replacement enabled.

The href attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Return this Location object's url, serialized.

The href attribute's setter must run these steps:

Parse the given value relative to the entry settings object. If that failed, throw a TypeError exception.

Location-object-setter navigate to the resulting URL record.

The href attribute setter intentionally has no security check.

The origin attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Return the serialization of this Location object's url's origin.

The protocol attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Return this Location object's url's scheme, followed by ":".

The protocol attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.

Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".

If possibleFailure is failure, then throw a "SyntaxError" DOMException.

If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.

Location-object-setter navigate to copyURL.

The host attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let url be this Location object's url.

If url's host is null, return the empty string.

If url's port is null, return url's host, serialized.

Return url's host, serialized, followed by ":" and url's port, serialized.

The host attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

Basic URL parse the given value, with copyURL as url and host state as state override.

Location-object-setter navigate to copyURL.

The hostname attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If this Location object's url's host is null, return the empty string.

Return this Location object's url's host, serialized.

The hostname attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

Basic URL parse the given value, with copyURL as url and hostname state as state override.

Location-object-setter navigate to copyURL.

The port attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If this Location object's url's port is null, return the empty string.

Return this Location object's url's port, serialized.

The port attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

If copyURL cannot have a username/password/port, then return.

If the given value is the empty string, then set copyURL's port to null.

Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.

Location-object-setter navigate to copyURL.

The pathname attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let url be this Location object's url.

If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

If url's path is empty, then return the empty string.

Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The pathname attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

Set copyURL's path to the empty list.

Basic URL parse the given value, with copyURL as url and path start state as state override.

Location-object-setter navigate to copyURL.

The search attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If this Location object's url's query is either null or the empty string, return the empty string.

Return "?", followed by this Location object's url's query.

The search attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

If the given value is the empty string, set copyURL's query to null.

Otherwise, run these substeps:

Let input be the given value with a single leading "?" removed, if any.

Set copyURL's query to the empty string.

Basic URL parse input, with copyURL as url and query state as state override, and the relevant Document's document's character encoding as encoding override.

Location-object-setter navigate to copyURL.

The hash attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

If this Location object's url's fragment is either null or the empty string, return the empty string.

Return "#", followed by this Location object's url's fragment.

The hash attribute's setter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Let copyURL be a copy of this Location object's url.

Let input be the given value with a single leading "#" removed, if any.

Set copyURL's fragment to the empty string.

Basic URL parse input, with copyURL as url and fragment state as state override.

Location-object-setter navigate to copyURL.

Unlike the equivalent API for the a and area elements, the hash attribute's setter does not special case the empty string to remain compatible with deployed scripts.

When the assign(url) method is invoked, the user agent must run the following steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.

Location-object navigate to the resulting URL record.

When the replace(url) method is invoked, the user agent must run the following steps:

Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.

Location-object navigate to the resulting URL record with the replacement flag set.

The replace() method intentionally has no security check.

When the reload() method is invoked, the user agent must run the appropriate steps from the following list:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin
Throw a "SecurityError" DOMException.

If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context
Repaint the browsing context and return.

If the browsing context's active document is an iframe srcdoc document
Reprocess the iframe attributes of the browsing context's browsing context container.

If the browsing context's active document has its reload override flag set
Perform an overridden reload, with the browsing context being navigated as the responsible browsing context. Rethrow any exceptions.

Otherwise
Navigate the browsing context to this Location object's relevant Document's URL to perform an entry update of the browsing context's current entry, with the exceptions enabled flag set. The source browsing context must be the browsing context being navigated. This is a reload-triggered navigation. Rethrow any exceptions.

When a user requests that the active document of a browsing context be reloaded through a user interface element, the user agent should navigate the browsing context to the same resource as that Document, to perform an entry update of the browsing context's current entry. This is a reload-triggered navigation. In the case of non-idempotent methods (e.g. HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g. purchases or database modifications) could be repeated. User agents may allow the user to explicitly override any caches when reloading. If browsing context's active document's reload override flag is set, then the user agent may instead perform an overridden reload rather than the navigation described in this paragraph (with the browsing context being reloaded as the source browsing context).

The ancestorOrigins attribute's getter must run these steps:

If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.

Otherwise, return this Location object's ancestor origins list.

The details of how the ancestorOrigins attribute works are still controversial and might change. See issue #1918 for more information.

As explained earlier, the Location exotic object requires additional logic beyond IDL for security purposes. The internal slot and internal methods Location objects must implement are defined below.

Every Location object has a [[DefaultProperties]] internal slot representing its own properties at time of its creation.

7.7.4.1 [[GetPrototypeOf]] ( )
If ! IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryGetPrototypeOf(this).

Return null.

7.7.4.2 [[SetPrototypeOf]] ( V )
Return ! SetImmutablePrototype(this, V).

7.7.4.3 [[IsExtensible]] ( )
Return true.

7.7.4.4 [[PreventExtensions]] ( )
Return false.

7.7.4.5 [[GetOwnProperty]] ( P )
If ! IsPlatformObjectSameOrigin(this) is true, then:

Let desc be ! OrdinaryGetOwnProperty(this, P).

If the value of the [[DefaultProperties]] internal slot of this contains P, then set desc.[[Configurable]] to true.

Return desc.

Let property be ! CrossOriginGetOwnPropertyHelper(this, P).

If property is not undefined, return property.

Throw a "SecurityError" DOMException.

7.7.4.6 [[DefineOwnProperty]] ( P, Desc )
If ! IsPlatformObjectSameOrigin(this) is true, then:

If the value of the [[DefaultProperties]] internal slot of this contains P, then return false.

Return ? OrdinaryDefineOwnProperty(this, P, Desc).

Throw a "SecurityError" DOMException.

7.7.4.7 [[Get]] ( P, Receiver )
If ! IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryGet(this, P, Receiver).

Return ? CrossOriginGet(this, P, Receiver).

7.7.4.8 [[Set]] ( P, V, Receiver )
If ! IsPlatformObjectSameOrigin(this) is true, then return ? OrdinarySet(this, P, Receiver).

Return ? CrossOriginSet(this, P, V, Receiver).

7.7.4.9 [[Delete]] ( P )
If ! IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryDelete(this, P).

Throw a "SecurityError" DOMException.

7.7.4.10 [[OwnPropertyKeys]] ( )
If ! IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryOwnPropertyKeys(this).

Return ! CrossOriginOwnPropertyKeys(this).

7.8 Browsing the Web
7.8.1 Navigating across documents
Certain actions cause the browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.

For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause a browsing context to navigate.

A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method and payload. Similarly, an iframe srcdoc document needs to know the data it is to use.

Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.

As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.

To navigate a browsing context browsingContext to a resource resource, optionally with an exceptions enabled flag, the user agent must run these steps:

If resource is a URL, then set resource to a new request whose url is resource.

If the source browsing context is not allowed to navigate browsingContext, then:

If the exceptions enabled flag is set, then throw a "SecurityError" DOMException.

Otherwise, the user agent may instead offer to open resource in a new top-level browsing context or in the top-level browsing context of the source browsing context, at the user's option, in which case the user agent must navigate that designated top-level browsing context to resource as if the user had requested it independently.

Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.

If there is a preexisting attempt to navigate browsingContext, and the source browsing context is the same as browsingContext, and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.

If the prompt to unload algorithm is being run for the active document of browsingContext, then return without affecting the prompt to unload algorithm.

If this is not a reload-triggered navigation, resource is a request, resource's url equals browsingContext's active document's URL with exclude fragments flag set, and resource's url's fragment is non-null, then navigate to that fragment, with replacement enabled if this was invoked with replacement enabled, and return.

Cancel any preexisting but not yet mature attempt to navigate browsingContext, including canceling any instances of the fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document object, abort that Document also. (Navigation attempts that have matured already have session history entries, and are therefore handled during the update the session history with the new page algorithm, later.)

Prompt to unload the active document of browsingContext. If the user refused to allow the document to be unloaded, then return.

If this instance of the navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.

Abort the active document of browsingContext.

If browsingContext is a nested browsing context, then put it in the delaying load events mode.

The user agent must take this nested browsing context out of the delaying load events mode when this navigation algorithm later matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.

Let navigationType be "form-submission" if the navigation algorithm was invoked as a result of the form submission algorithm, and "other" otherwise.

Return to whatever algorithm invoked the navigation steps and continue running these steps in parallel.

This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:

If resource is a response
Run process a navigate response with null, resource, navigationType, the source browsing context, and browsingContext, and then return.

If resource is a request whose url's scheme is "javascript"
Queue a task to run these "javascript: URL" steps, associated with the active document of browsingContext:

Let result be undefined, and jump to the step labeled process result below if either of the following are true:

The source browsing context's active document's origin is not the same origin as browsingContext's active document's origin.

As explained in issue #2591 this step does not work and presents a security issue.

The Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon resource, "other", the source browsing context, and browsingContext. [CSP]

Let urlString be the result of running the URL serializer on resource's url.

Remove the leading "javascript:" string from urlString.

Let script source be the result of applying the percent decode algorithm to urlString.

Replace script source with the result of applying the UTF-8 decode algorithm to script source.

Let address be the URL of the active document of browsingContext.

Let settings be the relevant settings object for the active document of browsingContext.

Let base URL be settings object's API base URL.

Let script be the result of creating a classic script given script source, settings, base URL, and the default classic script fetch options.

Let result be the result of running the classic script script. If evaluation was unsuccessful, let result be undefined instead. (The result will also be undefined if scripting is disabled.)

Let response be null.

Process result: If Type(result) is not String, then set response to a response whose status is 204.

Otherwise, set response a response whose header list consists of `Content-Type`/`text/html` and `Referrer-Policy`/settings's referrer policy, whose body is result, and whose HTTPS state is settings's HTTPS state.

The exact conversion between the JavaScript string result and the bytes that comprise a response body is not yet specified, pending further investigation into user agent behavior. See issue #1129.

When it comes time to set the document's address, use address as the override URL.

Run process a navigate response with resource, response, navigationType, the source browsing context, and browsingContext, and then return.

The task source for this task is the DOM manipulation task source.

So for example a javascript: URL in an href attribute of an a element would only be evaluated when the link was followed, while such a URL in the src attribute of an iframe element would be evaluated in the context of the iframe's own nested browsing context when the iframe is being set up; once evaluated, its return value (if it was a string) would replace that browsing context's Document, thus also changing the Window object of that browsing context.

If resource is to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is fast, and the user agent is not in a mode where it will avoid using application caches
Fetch resource from the most appropriate application cache of those that match.

For example, imagine an HTML page with an associated application cache displaying an image and a form, where the image is also used by several other application caches. If the user right-clicks on the image and chooses "View Image", then the user agent could decide to show the image from any of those caches, but it is likely that the most useful cache for the user would be the one that was used for the aforementioned HTML page. On the other hand, if the user submits the form, and the form does a POST submission, then the user agent will not use an application cache at all; the submission will be made to the network.

This still needs to be integrated with the Fetch standard. [FETCH]

If resource is a request whose url's scheme is a fetch scheme
Run process a navigate fetch given resource, the source browsing context, and browsing context, and navigationType.

Otherwise, resource is a request whose url's scheme is neither "javascript" nor a fetch scheme
Run process a navigate URL scheme given resource's url and browsingContext.

To process a navigate fetch, given a request request, browsing context sourceBrowsingContext, browsing context browsingContext, and string navigationType, run these steps:

Let response be null.

Set request's client to sourceBrowsingContext's active document's relevant settings object, destination to "document", mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and target client id to browsingContext's active document's relevant settings object's id.

If browsingContext is a child browsing context and the browsing context container of browsingContext has a browsing context scope origin, then set request's origin to that browsing context scope origin.

Create a new environment reservedEnvironment, and set its id to a new unique opaque string, its creation URL to request's url, and its target browsing context to browsingContext.

The created environment's active service worker is set in the handle fetch algorithm during the fetch if its creation URL matches a service worker registration. [SW]

Set request's reserved client to reservedEnvironment.

If the Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, navigationType, sourceBrowsingContext, and browsingContext, then set response to a network error. [CSP]

Otherwise:

Fetch request.

Wait for the task on the networking task source to process response and set response to the result.

If response has a location URL and it is either failure or a URL whose scheme is an HTTP(S) scheme, then set response to the result of performing HTTP-redirect fetch using request and response and then run this step again.

Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.

Otherwise, if response has a location URL that is a URL whose scheme is "blob", "file", "filesystem", or "javascript", then set response to a network error.

Otherwise, if response has a location URL that is a URL whose scheme is a fetch scheme, then run process a navigate fetch with a new request whose url is response's location URL, sourceBrowsingContext, browsingContext, and navigationType.

Otherwise, if response has a location URL that is a URL, run the process a navigate URL scheme given response's location URL and browsingContext.

Fallback in prefer-online mode: If response was not fetched from an application cache, and was to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is prefer-online, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:

Let candidate be the response identified by the URL in question from the most appropriate application cache of those that match.

If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The user agent may indicate to the user that the original page load failed, and that the page used was a previously cached response.

Fallback for fallback entries: If response was not fetched from an application cache, and was to be fetched using `GET`, and its URL matches the fallback namespace of one or more relevant application caches, and the most appropriate application cache of those that match does not have an entry in its online safelist that has the same origin as response's URL and that is a prefix match for response's URL, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:

Let candidate be the fallback response specified for the fallback namespace in question. If multiple application caches match, the user agent must use the fallback of the most appropriate application cache of those that match.

If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The document's URL, if appropriate, will still be the originally requested URL, not the fallback URL, but the user agent may indicate to the user that the original page load failed, that the page used was a fallback response, and what the URL of the fallback response actually is.

Run process a navigate response given request, response, navigationType, the source browsing context, browsingContext, and reservedEnvironment.

To process a navigate response, given null or a request request, a response response, a string navigationType, two browsing contexts source and browsingContext, and an optional environment reservedEnvironment, run these steps:

If any of the following are true, then display the inline content with an appropriate error shown to the user, with the newly created Document object's origin set to a new opaque origin, and return.

response is a network error.

TODO: Define X-Frame-Options processing here [whatwg/html#1230].

The Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, response, navigationType, source, and browsingContext. [CSP]

This is where the network errors defined and propagated by the WHATWG Fetch standard, such as DNS or TLS errors, end up being displayed to users. [FETCH]

If response's status is 204 or 205, then return.

If response has an `Content-Disposition` header specifying the attachment disposition type, then handle it as a download and return.

Let type be the computed type of response.

If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:

an HTML MIME type
Follow the steps given in the HTML document section, and then, once they have completed, return.
an XML MIME type that is not an explicitly supported XML MIME type
Follow the steps given in the XML document section. If that section determines that the content is not to be displayed as a generic XML document, then proceed to the next step in this overall set of steps. Otherwise, once the steps given in the XML document section have completed, return.
a JavaScript MIME type
a JSON MIME type that is not an explicitly supported JSON MIME type
"text/cache-manifest"
"text/css"
"text/plain"
"text/vtt"
Follow the steps given in the plain text file section, and then, once they have completed, return..
"multipart/x-mixed-replace"
Follow the steps given in the multipart/x-mixed-replace section, and then, once they have completed, return.
A supported image, video, or audio type
Follow the steps given in the media section, and then, once they have completed, return.
A type that will use an external application to render the content in browsingContext
Follow the steps given in the plugin section, and then, once they have completed, return.
An explicitly supported XML MIME type is an XML MIME type for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or one for which the user agent has dedicated processing rules (e.g. a Web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type), or one for which the user agent has a dedicated handler.

An explicitly supported JSON MIME type is a JSON MIME type for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or one for which the user agent has dedicated processing rules, or one for which the user agent has a dedicated handler.

Setting the document's address: If there is no override URL, then any Document created by these steps must have its URL set to the URL that was originally to be fetched, ignoring any other data that was used to obtain the resource. However, if there is an override URL, then any Document created by these steps must have its URL set to that URL instead.

An override URL is set when dereferencing a javascript: URL and when performing an overridden reload.

Initializing a new Document object: when a Document is created as part of the above steps, the user agent will be required to additionally run the following algorithm after creating the new object:

If browsingContext's only entry in its session history is the about:blank Document that was added when browsingContext was created, and navigation is occurring with replacement enabled, and that Document has the same origin as the new Document, then do nothing.

Otherwise:

Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:

For the global object, create a new Window object.

For the global this value, use browsingContext's WindowProxy object.

Let realm execution context be the running JavaScript execution context.

This is the JavaScript execution context created in the previous step.

Set up a window environment settings object with realm execution context and reservedEnvironment, if present.

Set the Document's HTTPS state to the HTTPS state of response.

Set the Document's referrer policy to the result of parsing the `Referrer-Policy` header of response. [REFERRERPOLICY]

Execute the Initialize a Document's CSP list algorithm on the Document object and the response used to generate the document. [CSP]

If request is non-null, then set the document's referrer to the serialization of request's referrer, if request's referrer is a URL record, and the empty string otherwise.

Per the WHATWG Fetch standard a request's referrer will be either a URL record or "no-referrer" at this point.

Implement the sandboxing for the Document.

Set the allow* flags for the Document.

If response has a `Refresh` header, then:

Multiple `Refresh` headers.

Let value be the value of the header with each byte mapped to a code point of equal value.

Run the shared declarative refresh steps with the Document and value.

Non-document content: If, given type, the new resource is to be handled by displaying some sort of inline content, e.g., a native rendering of the content or an error message because the specified type is not supported, then display the inline content, and then return.

Otherwise, the document's type is such that the resource will not affect browsingContext, e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed as a download. Process the resource appropriately.

To process a navigate URL scheme, given a URL url and browsing context browsingContext, run these steps:

If url is to be handled using a mechanism that does not affect browsingContext, e.g., because url's scheme is handled externally, then proceed with that mechanism instead.

Otherwise, url is to be handled by displaying some sort of inline content, e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme. Display the inline content.

In the case of a registered handler being used, navigate will be invoked with a new URL.

When a resource is handled by passing its URL or data to an external software package separate from the user agent (e.g. handing a mailto: URL to a mail client, or a Word document to a word processor), user agents should attempt to mitigate the risk that this is an attempt to exploit the target software, e.g. by prompting the user to confirm that the source browsing context's active document's origin is to be allowed to invoke the specified software. In particular, if the navigate algorithm, when it was invoked, was not triggered by user activation, the user agent should not invoke the external software package without prior user confirmation.

For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.

Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page. When a user agent is required to do this, it must queue a task (associated with the Document object of the current entry, not the new one) to run the following steps:

Unload the Document object of the current entry, with the recycle parameter set to false.

If this instance of the navigation algorithm is canceled while this step is running the unload a document algorithm, then the unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)

If the navigation was initiated for entry update of an entry
Replace the Document of the entry being updated, and any other entries that referenced the same document as that entry, with the new Document.

Traverse the history to the new entry.

If the navigation was initiated with a URL that equals the browsing context's active document's URL
Replace the current entry with a new entry representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".

Traverse the history to the new entry.

Otherwise
Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.

This doesn't necessarily have to affect the user agent's user interface.

Append a new entry at the end of the History object representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".

Traverse the history to the new entry. If the navigation was initiated with replacement enabled, then the traversal must itself be initiated with replacement enabled.

The navigation algorithm has now matured.

Fragment loop: Spin the event loop for a user-agent-defined amount of time, as desired by the user agent implementer. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)

If the Document object has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then return.

Scroll to the fragment given in the document's URL. If this fails to find an indicated part of the document, then return to the fragment loop step.

The task source for this task is the networking task source.

7.8.2 Page load processing model for HTML files
When an HTML document is to be loaded in a browsing context, the user agent must queue a task to create a Document object, mark it as being an HTML document, set its content type to "text/html", initialize the Document object, and finally create an HTML parser and associate it with the Document. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.

The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.

When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.

After creating the Document object, but before any script execution, certainly before the parser stops, the user agent must update the session history with the new page.

Application cache selection happens in the HTML parser.

The task source for the two tasks mentioned in this section must be the networking task source.

7.8.3 Page load processing model for XML files

Spec bugs: 17976

When faced with displaying an XML file inline, user agents must follow the requirements defined in the XML and Namespaces in XML recommendations, RFC 7303, DOM, and other relevant specifications to create a Document object and a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]

At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.

After the Document is created, the user agent must initialize the Document object.

The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.

If the document element, as parsed according to the XML specifications cited above, is found to be an html element with an attribute manifest whose value is not the empty string, then, as soon as the element is inserted into the document, the user agent must parse the value of that attribute relative to that element's node document, and if that is successful, must apply the URL serializer algorithm to the resulting URL record with the exclude fragment flag set to obtain manifest URL, and then run the application cache selection algorithm with manifest URL as the manifest URL, passing in the newly-created Document. Otherwise, if the attribute is absent, its value is the empty string, or parsing its value fails, then as soon as the document element is inserted into the document, the user agent must run the application cache selection algorithm with no manifest, and passing in the Document.

Because the processing of the manifest attribute happens only once the document element is parsed, any URLs referenced by processing instructions before the document element (such as <?xml-stylesheet?> PIs) will be fetched from the network and cannot be cached.

User agents may examine the namespace of the root Element node of this Document object to perform namespace-based dispatch to alternative processing tools, e.g. determining that the content is actually a syndication feed and passing it to a feed handler. If such processing is to take place, abort the steps in this section, and jump to the next step (labeled non-document content) in the navigate steps above.

Otherwise, then, with the newly created Document, the user agent must update the session history with the new page. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.

Error messages from the parse process (e.g. XML namespace well-formedness errors) may be reported inline by mutating the Document.

7.8.4 Page load processing model for text files
When a plain text document is to be loaded in a browsing context, the user agent must queue a task to create a Document object, mark it as being an HTML document, set its content type to the computed MIME type of the resource (type in the navigate algorithm), initialize the Document object, create an HTML parser, associate it with the Document, act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.

The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (type in the navigate algorithm).

The document's character encoding must be set to the character encoding used to decode the document.

Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.

When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.

After creating the Document object, but potentially before the page has finished parsing, the user agent must update the session history with the new page.

User agents may add content to the head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a title.

In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.

The task source for the two tasks mentioned in this section must be the networking task source.

7.8.5 Page load processing model for multipart/x-mixed-replace resources
When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must parse the resource using the rules for multipart types. [RFC2046]

For each body part obtained from the resource, the user agent must run process a navigate response using the new body part and the same browsing context, with replacement enabled if a previous body part from the same resource resulted in a Document object being created and initialized, and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.

For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.

Thus, load events (and for that matter unload events) do fire for each body part loaded.

7.8.6 Page load processing model for media
When an image, video, or audio resource is to be loaded in a browsing context, the user agent should create a Document object, mark it as being an HTML document, set its content type to the computed MIME type of the resource (type in the navigate algorithm), initialize the Document object, append an html element to the Document, append a head element and a body element to the html element, append an element host element for the media, as described below, to the body element, and set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.

The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.

Type of media	Element for the media	Appropriate attribute
Image	img	src
Video	video	src
Audio	audio	src
Then, the user agent must act as if it had stopped parsing.

Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.

After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.

User agents may add content to the head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.

7.8.7 Page load processing model for content that uses plugins
When a resource that requires an external resource to be rendered is to be loaded in a browsing context, the user agent should create a Document object, mark it as being an HTML document and mark it as being a plugin document, set its content type to the computed MIME type of the resource (type in the navigate algorithm), initialize the Document object, append an html element to the Document, append a head element and a body element to the html element, append an embed to the body element, and set the src attribute of the embed element to the address of the resource.

The term plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used to evade plugin-types directives. [CSP]

Then, the user agent must act as if it had stopped parsing.

Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.

After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.

User agents may add content to the head element of the Document, or attributes to the embed element, e.g. to link to a style sheet or to give the document a title.

If the Document's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized embed element will fail to render the content if the relevant plugin cannot be secured.

7.8.8 Page load processing model for inline content that doesn't have a DOM
When the user agent is to display a user agent page inline in a browsing context, the user agent should create a Document object, mark it as being an HTML document, set its content type to "text/html", initialize the Document object, and then either associate that Document with a custom rendering that is not rendered using the normal Document rendering rules, or mutate that Document until it represents the content the user agent wants to render.

Once the page has been set up, the user agent must act as if it had stopped parsing.

Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, passing in the newly-created Document.

After creating the Document object, but potentially before the page has been completely set up, the user agent must update the session history with the new page.

7.8.9 Navigating to a fragment
When a user agent is supposed to navigate to a fragment, optionally with replacement enabled, then the user agent must run the following steps:

If not with replacement enabled, then remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.

This doesn't necessarily have to affect the user agent's user interface.

Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.

Append a new entry at the end of the History object representing the new resource and its Document object, related state, and current entry's scroll restoration mode. Its URL must be set to the address to which the user agent was navigating. The title must be left unset.

Traverse the history to the new entry, with replacement enabled if this was invoked with replacement enabled, and with the non-blocking events flag set. This will scroll to the fragment given in what is now the document's URL.

If the scrolling fails because the relevant ID has not yet been parsed, then the original navigation algorithm will take care of the scrolling instead, as the last few steps of its update the session history with the new page algorithm.

When the user agent is required to scroll to the fragment and the indicated part of the document, if any, is being rendered, the user agent must either change the scrolling position of the document using the following algorithm, or perform some other action such that the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not being rendered, then the user agent must do nothing. The aforementioned algorithm is as follows:

If there is no indicated part of the document, set the Document's target element to null.

If the indicated part of the document is the top of the document, then:

Set the Document's target element to null.

Scroll to the beginning of the document for the Document. [CSSOMVIEW]

Otherwise:

Let target be element that is the indicated part of the document.

Set the Document's target element to target.

Use the scroll an element into view algorithm to scroll target into view, with the align to top flag set. [CSSOMVIEW]

Run the focusing steps for target, with the Document's viewport as the fallback target.

Move the sequential focus navigation starting point to target.

The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]

There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.

For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of the document is.

Let fragment be the document's URL's fragment.

If fragment is the empty string, then the indicated part of the document is the top of the document; return.

If find a potential indicated element with fragment returns non-null, than the return value is the indicated part of the document; return.

Let fragmentBytes be the result of percent-decoding fragment.

Let decodedFragment be the result of running UTF-8 decode without BOM or fail on fragmentBytes.

If find a potential indicated element with decodedFragment returns non-null, than the return value is the indicated part of the document; return.

If decodedFragment is an ASCII case-insensitive match for the string top, then the indicated part of the document is the top of the document; return.

There is no indicated part of the document.

To find a potential indicated element given a string fragment, run these steps:

If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.

If there is an a element in the document tree that has a name attribute whose value is equal to fragment, then return the first such element in tree order.

Return null.

The task source for the task mentioned in this section must be the DOM manipulation task source.

7.8.10 History traversal
When a user agent is required to traverse the history to a session history entry entry, optionally with replacement enabled, and optionally with the non-blocking events flag set, the user agent must act as follows.

This algorithm is not just invoked when explicitly going back or forwards in the session history — it is also invoked in other situations, for example when navigating a browsing context, as part of updating the session history with the new page.

If entry no longer holds a Document object, then navigate the browsing context to entry's URL to perform an entry update of entry, and return. The "navigate" algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point there is a Document object and so this step gets skipped. The navigation must be done using the same source browsing context as was used the first time entry was created. (This can never happen with replacement enabled.)

If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.

If the current entry's title was not set by the pushState() or replaceState() methods, then set its title to the value returned by the document.title IDL attribute.

If appropriate, update the current entry in the browsing context's Document object's History object to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.

If entry has a different Document object than the current entry, then run the following substeps:

Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.

If the origin of entry's Document object is not the same as the origin of the current entry's Document object, then run the following subsubsteps:

The current browsing context name must be stored with all the entries in the history that are associated with Document objects with the same origin as the active document and that are contiguous with the current entry.

If the browsing context is a top-level browsing context, but not an auxiliary browsing context, then set the browsing context's name to the empty string.

Set the active document of the browsing context to entry's Document object.

If entry has a browsing context name, then run the following subsubsteps:

Set the browsing context's browsing context name to entry's browsing context name.

Clear any browsing context names of all entries in the history that are associated with Document objects with the same origin as the new active document and that are contiguous with entry.

If entry's Document object has any form controls whose autofill field name is "off", invoke the reset algorithm of each of those elements.

If the current document readiness of entry's Document object is "complete", then queue a task to run the following subsubsteps:

If the Document's page showing flag is true, then abort these steps.

Set the Document's page showing flag to true.

Run any session history document visibility change steps for Document that are defined by other applicable specifications.

This is specifically intended for use by the Page Visibility specification. [PAGEVIS]

Fire an event named pageshow at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to true, and legacy target override flag set.

Set the document's URL to entry's URL.

If entry has a URL whose fragment differs from that of the current entry's when compared in a case-sensitive manner, and the two share the same Document object, then let hash changed be true, and let old URL be the current entry's URL and new URL be entry's URL. Otherwise, let hash changed be false.

If the traversal was initiated with replacement enabled, remove the entry immediately before the specified entry in the session history.

If entry is not an entry with persisted user state, but its URL's fragment is non-null, then scroll to the fragment.

Set the current entry to entry.

Let targetRealm be the current Realm Record.

If entry has serialized state, then let state be StructuredDeserialize(entry's serialized state, targetRealm). If this throws an exception, catch it, ignore the exception, and let statebe null.

Otherwise, let state be null.

Set history.state to state.

Let state changed be true if entry's Document object has a latest entry, and that entry is not entry; otherwise let it be false.

Set entry's Document object's latest entry to entry.

If the non-blocking events flag is not set, then run the following substeps immediately. Otherwise, the non-blocking events flag is set; queue a task to run the following substeps instead.

If state changed is true, then fire an event named popstate at the Document object's Window object, using PopStateEvent, with the bubbles attribute initialized to true and the state attribute initialized state.

If entry is an entry with persisted user state, then the user agent may restore persisted user state and update aspects of the document and its rendering.

If hash changed is true, then fire an event named hashchange at the browsing context's Window object, using HashChangeEvent, with the bubbles attribute initialized to true, the oldURL attribute initialized to old URL, and the newURL attribute initialized to new URL.

The task source for the tasks mentioned above is the DOM manipulation task source.

7.8.10.1 Persisted user state restoration
When the user agent is to restore persisted user state from a history entry, it must run the following steps immediately:

If the entry has a scroll restoration mode, let scrollRestoration be that. Otherwise let scrollRestoration be "auto"

If scrollRestoration is "manual" the user agent should not restore the scroll position for the Document or any of its scrollable regions, with the exception of any nested browsing contexts whose scroll restoration is controlled by their own history entry's scroll restoration mode, otherwise, it may do so.

Optionally, update other aspects of the document and its rendering, for instance values of form fields, that the user agent had previously recorded.

This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in either the Text state or the Search state, if the persisted state includes the directionality of user input in such controls.

Not restoring the scroll position by user agent does not imply that the scroll position will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.

7.8.10.2 The PopStateEvent interface
[Exposed=Window,
 Constructor(DOMString type, optional PopStateEventInit eventInitDict)]
interface PopStateEvent : Event {
  readonly attribute any state;
};

dictionary PopStateEventInit : EventInit {
  any state = null;
};
event . state
Returns a copy of the information that was provided to pushState() or replaceState().

The state attribute must return the value it was initialized to. It represents the context information for the event, or null, if the state represented is the initial state of the Document.

7.8.10.3 The HashChangeEvent interface

Support: hashchange
Chrome for Android	64+
Chrome	5+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	3.6+
Samsung Internet	4+
IE	8+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	2.2+
Opera	10.6+

Source: caniuse.com

[Exposed=Window,
 Constructor(DOMString type, optional HashChangeEventInit eventInitDict)]
interface HashChangeEvent : Event {
  readonly attribute USVString oldURL;
  readonly attribute USVString newURL;
};

dictionary HashChangeEventInit : EventInit {
  USVString oldURL = "";
  USVString newURL = "";
};
event . oldURL
Returns the URL of the session history entry that was previously current.

event . newURL
Returns the URL of the session history entry that is now current.

The oldURL attribute must return the value it was initialized to. It represents context information for the event, specifically the URL of the session history entry that was traversed from.

The newURL attribute must return the value it was initialized to. It represents context information for the event, specifically the URL of the session history entry that was traversed to.

7.8.10.4 The PageTransitionEvent interface
[Exposed=Window,
 Constructor(DOMString type, optional PageTransitionEventInit eventInitDict)]
interface PageTransitionEvent : Event {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : EventInit {
  boolean persisted = false;
};
event . persisted
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.

For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page.

Things that can cause the page to be unsalvageable include:

document.open()
Listening for beforeunload events
Listening for unload events
Having iframes that are not salvageable
Active WebSocket objects
Aborting a Document
The persisted attribute must return the value it was initialized to. It represents the context information for the event.

7.8.11 Unloading documents
A Document has a salvageable state, which must initially be true, a fired unload flag, which must initially be false, and a page showing flag, which must initially be false. The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).

Event loops have a termination nesting level counter, which must initially be 0.

To prompt to unload, given a Document object document and optionally a recursiveFlag, run these steps:

Increase the event loop's termination nesting level by 1.

Increase the document's ignore-opens-during-unload counter by 1.

Let event be the result of creating an event using BeforeUnloadEvent.

Initialize event's type attribute to beforeunload and its cancelable attribute true.

Dispatch: Dispatch event at document's Window object.

Decrease the event loop's termination nesting level by 1.

If any event listeners were triggered by the earlier dispatch step, then set document's salvageable state to false.

If document's active sandboxing flag set does not have its sandboxed modals flag set, and the returnValue attribute of the event object is not the empty string, or if the event was canceled, then the user agent may ask the user to confirm that they wish to unload the document.

The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.

The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless. A simple heuristic might be that if the user has not interacted with the document, the user agent would not ask for confirmation before unloading it.

If the user agent asks the user for confirmation, it must pause while waiting for the user's response.

If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.

If the recursiveFlag is not set, then:

Let descendants be the list of the descendant browsing contexts of document.

For each browsingContext in descendants:

Prompt to unload browsingContext's active document with the recursiveFlag set. If the user refused to allow the document to be unloaded, then the user implicitly also refused to allow document to be unloaded; break.

If the salvageable state of browsingContext's active document is false, then set the salvageable state of document to false.

Decrease the document's ignore-opens-during-unload counter by 1.

When a user agent is to unload a document, it must run the following steps. These steps are passed an argument, recycle, which is either true or false, indicating whether the Document object is going to be re-used. (This is set by the document.open() method.)

Increase the event loop's termination nesting level by one.

Increase the Document's ignore-opens-during-unload counter by one.

If the Document's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the pagehide event and don't rerun the unloading document visibility change steps).

Set the Document's page showing flag to false.

Fire an event named pagehide at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to true if the Document object's salvageable state is true, and false otherwise, and legacy target override flag set.

Run any unloading document visibility change steps for Document that are defined by other applicable specifications.

This is specifically intended for use by the Page Visibility specification. [PAGEVIS]

Unload event: If the Document's fired unload flag is false, then fire an event named unload at the Document's object Window object, with legacy target override flag set.

Decrease the event loop's termination nesting level by one.

If any event listeners were triggered by the earlier unload event step, then set the Document object's salvageable state to false and set the Document's fired unload flag to true.

Run any unloading document cleanup steps for Document that are defined by this specification and other applicable specifications.

If this algorithm was invoked by another instance of the "unload a document" algorithm (i.e. by the steps below that invoke this algorithm for all descendant browsing contexts), then jump to the step labeled end.

Let descendants be the list of the descendant browsing contexts of the Document.

If descendants is not an empty list, then for each browsing context b in descendants run the following substeps:

Unload the active document of the browsing context b with the recycle parameter set to false.

If the salvageable state of the active document of the browsing context b is false, then set the salvageable state of this document to false also.

If both the Document's salvageable state and recycle are false, then the Document's browsing context must discard the Document.

End: Decrease the Document's ignore-opens-during-unload counter by one.

This specification defines the following unloading document cleanup steps. Other specifications can define more.

Let window be the Document's Window object.

For each WebSocket object webSocket whose relevant global object is equal to window, make disappear webSocket.

If this affected any WebSocket objects, then set the Document's salvageable state to false.

If the Document's salvageable state is false, run the following substeps:

For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.

Empty window's list of active timers.

7.8.11.1 The BeforeUnloadEvent interface
[Exposed=Window]
interface BeforeUnloadEvent : Event {
  attribute DOMString returnValue;
};
There are no BeforeUnloadEvent-specific initialization methods.

The BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.

The returnValue attribute controls the process of prompting to unload. When the event is created, the attribute must be set to the empty string. On getting, it must return the last value it was set to. On setting, the attribute must be set to the new value.

This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.

7.8.12 Aborting a document load
If a Document is aborted, the user agent must run the following steps:

Abort the active documents of every child browsing context. If this results in any of those Document objects having their salvageable state set to false, then set this Document's salvageable state to false also.

Cancel any instances of the fetch algorithm in the context of this Document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set the Document's salvageable state to false.

If the Document has an active parser, then abort that parser and set the Document's salvageable state to false.

User agents may allow users to explicitly invoke the abort a document algorithm for a Document. If the user does so, then, if that Document is an active document, the user agent should queue a task to fire an event named abort at that Document's Window object before invoking the abort algorithm.

7.9 Offline Web applications

Support: offline-apps
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	3.5+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.1+
Opera	10.6+

Source: caniuse.com

This feature is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using any of the offline Web application features at this time is highly discouraged. Use service workers instead. [SW]

7.9.1 Introduction
This section is non-normative.

In order to enable users to continue interacting with Web applications and documents even when their network connection is unavailable — for instance, because they are traveling outside of their ISP's coverage area — authors can provide a manifest which lists the files that are needed for the Web application to work offline and which causes the user's browser to keep a copy of the files for use offline.

To illustrate this, consider a simple clock applet consisting of an HTML page "clock1.html", a CSS style sheet "clock.css", and a JavaScript script "clock.js".

Before adding the manifest, these three files might look like this:

<!-- clock1.html -->
<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Clock</title>
  <script src="clock.js"></script>
  <link rel="stylesheet" href="clock.css">
 </head>
 <body>
  <p>The time is: <output id="clock"></output></p>
 </body>
</html>
/* clock.css */
output { font: 2em sans-serif; }
/* clock.js */
setInterval(function () {
    document.getElementById('clock').value = new Date();
}, 1000);
If the user tries to open the "clock1.html" page while offline, though, the user agent (unless it happens to have it still in the local cache) will fail with an error.

The author can instead provide a manifest of the three files, say "clock.appcache":

CACHE MANIFEST
clock2.html
clock.css
clock.js
With a small change to the HTML file, the manifest (served as text/cache-manifest) is linked to the application:

<!-- clock2.html -->
<!DOCTYPE HTML>
<html manifest="clock.appcache">
 <head>
  <meta charset="utf-8">
  <title>Clock</title>
  <script src="clock.js"></script>
  <link rel="stylesheet" href="clock.css">
 </head>
 <body>
  <p>The time is: <output id="clock"></output></p>
 </body>
</html>
Now, if the user goes to the page, the browser will cache the files and make them available even when the user is offline.

Authors are encouraged to include the main page in the manifest also, but in practice the page that referenced the manifest is automatically cached even if it isn't explicitly mentioned.

With the exception of "no-store" directive, HTTP cache headers and restrictions on caching pages served over TLS (encrypted, using https:) are overridden by manifests. Thus, pages will not expire from an application cache before the user agent has updated it, and even applications served over TLS can be made to work offline.

View this example online.

7.9.1.1 Supporting offline caching for legacy applications
This section is non-normative.

The application cache feature works best if the application logic is separate from the application and user data, with the logic (markup, scripts, style sheets, images, etc) listed in the manifest and stored in the application cache, with a finite number of static HTML pages for the application, and with the application and user data stored in Web Storage or a client-side Indexed Database, updated dynamically using Web Sockets, XMLHttpRequest, server-sent events, or some other similar mechanism.

This model results in a fast experience for the user: the application immediately loads, and fresh data is obtained as fast as the network will allow it (possibly while stale data shows).

Legacy applications, however, tend to be designed so that the user data and the logic are mixed together in the HTML, with each operation resulting in a new HTML page from the server.

For example, consider a news application. The typical architecture of such an application, when not using the application cache feature, is that the user fetches the main page, and the server returns a dynamically-generated page with the current headlines and the user interface logic mixed together.

A news application designed for the application cache feature, however, would instead have the main page just consist of the logic, and would then have the main page fetch the data separately from the server, e.g. using XMLHttpRequest.

The mixed-content model does not work well with the application cache feature: since the content is cached, it would result in the user always seeing the stale data from the previous time the cache was updated.

While there is no way to make the legacy model work as fast as the separated model, it can at least be retrofitted for offline use using the prefer-online application cache mode. To do so, list all the static resources used by the HTML page you want to have work offline in an application cache manifest, use the manifest attribute to select that manifest from the HTML file, and then add the following line at the bottom of the manifest:

SETTINGS:
prefer-online
NETWORK:
*
This causes the application cache to only be used for master entries when the user is offline, and causes the application cache to be used as an atomic HTTP cache (essentially pinning resources listed in the manifest), while allowing all resources not listed in the manifest to be accessed normally when the user is online.

7.9.1.2 Events summary
This section is non-normative.

When the user visits a page that declares a manifest, the browser will try to update the cache. It does this by fetching a copy of the manifest and, if the manifest has changed since the user agent last saw it, redownloading all the resources it mentions and caching them anew.

As this is going on, a number of events get fired on the ApplicationCache object to keep the script updated as to the state of the cache update, so that the user can be notified appropriately. The events are as follows:

Event name	Interface	Fired when...	Next events
checking	Event	The user agent is checking for an update, or attempting to download the manifest for the first time. This is always the first event in the sequence.	noupdate, downloading, obsolete, error
noupdate	Event	The manifest hadn't changed.	Last event in sequence.
downloading	Event	The user agent has found an update and is fetching it, or is downloading the resources listed by the manifest for the first time.	progress, error, cached, updateready
progress	ProgressEvent	The user agent is downloading resources listed by the manifest. The event object's total attribute returns the total number of files to be downloaded. The event object's loaded attribute returns the number of files processed so far.	progress, error, cached, updateready
cached	Event	The resources listed in the manifest have been downloaded, and the application is now cached.	Last event in sequence.
updateready	Event	The resources listed in the manifest have been newly redownloaded, and the script can use swapCache() to switch to the new cache.	Last event in sequence.
obsolete	Event	The manifest was found to have become a 404 or 410 page, so the application cache is being deleted.	Last event in sequence.
error	Event	The manifest was a 404 or 410 page, so the attempt to cache the application has been aborted.	Last event in sequence.
The manifest hadn't changed, but the page referencing the manifest failed to download properly.
A fatal error occurred while fetching the resources listed in the manifest.
The manifest changed while the update was being run.	The user agent will try fetching the files again momentarily.
These events are cancelable; their default action is for the user agent to show download progress information. If the page shows its own update UI, canceling the events will prevent the user agent from showing redundant progress information.

7.9.2 Application caches
An application cache is a set of cached resources consisting of:

One or more resources (including their out-of-band metadata, such as HTTP headers, if any), identified by URLs, each falling into one (or more) of the following categories:

Master entries
These are documents that were added to the cache because a browsing context was navigated to that document and the document indicated that this was its cache, using the manifest attribute.

The manifest
This is the resource corresponding to the URL that was given in a master entry's html element's manifest attribute. The manifest is fetched and processed during the application cache download process. All the master entries have the same origin as the manifest.

Explicit entries
These are the resources that were listed in the cache's manifest in an explicit section.

Fallback entries
These are the resources that were listed in the cache's manifest in a fallback section.

Explicit entries and Fallback entries can be marked as foreign, which means that they have a manifest attribute but that it doesn't point at this cache's manifest.

A URL in the list can be flagged with multiple different types, and thus an entry can end up being categorized as multiple entries. For example, an entry can be a manifest entry and an explicit entry at the same time, if the manifest is listed within the manifest.

Zero or more fallback namespaces, each of which is mapped to a fallback entry.

These are URLs used as prefix match patterns for resources that are to be fetched from the network if possible, or to be replaced by the corresponding fallback entry if not. Each namespace URL has the same origin as the manifest.

Zero or more URLs that form the online safelist namespaces.

These are used as prefix match patterns, and declare URLs for which the user agent will ignore the application cache, instead fetching them normally (i.e. from the network or local HTTP cache as appropriate).

An online safelist wildcard flag, which is either open or blocking.

The open state indicates that any URL not listed as cached is to be implicitly treated as being in the online safelist namespaces; the blocking state indicates that URLs not listed explicitly in the manifest are to be treated as unavailable.

A cache mode flag, which is either in the fast state or the prefer-online state.

Each application cache has a completeness flag, which is either complete or incomplete.

An application cache group is a group of application caches, identified by the absolute URL of a resource manifest which is used to populate the caches in the group.

An application cache is newer than another if it was created after the other (in other words, application caches in an application cache group have a chronological order).

Only the newest application cache in an application cache group can have its completeness flag set to incomplete; the others are always all complete.

Each application cache group has an update status, which is one of the following: idle, checking, downloading.

A relevant application cache is an application cache that is the newest in its group to be complete.

Each application cache group has a list of pending master entries. Each entry in this list consists of a resource and a corresponding Document object. It is used during the application cache download process to ensure that new master entries are cached even if the application cache download process was already running for their application cache group when they were loaded.

An application cache group can be marked as obsolete, meaning that it must be ignored when looking at what application cache groups exist.

A cache host is a Document object.

Each cache host has an associated ApplicationCache object.

Each cache host initially is not associated with an application cache, but can become associated with one early during the page load process, when steps in the parser and in the navigation sections cause cache selection to occur.

Multiple application caches in different application cache groups can contain the same resource, e.g. if the manifests all reference that resource. If the user agent is to select an application cache from a list of relevant application caches that contain a resource, the user agent must use the application cache that the user most likely wants to see the resource from, taking into account the following:

which application cache was most recently updated,
which application cache was being used to display the resource from which the user decided to look at the new resource, and
which application cache the user prefers.
A URL matches a fallback namespace if there exists a relevant application cache whose manifest's URL has the same origin as the URL in question, and that has a fallback namespace that is a prefix match for the URL being examined. If multiple fallback namespaces match the same URL, the longest one is the one that matches. A URL looking for a fallback namespace can match more than one application cache at a time, but only matches one namespace in each cache.

If a manifest https://example.com/app1/manifest declares that https://example.com/resources/images is a fallback namespace, and the user navigates to https://example.com:80/resources/images/cat.png, then the user agent will decide that the application cache identified by https://example.com/app1/manifest contains a namespace with a match for that URL.

7.9.3 The cache manifest syntax
7.9.3.1 Some sample manifests
This section is non-normative.

This example manifest requires two images and a style sheet to be cached and safelists a CGI script.

CACHE MANIFEST
# the above line is required

# this is a comment
# there can be as many of these anywhere in the file
# they are all ignored
  # comments can have spaces before them
  # but must be alone on the line

# blank lines are ignored too

# these are files that need to be cached they can either be listed
# first, or a "CACHE:" header could be put before them, as is done
# lower down.
images/sound-icon.png
images/background.png
# note that each file has to be put on its own line

# here is a file for the online safelist -- it isn't cached, and
# references to this file will bypass the cache, always hitting the
# network (or trying to, if the user is offline).
NETWORK:
comm.cgi

# here is another set of files to cache, this time just the CSS file.
CACHE:
style/default.css
It could equally well be written as follows:

CACHE MANIFEST
NETWORK:
comm.cgi
CACHE:
style/default.css
images/sound-icon.png
images/background.png
Offline application cache manifests can use absolute paths or even absolute URLs:

CACHE MANIFEST

/main/home
/main/app.js
/settings/home
/settings/app.js
https://img.example.com/logo.png
https://img.example.com/check.png
https://img.example.com/cross.png
The following manifest defines a catch-all error page that is displayed for any page on the site while the user is offline. It also specifies that the online safelist wildcard flag is open, meaning that accesses to resources on other sites will not be blocked. (Resources on the same site are already not blocked because of the catch-all fallback namespace.)

So long as all pages on the site reference this manifest, they will get cached locally as they are fetched, so that subsequent hits to the same page will load the page immediately from the cache. Until the manifest is changed, those pages will not be fetched from the server again. When the manifest changes, then all the files will be redownloaded.

Subresources, such as style sheets, images, etc, would only be cached using the regular HTTP caching semantics, however.

CACHE MANIFEST
FALLBACK:
/ /offline.html
NETWORK:
*
7.9.3.2 Writing cache manifests
Manifests must be served using the text/cache-manifest MIME type. All resources served using the text/cache-manifest MIME type must follow the syntax of application cache manifests, as described in this section.

An application cache manifest is a text file, whose text is encoded using UTF-8. Data in application cache manifests is line-based. Newlines must be represented by U+000A LINE FEED (LF) characters, U+000D CARRIAGE RETURN (CR) characters, or U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) pairs. [ENCODING]

This is a willful violation of RFC 2046, which requires all text/* types to only allow CRLF line breaks. This requirement, however, is outdated; the use of CR, LF, and CRLF line breaks is commonly supported and indeed sometimes CRLF is not supported by text editors. [RFC2046]

The first line of an application cache manifest must consist of the string "CACHE", a single U+0020 SPACE character, the string "MANIFEST", and either a U+0020 SPACE character, a U+0009 CHARACTER TABULATION (tab) character, a U+000A LINE FEED (LF) character, or a U+000D CARRIAGE RETURN (CR) character. The first line may optionally be preceded by a U+FEFF BYTE ORDER MARK (BOM) character. If any other text is found on the first line, it is ignored.

Subsequent lines, if any, must all be one of the following:

A blank line
Blank lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters only.

A comment
Comment lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, followed by a single U+0023 NUMBER SIGN character (#), followed by zero or more characters other than U+000A LINE FEED (LF) and U+000D CARRIAGE RETURN (CR) characters.

Comments need to be on a line on their own. If they were to be included on a line with a URL, the "#" would be mistaken for part of a fragment.

A section header
Section headers change the current section. There are four possible section headers:

CACHE:
Switches to the explicit section.
FALLBACK:
Switches to the fallback section.
NETWORK:
Switches to the online safelist section.
SETTINGS:
Switches to the settings section.
Section header lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, followed by one of the names above (including the U+003A COLON character (:)) followed by zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

Ironically, by default, the current section is the explicit section.

Data for the current section
The format that data lines must take depends on the current section.

When the current section is the explicit section, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, a valid URL string identifying a resource other than the manifest itself, and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

When the current section is the fallback section, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, a valid URL string identifying a resource other than the manifest itself, one or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, another valid URL string identifying a resource other than the manifest itself, and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

When the current section is the online safelist section, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, either a single U+002A ASTERISK character (*) or a valid URL string identifying a resource other than the manifest itself, and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

When the current section is the settings section, data lines must consist of zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters, a setting, and then zero or more U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters.

Currently only one setting is defined:

The cache mode setting
This consists of the string "prefer-online". It sets the cache mode to prefer-online. (The cache mode defaults to fast.)
Within a settings section, each setting must occur no more than once.

Manifests may contain sections more than once. Sections may be empty.

URLs that are to be fallback pages associated with fallback namespaces, and those namespaces themselves, must be given in fallback sections, with the namespace being the first URL of the data line, and the corresponding fallback page being the second URL. All the other pages to be cached must be listed in explicit sections.

Fallback namespaces and fallback entries must have the same origin as the manifest itself. Fallback namespaces must also be in the same path as the manifest's URL.

A fallback namespace must not be listed more than once.

Namespaces that the user agent is to put into the online safelist must all be specified in online safelist sections. (This is needed for any URL that the page is intending to use to communicate back to the server.) To specify that all URLs are automatically safelisted in this way, a U+002A ASTERISK character (*) may be specified as one of the URLs.

Authors should not include namespaces in the online safelist for which another namespace in the online safelist is a prefix match.

Relative URLs must be given relative to the manifest's own URL. All URLs in the manifest must have the same scheme as the manifest itself (either explicitly or implicitly, through the use of relative URLs). [URL]

URLs in manifests must not have fragments (i.e. the U+0023 NUMBER SIGN character isn't allowed in URLs in manifests).

Fallback namespaces and namespaces in the online safelist are matched by prefix match.

7.9.3.3 Parsing cache manifests
When a user agent is to parse a manifest, it means that the user agent must run the following steps:

UTF-8 decode the byte stream corresponding with the manifest to be parsed.

The UTF-8 decode algorithm strips a leading BOM, if any.

Let base URL be the absolute URL representing the manifest.

Apply the URL parser to base URL, and let manifest path be the path component thus obtained.

Remove all the characters in manifest path after the last U+002F SOLIDUS character (/), if any. (The first character and the last character in manifest path after this step will both be slashes, the URL path separator character.)

Apply the URL parser steps to the base URL, so that the components from its URL record can be used by the subsequent steps of this algorithm.

Let explicit URLs be an initially empty list of absolute URLs for explicit entries.

Let fallback URLs be an initially empty mapping of fallback namespaces to absolute URLs for fallback entries.

Let online safelist namespaces be an initially empty list of absolute URLs for an online safelist.

Let online safelist wildcard flag be blocking.

Let cache mode flag be fast.

Let input be the decoded text of the manifest's byte stream.

Let position be a pointer into input, initially pointing at the first character.

If the characters starting from position are "CACHE", followed by a U+0020 SPACE character, followed by "MANIFEST", then advance position to the next character after those. Otherwise, this isn't a cache manifest; return with a failure while checking for the magic signature.

If the character at position is neither a U+0020 SPACE character, a U+0009 CHARACTER TABULATION (tab) character, U+000A LINE FEED (LF) character, nor a U+000D CARRIAGE RETURN (CR) character, then this isn't a cache manifest; return with a failure while checking for the magic signature.

This is a cache manifest. The algorithm cannot fail beyond this point (though bogus lines can get ignored).

Collect a sequence of code points that are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters from input given position, and ignore those characters. (Extra text on the first line, after the signature, is ignored.)

Let mode be "explicit".

Start of line: If position is past the end of input, then jump to the last step. Otherwise, collect a sequence of code points that are U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), U+0020 SPACE, or U+0009 CHARACTER TABULATION (tab) characters from input given position.

Now, collect a sequence of code points that are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters from input given position, and let the result be line.

Drop any trailing U+0020 SPACE and U+0009 CHARACTER TABULATION (tab) characters at the end of line.

If line is the empty string, then jump back to the step labeled start of line.

If the first character in line is a U+0023 NUMBER SIGN character (#), then jump back to the step labeled start of line.

If line equals "CACHE:" (the word "CACHE" followed by a U+003A COLON character (:)), then set mode to "explicit" and jump back to the step labeled start of line.

If line equals "FALLBACK:" (the word "FALLBACK" followed by a U+003A COLON character (:)), then set mode to "fallback" and jump back to the step labeled start of line.

If line equals "NETWORK:" (the word "NETWORK" followed by a U+003A COLON character (:)), then set mode to "online safelist" and jump back to the step labeled start of line.

If line equals "SETTINGS:" (the word "SETTINGS" followed by a U+003A COLON character (:)), then set mode to "settings" and jump back to the step labeled start of line.

If line ends with a U+003A COLON character (:), then set mode to "unknown" and jump back to the step labeled start of line.

This is either a data line or it is syntactically incorrect.

Let position be a pointer into line, initially pointing at the start of the string.

Let tokens be a list of strings, initially empty.

While position doesn't point past the end of line:

Let current token be an empty string.

While position doesn't point past the end of line and the character at position is neither a U+0020 SPACE nor a U+0009 CHARACTER TABULATION (tab) character, add the character at position to current token and advance position to the next character in input.

Add current token to the tokens list.

While position doesn't point past the end of line and the character at position is either a U+0020 SPACE or a U+0009 CHARACTER TABULATION (tab) character, advance position to the next character in input.

Process tokens as follows:

If mode is "explicit"
Let urlRecord be the result of parsing the first item in tokens with base URL; ignore the rest.

If urlRecord is failure, then jump back to the step labeled start of line.

If urlRecord has a different scheme component than base URL (the manifest's URL), then jump back to the step labeled start of line.

Let new URL be the result of applying the URL serializer algorithm to urlRecord, with the exclude fragment flag set.

Add new URL to the explicit URLs.

If mode is "fallback"
Let part one be the first token in tokens, and let part two be the second token in tokens.

Let urlRecordOne be the result of parsing part one with base URL.

Let urlRecordTwo be the result of parsing part two with base URL.

If either urlRecordOne or urlRecordTwo are failure, then jump back to the step labeled start of line.

If the origin of either urlRecordOne or urlRecordTwo is not same origin with the manifest's URL origin, then jump back to the step labeled start of line.

Let part one path be the path component of urlRecordOne.

If manifest path is not a prefix match for part one path, then jump back to the step labeled start of line.

Let part one be the result of applying the URL serializer algorithm to urlRecordOne, with the exclude fragment flag set.

Let part two be the result of applying the URL serializer algorithm to urlRecordTwo, with the exclude fragment flag set.

If part one is already in the fallback URLs mapping as a fallback namespace, then jump back to the step labeled start of line.

Otherwise, add part one to the fallback URLs mapping as a fallback namespace, mapped to part two as the fallback entry.

If mode is "online safelist"
If the first item in tokens is a U+002A ASTERISK character (*), then set online safelist wildcard flag to open and jump back to the step labeled start of line.

Otherwise, let urlRecord be the result of parsing the first item in tokens with base URL.

If urlRecord is failure, then jump back to the step labeled start of line.

If urlRecord has a different scheme component than base URL (the manifest's URL), then jump back to the step labeled start of line.

Let new URL be the result of applying the URL serializer algorithm to urlRecord, with the exclude fragment flag set.

Add new URL to the online safelist namespaces.

If mode is "settings"
If tokens contains a single token, and that token is a case-sensitive match for the string "prefer-online", then set cache mode flag to prefer-online and jump back to the step labeled start of line.

Otherwise, the line is an unsupported setting: do nothing; the line is ignored.

If mode is "unknown"
Do nothing. The line is ignored.

Jump back to the step labeled start of line. (That step jumps to the next, and last, step when the end of the file is reached.)

Return the explicit URLs list, the fallback URLs mapping, the online safelist namespaces, the online safelist wildcard flag, and the cache mode flag.

The resource that declares the manifest (with the manifest attribute) will always get taken from the cache, whether it is listed in the cache or not, even if it is listed in an online safelist namespace.

If a resource is listed in the explicit section or as a fallback entry in the fallback section, the resource will always be taken from the cache, regardless of any other matching entries in the fallback namespaces or online safelist namespaces.

When a fallback namespace and an online safelist namespace overlap, the online safelist namespace has priority.

The online safelist wildcard flag is applied last, only for URLs that match neither the online safelist namespace nor the fallback namespace and that are not listed in the explicit section.

7.9.4 Downloading or updating an application cache
When the user agent is required (by other parts of this specification) to start the application cache download process for an absolute URL purported to identify a manifest, or for an application cache group, potentially given a particular cache host, and potentially given a master resource, the user agent must run the steps below. These steps are always run in parallel with the event loop tasks.

Some of these steps have requirements that only apply if the user agent shows caching progress. Support for this is optional. Caching progress UI could consist of a progress bar or message panel in the user agent's interface, or an overlay, or something else. Certain events fired during the application cache download process allow the script to override the display of such an interface. (Such events are delayed until after the load event has fired.) The goal of this is to allow Web applications to provide more seamless update mechanisms, hiding from the user the mechanics of the application cache mechanism. User agents may display user interfaces independent of this, but are encouraged to not show prominent update progress notifications for applications that cancel the relevant events.

The application cache download process steps are as follows:

Optionally, wait until the permission to start the application cache download process has been obtained from the user and until the user agent is confident that the network is available. This could include doing nothing until the user explicitly opts-in to caching the site, or could involve prompting the user for permission. The algorithm might never get past this point. (This step is particularly intended to be used by user agents running on severely space-constrained devices or in highly privacy-sensitive environments).

Atomically, so as to avoid race conditions, perform the following substeps:

Pick the appropriate substeps:

If these steps were invoked with an absolute URL purported to identify a manifest
Let manifest URL be that absolute URL.

If there is no application cache group identified by manifest URL, then create a new application cache group identified by manifest URL. Initially, it has no application caches. One will be created later in this algorithm.

If these steps were invoked with an application cache group
Let manifest URL be the absolute URL of the manifest used to identify the application cache group to be updated.

If that application cache group is obsolete, then abort this instance of the application cache download process. This can happen if another instance of this algorithm found the manifest to be 404 or 410 while this algorithm was waiting in the first step above.

Let cache group be the application cache group identified by manifest URL.

If these steps were invoked with a master resource, then add the resource, along with the resource's Document, to cache group's list of pending master entries.

If these steps were invoked with a cache host, and the status of cache group is checking or downloading, then queue a post-load task to run these steps:

Let showProgress be the result of firing an event named checking at the ApplicationCache singleton of that cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent is checking to see if it can download the application.

If these steps were invoked with a cache host, and the status of cache group is downloading, then also queue a post-load task to run these steps:

Let showProgress be the result of firing an event named downloading at the ApplicationCache singleton of that cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user the application is being downloaded.

If the status of the cache group is either checking or downloading, then abort this instance of the application cache download process, as an update is already in progress.

Set the status of cache group to checking.

For each cache host associated with an application cache in cache group, queue a post-load task run these steps:

Let showProgress be the result of firing an event named checking at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent is checking for the availability of updates.

The remainder of the steps run in parallel.

If cache group already has an application cache in it, then this is an upgrade attempt. Otherwise, this is a cache attempt.

If this is a cache attempt, then this algorithm was invoked with a cache host; queue a post-load task to run these steps:

Let showProgress be the result of firing an event named checking at the ApplicationCache singleton of that cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent is checking for the availability of updates.

Let request be a new request whose url is manifest URL, client is null, destination is the empty string, referrer is "no-referrer", synchronous flag is set, credentials mode is "include", and whose use-URL-credentials flag is set.

Fetching the manifest: Let manifest be the result of fetching request. HTTP caching semantics should be honored for this request.

Parse manifest's body according to the rules for parsing manifests, obtaining a list of explicit entries, fallback entries and the fallback namespaces that map to them, entries for the online safelist, and values for the online safelist wildcard flag and the cache mode flag.

The MIME type of the resource is ignored — it is assumed to be text/cache-manifest. In the future, if new manifest formats are supported, the different types will probably be distinguished on the basis of the file signatures (for the current format, that is the "CACHE MANIFEST" string at the top of the file).

If fetching the manifest fails due to a 404 or 410 response status, then run these substeps:

Mark cache group as obsolete. This cache group no longer exists for any purpose other than the processing of Document objects already associated with an application cache in the cache group.

Let task list be an empty list of tasks.

For each cache host associated with an application cache in cache group, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named obsolete at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the application is no longer available for offline use.

For each entry in cache group's list of pending master entries, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named error (not obsolete!) at the ApplicationCache singleton of the Document for this entry, if there still is one, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent failed to save the application for offline use.

If cache group has an application cache whose completeness flag is incomplete, then discard that application cache.

If appropriate, remove any user interface indicating that an update for this cache is in progress.

Let the status of cache group be idle.

For each task in task list, queue that task as a post-load task.

Abort the application cache download process.

Otherwise, if fetching the manifest fails in some other way (e.g. the server returns another 4xx or 5xx response, or there is a DNS error, or the connection times out, or the user cancels the download, or the parser for manifests fails when checking the magic signature), or if the server returned a redirect, then run the cache failure steps. [HTTP]

If this is an upgrade attempt and the newly downloaded manifest is byte-for-byte identical to the manifest found in the newest application cache in cache group, or the response status is 304, then run these substeps:

Let cache be the newest application cache in cache group.

Let task list be an empty list of tasks.

For each entry in cache group's list of pending master entries, wait for the resource for this entry to have either completely downloaded or failed.

If the download failed (e.g. the server returns a 4xx or 5xx response, or there is a DNS error, the connection times out, or the user cancels the download), or if the resource is labeled with the "no-store" cache directive, then create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named error at the ApplicationCache singleton of the Document for this entry, if there still is one, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent failed to save the application for offline use.

Otherwise, associate the Document for this entry with cache; store the resource for this entry in cache, if it isn't already there, and categorize its entry as a master entry. If applying the URL parser algorithm to the resource's URL results in a URL record that has a non-null fragment component, the URL used for the entry in cache must instead be the absolute URL obtained from applying the URL serializer algorithm to the URL record with the exclude fragment flag set (application caches never include fragments).

For each cache host associated with an application cache in cache group, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named noupdate at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the application is up to date.

Empty cache group's list of pending master entries.

If appropriate, remove any user interface indicating that an update for this cache is in progress.

Let the status of cache group be idle.

For each task in task list, queue that task as a post-load task.

Abort the application cache download process.

Let new cache be a newly created application cache in cache group. Set its completeness flag to incomplete.

For each entry in cache group's list of pending master entries, associate the Document for this entry with new cache.

Set the status of cache group to downloading.

For each cache host associated with an application cache in cache group, queue a post-load task to run these steps:

Let showProgress be the result of firing an event named downloading at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that a new version is being downloaded.

Let file list be an empty list of URLs with flags.

Add all the URLs in the list of explicit entries obtained by parsing manifest to file list, each flagged with "explicit entry".

Add all the URLs in the list of fallback entries obtained by parsing manifest to file list, each flagged with "fallback entry".

If this is an upgrade attempt, then add all the URLs of master entries in the newest application cache in cache group whose completeness flag is complete to file list, each flagged with "master entry".

If any URL is in file list more than once, then merge the entries into one entry for that URL, that entry having all the flags that the original entries had.

For each URL in file list, run the following steps. These steps may be run in parallel for two or more of the URLs at a time. If, while running these steps, the ApplicationCache object's abort() method sends a signal to this instance of the application cache download process algorithm, then run the cache failure steps instead.

If the resource URL being processed was flagged as neither an "explicit entry" nor or a "fallback entry", then the user agent may skip this URL.

This is intended to allow user agents to expire resources not listed in the manifest from the cache. Generally, implementers are urged to use an approach that expires lesser-used resources first.

For each cache host associated with an application cache in cache group, queue a progress post-load task to run these steps:

Let showProgress be the result of firing an event named progress at the ApplicationCache singleton of the cache host, using ProgressEvent, with the cancelable attribute initialized to true, the lengthComputable attribute initialized to true, the total attribute initialized to the number of files in file list, and the loaded attribute initialized to the number of files in file list that have been either downloaded or skipped so far. [XHR]

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that a file is being downloaded in preparation for updating the application.

Let request be a new request whose url is URL, client is null, destination is the empty string, origin is manifest URL's origin, referrer is "no-referrer", synchronous flag is set, credentials mode is "include", use-URL-credentials flag is set, and redirect mode is "manual".

Fetch request. If this is an upgrade attempt, then use the newest application cache in cache group as an HTTP cache, and honor HTTP caching semantics (such as expiration, ETags, and so forth) with respect to that cache. User agents may also have other caches in place that are also honored.

If the previous step fails (e.g. the server returns a 4xx or 5xx response, or there is a DNS error, or the connection times out, or the user cancels the download), or if the server returned a redirect, or if the resource is labeled with the "no-store" cache directive, then run the first appropriate step from the following list: [HTTP]

If the URL being processed was flagged as an "explicit entry" or a "fallback entry"
If these steps are being run in parallel for any other URLs in file list, then abort this algorithm for those other URLs. Run the cache failure steps.

Redirects are fatal because they are either indicative of a network problem (e.g. a captive portal); or would allow resources to be added to the cache under URLs that differ from any URL that the networking model will allow access to, leaving orphan entries; or would allow resources to be stored under URLs different than their true URLs. All of these situations are bad.

If the error was a 404 or 410 HTTP response
If the resource was labeled with the "no-store" cache directive
Skip this resource. It is dropped from the cache.

Otherwise
Copy the resource and its metadata from the newest application cache in cache group whose completeness flag is complete, and act as if that was the fetched resource, ignoring the resource obtained from the network.

User agents may warn the user of these errors as an aid to development.

These rules make errors for resources listed in the manifest fatal, while making it possible for other resources to be removed from caches when they are removed from the server, without errors, and making non-manifest resources survive server-side errors.

Except for the "no-store" directive, HTTP caching rules that would cause a file to be expired or otherwise not cached are ignored for the purposes of the application cache download process.

Otherwise, the fetching succeeded. Store the resource in the new cache.

If the user agent is not able to store the resource (e.g. because of quota restrictions), the user agent may prompt the user or try to resolve the problem in some other manner (e.g. automatically pruning content in other caches). If the problem cannot be resolved, the user agent must run the cache failure steps.

If the URL being processed was flagged as an "explicit entry" in file list, then categorize the entry as an explicit entry.

If the URL being processed was flagged as a "fallback entry" in file list, then categorize the entry as a fallback entry.

If the URL being processed was flagged as an "master entry" in file list, then categorize the entry as a master entry.

As an optimization, if the resource is an HTML or XML file whose document element is an html element with a manifest attribute whose value doesn't match the manifest URL of the application cache being processed, then the user agent should mark the entry as being foreign.

For each cache host associated with an application cache in cache group, queue a progress post-load task to run these steps:

Let showProgress be the result of firing an event named progress at the ApplicationCache singleton of the cache host, using ProgressEvent, with the cancelable attribute initialized to true, the lengthComputable attribute initialized to true, and the total and loaded attributes initialized to the number of files in file list. [XHR]

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that all the files have been downloaded.

Store the list of fallback namespaces, and the URLs of the fallback entries that they map to, in new cache.

Store the URLs that form the new online safelist in new cache.

Store the value of the new online safelist wildcard flag in new cache.

Store the value of the new cache mode flag in new cache.

For each entry in cache group's list of pending master entries, wait for the resource for this entry to have either completely downloaded or failed.

If the download failed (e.g. the server returns a 4xx or 5xx response, or there is a DNS error, the connection times out, or the user cancels the download), or if the resource is labeled with the "no-store" cache directive, then run these substeps:

Unassociate the Document for this entry from new cache.

Queue a post-load task to run these steps:

Let showProgress be the result of firing an event named error at the ApplicationCache singleton of the Document for this entry, if there still is one, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent failed to save the application for offline use.

If this is a cache attempt and this entry is the last entry in cache group's list of pending master entries, then run these further substeps:

Discard cache group and its only application cache, new cache.

If appropriate, remove any user interface indicating that an update for this cache is in progress.

Abort the application cache download process.

Otherwise, remove this entry from cache group's list of pending master entries.

Otherwise, store the resource for this entry in new cache, if it isn't already there, and categorize its entry as a master entry.

Let request be a new request whose url is manifest URL, client is null, destination is the empty string, referrer is "no-referrer", synchronous flag is set, credentials mode is "include", and whose use-URL-credentials flag is set.

Let second manifest be the result of fetching request. HTTP caching semantics should again be honored for this request.

Since caching can be honored, authors are encouraged to avoid setting the cache headers on the manifest in such a way that the user agent would simply not contact the network for this second request; otherwise, the user agent would not notice if the cache had changed during the cache update process.

If the previous step failed for any reason, or if the fetching attempt involved a redirect, or if second manifest and manifest are not byte-for-byte identical, then schedule a rerun of the entire algorithm with the same parameters after a short delay, and run the cache failure steps.

Otherwise, store manifest in new cache, if it's not there already, and categorize its entry as the manifest.

Set the completeness flag of new cache to complete.

Let task list be an empty list of tasks.

If this is a cache attempt, then for each cache host associated with an application cache in cache group, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named cached at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the application has been cached and that they can now use it offline.

Otherwise, it is an upgrade attempt. For each cache host associated with an application cache in cache group, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named updateready at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that a new version is available and that they can activate it by reloading the page.

If appropriate, remove any user interface indicating that an update for this cache is in progress.

Set the update status of cache group to idle.

For each task in task list, queue that task as a post-load task.

The cache failure steps are as follows:

Let task list be an empty list of tasks.

For each entry in cache group's list of pending master entries, run the following further substeps. These steps may be run in parallel for two or more entries at a time.

Wait for the resource for this entry to have either completely downloaded or failed.

Unassociate the Document for this entry from its application cache, if it has one.

Create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named error at the ApplicationCache singleton of the Document for this entry, if there still is one, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent failed to save the application for offline use.

For each cache host still associated with an application cache in cache group, create a task to run these steps and append it to task list:

Let showProgress be the result of firing an event named error at the ApplicationCache singleton of the cache host, with the cancelable attribute initialized to true.

If showProgress is true and the user agent shows caching progress, then display some sort of user interface indicating to the user that the user agent failed to save the application for offline use.

Empty cache group's list of pending master entries.

If cache group has an application cache whose completeness flag is incomplete, then discard that application cache.

If appropriate, remove any user interface indicating that an update for this cache is in progress.

Let the status of cache group be idle.

If this was a cache attempt, discard cache group altogether.

For each task in task list, queue that task as a post-load task.

Abort the application cache download process.

Attempts to fetch resources as part of the application cache download process may be done with cache-defeating semantics, to avoid problems with stale or inconsistent intermediary caches.

User agents may invoke the application cache download process, in the background, for any application cache group, at any time (with no cache host). This allows user agents to keep caches primed and to update caches even before the user visits a site.

Each Document has a list of pending application cache download process tasks that is used to delay events fired by the algorithm above until the document's load event has fired. When the Document is created, the list must be empty.

When the steps above say to queue a post-load task task, where task is a task that dispatches an event on a target ApplicationCache object target, the user agent must run the appropriate steps from the following list:

If target's node document is ready for post-load tasks
Queue the task task.

Otherwise
Add task to target's node document's list of pending application cache download process tasks.

When the steps above say to queue a progress post-load task task, where task is a task that dispatches an event on a target ApplicationCache object target, the user agent must run the following steps:

If there is a task in target's node document's list of pending application cache download process tasks that is labeled as a progress task, then remove that task from the list.

Label task as a progress task.

Queue a post-load task task.

The task source for these tasks is the networking task source.

7.9.5 The application cache selection algorithm
When the application cache selection algorithm algorithm is invoked with a Document document and optionally a manifest URL manifest URL, the user agent must run the first applicable set of steps from the following list:

If there is a manifest URL, and document was loaded from an application cache, and the URL of the manifest of that cache's application cache group is not the same as manifest URL
Mark the entry for the resource from which document was taken in the application cache from which it was loaded as foreign.

Restart the current navigation from the top of the navigation algorithm, undoing any changes that were made as part of the initial load (changes can be avoided by ensuring that the step to update the session history with the new page is only ever completed after this application cache selection algorithm is run, though this is not required).

The navigation will not result in the same resource being loaded, because "foreign" entries are never picked during navigation.

User agents may notify the user of the inconsistency between the cache manifest and the document's own metadata, to aid in application development.

If document was loaded from an application cache, and that application cache still exists (it is not now obsolete)
Associate document with the application cache from which it was loaded. Invoke, in the background, the application cache download process for that application cache's application cache group, with document as the cache host.

If document was loaded using `GET`, and, there is a manifest URL, and manifest URL has the same origin as document
Invoke, in the background, the application cache download process for manifest URL, with document as the cache host and with the resource from which document was parsed as the master resource.

If there are relevant application caches that are identified by a URL with the same origin as the URL of document, and that have this URL as one of their entries, excluding entries marked as foreign, then the user agent should use the most appropriate application cache of those that match as an HTTP cache for any subresource loads. User agents may also have other caches in place that are also honored.

Otherwise
The Document is not associated with any application cache.

If there was a manifest URL, the user agent may report to the user that it was ignored, to aid in application development.

7.9.6 Changes to the networking model
If "AppCache" is not removed as a feature this section needs to be integrated into the Fetch standard.

When a cache host is associated with an application cache whose completeness flag is complete, any and all loads for resources related to that cache host other than those for child browsing contexts must go through the following steps instead of immediately invoking the mechanisms appropriate to that resource's scheme:

If the resource is not to be fetched using the GET method, or if applying the URL parser algorithm to both its URL and the application cache's manifest's URL results in two URL records with different scheme components, then fetch the resource normally and return.

If the resource's URL is a master entry, the manifest, an explicit entry, or a fallback entry in the application cache, then get the resource from the cache (instead of fetching it), and return.

If there is an entry in the application cache's online safelist that has the same origin as the resource's URL and that is a prefix match for the resource's URL, then fetch the resource normally and return.

If the resource's URL has the same origin as the manifest's URL, and there is a fallback namespace f in the application cache that is a prefix match for the resource's URL, then:

Fetch the resource normally. If this results in a redirect to a resource with another origin (indicative of a captive portal), or a 4xx or 5xx status code, or if there were network errors (but not if the user canceled the download), then instead get, from the cache, the resource of the fallback entry corresponding to the fallback namespace f. Return.

If the application cache's online safelist wildcard flag is open, then fetch the resource normally and return.

Fail the resource load as if there had been a generic network error.

The above algorithm ensures that so long as the online safelist wildcard flag is blocking, resources that are not present in the manifest will always fail to load (at least, after the application cache has been primed the first time), making the testing of offline applications simpler.

7.9.7 Expiring application caches
As a general rule, user agents should not expire application caches, except on request from the user, or after having been left unused for an extended period of time.

Application caches and cookies have similar implications with respect to privacy (e.g. if the site can identify the user when providing the cache, it can store data in the cache that can be used for cookie resurrection). Implementors are therefore encouraged to expose application caches in a manner related to HTTP cookies, allowing caches to be expunged together with cookies and other origin-specific data.

For example, a user agent could have a "delete site-specific data" feature that clears all cookies, application caches, local storage, databases, etc, from an origin all at once.

7.9.8 Disk space
User agents should consider applying constraints on disk usage of application caches, and care should be taken to ensure that the restrictions cannot be easily worked around using subdomains.

User agents should allow users to see how much space each domain is using, and may offer the user the ability to delete specific application caches.

For predictability, quotas should be based on the uncompressed size of data stored.

How quotas are presented to the user is not defined by this specification. User agents are encouraged to provide features such as allowing a user to indicate that certain sites are trusted to use more than the default quota, e.g. by presenting a non-modal user interface while a cache is being updated, or by having an explicit safelist in the user agent's configuration interface.

7.9.9 Security concerns with offline applications caches
This section is non-normative.

The main risk introduced by offline application caches is that an injection attack can be elevated into persistent site-wide page replacement. This attack involves using an injection vulnerability to upload two files to the victim site. The first file is an application cache manifest consisting of just a fallback entry pointing to the second file, which is an HTML page whose manifest is declared as that first file. Once the user has been directed to that second file, all subsequent accesses to any file covered by the given fallback namespace while either the user or the site is offline will instead show that second file. Targeted denial-of-service attacks or cookie bombing attacks (where the client is made to send so many cookies that the server refuses to process the request) can be used to ensure that the site appears offline.

To mitigate this, manifests can only specify fallbacks that are in the same path as the manifest itself. This means that a content injection upload vulnerability in a particular directory on a server can only be escalated to a take-over of that directory and its subdirectories. If there is no way to inject a file into the root directory, the entire site cannot be taken over.

If a site has been attacked in this way, simply removing the offending manifest might eventually clear the problem, since the next time the manifest is updated, a 404 error will be seen, and the user agent will clear the cache. "Eventually" is the key word here, however; while the attack on the user or server is ongoing, such that connections from an affected user to the affected site are blocked, the user agent will simply assume that the user is offline and will continue to use the hostile manifest. Unfortunately, if a cookie bombing attack has also been used, merely removing the manifest is insufficient; in addition, the server has to be configured to return a 404 or 410 response instead of the 413 "Request Entity Too Large" response.

TLS does not inherently protect a site from this attack, since the attack relies on content being served from the server itself. Not using application caches also does not prevent this attack, since the attack relies on an attacker-provided manifest.

7.9.10 Application cache API
[Exposed=Window]
interface ApplicationCache : EventTarget {

  // update status
  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  // updates
  void update();
  void abort();
  void swapCache();

  // events
  attribute EventHandler onchecking;
  attribute EventHandler onerror;
  attribute EventHandler onnoupdate;
  attribute EventHandler ondownloading;
  attribute EventHandler onprogress;
  attribute EventHandler onupdateready;
  attribute EventHandler oncached;
  attribute EventHandler onobsolete;
};
cache = window . applicationCache
Returns the ApplicationCache object that applies to the active document of that Window.

cache . status
Returns the current status of the application cache, as given by the constants defined below.

cache . update()
Invokes the application cache download process.

Throws an "InvalidStateError" DOMException if there is no application cache to update.

Calling this method is not usually necessary, as user agents will generally take care of updating application caches automatically.

The method can be useful in situations such as long-lived applications. For example, a Web mail application might stay open in a browser tab for weeks at a time. Such an application could want to test for updates each day.

cache . abort()
Cancels the application cache download process.

This method is intended to be used by Web application showing their own caching progress UI, in case the user wants to stop the update (e.g. because bandwidth is limited).

cache . swapCache()
Switches to the most recent application cache, if there is a newer one. If there isn't, throws an "InvalidStateError" DOMException.

This does not cause previously-loaded resources to be reloaded; for example, images do not suddenly get reloaded and style sheets and scripts do not get reparsed or reevaluated. The only change is that subsequent requests for cached resources will obtain the newer copies.

The updateready event will fire before this method can be called. Once it fires, the Web application can, at its leisure, call this method to switch the underlying cache to the one with the more recent updates. To make proper use of this, applications have to be able to bring the new features into play; for example, reloading scripts to enable new features.

An easier alternative to swapCache() is just to reload the entire page at a time suitable for the user, using location.reload().

There is a one-to-one mapping from cache hosts to ApplicationCache objects. The applicationCache attribute on Window objects must return the ApplicationCache object associated with the Window object's active document.

A Document has an associated ApplicationCache object even if that cache host has no actual application cache.

The status attribute, on getting, must return the current state of the application cache that the ApplicationCache object's cache host is associated with, if any. This must be the appropriate value from the following list:

UNCACHED (numeric value 0)
The ApplicationCache object's cache host is not associated with an application cache at this time.

IDLE (numeric value 1)
The ApplicationCache object's cache host is associated with an application cache whose application cache group's update status is idle, and that application cache is the newest cache in its application cache group, and the application cache group is not marked as obsolete.

CHECKING (numeric value 2)
The ApplicationCache object's cache host is associated with an application cache whose application cache group's update status is checking.

DOWNLOADING (numeric value 3)
The ApplicationCache object's cache host is associated with an application cache whose application cache group's update status is downloading.

UPDATEREADY (numeric value 4)
The ApplicationCache object's cache host is associated with an application cache whose application cache group's update status is idle, and whose application cache group is not marked as obsolete, but that application cache is not the newest cache in its group.

OBSOLETE (numeric value 5)
The ApplicationCache object's cache host is associated with an application cache whose application cache group is marked as obsolete.

If the update() method is invoked, the user agent must invoke the application cache download process, in the background, for the application cache group of the application cache with which the ApplicationCache object's cache host is associated, but without giving that cache host to the algorithm. If there is no such application cache, or if its application cache group is marked as obsolete, then the method must throw an "InvalidStateError" DOMException instead.

If the abort() method is invoked, the user agent must send a signal to the current application cache download process for the application cache group of the application cache with which the ApplicationCache object's cache host is associated, if any. If there is no such application cache, or it does not have a current application cache download process, then do nothing.

If the swapCache() method is invoked, the user agent must run the following steps:

Check that ApplicationCache object's cache host is associated with an application cache. If it is not, then throw an "InvalidStateError" DOMException.

Let cache be the application cache with which the ApplicationCache object's cache host is associated. (By definition, this is the same as the one that was found in the previous step.)

If cache's application cache group is marked as obsolete, then unassociate the ApplicationCache object's cache host from cache and return. (Resources will now load from the network instead of the cache.)

Check that there is an application cache in the same application cache group as cache whose completeness flag is complete and that is newer than cache. If there is not, then throw an "InvalidStateError" DOMException exception.

Let new cache be the newest application cache in the same application cache group as cache whose completeness flag is complete.

Unassociate the ApplicationCache object's cache host from cache and instead associate it with new cache.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the ApplicationCache interface:

Event handler	Event handler event type
onchecking	checking
onerror	error
onnoupdate	noupdate
ondownloading	downloading
onprogress	progress
onupdateready	updateready
oncached	cached
onobsolete	obsolete
7.9.11 Browser state

Support: online-status
Chrome for Android	64+
Chrome	14+
iOS Safari	4.2+
UC Browser for Android	11.8+
Firefox	41+
Samsung Internet	4+
IE	9+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	2.3+
Opera	15+

Source: caniuse.com

interface mixin NavigatorOnLine {
  readonly attribute boolean onLine;
};
self . navigator . onLine
Returns false if the user agent is definitely offline (disconnected from the network). Returns true if the user agent might be online.

The events online and offline are fired when the value of this attribute changes.

The navigator.onLine attribute must return false if the user agent will not contact the network when the user follows links or when a script requests a remote page (or knows that such an attempt would fail), and must return true otherwise.

When the value that would be returned by the navigator.onLine attribute of a Window or WorkerGlobalScope changes from true to false, the user agent must queue a task to fire an event named offline at the Window or WorkerGlobalScope object.

On the other hand, when the value that would be returned by the navigator.onLine attribute of a Window or WorkerGlobalScope changes from false to true, the user agent must queue a task to fire an event named online at the Window or WorkerGlobalScope object.

The task source for these tasks is the networking task source.

This attribute is inherently unreliable. A computer can be connected to a network without having Internet access.

In this example, an indicator is updated as the browser goes online and offline.

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>Online status</title>
  <script>
   function updateIndicator() {
     document.getElementById('indicator').textContent = navigator.onLine ? 'online' : 'offline';
   }
  </script>
 </head>
 <body onload="updateIndicator()" ononline="updateIndicator()" onoffline="updateIndicator()">
  <p>The network is: <span id="indicator">(state unknown)</span>
 </body>
</html>
8 Web application APIs
8.1 Scripting
8.1.1 Introduction
Various mechanisms can cause author-provided executable code to run in the context of a document. These mechanisms include, but are probably not limited to:

Processing of script elements.
Navigating to javascript: URLs.
Event handlers, whether registered through the DOM using addEventListener(), by explicit event handler content attributes, by event handler IDL attributes, or otherwise.
Processing of technologies like SVG that have their own scripting features.
8.1.2 Enabling and disabling scripting
Scripting is enabled in a browsing context when all of the following conditions are true:

The user agent supports scripting.
The user has not disabled scripting for this browsing context at this time. (User agents may provide users with the option to disable scripting globally, or in a finer-grained manner, e.g. on a per-origin basis.)
The browsing context's active document's active sandboxing flag set does not have its sandboxed scripts browsing context flag set.
Scripting is disabled in a browsing context when any of the above conditions are false (i.e. when scripting is not enabled).

Scripting is enabled for a node if the node's node document has a browsing context, and scripting is enabled in that browsing context.

Scripting is disabled for a node if there is no such browsing context, or if scripting is disabled in that browsing context.

8.1.3 Processing model
8.1.3.1 Definitions
A script is one of two possible structs. All scripts have:

A settings object
An environment settings object, containing various settings that are shared with other scripts in the same context.

A record
Either a Script Record, for classic scripts; a Source Text Module Record, for module scripts; or null. In the former two cases, it represents a parsed script; null represents a failure parsing.

A parse error
A JavaScript value, which has meaning only if the record is null, indicating that the corresponding script source text could not be parsed.

An error to rethrow
A JavaScript value representing an error that will prevent evaluation from succeeding. It will be re-thrown by any attempts to run the script.

Since this exception value is provided by the JavaScript specification, we know that it is never null, so we use null to signal that no error has occurred.

Fetch options
A script fetch options, containing various options related to fetching this script or module scripts that it imports.
A base URL
A base URL used for resolving module specifiers. This will either be the URL from which the script was obtained, for external scripts, or the document base URL of the containing document, for inline scripts.

A classic script is a type of script that has the following additional item:

A muted errors boolean
A boolean which, if true, means that error information will not be provided for errors in this script. This is used to mute errors for cross-origin scripts, since that can leak private information.

A module script is another type of script. It has no additional items.

The active script is determined by the following algorithm:

Let record be GetActiveScriptOrModule().

If record is null, return null.

Return record.[[HostDefined]].

An environment is an object that identifies the settings of a current or potential execution environment. An environment has the following fields:

An id
An opaque string that uniquely identifies the environment.

A creation URL
A URL record that represents the location of the resource with which the environment is associated.

In the case of an environment settings object, this URL might be distinct from the environment settings object's responsible document's URL, due to mechanisms such as history.pushState().

A target browsing context
Null or a target browsing context for a navigation request.

An active service worker
Null or a service worker that controls the environment.

An execution ready flag
A flag that indicates whether the environment setup is done. It is initially unset.

An environment settings object is an environment that additionally specifies algorithms for:

A realm execution context
A JavaScript execution context shared by all scripts that use this settings object, i.e. all scripts in a given JavaScript realm. When we run a classic script or run a module script, this execution context becomes the top of the JavaScript execution context stack, on top of which another execution context specific to the script in question is pushed. (This setup ensures ParseScript and Source Text Module Record's Evaluate know which Realm to use.)

A module map
A module map that is used when importing JavaScript modules.

A responsible browsing context
A browsing context that is assigned responsibility for actions taken by the scripts that use this environment settings object.

When a script creates and navigates a new top-level browsing context, the opener attribute of the new browsing context's Window object will be set to the responsible browsing context's WindowProxy object.

A responsible event loop
An event loop that is used when it would not be immediately clear what event loop to use.

A responsible document
A Document that is assigned responsibility for actions taken by the scripts that use this environment settings object.

For example, the URL of the responsible document is used to set the URL of the Document after it has been reset using document.open().

If the responsible event loop is not a browsing context event loop, then the environment settings object has no responsible document.

An API URL character encoding
A character encoding used to encode URLs by APIs called by scripts that use this environment settings object.

An API base URL
A URL used by APIs called by scripts that use this environment settings object to parse URLs.

An origin
An origin used in security checks.

An HTTPS state
An HTTPS state value representing the security properties of the network channel used to deliver the resource with which the environment settings object is associated.

A referrer policy
The default referrer policy for fetches performed using this environment settings object as a request client. [REFERRERPOLICY]

An environment settings object also has an outstanding rejected promises weak set and an about-to-be-notified rejected promises list, used to track unhandled promise rejections. The outstanding rejected promises weak set must not create strong references to any of its members, and implementations are free to limit its size, e.g. by removing old entries from it when new ones are added.

8.1.3.2 Fetching scripts
This section introduces a number of algorithms for fetching scripts, taking various necessary inputs and resulting in classic or module scripts.

Script fetch options is a struct with the following items:

cryptographic nonce
The cryptographic nonce metadata used for the initial fetch and for fetching any imported modules

integrity metadata
The integrity metadata used for the initial fetch

parser metadata
The parser metadata used for the initial fetch and for fetching any imported modules

credentials mode
The credentials mode used for the initial fetch (for module scripts) and for fetching any imported modules (for both module scripts and classic scripts)

referrer policy
The referrer policy used for the initial fetch and for fetching any imported modules

Recall that via the import() feature, classic scripts can import module scripts.

The default classic script fetch options are a script fetch options whose cryptographic nonce is the empty string, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is "omit", and referrer policy is the empty string.

Given a request request and a script fetch options options, we define:

set up the classic script request
Set request's cryptographic nonce metadata to options's cryptographic nonce, its integrity metadata to options's integrity metadata, its parser metadata to options's parser metadata, and its referrer policy to options's referrer policy.

set up the module script request
Set request's cryptographic nonce metadata to options's cryptographic nonce, its integrity metadata to options's integrity metadata, its parser metadata to options's parser metadata, its credentials mode to options's credentials mode, and its referrer policy to options's referrer policy.

For any given script fetch options options, the descendant script fetch options are a new script fetch options whose items all have the same values, except for the integrity metadata, which is instead the empty string.

The algorithms below can be customized by optionally supplying a custom perform the fetch hook, which takes a request and an is top-level flag. The algorithm must complete with a response (which may be a network error), either synchronously (when using fetch a classic worker-imported script) or asynchronously (otherwise). The is top-level flag will be set for all classic script fetches, and for the initial fetch when fetching a module script graph or fetching a module worker script graph, but not for the fetches resulting from import statements encountered throughout the graph.

By default, not supplying the perform the fetch will cause the below algorithms to simply fetch the given request, with algorithm-specific customizations to the request and validations of the resulting response.

To layer your own customizations on top of these algorithm-specific ones, supply a perform the fetch hook that modifies the given request, fetches it, and then performs specific validations of the resulting response (completing with a network error if the validations fail).

The hook can also be used to perform more subtle customizations, such as keeping a cache of responses and avoiding performing a fetch at all.

Service Workers is an example of a specification that runs these algorithms with its own options for the hook. [SW]

Now for the algorithms themselves.

To fetch a classic script given a url, a settings object, some options, a CORS setting, and a character encoding, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).

Let request be the result of creating a potential-CORS request given url, "script", and CORS setting.

Set request's client to settings object.

Set up the classic script request given request and options.

If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.

response can be either CORS-same-origin or CORS-cross-origin. This only affects how error reporting happens.

Let response be response's unsafe response.

If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.

If response's Content Type metadata, if any, specifies a character encoding, and the user agent supports that encoding, then set character encoding to that encoding (ignoring the passed-in value).

Let source text be the result of decoding response's body to Unicode, using character encoding as the fallback encoding.

The decode algorithm overrides character encoding if the file contains a BOM.

Let muted errors be true if response was CORS-cross-origin, and false otherwise.

Let script be the result of creating a classic script given source text, settings object, response's url, options, and muted errors.

Asynchronously complete this algorithm with script.
To fetch a classic worker script given a url, a fetch client settings object, a destination, and a script settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).

Let request be a new request whose url is url, client is fetch client settings object, destination is destination, mode is "same-origin", credentials mode is "same-origin", parser metadata is "not parser-inserted", and whose use-URL-credentials flag is set.

If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.

Let response be response's unsafe response.

If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.

Let source text be the result of UTF-8 decoding response's body.

Let script be the result of creating a classic script using source text, script settings object, response's url, and the default classic script fetch options.

Asynchronously complete this algorithm with script.
To fetch a classic worker-imported script given a url and a settings object, run these steps. The algorithm will synchronously complete with a classic script on success, or throw an exception on failure.

Let request be a new request whose url is url, client is settings object, destination is "script", parser metadata is "not parser-inserted", synchronous flag is set, and whose use-URL-credentials flag is set.

If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Let response be the result.

Otherwise, fetch request, and let response be the result.

Unlike other algorithms in this section, the fetching process is synchronous here. Thus any perform the fetch steps will also finish their work synchronously.

Let response be response's unsafe response.

If response's type is "error", or response's status is not an ok status, throw a "NetworkError" DOMException.

Let source text be the result of UTF-8 decoding response's body.

Let muted errors be true if response was CORS-cross-origin, and false otherwise.

Let script be the result of creating a classic script given source text, settings object, response's url, the default classic script fetch options, and muted errors.

Return script.

To fetch a module script graph given a url, a settings object, a destination, and some options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).

Let visited set be « url ».

Perform the internal module script graph fetching procedure given url, settings object, destination, options, settings object, visited set, "client", and with the top-level module fetch flag set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well.

When the internal module script graph fetching procedure asynchronously completes with result, asynchronously complete this algorithm with result.

To fetch a module worker script graph given a url, a fetch client settings object, a destination, a credentials mode, and a module map settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).

Let visited set be « url ».

Let options be a script fetch options whose cryptographic nonce is the empty string, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is credentials mode, and referrer policy is the empty string.

Perform the internal module script graph fetching procedure given url, fetch client settings object, destination, options, module map settings object, visited set, "client", and with the top-level module fetch flag set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well.

When the internal module script graph fetching procedure asynchronously completes with result, asynchronously complete this algorithm with result.

The following algorithms are meant for internal use by this specification only as part of fetching a module script graph or preparing a script, and should not be used directly by other specifications.

To perform the internal module script graph fetching procedure given a url, a fetch client settings object, a destination, a some options, a module map settings object, a visited set, a referrer, and a top-level module fetch flag, perform these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).

Assert: visited set contains url.

Fetch a single module script given url, fetch client settings object, destination, options, module map settings object, referrer, and the top-level module fetch flag. If the caller of this algorithm specified custom perform the fetch steps, pass those along while fetching a single module script.

Return from this algorithm, and run the following steps when fetching a single module script asynchronously completes with result:

If result is null, asynchronously complete this algorithm with null, and abort these steps.

If the top-level module fetch flag is set, fetch the descendants of and instantiate result given destination and visited set. Otherwise, fetch the descendants of result given the same arguments.

When the appropriate algorithm asynchronously completes with final result, asynchronously complete this algorithm with final result.

To fetch a single module script, given a url, a fetch client settings object, a destination, some options, a module map settings object, a referrer, and a top-level module fetch flag, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).

Let moduleMap be module map settings object's module map.

If moduleMap[url] is "fetching", wait in parallel until that entry's value changes, then queue a task on the networking task source to proceed with running the following steps.

If moduleMap[url] exists, asynchronously complete this algorithm with moduleMap[url], and abort these steps.

Set moduleMap[url] to "fetching".

Let request be a new request whose url is url, destination is destination, mode is "cors", referrer is referrer, and client is fetch client settings object.

Set up the module script request given request and options.

If the caller specified custom steps to perform the fetch, perform them on request, setting the is top-level flag if the top-level module fetch flag is set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.

response is always CORS-same-origin.

If any of the following conditions are met, set moduleMap[url] to null, asynchronously complete this algorithm with null, and abort these steps:

response's type is "error"

response's status is not an ok status

The result of extracting a MIME type from response's header list is not a JavaScript MIME type

For historical reasons, fetching a classic script does not include MIME type checking. In contrast, module scripts will fail to load if they are not of a correct MIME type.

Let source text be the result of UTF-8 decoding response's body.

Let module script be the result of creating a module script given source text, module map settings object, response's url, and options.

Set moduleMap[url] to module script, and asynchronously complete this algorithm with module script.

It is intentional that the module map is keyed by the request URL, whereas the base URL for the module script is set to the response URL. The former is used to deduplicate fetches, while the latter is used for URL resolution.

To fetch the descendants of a module script module script, given a destination and a visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).

If module script's record is null, then asynchronously complete this algorithm with module script and abort these steps.

Let record be module script's record.

If record.[[RequestedModules]] is empty, asynchronously complete this algorithm with module script.

Let urls be a new empty list.

For each string requested of record.[[RequestedModules]],

Let url be the result of resolving a module specifier given module script and requested.

Assert: url is never failure, because resolving a module specifier must have been previously successful with these same two arguments.

If visited set does not contain url, then:

Append url to urls.

Append url to visited set.

Let options be the descendant script fetch options for module script's fetch options.

For each url in urls, perform the internal module script graph fetching procedure given url, options, destination, module script's settings object, module script's settings object, visited set, module script's base URL, and with the top-level module fetch flag unset. If the caller of this algorithm specified custom perform the fetch steps, pass those along while performing the internal module script graph fetching procedure.

These invocations of the internal module script graph fetching procedure should be performed in parallel to each other.

If any of the invocations of the internal module script graph fetching procedure asynchronously complete with null, asynchronously complete this algorithm with null, aborting these steps.

Otherwise, wait until all of the internal module script graph fetching procedure invocations have asynchronously completed. Asynchronously complete this algorithm with module script.

To fetch the descendants of and instantiate a module script module script, given a destination and an optional visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).

If visited set was not given, let it be an empty set.

Fetch the descendants of module script, given destination and visited set.

Return from this algorithm, and run the following steps when fetching the descendants of a module script asynchronously completes with result.

If result is null, then asynchronously complete this algorithm with result.

In this case, there was an error fetching one or more of the descendants. We will not attempt to instantiate.

Let parse error be the result of finding the first parse error given result.

If parse error is null, then:

Let record be result's record.

Perform record.Instantiate().

This step will recursively call Instantiate on all of the module's uninstantiated dependencies.

If this throws an exception, set result's error to rethrow to that exception.

Otherwise, set result's error to rethrow to parse error.

Asynchronously complete this algorithm with result.

To find the first parse error given a root moduleScript and an optional discoveredSet:

Let moduleMap be moduleScript's settings object's module map.

If discoveredSet was not given, let it be an empty set.

Append moduleScript to discoveredSet.

If moduleScript's record is null, then return moduleScript's parse error.

Let childSpecifiers be the value of moduleScript's record's [[RequestedModules]] internal slot.

Let childURLs be the list obtained by calling resolve a module specifier once for each item of childSpecifiers, given moduleScript and that item. (None of these will ever fail, as otherwise moduleScript would have been marked as itself having a parse error.)

Let childModules be the list obtained by getting each value in moduleMap whose key is given by an item of childURLs.

For each childModule of childModules:

Assert: childModule is a module script (i.e., it is not "fetching" or null); by now all module scripts in the graph rooted at moduleScript will have successfully been fetched.

If discoveredSet already contains childModule, continue.

Let childParseError be the result of finding the first parse error given childModule and discoveredSet.

If childParseError is not null, return childParseError.

Return null.

8.1.3.3 Creating scripts
To create a classic script, given a JavaScript string source, an environment settings object settings, a URL baseURL, some script fetch options options, and an optional muted errors boolean:

If muted errors was not provided, let it be false.

If scripting is disabled for settings's responsible browsing context, then set source to the empty string.

Let script be a new classic script that this algorithm will subsequently initialize.

Set script's settings object to settings.

Set script's base URL to baseURL.

Set script's fetch options to options.

Set script's muted errors to muted errors.

Set script's parse error and error to rethrow to null.

Let result be ParseScript(source, settings's Realm, script).

Passing script as the last parameter here ensures result.[[HostDefined]] will be script.

If result is a list of errors, then:

Set script's parse error and its error to rethrow to result[0].

Return script.

Set script's record to result.

Return script.

To create a module script, given a JavaScript string source, an environment settings object settings, a URL baseURL, and some script fetch options options:

If scripting is disabled for settings's responsible browsing context, then set source to the empty string.

Let script be a new module script that this algorithm will subsequently initialize.

Set script's settings object to settings.

Set script's base URL to baseURL.

Set script's fetch options to options.

Set script's parse error and error to rethrow to null.

Let result be ParseModule(source, settings's Realm, script).

Passing script as the last parameter here ensures result.[[HostDefined]] will be script.

If result is a list of errors, then:

Set script's parse error to result[0].

Return script.

For each string requested of result.[[RequestedModules]]:

Let url be the result of resolving a module specifier given script and requested.

If url is failure, then:

Let error be a new TypeError exception.

Set script's parse error to error.

Return script.

This step is essentially validating all of the requested module specifiers. We treat a module with unresolvable module specifiers the same as one that cannot be parsed; in both cases, a syntactic issue makes it impossible to ever contemplate instantiating the module later.

Set script's record to result.

Return script.

8.1.3.4 Calling scripts
To run a classic script given a classic script script and an optional rethrow errors boolean:

If rethrow errors is not given, let it be false.

Let settings be the settings object of script.

Check if we can run script with settings. If this returns "do not run" then return.

Prepare to run script given settings.

Let evaluationStatus be null.

If script's error to rethrow is not null, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: script's error to rethrow, [[Target]]: empty }.

Otherwise, set evaluationStatus to ScriptEvaluation(script's record).

If ScriptEvaluation does not complete because the user agent has aborted the running script, leave evaluationStatus as null.

If evaluationStatus is an abrupt completion, then:

If rethrow errors is true and script's muted errors is false, then:

Clean up after running script with settings.

Rethrow evaluationStatus.[[Value]].

If rethrow errors is true and script's muted errors is true, then:

Clean up after running script with settings.

Throw a "NetworkError" DOMException.

Otherwise, rethrow errors is false. Perform the following steps:

Report the exception given by evaluationStatus.[[Value]] for script.

Clean up after running script with settings.

Return undefined.

Clean up after running script with settings.

If evaluationStatus is a normal completion, return evaluationStatus.[[Value]].

This value is only ever used by the javascript: URL steps.

If we've reached this point, evaluationStatus was left as null because the script was aborted prematurely during evaluation. Return undefined.

To run a module script given a module script script, with an optional rethrow errors boolean:

If rethrow errors is not given, let it be false.

Let settings be the settings object of script.

Check if we can run script with settings. If this returns "do not run" then return.

Prepare to run script given settings.

Let evaluationStatus be null.

If script's error to rethrow is not null, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: script's error to rethrow, [[Target]]: empty }.

Otherwise:

Let record be script's record.

Set evaluationStatus to record.Evaluate().

This step will recursively evaluate all of the module's dependencies.

If Evaluate fails to complete as a result of the user agent aborting the running script, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: a new "QuotaExceededError" DOMException, [[Target]]: empty }.

If evaluationStatus is an abrupt completion, then:

If rethrow errors is true, rethrow the exception given by evaluationStatus.[[Value]].

Otherwise, report the exception given by evaluationStatus.[[Value]] for script.

Clean up after running script with settings.

The steps to check if we can run script with an environment settings object settings are as follows. They return either "run" or "do not run".

If the global object specified by settings is a Window object whose Document object is not fully active, then return "do not run".

If scripting is disabled for the responsible browsing context specified by settings, then return "do not run".

Return "run".

The steps to prepare to run script with an environment settings object settings are as follows:

Push settings's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.

The steps to clean up after running script with an environment settings object settings are as follows:

Assert: settings's realm execution context is the running JavaScript execution context.

Remove settings's realm execution context from the JavaScript execution context stack.

If the JavaScript execution context stack is now empty, perform a microtask checkpoint. (If this runs scripts, these algorithms will be invoked reentrantly.)

These algorithms are not invoked by one script directly calling another, but they can be invoked reentrantly in an indirect manner, e.g. if a script dispatches an event which has event listeners registered.

The running script is the script in the [[HostDefined]] field in the ScriptOrModule component of the running JavaScript execution context.

8.1.3.5 Realms, settings objects, and global objects
A global object is a JavaScript object that is the [[GlobalObject]] field of a JavaScript realm.

In this specification, all JavaScript realms are initialized with global objects that are either Window or WorkerGlobalScope objects.

There is always a 1-to-1-to-1 mapping between JavaScript realms, global objects, and environment settings objects:

A JavaScript realm has a [[HostDefined]] field, which contains the Realm's settings object.

A JavaScript realm has a [[GlobalObject]] field, which contains the Realm's global object.

Each global object in this specification is created during the initialization of a corresponding JavaScript realm, known as the global object's Realm.

Each global object in this specification is created alongside a corresponding environment settings object, known as its relevant settings object.

An environment settings object's realm execution context's Realm component is the environment settings object's Realm.

An environment settings object's Realm then has a [[GlobalObject]] field, which contains the environment settings object's global object.

When defining algorithm steps throughout this specification, it is often important to indicate what JavaScript realm is to be used—or, equivalently, what global object or environment settings object is to be used. In general, there are at least four possibilities:

Entry
This corresponds to the script that initiated the currently running script action: i.e., the function or script that the user agent called into when it called into author code.
Incumbent
This corresponds to the most-recently-entered author function or script on the stack, or the author function or script that originally scheduled the currently-running callback.
Current
This corresponds to the currently-running function object, including built-in user-agent functions which might not be implemented as JavaScript. (It is derived from the current JavaScript realm.)
Relevant
Every platform object has a relevant Realm, which is roughly the JavaScript realm in which it was created. When writing algorithms, the most prominent platform object whose relevant Realm might be important is the this value of the currently-running function object. In some cases, there can be other important relevant Realms, such as those of any arguments.
Note how the entry, incumbent, and current concepts are usable without qualification, whereas the relevant concept must be applied to a particular platform object.

Consider the following pages, with a.html being loaded in a browser window, b.html being loaded in an iframe as shown, and c.html and d.html omitted (they can simply be empty documents):

<!-- a.html -->
<!DOCTYPE html>
<html lang="en">
<title>Entry page</title>

<iframe src="b.html"></iframe>
<button onclick="frames[0].hello()">Hello</button>

<!--b.html -->
<!DOCTYPE html>
<html lang="en">
<title>Incumbent page</title>

<iframe src="c.html" id="c"></iframe>
<iframe src="d.html" id="d"></iframe>

<script>
  const c = document.querySelector("#c").contentWindow;
  const d = document.querySelector("#d").contentWindow;

  window.hello = () => {
    c.print.call(d);
  };
</script>
Each page has its own browsing context, and thus its own JavaScript realm, global object, and environment settings object.

When the print() method is called in response to pressing the button in a.html, then:

The entry Realm is that of a.html.

The incumbent Realm is that of b.html.

The current Realm is that of c.html (since it is the print() method from c.html whose code is running).

The relevant Realm of the object on which the print() method is being called is that of d.html.

The incumbent and entry concepts should not be used by new specifications, as they are excessively complicated and unintuitive to work with. We are working to remove almost all existing uses from the platform: see issue #1430 for incumbent, and issue #1431 for entry.

In general, web platform specifications should use the relevant concept, applied to the object being operated on (usually the this value of the current method). This mismatches the JavaScript specification, where current is generally used as the default (e.g. in determining the JavaScript realm whose Array constructor should be used to construct the result in Array.prototype.map). But this inconsistency is so embedded in the platform that we have to accept it going forward.

Note that in constructors, where there is no this value yet, the current concept is the appropriate default.

One reason why the relevant concept is generally a better default choice than the current concept is that it is more suitable for creating an object that is to be persisted and returned multiple times. For example, the navigator.getBattery() method creates promises in the relevant Realm for the Navigator object on which it is invoked. This has the following impact: [BATTERY]

<!-- outer.html -->
<!DOCTYPE html>
<html lang="en">
<title>Relevant Realm demo: outer page</title>
<script>
  function doTest() {
    const promise = navigator.getBattery.call(frames[0].navigator);

    console.log(promise instanceof Promise);           // logs false
    console.log(promise instanceof frames[0].Promise); // logs true

    frames[0].hello();
  }
</script>
<iframe src="inner.html" onload="doTest()"></iframe>

<!-- inner.html -->
<!DOCTYPE html>
<html lang="en">
<title>Relevant Realm demo: inner page</title>
<script>
  function hello() {
    const promise = navigator.getBattery();

    console.log(promise instanceof Promise);        // logs true
    console.log(promise instanceof parent.Promise); // logs false
  }
</script>
If the algorithm for the getBattery() method had instead used the current Realm, all the results would be reversed. That is, after the first call to getBattery() in outer.html, the Navigator object in inner.html would be permanently storing a Promise object created in outer.html's JavaScript realm, and calls like that inside the hello() function would thus return a promise from the "wrong" realm. Since this is undesirable, the algorithm instead uses the relevant Realm, giving the sensible results indicated in the comments above.

The rest of this section deals with formally defining the entry, incumbent, current, and relevant concepts.

8.1.3.5.1 Entry
The process of calling scripts will push or pop realm execution contexts onto the JavaScript execution context stack, interspersed with other execution contexts.

With this in hand, we define the entry execution context to be the most recently pushed item in the JavaScript execution context stack that is a realm execution context. The entry Realm is the entry execution context's Realm component.

Then, the entry settings object is the environment settings object of the entry Realm.

Similarly, the entry global object is the global object of the entry Realm.

8.1.3.5.2 Incumbent
All JavaScript execution contexts must contain, as part of their code evaluation state, a skip-when-determining-incumbent counter value, which is initially zero. In the process of preparing to run a callback and cleaning up after running a callback, this value will be incremented and decremented.

Every event loop has an associated backup incumbent settings object stack, initially empty. Roughly speaking, it is used to determine the incumbent settings object when no author code is on the stack, but author code is responsible for the current algorithm having been run in some way. The process of preparing to run a callback and cleaning up after running a callback manipulate this stack. [WEBIDL]

When Web IDL is used to invoke author code, or when EnqueueJob invokes a promise job, they use the following algorithms to track relevant data for determining the incumbent settings object:

To prepare to run a callback with an environment settings object settings:

Push settings onto the backup incumbent settings object stack.

Let context be the topmost script-having execution context.

If context is not null, increment context's skip-when-determining-incumbent counter.

To clean up after running a callback with an environment settings object settings:

Let context be the topmost script-having execution context.

This will be the same as the topmost script-having execution context inside the corresponding invocation of prepare to run a callback.

If context is not null, decrement context's skip-when-determining-incumbent counter.

Assert: the topmost entry of the backup incumbent settings object stack is settings.

Remove settings from the backup incumbent settings object stack.

Here, the topmost script-having execution context is the topmost entry of the JavaScript execution context stack that has a non-null ScriptOrModule component, or null if there is no such entry in the JavaScript execution context stack.

With all this in place, the incumbent settings object is determined as follows:

Let context be the topmost script-having execution context.

If context is null, or if context's skip-when-determining-incumbent counter is greater than zero, then:

Assert: the backup incumbent settings object stack is not empty.

This assert would fail if you try to obtain the incumbent settings object from inside an algorithm that was triggered neither by calling scripts nor by Web IDL invoking a callback. For example, it would trigger if you tried to obtain the incumbent settings object inside an algorithm that ran periodically as part of the event loop, with no involvement of author code. In such cases the incumbent concept cannot be used.

Return the topmost entry of the backup incumbent settings object stack.

Return context's Realm component's settings object.

Then, the incumbent Realm is the Realm of the incumbent settings object.

Similarly, the incumbent global object is the global object of the incumbent settings object.

The following series of examples is intended to make it clear how all of the different mechanisms contribute to the definition of the incumbent concept:

Consider the following very simple example:

<!DOCTYPE html>
<iframe></iframe>
<script>
  new frames[0].MessageChannel();
</script>
When the MessageChannel() constructor looks up the incumbent settings object to use as the owner of the new MessagePort objects, the topmost script-having execution context will be that corresponding to the script element: it was pushed onto the JavaScript execution context stack as part of ScriptEvaluation during the run a classic script algorithm. Since there are no Web IDL callback invocations involved, the context's skip-when-determining-incumbent counter is zero, so it is used to determine the incumbent settings object; the result is the environment settings object of window.

(In this example, the environment settings object of frames[0] is not involved at all. It is the current settings object, but the MessageChannel() constructor cares only about the incumbent, not current.)

Consider the following more complicated example:

<!DOCTYPE html>
<iframe></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  window.setTimeout(bound);
</script>
There are two interesting environment settings objects here: that of window, and that of frames[0]. Our concern is: what is the incumbent settings object at the time that the algorithm for postMessage() executes?

It should be that of window, to capture the intuitive notion that the author script responsible for causing the algorithm to happen is executing in window, not frames[0]. Another way of capturing the intuition here is that invoking algorithms asynchronously (in this case via setTimeout()) should not change the incumbent concept.

Let us now explain how the steps given above give us our intuitively-desired result of window's relevant settings object.

When bound is converted to a Web IDL callback type, the incumbent settings object is that corresponding to window (in the same manner as in our simple example above). Web IDL stores this as the resulting callback value's callback context.

When the task posted by setTimeout() executes, the algorithm for that task uses Web IDL to invoke the stored callback value. Web IDL in turn calls the above prepare to run a callback algorithm. This pushes the stored callback context onto the backup incumbent settings object stack. At this time (inside the timer task) there is no author code on the stack, so the topmost script-having execution context is null, and nothing gets its skip-when-determining-incumbent counter incremented.

Invoking the callback then calls bound, which in turn calls the postMessage() method of frames[0]. When the postMessage() algorithm looks up the incumbent settings object, there is still no author code on the stack, since the bound function just directly calls the built-in method. So the topmost script-having execution context will be null: the JavaScript execution context stack only contains an execution context corresponding to postMessage(), with no ScriptEvaluation context or similar below it.

This is where we fall back to the backup incumbent settings object stack. As noted above, it will contain as its topmost entry the relevant settings object of window. So that is what is used as the incumbent settings object while executing the postMessage() algorithm.

Consider this final, even more convoluted example:

<!-- a.html -->
<!DOCTYPE html>
<button>click me</button>
<iframe></iframe>
<script>
const bound = frames[0].location.assign.bind(frames[0].location, "https://example.com/");
document.querySelector("button").addEventListener("click", bound);
</script>

<!-- b.html -->
<!DOCTYPE html>
<iframe src="a.html"></iframe>
<script>
  const iframe = document.querySelector("iframe");
  iframe.onload = function onLoad() {
    iframe.contentWindow.document.querySelector("button").click();
  };
</script>
Again there are two interesting environment settings objects in play: that of a.html, and that of b.html. When the location.assign() method triggers the Location-object navigate algorithm, what will be the incumbent settings object? As before, it should intuitively be that of a.html: the click listener was originally scheduled by a.html, so even if something involving b.html causes the listener to fire, the incumbent responsible is that of a.html.

The callback setup is similar to the previous example: when bound is converted to a Web IDL callback type, the incumbent settings object is that corresponding to a.html, which is stored as the callback's callback context.

When the click() method is called inside b.html, it dispatches a click event on the button that is inside a.html. This time, when the prepare to run a callback algorithm executes as part of event dispatch, there is author code on the stack; the topmost script-having execution context is that of the onLoad function, whose skip-when-determining-incumbent counter gets incremented. Additionally, a.html's environment settings object (stored as the EventHandler's callback context) is pushed onto the backup incumbent settings object stack.

Now, when the Location-object navigate algorithm looks up the incumbent settings object, the topmost script-having execution context is still that of the onLoad function (due to the fact we are using a bound function as the callback). Its skip-when-determining-incumbent counter value is one, however, so we fall back to the backup incumbent settings object stack. This gives us the environment settings object of a.html, as expected.

Note that this means that even though it is the iframe inside a.html that navigates, it is a.html itself that is used as the source browsing context, which determines among other things the request client. This is perhaps the only justifiable use of the incumbent concept on the web platform; in all other cases the consequences of using it are simply confusing and we hope to one day switch them to use current or relevant as appropriate.

8.1.3.5.3 Current
The JavaScript specification defines the current Realm Record, sometimes abbreviated to the "current Realm". [JAVASCRIPT]

Then, the current settings object is the environment settings object of the current Realm Record.

Similarly, the current global object is the global object of the current Realm Record.

8.1.3.5.4 Relevant
The relevant settings object for a platform object is defined as follows:

If the object is a global object
Each global object in this specification is created alongside a corresponding environment settings object; that is its relevant settings object.
Otherwise
The relevant settings object for a non-global platform object o is the environment settings object whose global object is the global object of the global environment associated with o.

The "global environment associated with" concept is from the olden days, before the modern JavaScript specification and its concept of realms. We expect that as the Web IDL specification gets updated, every platform object will have a Realm associated with it, and this definition can be re-cast in those terms. [JAVASCRIPT] [WEBIDL]

Then, the relevant Realm for a platform object is the Realm of its relevant settings object.

Similarly, the relevant global object for a platform object is the global object of its relevant settings object.

8.1.3.6 Killing scripts
Although the JavaScript specification does not account for this possibility, it's sometimes necessary to abort a running script. This causes any ScriptEvaluation or Source Text Module Record Evaluate invocations to cease immediately, emptying the JavaScript execution context stack without triggering any of the normal mechanisms like finally blocks. [JAVASCRIPT]

User agents may impose resource limitations on scripts, for example CPU quotas, memory limits, total execution time limits, or bandwidth limitations. When a script exceeds a limit, the user agent may either throw a "QuotaExceededError" DOMException, abort the script without an exception, prompt the user, or throttle script execution.

For example, the following script never terminates. A user agent could, after waiting for a few seconds, prompt the user to either terminate the script or let it continue.

<script>
 while (true) { /* loop */ }
</script>
User agents are encouraged to allow users to disable scripting whenever the user is prompted either by a script (e.g. using the window.alert() API) or because of a script's actions (e.g. because it has exceeded a time limit).

If scripting is disabled while a script is executing, the script should be terminated immediately.

User agents may allow users to specifically disable scripts just for the purposes of closing a browsing context.

For example, the prompt mentioned in the example above could also offer the user with a mechanism to just close the page entirely, without running any unload event handlers.

8.1.3.7 Integration with the JavaScript job queue
The JavaScript specification defines the JavaScript job and job queue abstractions in order to specify certain invariants about how promise operations execute with a clean JavaScript execution context stack and in a certain order. However, as of the time of this writing the definition of EnqueueJob in that specification is not sufficiently flexible to integrate with HTML as a host environment. [JAVASCRIPT]

This is not strictly true. It is in fact possible, by taking liberal advantage of the many "implementation defined" sections of the algorithm, to contort it to our purposes. However, the end result is a mass of messy indirection and workarounds that essentially bypasses the job queue infrastructure entirely, albeit in a way that is technically sanctioned within the bounds of implementation-defined behavior. We do not take this path, and instead introduce the following willful violation.

As such, user agents must instead use the following definition in place of that in the JavaScript specification. These ensure that the promise jobs enqueued by the JavaScript specification are properly integrated into the user agent's event loops.

The RunJobs abstract operation from the JavaScript specification must not be used by user agents.

8.1.3.7.1 EnqueueJob(queueName, job, arguments)
When the JavaScript specification says to call the EnqueueJob abstract operation, the following algorithm must be used in place of JavaScript's EnqueueJob:

Assert: queueName is "PromiseJobs". ("ScriptJobs" must not be used by user agents.)

Let job settings be some appropriate environment settings object.

It is not yet clear how to specify the environment settings object that should be used here. In practice, this means that the entry concept is not correctly specified while executing a job. See discussion in issue #1189.

Let incumbent settings be the incumbent settings object.

Let active script be the active script.

Assert: active script is not null, as jobs are only enqueued by the JavaScript specification while a script is active.

Let script execution context be a new JavaScript execution context, with its Function field set to null, its Realm field set to active script's settings object's Realm, and its ScriptOrModule set to active script's record.

Queue a microtask, on job settings's responsible event loop, to perform the following steps:

Check if we can run script with job settings. If this returns "do not run" then return.

Prepare to run script with job settings.

This affects the entry concept while the job runs.

Prepare to run a callback with incumbent settings.

This affects the incumbent concept while the job runs.

Push script execution context onto the JavaScript execution context stack.

This affects the active script while the job runs, in cases like Promise.resolve("...").then(eval) where there would otherwise be no active script since eval() is a built-in function that does not originate from any particular script.

Let result be the result of performing the abstract operation specified by job, using the elements of arguments as its arguments.

Pop script execution context from the JavaScript execution context stack.

Clean up after running a callback with incumbent settings.

Clean up after running script with job settings.

If result is an abrupt completion, report the exception given by result.[[Value]].

8.1.3.8 Integration with the JavaScript module system
The JavaScript specification defines a syntax for modules, as well as some host-agnostic parts of their processing model. This specification defines the rest of their processing model: how the module system is bootstrapped, via the script element with type attribute set to "module", and how modules are fetched, resolved, and executed. [JAVASCRIPT]

Although the JavaScript specification speaks in terms of "scripts" versus "modules", in general this specification speaks in terms of classic scripts versus module scripts, since both of them use the script element.

A module map is a map of URL records to values that are either a module script, null (used to represent failed fetches), or a placeholder value "fetching". Module maps are used to ensure that imported JavaScript modules are only fetched, parsed, and evaluated once per Document or worker.

Since module maps are keyed by URL, the following code will create three separate entries in the module map, since it results in three different URLs:

import "https://example.com/module.js";
import "https://example.com/module.js#map-buster";
import "https://example.com/module.js?debug=true";
That is, URL queries and fragments can be varied to create distinct entries in the module map; they are not ignored. Thus, three separate fetches and three separate module evaluations will be performed.

In contrast, the following code would only create a single entry in the module map, since after applying the URL parser to these inputs, the resulting URL records are equal:

import "https://example.com/module2.js";
import "https:example.com/module2.js";
import "https://///example.com\\module2.js";
import "https://example.com/foo/../module2.js";
So in this second example, only one fetch and one module evaluation will occur.

Note that this behavior is the same as how shared workers are keyed by their parsed constructor url.

To resolve a module specifier given a script script and a JavaScript string specifier, perform the following steps. It will return either a URL record or failure.

Apply the URL parser to specifier. If the result is not failure, return the result.

If specifier does not start with the character U+002F SOLIDUS (/), the two-character sequence U+002E FULL STOP, U+002F SOLIDUS (./), or the three-character sequence U+002E FULL STOP, U+002E FULL STOP, U+002F SOLIDUS (../), return failure.

This restriction is in place so that in the future we can allow custom module loaders to give special meaning to "bare" import specifiers, like import "jquery" or import "web/crypto". For now any such imports will fail, instead of being treated as relative URLs.

Return the result of applying the URL parser to specifier with script's base URL as the base URL.

The following are valid module specifiers according to the above algorithm:

https://example.com/apples.js
http:example.com\pears.mjs (becomes http://example.com/pears.mjs as step 1 parses with no base URL)
//example.com/bananas
./strawberries.js.cgi
../lychees
/limes.jsx
data:text/javascript,export default 'grapes';
blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f
The following are valid module specifiers according to the above algorithm, but will invariably cause failures when they are fetched:

javascript:export default 'artichokes';
data:text/plain,export default 'kale';
about:legumes
wss://example.com/celery
The following are not valid module specifiers according to the above algorithm:

https://eggplant:b/c
pumpkins.js
.tomato
..zucchini.js
.\yam.es
8.1.3.8.1 HostResolveImportedModule(referencingScriptOrModule, specifier)
JavaScript contains an implementation-defined HostResolveImportedModule abstract operation, very slightly updated by the import() proposal. User agents must use the following implementation: [JAVASCRIPT] [JSIMPORT]

Let referencing script be referencingScriptOrModule.[[HostDefined]].

Let moduleMap be referencing script's settings object's module map.

Let url be the result of resolving a module specifier given referencing script and specifier.

Assert: url is never failure, because resolving a module specifier must have been previously successful with these same two arguments.

Let resolved module script be moduleMap[url]. (This entry must exist for us to have gotten to this point.)

Assert: resolved module script is a module script (i.e., is not null or "fetching").

Assert: resolved module script's record is not null.

Return resolved module script's record.

8.1.3.8.2 HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability)
The import() proposal contains an implementation-defined HostImportModuleDynamically abstract operation. User agents must use the following implementation: [JSIMPORT]

Let referencing script be referencingScriptOrModule.[[HostDefined]].

Run the following steps in parallel:

Let url be the result of resolving a module specifier given referencing script and specifier.

If url is failure, then:

Let completion be Completion { [[Type]]: throw, [[Value]]: a new TypeError, [[Target]]: empty }.

Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion).

Return.

Let options be the descendant script fetch options for referencing script's fetch options.

Fetch a module script graph given url, settings object, "script", and options. Wait until the algorithm asynchronously completes with result.

If result is null, then:

Let completion be Completion { [[Type]]: throw, [[Value]]: a new TypeError, [[Target]]: empty }.

Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion).

Return.

Run the module script result, with the rethrow errors boolean set to true.

If running the module script throws an exception, then perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, the thrown exception completion).

Otherwise, perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, NormalCompletion(undefined)).

Return undefined.

8.1.3.8.3 HostGetImportMetaProperties(moduleRecord)
The import.meta proposal contains an implementation-defined HostGetImportMetaProperties abstract operation. User agents must use the following implementation: [JSIMPORTMETA]

Let module script be moduleRecord.[[HostDefined]].

Let urlString be module script's base URL, serialized.

Return « Record { [[Key]]: "url", [[Value]]: urlString } ».

8.1.3.9 Integration with the JavaScript agent formalism
JavaScript defines the concept of an agent. Until such a time that this standard has a better handle on lifetimes, we define five types of agents that user agents must allocate at the appropriate time.

In the future, when this specification has a better handle on lifetimes, we hope to define exactly when agents and agent clusters are created.

JavaScript is expected to define agents in more detail; in particular that they hold a set of realms: tc39/ecma262 issue #882.

Similar-origin window agent
An agent whose [[CanBlock]] is false and whose set of realms consists of all realms of Window objects whose relevant settings object's responsible browsing context is in the same unit of related similar-origin browsing contexts.

Two Window objects that are same origin can be in different similar-origin window agents, for instance if they are each in their own unit of related similar-origin browsing contexts.

Dedicated worker agent
An agent whose [[CanBlock]] is true and whose set of realms consists of a single DedicatedWorkerGlobalScope object's Realm.

Shared worker agent
An agent whose [[CanBlock]] is true and whose set of realms consists a single SharedWorkerGlobalScope object's Realm.

Service worker agent
An agent whose [[CanBlock]] is false and whose set of realms consists of a single ServiceWorkerGlobalScope object's Realm.

Worklet agent
An agent whose [[CanBlock]] is false and whose set of realms consists of a single WorkletGlobalScope object's Realm.

While conceptually it might be cleaner for worklets that end up with multiple realms to put all those in the same agent, it is not observable in practice.

8.1.3.10 Integration with the JavaScript agent cluster formalism
Can share memory with defines an equivalence relation. An agent cluster consists of all agents in the same equivalence class with respect to the can share memory with equivalence relation.

A similar-origin window agent, dedicated worker agent, shared worker agent, or service worker agent, agent, can share memory with any dedicated worker agent whose single realm's global object's owner set contains an item whose relevant Realm belongs to agent.

We use item above as an owner set can contain Document objects.

A worklet agent … currently worklets have no clearly defined owner, see: w3c/css-houdini-drafts issue #224.

In addition, any agent A can share memory with:

A,
any agent B such that B can share memory with A, and
any agent B such that there exists an agent C, where A can share memory with C and C can share memory with B.
The agent cluster concept is crucial for defining the JavaScript memory model, and in particular among which agents the backing data of SharedArrayBuffer objects can be shared.

The following pairs of global objects are each within the same agent cluster, and thus can use SharedArrayBuffer instances to share memory with each other:

A Window object and a dedicated worker that it created.
A worker (of any type) and a dedicated worker it created.
A Window object A and the Window object of an iframe element that A created that could be same origin-domain with A.
A Window object and a same origin-domain Window object that opened it.
The following pairs of global objects are not within the same agent cluster, and thus cannot share memory:

A Window object and a shared worker it created.
A worker (of any type) and a shared worker it created.
A Window object and a service worker it created.
A Window object and the Window object of an iframe element that A created that cannot be same origin-domain with A.
8.1.3.11 Runtime script errors
When the user agent is required to report an error for a particular script script with a particular position line:col, using a particular target target, it must run these steps, after which the error is either handled or not handled:

If target is in error reporting mode, then return; the error is not handled.

Let target be in error reporting mode.

Let message be a user-agent-defined string describing the error in a helpful manner.
Let errorValue be the value that represents the error: in the case of an uncaught exception, that would be the value that was thrown; in the case of a JavaScript error that would be an Error object. If there is no corresponding value, then the null value must be used instead.

Let urlString be the result of applying the URL serializer to the URL record that corresponds to the resource from which script was obtained.

The resource containing the script will typically be the file from which the Document was parsed, e.g. for inline script elements or event handler content attributes; or the JavaScript file that the script was in, for external scripts. Even for dynamically-generated scripts, user agents are strongly encouraged to attempt to keep track of the original source of a script. For example, if an external script uses the document.write() API to insert an inline script element during parsing, the URL of the resource containing the script would ideally be reported as being the external script, and the line number might ideally be reported as the line with the document.write() call or where the string passed to that call was first constructed. Naturally, implementing this can be somewhat non-trivial.

User agents are similarly encouraged to keep careful track of the original line numbers, even in the face of document.write() calls mutating the document as it is parsed, or event handler content attributes spanning multiple lines.

If script's muted errors is true, then set message to "Script error.", urlString to the empty string, line and col to 0, and errorValue to null.

Let notHandled be the result of firing an event named error at target, using ErrorEvent, with the cancelable attribute initialized to true, the message attribute initialized to message, the filename attribute initialized to urlString, the lineno attribute initialized to line, the colno attribute initialized to col, and the error attribute initialized to errorValue.

Let target no longer be in error reporting mode.

If notHandled is false, then the error is handled. Otherwise, the error is not handled.

Returning true in an event handler cancels the event per the event handler processing algorithm.

8.1.3.11.1 Runtime script errors in documents
When the user agent is to report an exception E, the user agent must report the error for the relevant script, with the problematic position (line number and column number) in the resource containing the script, using the global object specified by the script's settings object as the target. If the error is still not handled after this, then the error may be reported to a developer console.

8.1.3.11.2 The ErrorEvent interface
[Constructor(DOMString type, optional ErrorEventInit eventInitDict), Exposed=(Window,Worker)]
interface ErrorEvent : Event {
  readonly attribute DOMString message;
  readonly attribute USVString filename;
  readonly attribute unsigned long lineno;
  readonly attribute unsigned long colno;
  readonly attribute any error;
};

dictionary ErrorEventInit : EventInit {
  DOMString message = "";
  USVString filename = "";
  unsigned long lineno = 0;
  unsigned long colno = 0;
  any error = null;
};
The message attribute must return the value it was initialized to. It represents the error message.

The filename attribute must return the value it was initialized to. It represents the URL of the script in which the error originally occurred.

The lineno attribute must return the value it was initialized to. It represents the line number where the error occurred in the script.

The colno attribute must return the value it was initialized to. It represents the column number where the error occurred in the script.

The error attribute must return the value it was initialized to. Where appropriate, it is set to the object representing the error (e.g., the exception object in the case of an uncaught DOM exception).

8.1.3.12 Unhandled promise rejections
In addition to synchronous runtime script errors, scripts may experience asynchronous promise rejections, tracked via the unhandledrejection and rejectionhandled events.


Support: unhandledrejection
Chrome for Android	64+
Chrome	49+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	None
Samsung Internet	5+
IE	None
Opera Mini	None
Safari	11+
Edge	None
Android Browser	62+
Opera	36+

Source: caniuse.com

When the user agent is to notify about rejected promises on a given environment settings object settings object, it must run these steps:

Let list be a copy of settings object's about-to-be-notified rejected promises list.

If list is empty, return.

Clear settings object's about-to-be-notified rejected promises list.

Queue a task to run the following substep:

For each promise p in list:

If p's [[PromiseIsHandled]] internal slot is true, continue to the next iteration of the loop.

Let notHandled be the result of firing an event named unhandledrejection at settings object's global object, using PromiseRejectionEvent, with the cancelable attribute initialized to true, the promise attribute initialized to p, and the reason attribute initialized to the value of p's [[PromiseResult]] internal slot.

If notHandled is false, then the promise rejection is handled. Otherwise, the promise rejection is not handled.

If p's [[PromiseIsHandled]] internal slot is false, add p to settings object's outstanding rejected promises weak set.

This algorithm results in promise rejections being marked as handled or not handled. These concepts parallel handled and not handled script errors. If a rejection is still not handled after this, then the rejection may be reported to a developer console.

8.1.3.12.1 HostPromiseRejectionTracker(promise, operation)
JavaScript contains an implementation-defined HostPromiseRejectionTracker(promise, operation) abstract operation. User agents must use the following implementation: [JAVASCRIPT]

Let script be the running script.

If script's muted errors is true, terminate these steps.

Let settings object be script's settings object.

If operation is "reject",

Add promise to settings object's about-to-be-notified rejected promises list.

If operation is "handle",

If settings object's about-to-be-notified rejected promises list contains promise, then remove promise from that list and return.

If settings object's outstanding rejected promises weak set does not contain promise, then return.

Remove promise from settings object's outstanding rejected promises weak set.

Queue a task to fire an event named rejectionhandled at settings object's global object, using PromiseRejectionEvent, with the promise attribute initialized to promise, and the reason attribute initialized to the value of promise's [[PromiseResult]] internal slot.

8.1.3.12.2 The PromiseRejectionEvent interface
[Constructor(DOMString type, PromiseRejectionEventInit eventInitDict), Exposed=(Window,Worker)]
interface PromiseRejectionEvent : Event {
  readonly attribute Promise<any> promise;
  readonly attribute any reason;
};

dictionary PromiseRejectionEventInit : EventInit {
  required Promise<any> promise;
  any reason;
};
The promise attribute must return the value it was initialized to. It represents the promise which this notification is about.

The reason attribute must return the value it was initialized to. It represents the rejection reason for the promise.

8.1.3.13 HostEnsureCanCompileStrings(callerRealm, calleeRealm)
JavaScript contains an implementation-defined HostEnsureCanCompileStrings(callerRealm, calleeRealm) abstract operation. User agents must use the following implementation: [JAVASCRIPT]

Perform ? EnsureCSPDoesNotBlockStringCompilation(callerRealm, calleeRealm). [CSP]

8.1.4 Event loops
8.1.4.1 Definitions
To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. There are two kinds of event loops: those for browsing contexts, and those for workers.

There must be at least one browsing context event loop per user agent, and at most one per unit of related similar-origin browsing contexts.

When there is more than one event loop for a unit of related browsing contexts, complications arise when a browsing context in that group is navigated such that it switches from one unit of related similar-origin browsing contexts to another. This specification does not currently describe how to handle these complications.

A browsing context event loop always has at least one browsing context. If such an event loop's browsing contexts all go away, then the event loop goes away as well. A browsing context always has an event loop coordinating its activities.

Worker event loops are simpler: each worker has one event loop, and the worker processing model manages the event loop's lifetime.

An event loop has one or more task queues. A task queue is an ordered list of tasks, which are algorithms that are responsible for such work as:

Events
Dispatching an Event object at a particular EventTarget object is often done by a dedicated task.

Not all events are dispatched using the task queue, many are dispatched during other tasks.

Parsing
The HTML parser tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.

Callbacks
Calling a callback is often done by a dedicated task.

Using a resource
When an algorithm fetches a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.

Reacting to DOM manipulation
Some elements have tasks that trigger in response to DOM manipulation, e.g. when that element is inserted into the document.

Each task in a browsing context event loop is associated with a Document; if the task was queued in the context of an element, then it is the element's node document; if the task was queued in the context of a browsing context, then it is the browsing context's active document at the time the task was queued; if the task was queued by or for a script then the document is the responsible document specified by the script's settings object.

A task is intended for a specific event loop: the event loop that is handling tasks for the task's associated Document or worker.

When a user agent is to queue a task, it must add the given task to one of the task queues of the relevant event loop.

Each task is defined as coming from a specific task source. All the tasks from one particular task source and destined to a particular event loop (e.g. the callbacks generated by timers of a Document, the events fired for mouse movements over that Document, the tasks queued for the parser of that Document) must always be added to the same task queue, but tasks from different task sources may be placed in different task queues.

For example, a user agent could have one task queue for mouse and key events (the user interaction task source), and another for everything else. The user agent could then give keyboard and mouse events preference over other tasks three quarters of the time, keeping the interface responsive but not starving other task queues, and never processing events from any one task source out of order.

Each event loop has a currently running task. Initially, this is null. It is used to handle reentrancy. Each event loop also has a performing a microtask checkpoint flag, which must initially be false. It is used to prevent reentrant invocation of the perform a microtask checkpoint algorithm.

8.1.4.2 Processing model
An event loop must continually run through the following steps for as long as it exists:

Let oldestTask be the oldest task on one of the event loop's task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below.

Set the event loop's currently running task to oldestTask.

Run oldestTask.

Set the event loop's currently running task back to null.

Remove oldestTask from its task queue.

Microtasks: Perform a microtask checkpoint.

Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.

Let now be the value that would be returned by the Performance object's now() method. [HRT]

Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:

Any Document B that is nested through a Document A must be listed after A in the list.

If there are two documents A and B whose browsing contexts are both nested browsing contexts and their browsing context containers are both elements in the same Document C, then the order of A and B in the list must match the relative tree order of their respective browsing context containers in C.

In the steps below that iterate over docs, each Document must be processed in the order it is found in the list.

If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context's top-level browsing context is in B.

Whether a top-level browsing context would benefit from having its rendering updated depends on various factors, such as the update frequency. For example, if the browser is attempting to achieve a 60Hz refresh rate, then these steps are only necessary every 60th of a second (about 16.7ms). If the browser finds that a top-level browsing context is not able to sustain this rate, it might drop to a more sustainable 30Hz for that set of Documents, rather than occasionally dropping frames. (This specification does not mandate any particular model for when to update the rendering.) Similarly, if a top-level browsing context is in the background, the user agent might decide to drop that page to a much slower 4Hz, or even less.

Another example of why a browser might skip updating the rendering is to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). For example, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.

If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.

As with top-level browsing contexts, a variety of factors can influence whether it is profitable for a browser to update the rendering of nested browsing contexts. For example, a user agent might wish to spend less resources rendering third-party content, especially if it is not currently visible to the user or if resources are constrained. In such cases, the browser could decide to update the rendering for such content infrequently or never.

For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]

For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]

For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]

For each fully active Document in docs, update animations and send events for that Document, passing in now as the timestamp. [WEBANIMATIONS]

For each fully active Document in docs, run the fullscreen steps for that Document, passing in now as the timestamp. [FULLSCREEN]

For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.

For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]

For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.

If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop's task queues and the WorkerGlobalScope object's closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.

Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue. There are two kinds of microtasks: solitary callback microtasks, and compound microtasks.

This specification only has solitary callback microtasks. Specifications that use compound microtasks have to take extra care to wrap callbacks to handle spinning the event loop.

When an algorithm requires a microtask to be queued, it must be appended to the relevant event loop's microtask queue; the task source of such a microtask is the microtask task source.

It is possible for a microtask to be moved to a regular task queue, if, during its initial execution, it spins the event loop. In that case, the microtask task source is the task source used. Normally, the task source of a microtask is irrelevant.

When a user agent is to perform a microtask checkpoint, if the performing a microtask checkpoint flag is false, then the user agent must run the following steps:

Set the performing a microtask checkpoint flag to true.

While the event loop's microtask queue is not empty:

Let oldestMicrotask be the oldest microtask on the event loop's microtask queue.

Set the event loop's currently running task to oldestMicrotask.

Run oldestMicrotask.

This might involve invoking scripted callbacks, which eventually calls the clean up after running script steps, which call this perform a microtask checkpoint algorithm again, which is why we use the performing a microtask checkpoint flag to avoid reentrancy.

Set the event loop's currently running task back to null.

Remove oldestMicrotask from the microtask queue.

For each environment settings object whose responsible event loop is this event loop, notify about rejected promises on that environment settings object.

Cleanup Indexed Database transactions.

Set the performing a microtask checkpoint flag to false.

If, while a compound microtask is running, the user agent is required to execute a compound microtask subtask to run a series of steps, the user agent must run the following steps:

Let parent be the event loop's currently running task (the currently running compound microtask).

Let subtask be a new task that consists of running the given series of steps. The task source of such a microtask is the microtask task source. This is a compound microtask subtask.

Set the event loop's currently running task to subtask.

Run subtask.

Set the event loop's currently running task back to parent.

When an algorithm running in parallel is to await a stable state, the user agent must queue a microtask that runs the following steps, and must then stop executing (execution of the algorithm resumes when the microtask is run, as described in the following steps):

Run the algorithm's synchronous section.

Resumes execution of the algorithm in parallel, if appropriate, as described in the algorithm's steps.

Steps in synchronous sections are marked with ⌛.

When an algorithm says to spin the event loop until a condition goal is met, the user agent must run the following steps:

Let task be the event loop's currently running task.

This might be a microtask, in which case it is a solitary callback microtask. It could also be a compound microtask subtask, or a regular task that is not a microtask. It will not be a compound microtask.

Let task source be task's task source.

Let old stack be a copy of the JavaScript execution context stack.

Empty the JavaScript execution context stack.

Perform a microtask checkpoint.

Stop task, allowing whatever algorithm that invoked it to resume, but continue these steps in parallel.

This causes one of the following algorithms to continue: the event loop's main set of steps, the perform a microtask checkpoint algorithm, or the execute a compound microtask subtask algorithm.

Wait until the condition goal is met.

Queue a task to continue running these steps, using the task source task source. Wait until this new task runs before continuing these steps.

Replace the JavaScript execution context stack with the old stack.

Return to the caller.

Some of the algorithms in this specification, for historical reasons, require the user agent to pause while running a task until a condition goal is met. This means running the following steps:

If necessary, update the rendering or user interface of any Document or browsing context to reflect the current state.

Wait until the condition goal is met. While a user agent has a paused task, the corresponding event loop must not run further tasks, and any script in the currently running task must block. User agents should remain responsive to user input while paused, however, albeit in a reduced capacity since the event loop will not be doing anything.

Pausing is highly detrimental to the user experience, especially in scenarios where a single event loop is shared among multiple documents. User agents are encouraged to experiment with alternatives to pausing, such as spinning the event loop or even simply proceeding without any kind of suspended execution at all, insofar as it is possible to do so while preserving compatibility with existing content. This specification will happily change if a less-drastic alternative is discovered to be web-compatible.

In the interim, implementers should be aware that the variety of alternatives that user agents might experiment with can change subtle aspects of event loop behavior, including task and microtask timing. Implementations should continue experimenting even if doing so causes them to violate the exact semantics implied by the pause operation.

8.1.4.3 Generic task sources
The following task sources are used by a number of mostly unrelated features in this and other specifications.

The DOM manipulation task source
This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document.

The user interaction task source
This task source is used for features that react to user interaction, for example keyboard or mouse input.

Events sent in response to user input (e.g. click events) must be fired using tasks queued with the user interaction task source. [UIEVENTS]

The networking task source
This task source is used for features that trigger in response to network activity.

The history traversal task source
This task source is used to queue calls to history.back() and similar APIs.

8.1.4.4 Dealing with the event loop from other specifications
Writing specifications that correctly interact with the event loop can be tricky. This is compounded by how this specification uses concurrency-model-independent terminology, so we say things like "event loop" and "in parallel" instead of using more familiar model-specific terms like "main thread" or "on a background thread".

By default, specification text generally runs on the event loop. This falls out from the formal event loop processing model, in that you can eventually trace most algorithms back to a task queued there.

The algorithm steps for any JavaScript method will be invoked by author code calling that method. And author code can only be run via queued tasks, usually originating somewhere in the script processing model.

From this starting point, the overriding guideline is that any work a specification needs to perform that would otherwise block the event loop must instead be performed in parallel with it. This includes (but is not limited to):

performing heavy computation;

displaying a user-facing prompt;

performing operations which could require involving outside systems (i.e. "going out of process").

The next complication is that, in algorithm sections that are in parallel, you must not create or manipulate objects associated to a specific JavaScript realm, global, or environment settings object. (Stated in more familiar terms, you must not directly access main-thread artifacts from a background thread.) Doing so would create data races observable to JavaScript code, since after all, your algorithm steps are running in parallel to the JavaScript code.

You can, however, manipulate specification-level data structures and values from the WHATWG Infra Standard, as those are realm-agnostic. They are never directly exposed to JavaScript without a specific conversion taking place (often via Web IDL). [INFRA] [WEBIDL]

To affect the world of observable JavaScript objects, then, you must queue a task to perform any such manipulations. This ensures your steps are properly interleaved with respect to other things happening on the event loop. Furthermore, you must choose a task source when queueing a task; this governs the relative order of your steps versus others. If you are unsure which task source to use, pick one of the generic task sources that sounds most applicable.

Most invocations of queue a task implicitly use "the relevant event loop", i.e., the one that is obvious from context. That is because it is very rare for algorithms to be invoked in contexts involving multiple event loops. (Unlike contexts involving multiple global objects, which happen all the time!) So unless you are writing a specification which, e.g., deals with manipulating workers, you can omit this argument when queueing a task.

Putting this all together, we can provide a template for a typical algorithm that needs to do work asynchronously:

Do any synchronous setup work, while still on the event loop. This may include converting realm-specific JavaScript values into realm-agnostic specification-level values.

Perform a set of potentially-expensive steps in parallel, operating entirely on realm-agnostic values, and producing a realm-agnostic result.

Queue a task, on a specified task source, to convert the realm-agnostic result back into observable effects on the observable world of JavaScript objects on the event loop.

The following is an algorithm that "encrypts" a passed-in list of scalar value strings input, after parsing them as URLs:

Let urls be an empty list.

For each string of input:

Let parsed be the result of parsing string relative to the current settings object.

If parsed is failure, return a promise rejected with a "SyntaxError" DOMException.

Let serialized be the result of applying the URL serializer to parsed.

Append serialized to urls.

Let realm be the current Realm Record.

Let p be a new promise.

Run the following steps in parallel:

Let encryptedURLs be an empty list.

For each url of urls:

Wait 100 milliseconds, so that people think we're doing heavy-duty encryption.

Let encrypted be a new JavaScript string derived from url, whose nth code unit is equal to url's nth code unit plus 13.

Append encrypted to encryptedURLs.

Queue a task, on the networking task source, to perform the following steps:

Let array be the result of converting encryptedURLs to a JavaScript array, in realm.

Resolve p with array.

Return p.

Here are several things to notice about this algorithm:

It does its URL parsing up front, on the event loop, before going to the in parallel steps. This is necessary, since parsing depends on the current settings object, which would no longer be current after going in parallel.

Alternately, it could have saved a reference to the current settings object's API base URL and used it during the in parallel steps; that would have been equivalent. However, we recommend instead doing as much work as possible up front, as this example does. Attempting to save the correct values can be error prone; for example, if we'd saved just the current settings object, instead of its API base URL, there would have been a potential race.

It implicitly passes a list of JavaScript strings from the initial steps to the in parallel steps. This is OK, as both lists and JavaScript strings are realm-agnostic.

It performs "expensive computation" (waiting for 100 milliseconds per input URL) during the in parallel steps, thus not blocking the main event loop.

Promises, as observable JavaScript objects, are never created and manipulated during the in parallel steps. p is created before entering those steps, and then is manipulated during a task that is queued specifically for that purpose.

The creation of a JavaScript array object also happens during the queued task, and is careful to specify which realm it creates the array in since that is no longer obvious from context.

(On these last two points, see also w3ctag/promises-guide#52, heycam/webidl#135, and heycam/webidl#371, where we are still mulling over the subtleties of the above promise-resolution pattern.)

Another thing to note is that, in the event this algorithm was called from a Web IDL-specified operation taking a sequence<USVString>, there was an automatic conversion from realm-specific JavaScript objects provided by the author as input, into the realm-agnostic sequence<USVString> Web IDL type, which we then treat as a list of scalar value strings. So depending on how your specification is structured, there may be other implicit steps happening on the main event loop that play a part in this whole process of getting you ready to go in parallel.

8.1.5 Events
8.1.5.1 Event handlers
Many objects can have event handlers specified. These act as non-capture event listeners for the object on which they are specified. [DOM]

An event handler has a name, which always starts with "on" and is followed by the name of the event for which it is intended.

An event handler has a value, which is either null, or is a callback object, or is an internal raw uncompiled handler. The EventHandler callback function type describes how this is exposed to scripts. Initially, an event handler's value must be set to null.

Event handlers are exposed in one of two ways.

The first way, common to all event handlers, is as an event handler IDL attribute.

The second way is as an event handler content attribute. Event handlers on HTML elements and some of the event handlers on Window objects are exposed in this way.

An event handler IDL attribute is an IDL attribute for a specific event handler. The name of the IDL attribute is the same as the name of the event handler.

Event handler IDL attributes, on setting, must set the corresponding event handler to their new value, and on getting, must return the result of getting the current value of the event handler in question.

If an event handler IDL attribute exposes an event handler of an object that doesn't exist, it must always return null on getting and must do nothing on setting.

This can happen in particular for event handler IDL attribute on body elements that do not have corresponding Window objects.

Certain event handler IDL attributes have additional requirements, in particular the onmessage attribute of MessagePort objects.

An event handler content attribute is a content attribute for a specific event handler. The name of the content attribute is the same as the name of the event handler.

Event handler content attributes, when specified, must contain valid JavaScript code which, when parsed, would match the FunctionBody production after automatic semicolon insertion.

When an event handler content attribute is set, execute the following steps:

If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "script attribute", and the attribute's value, then return. [CSP]

Set the corresponding event handler to an internal raw uncompiled handler consisting of the attribute's new value and the script location where the attribute was set to this value

When an event handler content attribute is removed, the user agent must set the corresponding event handler to null.

When an event handler H of an EventTarget object T is first set to a non-null value, then:

Let callback be the result of creating a Web IDL EventListener instance representing a reference to a function of one argument that executes the steps of the event handler processing algorithm, given H and its argument.

The EventListener's callback context can be arbitrary; it does not impact the steps of the event handler processing algorithm. [DOM]

The callback is emphatically not the event handler itself. Every event handler ends up registering the same callback, the algorithm defined below, which takes care of invoking the right callback, and processing the callback's return value.

Let listener be a new event listener whose type is the event handler event type corresponding to H and callback is callback.

To be clear, an event listener is different from an EventListener.

Add an event listener with T and listener.

This only happens the first time the event handler's value is set. Since listeners are called in the order they were registered, the order of event listeners for a particular event type will always be first the event listeners registered with addEventListener() before the first time the event handler was set to a non-null value, then the callback to which it is currently set, if any, and finally the event listeners registered with addEventListener() after the first time the event handler was set to a non-null value.

This example demonstrates the order in which event listeners are invoked. If the button in this example is clicked by the user, the page will show four alerts, with the text "ONE", "TWO", "THREE", and "FOUR" respectively.

<button id="test">Start Demo</button>
<script>
 var button = document.getElementById('test');
 button.addEventListener('click', function () { alert('ONE') }, false);
 button.setAttribute('onclick', "alert('NOT CALLED')"); // event handler listener is registered here
 button.addEventListener('click', function () { alert('THREE') }, false);
 button.onclick = function () { alert('TWO'); };
 button.addEventListener('click', function () { alert('FOUR') }, false);
</script>
The interfaces implemented by the event object do not influence whether an event handler is triggered or not.

The event handler processing algorithm for an event handler H and an Event object E is as follows:

Let callback be the result of getting the current value of the event handler H.

If callback is null, then return.

Let special error event handling be true if E is an ErrorEvent object, E's type is error, and E's currentTarget implements the WindowOrWorkerGlobalScope mixin. Otherwise, let special error event handling be false.

Process the Event object E as follows:

If special error event handling is true
Invoke callback with five arguments, the first one having the value of E's message attribute, the second having the value of E's filename attribute, the third having the value of E's lineno attribute, the fourth having the value of E's colno attribute, the fifth having the value of E's error attribute, and with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]

Otherwise
Invoke callback with one argument, the value of which is the Event object E, with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]

If an exception gets thrown by the callback, end these steps and allow the exception to propagate. (It will propagate to the DOM event dispatch logic, which will then report the exception.)

Process return value as follows:

If E is a BeforeUnloadEvent object and E's type is beforeunload
In this case, the event handler IDL attribute's type will be OnBeforeUnloadEventHandler, so return value will have been coerced into either null or a DOMString.

If return value is not null, then:

Set E's canceled flag.

If E's returnValue attribute's value is the empty string, then set E's returnValue attribute's value to return value.

If special error event handling is true
If return value is true, then set E's canceled flag.

Otherwise
If return value is false, then set E's canceled flag.

If we've gotten to this "Otherwise" clause because E's type is beforeunload but E is not a BeforeUnloadEvent object, then return value will never be false, since in such cases return value will have been coerced into either null or a DOMString.

The EventHandler callback function type represents a callback used for event handlers. It is represented in Web IDL as follows:

[TreatNonObjectAsNull]
callback EventHandlerNonNull = any (Event event);
typedef EventHandlerNonNull? EventHandler;
In JavaScript, any Function object implements this interface.

For example, the following document fragment:

<body onload="alert(this)" onclick="alert(this)">
...leads to an alert saying "[object Window]" when the document is loaded, and an alert saying "[object HTMLBodyElement]" whenever the user clicks something in the page.

The return value of the function affects whether the event is canceled or not: as described above, if the return value is false, the event is canceled.

There are two exceptions in the platform, for historical reasons:

The onerror handlers on global objects, where returning true cancels the event

The onbeforeunload handler, where returning any non-null and non-undefined value will cancel the event.

For historical reasons, the onerror handler has different arguments:

[TreatNonObjectAsNull]
callback OnErrorEventHandlerNonNull = any ((Event or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long colno, optional any error);
typedef OnErrorEventHandlerNonNull? OnErrorEventHandler;
window.onerror = (message, source, lineno, colno, error) => { … };
Similarly, the onbeforeunload handler has a different return value:

[TreatNonObjectAsNull]
callback OnBeforeUnloadEventHandlerNonNull = DOMString? (Event event);
typedef OnBeforeUnloadEventHandlerNonNull? OnBeforeUnloadEventHandler;
An internal raw uncompiled handler is a tuple with the following information:

An uncompiled script body
A location where the script body originated, in case an error needs to be reported
When the user agent is to get the current value of the event handler H, it must run these steps:

If H's value is an internal raw uncompiled handler, run these substeps:

If H is an element's event handler, then let element be the element, and document be the element's node document.

Otherwise, H is a Window object's event handler: let element be null, and let document be H's associated Document.

If scripting is disabled for document, then return null.

Let body be the uncompiled script body in the internal raw uncompiled handler.

Let location be the location where the script body originated, as given by the internal raw uncompiled handler.

If element is not null and element has a form owner, let form owner be that form owner. Otherwise, let form owner be null.

Let settings object be the relevant settings object of document.

If body is not parsable as FunctionBody or if parsing detects an early error, then follow these substeps:

Set H's value to null.

Report the error for the appropriate script and with the appropriate position (line number and column number) given by location, using settings object's global object. If the error is still not handled after this, then the error may be reported to a developer console.

Return null.

If body begins with a Directive Prologue that contains a Use Strict Directive then let strict be true, otherwise let strict be false.

Push settings object's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.

This is necessary so the subsequent invocation of FunctionCreate takes place in the correct JavaScript Realm.

Let function be the result of calling FunctionCreate, with arguments:

kind
Normal
ParameterList
If H is an onerror event handler of a Window object
Let the function have five arguments, named event, source, lineno, colno, and error.
Otherwise
Let the function have a single argument called event.
Body
The result of parsing body above.
Scope
If H is an element's event handler, then let Scope be NewObjectEnvironment(document, the global environment).

Otherwise, H is a Window object's event handler: let Scope be the global environment.

If form owner is not null, let Scope be NewObjectEnvironment(form owner, Scope).

If element is not null, let Scope be NewObjectEnvironment(element, Scope).

Strict
The value of strict.
Remove settings object's realm execution context from the JavaScript execution context stack.

Set H's value to the result of creating a Web IDL callback function whose object reference is function and whose callback context is settings object.

Return H's value.

8.1.5.2 Event handlers on elements, Document objects, and Window objects
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document and Window objects, as event handler IDL attributes:

Event handler	Event handler event type
onabort	abort
onauxclick	auxclick
oncancel	cancel
oncanplay	canplay
oncanplaythrough	canplaythrough
onchange	change
onclick	click
onclose	close
oncontextmenu	contextmenu
oncuechange	cuechange
ondblclick	dblclick
ondrag	drag
ondragend	dragend
ondragenter	dragenter
ondragexit	dragexit
ondragleave	dragleave
ondragover	dragover
ondragstart	dragstart
ondrop	drop
ondurationchange	durationchange
onemptied	emptied
onended	ended
oninput	input
oninvalid	invalid
onkeydown	keydown
onkeypress	keypress
onkeyup	keyup
onloadeddata	loadeddata
onloadedmetadata	loadedmetadata
onloadend	loadend
onloadstart	loadstart
onmousedown	mousedown
onmouseenter	mouseenter
onmouseleave	mouseleave
onmousemove	mousemove
onmouseout	mouseout
onmouseover	mouseover
onmouseup	mouseup
onwheel	wheel
onpause	pause
onplay	play
onplaying	playing
onprogress	progress
onratechange	ratechange
onreset	reset
onsecuritypolicyviolation	securitypolicyviolation
onseeked	seeked
onseeking	seeking
onselect	select
onstalled	stalled
onsubmit	submit
onsuspend	suspend
ontimeupdate	timeupdate
ontoggle	toggle
onvolumechange	volumechange
onwaiting	waiting
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements other than body and frameset elements, as both event handler content attributes and event handler IDL attributes; that must be supported by all Document objects, as event handler IDL attributes; and that must be supported by all Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's associated Document:

Event handler	Event handler event type
onblur	blur
onerror	error
onfocus	focus
onload	load
onresize	resize
onscroll	scroll
The following are the event handlers (and their corresponding event handler event types) that must be supported by Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's associated Document:

Event handler	Event handler event type
onafterprint	afterprint
onbeforeprint	beforeprint
onbeforeunload	beforeunload
onhashchange	hashchange
onlanguagechange	languagechange
onmessage	message
onmessageerror	messageerror
onoffline	offline
ononline	online
onpagehide	pagehide
onpageshow	pageshow
onpopstate	popstate
onrejectionhandled	rejectionhandled
onstorage	storage
onunhandledrejection	unhandledrejection
onunload	unload
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document objects, as event handler IDL attributes:

Event handler	Event handler event type
oncut	cut
oncopy	copy
onpaste	paste
The following are the event handlers (and their corresponding event handler event types) that must be supported on Document objects as event handler IDL attributes:

Event handler	Event handler event type
onreadystatechange	readystatechange
8.1.5.2.1 IDL definitions
interface mixin GlobalEventHandlers {
  attribute EventHandler onabort;
  attribute EventHandler onauxclick;
  attribute EventHandler onblur;
  attribute EventHandler oncancel;
  attribute EventHandler oncanplay;
  attribute EventHandler oncanplaythrough;
  attribute EventHandler onchange;
  attribute EventHandler onclick;
  attribute EventHandler onclose;
  attribute EventHandler oncontextmenu;
  attribute EventHandler oncuechange;
  attribute EventHandler ondblclick;
  attribute EventHandler ondrag;
  attribute EventHandler ondragend;
  attribute EventHandler ondragenter;
  attribute EventHandler ondragexit;
  attribute EventHandler ondragleave;
  attribute EventHandler ondragover;
  attribute EventHandler ondragstart;
  attribute EventHandler ondrop;
  attribute EventHandler ondurationchange;
  attribute EventHandler onemptied;
  attribute EventHandler onended;
  attribute OnErrorEventHandler onerror;
  attribute EventHandler onfocus;
  attribute EventHandler oninput;
  attribute EventHandler oninvalid;
  attribute EventHandler onkeydown;
  attribute EventHandler onkeypress;
  attribute EventHandler onkeyup;
  attribute EventHandler onload;
  attribute EventHandler onloadeddata;
  attribute EventHandler onloadedmetadata;
  attribute EventHandler onloadend;
  attribute EventHandler onloadstart;
  attribute EventHandler onmousedown;
  [LenientThis] attribute EventHandler onmouseenter;
  [LenientThis] attribute EventHandler onmouseleave;
  attribute EventHandler onmousemove;
  attribute EventHandler onmouseout;
  attribute EventHandler onmouseover;
  attribute EventHandler onmouseup;
  attribute EventHandler onwheel;
  attribute EventHandler onpause;
  attribute EventHandler onplay;
  attribute EventHandler onplaying;
  attribute EventHandler onprogress;
  attribute EventHandler onratechange;
  attribute EventHandler onreset;
  attribute EventHandler onresize;
  attribute EventHandler onscroll;
  attribute EventHandler onsecuritypolicyviolation;
  attribute EventHandler onseeked;
  attribute EventHandler onseeking;
  attribute EventHandler onselect;
  attribute EventHandler onstalled;
  attribute EventHandler onsubmit;
  attribute EventHandler onsuspend;
  attribute EventHandler ontimeupdate;
  attribute EventHandler ontoggle;
  attribute EventHandler onvolumechange;
  attribute EventHandler onwaiting;
};

interface mixin WindowEventHandlers {
  attribute EventHandler onafterprint;
  attribute EventHandler onbeforeprint;
  attribute OnBeforeUnloadEventHandler onbeforeunload;
  attribute EventHandler onhashchange;
  attribute EventHandler onlanguagechange;
  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
  attribute EventHandler onoffline;
  attribute EventHandler ononline;
  attribute EventHandler onpagehide;
  attribute EventHandler onpageshow;
  attribute EventHandler onpopstate;
  attribute EventHandler onrejectionhandled;
  attribute EventHandler onstorage;
  attribute EventHandler onunhandledrejection;
  attribute EventHandler onunload;
};

interface mixin DocumentAndElementEventHandlers {
  attribute EventHandler oncopy;
  attribute EventHandler oncut;
  attribute EventHandler onpaste;
};
8.1.5.3 Event firing
Certain operations and methods are defined as firing events on elements. For example, the click() method on the HTMLElement interface is defined as firing a click event on the element. [UIEVENTS]

Firing a synthetic mouse event named e at target, with an optional not trusted flag, means running these steps:

Let event be the result of creating an event using MouseEvent.

Initialize event's type attribute to e.

Initialize event's bubbles and cancelable attributes to true.

Set event's composed flag.

If the not trusted flag is set, initialize event's isTrusted attribute to false.

Initialize event's ctrlKey, shiftKey, altKey, and metaKey attributes according to the current state of the key input device, if any (false for any keys that are not available).

Initialize event's view attribute to target's node document's Window object, if any, and null otherwise.

event's getModifierState() method is to return values appropriately describing the current state of the key input device.

Return the result of dispatching event at target.

Firing a click event at target means firing a synthetic mouse event named click at target.

8.2 The WindowOrWorkerGlobalScope mixin
The WindowOrWorkerGlobalScope mixin is for use of APIs that are to be exposed on Window and WorkerGlobalScope objects.

Other standards are encouraged to further extend it using partial interface WindowOrWorkerGlobalScope { … }; along with an appropriate reference.

typedef (DOMString or Function) TimerHandler;

interface mixin WindowOrWorkerGlobalScope {
  [Replaceable] readonly attribute USVString origin;

  // base64 utility methods
  DOMString btoa(DOMString data);
  ByteString atob(DOMString data);

  // timers
  long setTimeout(TimerHandler handler, optional long timeout = 0, any... arguments);
  void clearTimeout(optional long handle = 0);
  long setInterval(TimerHandler handler, optional long timeout = 0, any... arguments);
  void clearInterval(optional long handle = 0);

  // ImageBitmap
  Promise<ImageBitmap> createImageBitmap(ImageBitmapSource image, optional ImageBitmapOptions options);
  Promise<ImageBitmap> createImageBitmap(ImageBitmapSource image, long sx, long sy, long sw, long sh, optional ImageBitmapOptions options);
};
Window includes WindowOrWorkerGlobalScope;
WorkerGlobalScope includes WindowOrWorkerGlobalScope;
origin = self . origin
Returns the global object's origin, serialized as string.

Developers are strongly encouraged to use self.origin over location.origin. The former returns the origin of the environment, the latter of the URL of the environment. Imagine the following script executing in a document on https://stargate.example/:

var frame = document.createElement("iframe")
frame.onload = function() {
  var frameWin = frame.contentWindow
  console.log(frameWin.location.origin) // "null"
  console.log(frameWin.origin) // "https://stargate.example"
}
document.body.appendChild(frame)
self.origin is a more reliable security indicator.

The origin attribute's getter must return this object's relevant settings object's origin, serialized.

8.3 Base64 utility methods

Support: atob-btoa
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	10+
Opera Mini	all+
Safari	3.1+
Edge	12+
Android Browser	2.1+
Opera	10.6+

Source: caniuse.com

The atob() and btoa() methods allow developers to transform content to and from the base64 encoding.

In these APIs, for mnemonic purposes, the "b" can be considered to stand for "binary", and the "a" for "ASCII". In practice, though, for primarily historical reasons, both the input and output of these functions are Unicode strings.

result = self . btoa( data )
Takes the input data, in the form of a Unicode string containing only characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, and converts it to its base64 representation, which it returns.

Throws an "InvalidCharacterError" DOMException exception if the input string contains any out-of-range characters.

result = self . atob( data )
Takes the input data, in the form of a Unicode string containing base64-encoded binary data, decodes it, and returns a string consisting of characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, corresponding to that binary data.

Throws an "InvalidCharacterError" DOMException if the input string is not valid base64 data.

The btoa(data) method must throw an "InvalidCharacterError" DOMException if data contains any character whose code point is greater than U+00FF. Otherwise, the user agent must convert data to a byte sequence whose nth byte is the eight-bit representation of the nth code point of data, and then must apply forgiving-base64 encode to that byte sequence and return the result.

The atob(data) method, when invoked, must run the following steps:

Let decodedData be the result of running forgiving-base64 decode on data.

If decodedData is failure, then throw an "InvalidCharacterError" DOMException.

Return decodedData.

8.4 Dynamic markup insertion
APIs for dynamically inserting markup into the document interact with the parser, and thus their behavior varies depending on whether they are used with HTML documents (and the HTML parser) or XML documents (and the XML parser).

Document objects have a throw-on-dynamic-markup-insertion counter, which is used in conjunction with the create an element for the token algorithm to prevent custom element constructors from being able to use document.open(), document.close(), and document.write() when they are invoked by the parser. Initially, the counter must be set to zero.

8.4.1 Opening the input stream
The open() method comes in several variants with different numbers of arguments.

document = document . open( [ type [, replace ] ] )
Causes the Document to be replaced in-place, as if it was a new Document object, but reusing the previous object, which is then returned.

The resulting Document has an HTML parser associated with it, which can be given data to parse using document.write(). (The type argument is ignored.)

If the replace argument is present and has the value "replace", the existing entries in the session history for the Document object are removed.

The method has no effect if the Document is still being parsed.

Throws an "InvalidStateError" DOMException if the Document is an XML document.

Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.

window = document . open( url, name, features )
Works like the window.open() method.

Document objects have an ignore-opens-during-unload counter, which is used to prevent scripts from invoking the document.open() method (directly or indirectly) while the document is being unloaded. Initially, the counter must be set to zero.

The document open steps, given a document and replaceInput, are as follows:

If document is an XML document, then throw an "InvalidStateError" DOMException exception.

If document's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError" DOMException.

If document is not an active document, then return document.

If document's origin is not same origin to the origin of the responsible document specified by the entry settings object, then throw a "SecurityError" DOMException.

If document has an active parser whose script nesting level is greater than 0, then return document.

This basically causes document.open() to be ignored when it's called in an inline script found during parsing, while still letting it have an effect when called from a non-parser task such as a timer callback or event handler.

Similarly, if document's ignore-opens-during-unload counter is greater than 0, then return document.

This basically causes document.open() to be ignored when it's called from a beforeunload, pagehide, or unload event handler while the Document is being unloaded.

Let replace be false.

If replaceInput is an ASCII case-insensitive match for "replace", then set replace to true.

Otherwise, if document's browsing context's session history contains only one Document object, and that was the about:blank Document created when document's browsing context was created, and that Document object has never had the unload a document algorithm invoked on it (e.g., by a previous call to document.open()), then set replace to true.

Set document's salvageable state to false.

Prompt to unload document. If the user refused to allow the document to be unloaded, then return document.

Unload document, with the recycle parameter set to true.

Abort document.

Unregister all event listeners registered on document and its descendants.

Remove any tasks associated with document in any task source.

Remove all child nodes of document, without firing any mutation events.

Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:

For the global object, create a new Window object window.

For the global this value, use document's browsing context's associated WindowProxy.

This is not universally implemented and can perhaps be removed; see issue #1698.

Let realm execution context be the running JavaScript execution context.

This is the JavaScript execution context created in the previous step.

Set up a window environment settings object with realm execution context.

Set the active document of document's browsing context to document with window.

Replace document's singleton objects with new instances of those objects, created in window's Realm. (This includes in particular the History, ApplicationCache, and Navigator, objects, the various BarProp objects, the two Storage objects, the various HTMLCollection objects, and objects defined by other specifications, like Selection. It also includes all the Web IDL prototypes in the JavaScript binding, including document's prototype.)

Change document's character encoding to UTF-8.

If document is ready for post-load tasks, then set document's reload override flag and set document's reload override buffer to the empty string.

Set document's salvageable state back to true.

Change document's URL to the URL of the responsible document specified by the entry settings object.

If document's iframe load in progress flag is set, then set document's mute iframe load flag.

Create a new HTML parser and associate it with document. This is a script-created parser (meaning that it can be closed by the document.open() and document.close() methods, and that the tokenizer will wait for an explicit call to document.close() before emitting an end-of-file token). The encoding confidence is irrelevant.

Set the current document readiness of document to "loading".

Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.

Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.

This doesn't necessarily have to affect the user agent's user interface.

Remove any earlier entries whose Document object is document.

If replace is false, then add a new entry, just before the last entry, and associate with the new entry the text that was parsed by the previous parser associated with document, as well as the state of document at the start of these steps. This allows the user to step backwards in the session history to see the page before it was blown away by the document.open() call. This new entry does not have a Document object, so a new one will be created if the session history is traversed to that entry.

Set document's fired unload flag to false. (It could have been set to true during the unload step above.)

Finally, set the insertion point to point at just before the end of the input stream (which at this point will be empty).

Return document.

When invoked with two arguments or fewer, the document.open(type, replace) method must return the result of running the document open steps with this Document object and replace.

The type argument is ignored. Also, the document.open() method does not affect whether a Document is ready for post-load tasks or completely loaded.

When invoked with three arguments, the open(url, name, features) method must run these steps:

If this Document object is not an active document, then throw an "InvalidStateError" DOMException exception.

Return the result of running the window open steps with url, name, and features.

8.4.2 Closing the input stream
document . close()
Closes the input stream that was opened by the document.open() method.

Throws an "InvalidStateError" DOMException if the Document is an XML document.

Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.

The close() method must run the following steps:

If the Document object is an XML document, then throw an "InvalidStateError" DOMException.

If the Document object's throw-on-dynamic-markup-insertion counter is greater than zero, then throw an "InvalidStateError" DOMException.

If there is no script-created parser associated with the document, then return.

Insert an explicit "EOF" character at the end of the parser's input stream.

If there is a pending parsing-blocking script, then return.

Run the tokenizer, processing resulting tokens as they are emitted, and stopping when the tokenizer reaches the explicit "EOF" character or spins the event loop.

8.4.3 document.write()
document . write(text...)
In general, adds the given string(s) to the Document's input stream.

This method has very idiosyncratic behavior. In some cases, this method can affect the state of the HTML parser while the parser is running, resulting in a DOM that does not correspond to the source of the document (e.g. if the string written is the string "<plaintext>" or "<!--"). In other cases, the call can clear the current page first, as if document.open() had been called. In yet more cases, the method is simply ignored, or throws an exception. Users agents are explicitly allowed to avoid executing script elements inserted via this method. And to make matters even worse, the exact behavior of this method can in some cases be dependent on network latency, which can lead to failures that are very hard to debug. For all these reasons, use of this method is strongly discouraged.

Throws an "InvalidStateError" DOMException when invoked on XML documents.

Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.

Document objects have an ignore-destructive-writes counter, which is used in conjunction with the processing of script elements to prevent external scripts from being able to use document.write() to blow away the document by implicitly calling document.open(). Initially, the counter must be set to zero.

The document write steps, given a Document object document and a string input, are as follows:

If document is an XML document, then throw an "InvalidStateError" DOMException.

If document's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError" DOMException.

If document is not an active document, then return.

If the insertion point is undefined, then:

If document's ignore-opens-during-unload counter is greater than 0 or document's ignore-destructive-writes counter is greater than 0, then return.

Run the document open steps with document and the empty string. If the user refused to allow the document to be unloaded, then return. Otherwise, the insertion point will point at just before the end of the (empty) input stream.

Insert input into the input stream just before the insertion point.

If document's reload override flag is set, then append input to document's reload override buffer.

If there is no pending parsing-blocking script, have the HTML parser process input, one code point at a time, processing resulting tokens as they are emitted, and stopping when the tokenizer reaches the insertion point or when the processing of the tokenizer is aborted by the tree construction stage (this can happen if a script end tag token is emitted by the tokenizer).

If the document.write() method was called from script executing inline (i.e. executing because the parser parsed a set of script tags), then this is a reentrant invocation of the parser. If the parser pause flag is set, the tokenizer will abort immediately and no HTML will be parsed, per the tokenizer's parser pause flag check.

The document.write(...) method, when invoked, must run the document write steps with this Document object and a string that is the concatanation of all arguments passed.

8.4.4 document.writeln()
document . writeln(text...)
Adds the given string(s) to the Document's input stream, followed by a newline character. If necessary, calls the open() method implicitly first.

Throws an "InvalidStateError" DOMException when invoked on XML documents.

Throws an "InvalidStateError" DOMException if the parser is currently executing a custom element constructor.

The document.writeln(...) method, when invoked, must run the document write steps with this Document object and a string that is the concatanation of all arguments passed and U+000A LINE FEED.

8.5 Timers
The setTimeout() and setInterval() methods allow authors to schedule timer-based callbacks.

handle = self . setTimeout( handler [, timeout [, arguments... ] ] )
Schedules a timeout to run handler after timeout milliseconds. Any arguments are passed straight through to the handler.

handle = self . setTimeout( code [, timeout ] )
Schedules a timeout to compile and run code after timeout milliseconds.

self . clearTimeout( handle )
Cancels the timeout set with setTimeout() or setInterval() identified by handle.

handle = self . setInterval( handler [, timeout [, arguments... ] ] )
Schedules a timeout to run handler every timeout milliseconds. Any arguments are passed straight through to the handler.

handle = self . setInterval( code [, timeout ] )
Schedules a timeout to compile and run code every timeout milliseconds.

self . clearInterval( handle )
Cancels the timeout set with setInterval() or setTimeout() identified by handle.

Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.

This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, other tasks, etc, are to be expected.

Objects that implement the WindowOrWorkerGlobalScope mixin have a list of active timers. Each entry in this lists is identified by a number, which must be unique within the list for the lifetime of the object that implements the WindowOrWorkerGlobalScope mixin.

The setTimeout() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to false.

The setInterval() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to true.

The clearTimeout() and clearInterval() methods must clear the entry identified as handle from the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, if any, where handle is the argument passed to the method. (If handle does not identify an entry in the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, the method does nothing.)

Because clearTimeout() and clearInterval() clear entries from the same list, either method can be used to clear timers created by setTimeout() or setInterval().

The timer initialization steps, which are invoked with some method arguments, a method context, a repeat flag which can be true or false, and optionally (and only if the repeat flag is true) a previous handle, are as follows:

Let method context proxy be method context if that is a WorkerGlobalScope object, or else the WindowProxy that corresponds to method context.

If previous handle was provided, let handle be previous handle; otherwise, let handle be a user-agent-defined integer that is greater than zero that will identify the timeout to be set by this call in the list of active timers.

If previous handle was not provided, add an entry to the list of active timers for handle.

Let callerRealm be the current Realm Record, and calleeRealm be method context's JavaScript realm.

Let initiating script be the active script.

Assert: initiating script is not null, since this algorithm is always called from some script.

Let task be a task that runs the following substeps:

If the entry for handle in the list of active timers has been cleared, then abort these steps.

Run the appropriate set of steps from the following list:

If the first method argument is a Function
Invoke the Function. Use the third and subsequent method arguments (if any) as the arguments for invoking the Function. Use method context proxy as the callback this value.

Otherwise
Perform HostEnsureCanCompileStrings(callerRealm, calleeRealm). If this throws an exception, catch it, report the exception, and abort these steps.

Let script source be the first method argument.

Let settings object be method context's environment settings object.

Let base URL be initiating script's base URL.

Let fetch options be a script fetch options whose cryptographic nonce is initiating script's fetch options's cryptographic nonce, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is initiating script's fetch options's credentials mode, and referrer policy is initiating script's fetch options's referrer policy.

The effect of these options ensures that the string compilation done by setTimeout() and setInterval() behaves equivalently to that done by eval(). That is, module script fetches via import() will behave the same in both contexts.

Let script be the result of creating a classic script given script source, settings object, base URL, and fetch options.

Run the classic script script.

If the repeat flag is true, then call timer initialization steps again, passing them the same method arguments, the same method context, with the repeat flag still set to true, and with the previous handle set to handler.

Let timeout be the second method argument.

If the currently running task is a task that was created by this algorithm, then let nesting level be the task's timer nesting level. Otherwise, let nesting level be zero.

The task's timer nesting level is used both for nested calls to setTimeout(), and for the repeating timers created by setInterval(). (Or, indeed, for any combination of the two.) In other words, it represents nested invocations of this algorithm, not of a particular method.

If timeout is less than 0, then set timeout to 0.

If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.

Increment nesting level by one.

Let task's timer nesting level be nesting level.

Return handle, and then continue running this algorithm in parallel.

If method context is a Window object, wait until the Document associated with method context has been fully active for a further timeout milliseconds (not necessarily consecutively).

Otherwise, method context is a WorkerGlobalScope object; wait until timeout milliseconds have passed with the worker not suspended (not necessarily consecutively).

Wait until any invocations of this algorithm that had the same method context, that started before this one, and whose timeout is equal to or less than this one's, have completed.

Argument conversion as defined by Web IDL (for example, invoking toString() methods on objects passed as the first argument) happens in the algorithms defined in Web IDL, before this algorithm is invoked.

So for example, the following rather silly code will result in the log containing "ONE TWO ":

var log = '';
function logger(s) { log += s + ' '; }

setTimeout({ toString: function () {
  setTimeout("logger('ONE')", 100);
  return "logger('TWO')";
} }, 100);
Optionally, wait a further user-agent defined length of time.

This is intended to allow user agents to pad timeouts as needed to optimize the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.

Queue the task task.

Once the task has been processed, if the repeat flag is false, it is safe to remove the entry for handle from the list of active timers (there is no way for the entry's existence to be detected past this point, so it does not technically matter one way or the other).

The task source for these tasks is the timer task source.

To run tasks of several milliseconds back to back without any delay, while still yielding back to the browser to avoid starving the user interface (and to avoid the browser killing the script for hogging the CPU), simply queue the next timer before performing work:

function doExpensiveWork() {
  var done = false;
  // ...
  // this part of the function takes up to five milliseconds
  // set done to true if we're done
  // ...
  return done;
}

function rescheduleWork() {
  var handle = setTimeout(rescheduleWork, 0); // preschedule next iteration
  if (doExpensiveWork())
    clearTimeout(handle); // clear the timeout if we don't need it
}

function scheduleWork() {
  setTimeout(rescheduleWork, 0);
}

scheduleWork(); // queues a task to do lots of work
8.6 User prompts
8.6.1 Simple dialogs
window . alert(message)
Displays a modal alert with the given message, and waits for the user to dismiss it.

result = window . confirm(message)
Displays a modal OK/Cancel prompt with the given message, waits for the user to dismiss it, and returns true if the user clicks OK and false if the user clicks Cancel.

result = window . prompt(message [, default] )
Displays a modal text control prompt with the given message, waits for the user to dismiss it, and returns the value that the user entered. If the user cancels the prompt, then returns null instead. If the second argument is present, then the given value is used as a default.

Logic that depends on tasks or microtasks, such as media elements loading their media data, are stalled when these methods are invoked.

To optionally truncate a simple dialog string s, return either s itself or some string derived from s that is shorter. User agents should not provide UI for displaying the elided portion of s, as this makes it too easy for abusers to create dialogs of the form "Important security alert! Click 'Show More' for full details!".

For example, a user agent might want to only display the first 100 characters of a message. Or, a user agent might replace the middle of the string with "…". These types of modifications can be useful in limiting the abuse potential of unnaturally large, trustworthy-looking system dialogs.

The alert(message) method, when invoked, must run the following steps:

If the event loop's termination nesting level is nonzero, optionally return.

If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.

Optionally, return. (For example, the user agent might give the user the option to ignore all alerts, and would thus abort at this step whenever the method was invoked.)

If the method was invoked with no arguments, then let message be the empty string; otherwise, let message be the method's first argument.

Set message to the result of optionally truncating message.

Show message to the user.

Optionally, pause while waiting for the user to acknowledge the message.

The confirm(message) method, when invoked, must run the following steps:

If the event loop's termination nesting level is nonzero, optionally return false.

If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.

Optionally, return false. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)

Set message to the result of optionally truncating message.

Show message to the user, and ask the user to respond with a positive or negative response.

Pause until the user responds either positively or negatively.

If the user responded positively, return true; otherwise, the user responded negatively: return false.

The prompt(message, default) method, when invoked, must run the following steps:

If the event loop's termination nesting level is nonzero, optionally return null.

If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.

Optionally, return null. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)

Set message to the result of optionally truncating message.

Set default to the result of optionally truncating default.

Show message to the user, and ask the user to either respond with a string value or abort. The response must be defaulted to the value given by default.

Pause while waiting for the user's response.

If the user aborts, then return null; otherwise, return the string that the user responded with.

8.6.2 Printing
window . print()
Prompts the user to print the page.

When the print() method is invoked, if the Document is ready for post-load tasks, then the user agent must run the printing steps in parallel. Otherwise, the user agent must only set the print when loaded flag on the Document.

User agents should also run the printing steps whenever the user asks for the opportunity to obtain a physical form (e.g. printed copy), or the representation of a physical form (e.g. PDF copy), of a document.

The printing steps are as follows:


Spec bugs: 27864

The user agent may display a message to the user or return (or both).

For instance, a kiosk browser could silently ignore any invocations of the print() method.

For instance, a browser on a mobile device could detect that there are no printers in the vicinity and display a message saying so before continuing to offer a "save to PDF" option.

If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then return.

If the printing dialog is blocked by a Document's sandbox, then neither the beforeprint nor afterprint events will be fired.

The user agent must fire an event named beforeprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.

The beforeprint event can be used to annotate the printed copy, for instance adding the time at which the document was printed.

The user agent should offer the user the opportunity to obtain a physical form (or the representation of a physical form) of the document. The user agent may wait for the user to either accept or decline before returning; if so, the user agent must pause while the method is waiting. Even if the user agent doesn't wait at this point, the user agent must use the state of the relevant documents as they are at this point in the algorithm if and when it eventually creates the alternate form.

The user agent must fire an event named afterprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.

The afterprint event can be used to revert annotations added in the earlier event, as well as showing post-printing UI. For instance, if a page is walking the user through the steps of applying for a home loan, the script could automatically advance to the next step after having printed a form or other.

8.7 System state and capabilities
8.7.1 The Navigator object
The navigator attribute of the Window interface must return an instance of the Navigator interface, which represents the identity and state of the user agent (the client), and allows Web pages to register themselves as potential protocol handlers:

[Exposed=Window]
interface Navigator {
  // objects implementing this interface also implement the interfaces given below
};
Navigator includes NavigatorID;
Navigator includes NavigatorLanguage;
Navigator includes NavigatorOnLine;
Navigator includes NavigatorContentUtils;
Navigator includes NavigatorCookies;
Navigator includes NavigatorPlugins;
Navigator includes NavigatorConcurrentHardware;
These interface mixins are defined separately so that WorkerNavigator can re-use parts of the Navigator interface.

8.7.1.1 Client identification
interface mixin NavigatorID {
  readonly attribute DOMString appCodeName; // constant "Mozilla"
  readonly attribute DOMString appName; // constant "Netscape"
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString product; // constant "Gecko"
  [Exposed=Window] readonly attribute DOMString productSub;
  readonly attribute DOMString userAgent;
  [Exposed=Window] readonly attribute DOMString vendor;
  [Exposed=Window] readonly attribute DOMString vendorSub; // constant ""
};
In certain cases, despite the best efforts of the entire industry, Web browsers have bugs and limitations that Web authors are forced to work around.

This section defines a collection of attributes that can be used to determine, from script, the kind of user agent in use, in order to work around these issues.

The user agent has a navigator compatibility mode, which is either Chrome, Gecko, or WebKit.

The navigator compatibility mode constrains the NavigatorID interface to the combinations of attribute values and presence of taintEnabled() and oscpu that are known to be compatible with existing Web content.

Client detection should always be limited to detecting known current versions; future versions and unknown versions should always be assumed to be fully compliant.

self . navigator . appCodeName
Returns the string "Mozilla".

self . navigator . appName
Returns the string "Netscape".

self . navigator . appVersion
Returns the version of the browser.

self . navigator . platform
Returns the name of the platform.

self . navigator . product
Returns the string "Gecko".

window . navigator . productSub
Returns either the string "20030107", or the string "20100101".

self . navigator . userAgent
Returns the complete `User-Agent` header.

window . navigator . vendor
Returns either the empty string, the string "Apple Computer, Inc.", or the string "Google Inc.".

window . navigator . vendorSub
Returns the empty string.

appCodeName
Must return the string "Mozilla".

appName
Must return the string "Netscape".

appVersion
Must return either the string "4.0" or a string representing the version of the browser in detail, e.g. "1.0 (VMS; en-US) Mellblomenator/9000".

platform
Must return either the empty string or a string representing the platform on which the browser is executing, e.g. "MacIntel", "Win32", "FreeBSD i386", "WebTV OS".

product
Must return the string "Gecko".

productSub
Must return the appropriate string from the following list:

If the navigator compatibility mode is Chrome or WebKit
The string "20030107".

If the navigator compatibility mode is Gecko
The string "20100101".

userAgent
Must return the default `User-Agent` value.

vendor
Must return the appropriate string from the following list:

If the navigator compatibility mode is Chrome
The string "Google Inc.".

If the navigator compatibility mode is Gecko
The empty string.

If the navigator compatibility mode is WebKit
The string "Apple Computer, Inc.".

vendorSub
Must return the empty string.

If the navigator compatibility mode is Gecko, then the user agent must also support the following partial interface:

partial interface NavigatorID {
  [Exposed=Window] boolean taintEnabled(); // constant false
  [Exposed=Window] readonly attribute DOMString oscpu;
};
The taintEnabled() method must return false.

The oscpu attribute's getter must return either the empty string or a string representing the platform on which the browser is executing, e.g. "Windows NT 10.0; Win64; x64", "Linux x86_64".

Any information in this API that varies from user to user can be used to profile the user. In fact, if enough such information is available, a user can actually be uniquely identified. For this reason, user agent implementers are strongly urged to include as little information in this API as possible.
8.7.1.2 Language preferences
interface mixin NavigatorLanguage {
  readonly attribute DOMString language;
  readonly attribute FrozenArray<DOMString> languages;
};
self . navigator . language
Returns a language tag representing the user's preferred language.

self . navigator . languages
Returns an array of language tags representing the user's preferred languages, with the most preferred language first.

The most preferred language is the one returned by navigator.language.

A languagechange event is fired at the Window or WorkerGlobalScope object when the user agent's understanding of what the user's preferred languages are changes.

language
Must return a valid BCP 47 language tag representing either a plausible language or the user's most preferred language. [BCP47]

languages
Must return a frozen array of valid BCP 47 language tags representing either one or more plausible languages, or the user's preferred languages, ordered by preference with the most preferred language first. The same object must be returned until the user agent needs to return different values, or values in a different order. [BCP47]

Whenever the user agent needs to make the navigator.languages attribute of a Window or WorkerGlobalScope object return a new set of language tags, the user agent must queue a task to fire an event named languagechange at the Window or WorkerGlobalScope object and wait until that task begins to be executed before actually returning a new value.

The task source for this task is the DOM manipulation task source.

To determine a plausible language, the user agent should bear in mind the following:

Any information in this API that varies from user to user can be used to profile or identify the user.
If the user is not using a service that obfuscates the user's point of origin (e.g. the Tor anonymity network), then the value that is least likely to distinguish the user from other users with similar origins (e.g. from the same IP address block) is the language used by the majority of such users. [TOR]
If the user is using an anonymizing service, then the value "en-US" is suggested; if all users of the service use that same value, that reduces the possibility of distinguishing the users from each other.
To avoid introducing any more fingerprinting vectors, user agents should use the same list for the APIs defined in this function as for the HTTP `Accept-Language` header.
8.7.1.3 Custom scheme handlers: the registerProtocolHandler() method

Support: registerprotocolhandler
Chrome for Android	None
Chrome	13+
iOS Safari	None
UC Browser for Android	None
Firefox	3+
Samsung Internet	None
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	None
Opera	11.6+

Source: caniuse.com

interface mixin NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, USVString url, DOMString title);
  void unregisterProtocolHandler(DOMString scheme, USVString url);
};
The registerProtocolHandler() method allows Web sites to register themselves as possible handlers for particular schemes. For example, an online telephone messaging service could register itself as a handler of the sms: scheme, so that if the user clicks on such a link, they are given the opportunity to use that web site. [SMS]

window . navigator . registerProtocolHandler(scheme, url, title)
Registers a handler for the given scheme, at the given URL, with the given title.

The string "%s" in the URL is used as a placeholder for where to put the URL of the content to be handled.

Throws a "SecurityError" DOMException if the user agent blocks the registration (this might happen if trying to register as a handler for "http", for instance).

Throws a "SyntaxError" DOMException if the "%s" string is missing in the URL.

User agents may, within the constraints described in this section, do whatever they like when the method is called. A UA could, for instance, prompt the user and offer the user the opportunity to add the site to a shortlist of handlers, or make the handlers their default, or cancel the request. UAs could provide such a UI through modal UI or through a non-modal transient notification interface. UAs could also simply silently collect the information, providing it only when relevant to the user.

User agents should keep track of which sites have registered handlers (even if the user has declined such registrations) so that the user is not repeatedly prompted with the same request.

The arguments to the method have the following meanings and corresponding implementation requirements. The requirements that involve throwing exceptions must be processed in the order given below, stopping at the first exception thrown. (So the exceptions for the first argument take precedence over the exceptions for the second argument.)

scheme
A scheme, such as "mailto" or "web+auth". The scheme must be compared in an ASCII case-insensitive manner by user agents for the purposes of comparing with the scheme part of URLs that they consider against the list of registered handlers.

The scheme value, if it contains a colon (as in "mailto:"), will never match anything, since schemes don't contain colons.

If the registerProtocolHandler() method is invoked with a scheme that is neither a safelisted scheme nor a scheme whose value starts with the substring "web+" and otherwise contains only ASCII lower alphas, and whose length is at least five characters (including the "web+" prefix), the user agent must throw a "SecurityError" DOMException.

The following schemes are the safelisted schemes:

bitcoin
geo
im
irc
ircs
magnet
mailto
mms
news
nntp
openpgp4fpr
sip
sms
smsto
ssh
tel
urn
webcal
wtai
xmpp
This list can be changed. If there are schemes that ought to be added, please send feedback.

This list excludes any schemes that could reasonably be expected to be supported inline, e.g. in an iframe, such as http or (more theoretically) gopher. If those were supported, they could potentially be used in man-in-the-middle attacks, by replacing pages that have frames with such content with content under the control of the protocol handler. If the user agent has native support for the schemes, this could further be used for cookie-theft attacks.

url
A string used to build the URL of the page that will handle the requests.

User agents must throw a "SyntaxError" DOMException if the url argument passed to one of these methods does not contain the exact literal string "%s".

User agents must throw a "SyntaxError" DOMException if parsing the url argument relative to the relevant settings object of this NavigatorContentUtils object is not successful.

The resulting URL string would by definition not be a valid URL string as it would include the string "%s" which is not a valid component in a URL.

User agents must throw a "SecurityError" DOMException if the resulting URL record has an origin that differs from the origin specified by the relevant settings object of this NavigatorContentUtils object.

This is forcibly the case if the %s placeholder is in the scheme, host, or port parts of the URL.

The resulting URL string is the proto-URL. It identifies the handler for the purposes of the methods described below.

When the user agent uses this handler, it must replace the first occurrence of the exact literal string "%s" in the url argument with an escaped version of the absolute URL of the content in question (as defined below), then parse the resulting URL, relative to the relevant settings object of the NavigatorContentUtils object on which the registerProtocolHandler() method was invoked, and then navigate an appropriate browsing context to the resulting URL.

To get the escaped version of the absolute URL of the content in question, the user agent must replace every character in that absolute URL that is not a character in the URL default encode set with the result of UTF-8 percent encoding that character.

If the user had visited a site at https://example.com/ that made the following call:

navigator.registerProtocolHandler('web+soup', 'soup?url=%s', 'SoupWeb™')
...and then, much later, while visiting https://www.example.net/, clicked on a link such as:

<a href="web+soup:chicken-kïwi">Download our Chicken Kïwi soup!</a>
...then the UA might navigate to the following URL:

https://example.com/soup?url=web+soup:chicken-k%C3%AFwi
This site could then do whatever it is that it does with soup (synthesize it and ship it to the user, or whatever).

title
A descriptive title of the handler, which the UA might use to remind the user what the site in question is.

This section does not define how the pages registered by this method are used, beyond the requirements on how to process the url value (see above). To some extent, the processing model for navigating across documents defines some cases where these methods are relevant, but in general UAs may use this information wherever they would otherwise consider handing content to native plugins or helper applications.

In addition to the registration method, there is also a method for unregistering handlers.

window . navigator . unregisterProtocolHandler(scheme, url)
Unregisters the handler given by the arguments.

The unregisterProtocolHandler() method must unregister the handler described by the two arguments to the method, where the first argument gives the scheme and the second gives the string used to build the URL of the page that will handle the requests.

The first argument must be compared to the schemes for which custom protocol handlers are registered in an ASCII case-insensitive manner to find the relevant handlers.

The second argument must be preprocessed as described below, and if that is successful, must then be matched against the proto-URLs of the relevant handlers to find the described handler.

The second argument must be preprocessed as follows:

If the string does not contain the substring "%s", then return. There's no matching handler.

Parse the string relative to the relevant settings object of this NavigatorContentUtils object. If this fails, then throw a "SyntaxError" DOMException.

If the resulting URL record's origin is not the same origin as the origin of the relevant settings object of this NavigatorContentUtils object, then throw a "SecurityError" DOMException.

Return the resulting URL string as the result of preprocessing the argument.

8.7.1.3.1 Security and privacy
These mechanisms can introduce a number of concerns, in particular privacy concerns.

Hijacking all Web usage. User agents should not allow schemes that are key to its normal operation, such as an HTTP(S) scheme, to be rerouted through third-party sites. This would allow a user's activities to be trivially tracked, and would allow user information, even in secure connections, to be collected.

Hijacking defaults. User agents are strongly urged to not automatically change any defaults, as this could lead the user to send data to remote hosts that the user is not expecting. New handlers registering themselves should never automatically cause those sites to be used.

Registration spamming. User agents should consider the possibility that a site will attempt to register a large number of handlers, possibly from multiple domains (e.g., by redirecting through a series of pages each on a different domain, and each registering a handler for web+spam: — analogous practices abusing other web browser features have been used by pornography Web sites for many years). User agents should gracefully handle such hostile attempts, protecting the user.

Misleading titles. User agents should not rely wholly on the title argument to the methods when presenting the registered handlers to the user, since sites could easily lie. For example, a site hostile.example.net could claim that it was registering the "Cuddly Bear Happy Scheme Handler". User agents should therefore use the handler's origin in any UI along with any title.

Hostile handler metadata. User agents should protect against typical attacks against strings embedded in their interface, for example ensuring that markup or escape characters in such strings are not executed, that null bytes are properly handled, that over-long strings do not cause crashes or buffer overruns, and so forth.

Leaking Intranet URLs. The mechanism described in this section can result in secret Intranet URLs being leaked, in the following manner:

The user registers a third-party scheme handler as the default handler for a scheme.
The user then browses their corporate Intranet site and accesses a URL that uses that scheme.
The user agent contacts the third party and hands the third party the URL to the Intranet content.
No actual confidential file data is leaked in this manner, but the URLs themselves could contain confidential information. For example, the URL could be https://www.corp.example.com/upcoming-aquisitions/the-sample-company.egf, which might tell the third party that Example Corporation is intending to merge with The Sample Company. Implementors might wish to consider allowing administrators to disable this feature for certain subdomains, content types, or schemes.

Leaking credentials. User agents must never send username or password information in the URLs that are escaped and included sent to the handler sites. User agents may even avoid attempting to pass to Web-based handlers the URLs of resources that are known to require authentication to access, as such sites would be unable to access the resources in question without prompting the user for credentials themselves (a practice that would require the user to know whether to trust the third-party handler, a decision many users are unable to make or even understand).

Interface interference. User agents should be prepared to handle intentionally long arguments to the methods. For example, if the user interface exposed consists of an "accept" button and a "deny" button, with the "accept" binding containing the name of the handler, it's important that a long name not cause the "deny" button to be pushed off the screen.

8.7.1.4 Cookies
interface mixin NavigatorCookies {
  readonly attribute boolean cookieEnabled;
};
window . navigator . cookieEnabled
Returns false if setting a cookie will be ignored, and true otherwise.

The cookieEnabled attribute must return true if the user agent attempts to handle cookies according to the cookie specification, and false if it ignores cookie change requests. [COOKIES]

8.7.1.5 Plugins
interface mixin NavigatorPlugins {
  [SameObject] readonly attribute PluginArray plugins;
  [SameObject] readonly attribute MimeTypeArray mimeTypes;
  boolean javaEnabled();
};

[Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface PluginArray {
  void refresh(optional boolean reload = false);
  readonly attribute unsigned long length;
  getter Plugin? item(unsigned long index);
  getter Plugin? namedItem(DOMString name);
};

[Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface MimeTypeArray {
  readonly attribute unsigned long length;
  getter MimeType? item(unsigned long index);
  getter MimeType? namedItem(DOMString name);
};

[Exposed=Window,
 LegacyUnenumerableNamedProperties]
interface Plugin {
  readonly attribute DOMString name;
  readonly attribute DOMString description;
  readonly attribute DOMString filename;
  readonly attribute unsigned long length;
  getter MimeType? item(unsigned long index);
  getter MimeType? namedItem(DOMString name);
};

[Exposed=Window]
interface MimeType {
  readonly attribute DOMString type;
  readonly attribute DOMString description;
  readonly attribute DOMString suffixes; // comma-separated
  readonly attribute Plugin enabledPlugin;
};
window . navigator . plugins . refresh( [ refresh ] )
Updates the lists of supported plugins and MIME types for this page, and reloads the page if the lists have changed.

window . navigator . plugins . length
Returns the number of plugins, represented by Plugin objects, that the user agent reports.

plugin = window . navigator . plugins . item(index)
window . navigator . plugins[index]
Returns the specified Plugin object.

plugin = window . navigator . plugins . item(name)
window . navigator . plugins[name]
Returns the Plugin object for the plugin with the given name.

window . navigator . mimeTypes . length
Returns the number of MIME types, represented by MimeType objects, supported by the plugins that the user agent reports.

mimeType = window . navigator . mimeTypes . item(index)
window . navigator . mimeTypes[index]
Returns the specified MimeType object.

mimeType = window . navigator . mimeTypes . item(name)
window . navigator . mimeTypes[name]
Returns the MimeType object for the given MIME type.

plugin . name
Returns the plugin's name.

plugin . description
Returns the plugin's description.

plugin . filename
Returns the plugin library's filename, if applicable on the current platform.

plugin . length
Returns the number of MIME types, represented by MimeType objects, supported by the plugin.

mimeType = plugin . item(index)
plugin[index]
Returns the specified MimeType object.

mimeType = plugin . item(name)
plugin[name]
Returns the MimeType object for the given MIME type.

mimeType . type
Returns the MIME type.

mimeType . description
Returns the MIME type's description.

mimeType . suffixes
Returns the MIME type's typical file extensions, in a comma-separated list.

mimeType . enabledPlugin
Returns the Plugin object that implements this MIME type.

window . navigator . javaEnabled()
Returns true if there's a plugin that supports the MIME type "application/x-java-vm".

The navigator.plugins attribute must return a PluginArray object.

The navigator.mimeTypes attribute must return a MimeTypeArray object.

A PluginArray object represents none, some, or all of the plugins supported by the user agent, each of which is represented by a Plugin object. Each of these Plugin objects may be hidden plugins. A hidden plugin can't be enumerated, but can still be inspected by using its name.

The fewer plugins are represented by the PluginArray object, and of those, the more that are hidden, the more the user's privacy will be protected. Each exposed plugin increases the number of bits that can be derived for fingerprinting. Hiding a plugin helps, but unless it is an extremely rare plugin, it is likely that a site attempting to derive the list of plugins can still determine whether the plugin is supported or not by probing for it by name (the names of popular plugins are widely known). Therefore not exposing a plugin at all is preferred. Unfortunately, many legacy sites use this feature to determine, for example, which plugin to use to play video. Not exposing any plugins at all might therefore not be entirely plausible.

The PluginArray objects created by a user agent must not be live. The set of plugins represented by the objects must not change once an object is created, except when it is updated by the refresh() method.

Each plugin represented by a PluginArray can support a number of MIME types. For each such plugin, the user agent must pick one or more of these MIME types to be those that are explicitly supported.

The explicitly supported MIME types of a plugin are those that are exposed through the Plugin and MimeTypeArray interfaces. As with plugins themselves, any variation between users regarding what is exposed allows sites to fingerprint users. User agents are therefore encouraged to expose the same MIME types for all users of a plugin, regardless of the actual types supported... at least, within the constraints imposed by compatibility with legacy content.

The supported property indices of a PluginArray object are the numbers from zero to the number of non-hidden plugins represented by the object, if any.
The length attribute must return the number of non-hidden plugins represented by the object.
The item() method of a PluginArray object must return null if the argument is not one of the object's supported property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

Let list be the Plugin objects representing the non-hidden plugins represented by the PluginArray object.

Sort list alphabetically by the name of each Plugin.

Return the indexth entry in list.

It is important for privacy that the order of plugins not leak additional information, e.g. the order in which plugins were installed.

The supported property names of a PluginArray object are the values of the name attributes of all the Plugin objects represented by the PluginArray object.
The namedItem() method of a PluginArray object must return null if the argument is not one of the object's supported property names, and otherwise must return the Plugin object, of those represented by the PluginArray object, that has a name equal to the method's argument.

The refresh() method of the PluginArray object of a Navigator object, when invoked, must check to see if any plugins have been installed or reconfigured since the user agent created the PluginArray object. If so, and the method's argument is true, then the user agent must act as if the location.reload() method was called instead. Otherwise, the user agent must update the PluginArray object and MimeTypeArray object created for attributes of that Navigator object, and the Plugin and MimeType objects created for those PluginArray and MimeTypeArray objects, using the same Plugin objects for cases where the name is the same, and the same MimeType objects for cases where the type is the same, and creating new objects for cases where there were no matching objects immediately prior to the refresh() call. Old Plugin and MimeType objects must continue to return the same values that they had prior to the update, though naturally now the data is stale and may appear inconsistent (for example, an old MimeType entry might list as its enabledPlugin a Plugin object that no longer lists that MimeType as a supported MimeType).

A MimeTypeArray object represents the MIME types explicitly supported by plugins supported by the user agent, each of which is represented by a MimeType object.

The MimeTypeArray objects created by a user agent must not be live. The set of MIME types represented by the objects must not change once an object is created, except when it is updated by the PluginArray object's refresh() method.

The supported property indices of a MimeTypeArray object are the numbers from zero to the number of MIME types explicitly supported by non-hidden plugins represented by the corresponding PluginArray object, if any.
The length attribute must return the number of MIME types explicitly supported by non-hidden plugins represented by the corresponding PluginArray object, if any.
The item() method of a MimeTypeArray object must return null if the argument is not one of the object's supported property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

Let list be the MimeType objects representing the MIME types explicitly supported by non-hidden plugins represented by the corresponding PluginArray object, if any.

Sort list alphabetically by the type of each MimeType.

Return the indexth entry in list.

It is important for privacy that the order of MIME types not leak additional information, e.g. the order in which plugins were installed.

The supported property names of a MimeTypeArray object are the values of the type attributes of all the MimeType objects represented by the MimeTypeArray object.
The namedItem() method of a MimeTypeArray object must return null if the argument is not one of the object's supported property names, and otherwise must return the MimeType object that has a type equal to the method's argument.

A Plugin object represents a plugin. It has several attributes to provide details about the plugin, and can be enumerated to obtain the list of MIME types that it explicitly supports.

The Plugin objects created by a user agent must not be live. The set of MIME types represented by the objects, and the values of the objects' attributes, must not change once an object is created, except when updated by the PluginArray object's refresh() method.

The reported MIME types for a Plugin object are the MIME types explicitly supported by the corresponding plugin when this object was last created or updated by PluginArray.refresh(), whichever happened most recently.

The supported property indices of a Plugin object are the numbers from zero to the number of reported MIME types.
The length attribute must return the number of reported MIME types.
The item() method of a Plugin object must return null if the argument is not one of the object's supported property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

Let list be the MimeType objects representing the reported MIME types.

Sort list alphabetically by the type of each MimeType.

Return the indexth entry in list.

It is important for privacy that the order of MIME types not leak additional information, e.g. the order in which plugins were installed.

The supported property names of a Plugin object are the values of the type attributes of the MimeType objects representing the reported MIME types.
The namedItem() method of a Plugin object must return null if the argument is not one of the object's supported property names, and otherwise must return the MimeType object that has a type equal to the method's argument.

The name attribute must return the plugin's name.

The description and filename attributes must return user-agent-defined (or, in all likelihood, plugin-defined) strings. In each case, the same string must be returned each time, except that the strings returned may change when the PluginArray.refresh() method updates the object.

If the values returned by the description or filename attributes vary between versions of a plugin, they can be used both as a fingerprinting vector and, even more importantly, as a trivial way to determine what security vulnerabilities a plugin (and thus a browser) may have. It is thus highly recommended that the description attribute just return the same value as the name attribute, and that the filename attribute return the empty string.
A MimeType object represents a MIME type that is, or was, explicitly supported by a plugin.

The MimeType objects created by a user agent must not be live. The values of the objects' attributes must not change once an object is created, except when updated by the PluginArray object's refresh() method.

The type attribute must return the valid MIME type string with no parameters describing the MIME type.

The description and suffixes attributes must return user-agent-defined (or, in all likelihood, plugin-defined) strings. In each case, the same string must be returned each time, except that the strings returned may change when the PluginArray.refresh() method updates the object.

If the values returned by the description or suffixes attributes vary between versions of a plugin, they can be used both as a fingerprinting vector and, even more importantly, as a trivial way to determine what security vulnerabilities a plugin (and thus a browser) may have. It is thus highly recommended that the description attribute just return the same value as the type attribute, and that the suffixes attribute return the empty string.
Commas in the suffixes attribute are interpreted as separating subsequent filename extensions, as in "htm,html".

The enabledPlugin attribute must return the Plugin object that represents the plugin that explicitly supported the MIME type that this MimeType object represents when this object was last created or updated by PluginArray.refresh(), whichever happened most recently.

The navigator.javaEnabled() method must return true if the user agent supports a plugin that supports the MIME type "application/x-java-vm"; otherwise it must return false.
8.8 Images
[Exposed=(Window,Worker), Serializable, Transferable]
interface ImageBitmap {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  void close();
};

typedef (CanvasImageSource or
         Blob or
         ImageData) ImageBitmapSource;

enum ImageOrientation { "none", "flipY" };
enum PremultiplyAlpha { "none", "premultiply", "default" };
enum ColorSpaceConversion { "none", "default" };
enum ResizeQuality { "pixelated", "low", "medium", "high" };

dictionary ImageBitmapOptions {
  ImageOrientation imageOrientation = "none";
  PremultiplyAlpha premultiplyAlpha = "default";
  ColorSpaceConversion colorSpaceConversion = "default";
  [EnforceRange] unsigned long resizeWidth;
  [EnforceRange] unsigned long resizeHeight;
  ResizeQuality resizeQuality = "low";
};
An ImageBitmap object represents a bitmap image that can be painted to a canvas without undue latency.

The exact judgement of what is undue latency of this is left up to the implementer, but in general if making use of the bitmap requires network I/O, or even local disk I/O, then the latency is probably undue; whereas if it only requires a blocking read from a GPU or system RAM, the latency is probably acceptable.

promise = self . createImageBitmap(image [, options ])
promise = self . createImageBitmap(image, sx, sy, sw, sh [, options ])
Takes image, which can be an img element, an SVG image element, a video element, a canvas element, a Blob object, an ImageData object, or another ImageBitmap object, and returns a promise that is resolved when a new ImageBitmap is created.

If no ImageBitmap object can be constructed, for example because the provided image data is not actually an image, then the promise is rejected instead.

If sx, sy, sw, and sh arguments are provided, the source image is cropped to the given pixels, with any pixels missing in the original replaced by transparent black. These coordinates are in the source image's pixel coordinate space, not in CSS pixels.

If options is provided, the ImageBitmap object's bitmap data is modified according to options. For example, if the premultiplyAlpha option is set to "premultiply", the bitmap data's color channels are premultiplied by its alpha channel.

Rejects the promise with an "InvalidStateError" DOMException if the source image is not in a valid state (e.g., an img element that hasn't loaded successfully, an ImageBitmap object whose [[Detached]] internal slot value is true, an ImageData object whose data attribute value's [[ViewedArrayBuffer]] internal slot is detached, or a Blob whose data cannot be interpreted as a bitmap image).

Rejects the promise with a "SecurityError" DOMException if the script is not allowed to access the image data of the source image (e.g. a video that is CORS-cross-origin, or a canvas being drawn on by a script in a worker from another origin).

imageBitmap . close()
Releases imageBitmap's underlying bitmap data.

imageBitmap . width
Returns the intrinsic width of the image, in CSS pixels.

imageBitmap . height
Returns the intrinsic height of the image, in CSS pixels.

An ImageBitmap object whose [[Detached]] internal slot value is false always has associated bitmap data, with a width and a height. However, it is possible for this data to be corrupted. If an ImageBitmap object's media data can be decoded without errors, it is said to be fully decodable.

An ImageBitmap object's bitmap has an origin-clean flag, which indicates whether the bitmap is tainted by content from a different origin. The flag is initially set to true and may be changed to false by the steps of createImageBitmap().

ImageBitmap objects are serializable objects and transferable objects.

Their serialization steps, given value and serialized, are:

Set serialized.[[BitmapData]] to a copy of value's bitmap data.

Set serialized.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.

Their deserialization steps, given serialized and value, are:

Set value's bitmap data to serialized.[[BitmapData]].

If serialized.[[OriginClean]] is true, set value's origin-clean flag.

Their transfer steps, given value and dataHolder, are:

Set dataHolder.[[BitmapData]] to value's bitmap data.

Set dataHolder.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.

Unset value's bitmap data.

Their transfer-receiving steps, given dataHolder and value, are:

Set value's bitmap data to dataHolder.[[BitmapData]].

If dataHolder.[[OriginClean]] is true, set value's origin-clean flag.

The createImageBitmap(image, options) and createImageBitmap(image sx, sy, sw, sh, options) methods, when invoked, must run these steps:

Let p be a new promise.

If either sw or sh is given and is 0, then return p rejected with a RangeError.

If either options's resizeWidth or options's resizeHeight is present and is 0, then return p rejected with an "InvalidStateError" DOMException.

Check the usability of the image argument. If this throws an exception or returns bad, then return p rejected with an "InvalidStateError" DOMException.

Let imageBitmap be a new ImageBitmap object.

Switch on image:

img
SVG image
If image's media data has no intrinsic dimensions (e.g., it's a vector graphic with no specified content size) and either options's resizeWidth or options's resizeHeight is not present, then return p rejected with an "InvalidStateError" DOMException.

If image's media data has no intrinsic dimensions (e.g., it's a vector graphics with no specified content size), it should be rendered to a bitmap of the size specified by the resizeWidth and the resizeHeight options.

Set imageBitmap's bitmap data to a copy of image's media data, cropped to the source rectangle with formatting. If this is an animated image, imageBitmap's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.

If the origin of image's image is not same origin with entry settings object's origin, then set the origin-clean flag of imageBitmap's bitmap to false.

Run this step in parallel:

Resolve p with imageBitmap.

video
If image's networkState attribute is NETWORK_EMPTY, then return p rejected with an "InvalidStateError" DOMException.

Set imageBitmap's bitmap data to a copy of the frame at the current playback position, at the media resource's intrinsic width and intrinsic height (i.e., after any aspect-ratio correction has been applied), cropped to the source rectangle with formatting.

If the origin of image's video is not same origin with entry settings object's origin, then set the origin-clean flag of imageBitmap's bitmap to false.

Run this step in parallel:

Resolve p with imageBitmap.

canvas
Set imageBitmap's bitmap data to a copy of image's bitmap data, cropped to the source rectangle with formatting.

Set the origin-clean flag of the imageBitmap's bitmap to the same value as the origin-clean flag of image's bitmap.

Run this step in parallel:

Resolve p with imageBitmap.

Blob
Run these step in parallel:

Let imageData be the result of reading image's data. If an error occurs during reading of the object, then reject p with an "InvalidStateError" DOMException and abort these steps.

Apply the image sniffing rules to determine the file format of imageData, with MIME type of image (as given by image's type attribute) giving the official type.

If imageData is not in a supported image file format (e.g., it's not an image at all), or if imageData is corrupted in some fatal way such that the image dimensions cannot be obtained (e.g., a vector graphic with no intrinsic size), then reject p with an "InvalidStateError" DOMException and abort these steps.

Set imageBitmap's bitmap data to imageData, cropped to the source rectangle with formatting. If this is an animated image, imageBitmap's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.

Resolve p with imageBitmap.

ImageData
Let buffer be image's data attribute value's [[ViewedArrayBuffer]] internal slot.

If IsDetachedBuffer(buffer) is true, then return p rejected with an "InvalidStateError" DOMException.

Set imageBitmap's bitmap data to image's image data, cropped to the source rectangle with formatting.

Run this step in parallel:

Resolve p with imageBitmap.

ImageBitmap
Set imageBitmap's bitmap data to a copy of image's bitmap data, cropped to the source rectangle with formatting.

Set the origin-clean flag of imageBitmap's bitmap to the same value as the origin-clean flag of image's bitmap.

Run this step in parallel:

Resolve p with imageBitmap.

Return p.

When the steps above require that the user agent crop bitmap data to the source rectangle with formatting, the user agent must run the following steps:

Let input be the bitmap data being transformed.

If sx, sy, sw and sh are specified, let sourceRectangle be a rectangle whose corners are the four points (sx, sy), (sx+sw, sy),(sx+sw, sy+sh), (sx,sy+sh). Otherwise let sourceRectangle be a rectangle whose corners are the four points (0,0), (width of input, 0), (width of input, height of input), (0, height of input).

If either sw or sh are negative, then the top-left corner of this rectangle will be to the left or above the (sx, sy) point.

Clip sourceRectangle to the dimensions of input.

Let outputWidth be determined as follows:

If the resizeWidth member of options is specified
the value of the resizeWidth member of options
If the resizeWidth member of options is not specified, but the resizeHeight member is specified
the width of sourceRectangle, times the value of the resizeHeight member of options, divided by the height of sourceRectangle, rounded up to the nearest integer
If neither resizeWidth nor resizeHeight are specified
the width of sourceRectangle
Let outputHeight be determined as follows:

If the resizeHeight member of options is specified
the value of the resizeHeight member of options
If the resizeHeight member of options is not specified, but the resizeWidth member is specified
the height of sourceRectangle, times the value of the resizeWidth member of options, divided by the width of sourceRectangle, rounded up to the nearest integer
If neither resizeWidth nor resizeHeight are specified
the height of sourceRectangle
Place input on an infinite transparent black grid plane, positioned so that its top left corner is at the origin of the plane, with the x-coordinate increasing to the right, and the y-coordinate increasing down, and with each pixel in the input image data occupying a cell on the plane's grid.

Let output be the rectangle on the plane denoted by sourceRectangle.

Scale output to the size specified by outputWidth and outputHeight. The user agent should use the value of the resizeQuality option to guide the choice of scaling algorithm.

If the value of the imageOrientation member of options is "flipY", output must be flipped vertically, disregarding any image orientation metadata of the source (such as EXIF metadata), if any. [EXIF]

If the value is "none", no extra step is required.

If image is an img element or a Blob object, let val be the value of the colorSpaceConversion member of options, and then run these substeps:

If val is "default", the color space conversion behavior is implementation-specific, and should be chosen according to the color space that the implementation uses for drawing images onto the canvas.

If val is "none", output must be decoded without performing any color space conversions. This means that the image decoding algorithm must ignore color profile metadata embedded in the source data as well as the display device color profile.

The native color space of canvas is currently unspecified, but this is expected to change in the future.

Let val be the value of premultiplyAlpha member of options, and then run these substeps:

If val is "default", the alpha premultiplication behavior is implementation-specific, and should be chosen according to implementation deems optimal for drawing images onto the canvas.

If val is "premultiply", the output that is not premultiplied by alpha must have its color components multiplied by alpha and that is premultiplied by alpha must be left untouched.

If val is "none", the output that is not premultiplied by alpha must be left untouched and that is premultiplied by alpha must have its color components divided by alpha.

Return output.

When the close() method is called, the user agent must run these steps:

Set this ImageBitmap object's [[Detached]] internal slot value to true.

Unset this ImageBitmap object's bitmap data.

The width attribute's getter must run these steps:

If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.

Return this ImageBitmap object's width, in CSS pixels.

The height attribute's getter must run these steps:

If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.

Return this ImageBitmap object's height, in CSS pixels.

The ResizeQuality enumeration is used to express a preference for the interpolation quality to use when scaling images.

The "pixelated" value indicates a preference to scale the image that maximizes the appearance. Scaling algorithms that "smooth" colors are acceptable, such as bilinear interpolation.

The "low" value indicates a preference for a low level of image interpolation quality. Low-quality image interpolation may be more computationally efficient than higher settings.

The "medium" value indicates a preference for a medium level of image interpolation quality.

The "high" value indicates a preference for a high level of image interpolation quality. High-quality image interpolation may be more computationally expensive than lower settings.

Bilinear scaling is an example of a relatively fast, lower-quality image-smoothing algorithm. Bicubic or Lanczos scaling are examples of image-scaling algorithms that produce higher-quality output. This specification does not mandate that specific interpolation algorithms be used unless the value is "pixelated".

Using this API, a sprite sheet can be precut and prepared:

var sprites = {};
function loadMySprites() {
  var image = new Image();
  image.src = 'mysprites.png';
  var resolver;
  var promise = new Promise(function (arg) { resolver = arg });
  image.onload = function () {
    resolver(Promise.all([
      createImageBitmap(image,  0,  0, 40, 40).then(function (image) { sprites.person = image }),
      createImageBitmap(image, 40,  0, 40, 40).then(function (image) { sprites.grass  = image }),
      createImageBitmap(image, 80,  0, 40, 40).then(function (image) { sprites.tree   = image }),
      createImageBitmap(image,  0, 40, 40, 40).then(function (image) { sprites.hut    = image }),
      createImageBitmap(image, 40, 40, 40, 40).then(function (image) { sprites.apple  = image }),
      createImageBitmap(image, 80, 40, 40, 40).then(function (image) { sprites.snake  = image })
    ]));
  };
  return promise;
}

function runDemo() {
  var canvas = document.querySelector('canvas#demo');
  var context = canvas.getContext('2d');
  context.drawImage(sprites.tree, 30, 10);
  context.drawImage(sprites.snake, 70, 10);
}

loadMySprites().then(runDemo);
8.9 Animation frames

Support: requestanimationframe
Chrome for Android	64+
Chrome	24+
iOS Safari	7.0+
UC Browser for Android	11.8+
Firefox	23+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	6.1+
Edge	12+
Android Browser	4.4+
Opera	15+

Source: caniuse.com

Each Document has a list of animation frame callbacks, which must be initially empty, and an animation frame callback identifier, which is a number which must initially be zero.

When the requestAnimationFrame() method is called, the user agent must run the following steps:

Let document be this Window object's associated Document.

Increment document's animation frame callback identifier by one.

Append the method's argument to document's list of animation frame callbacks, associated with document's animation frame callback identifier's current value.

Return document's animation frame callback identifier's current value.

When the cancelAnimationFrame() method is called, the user agent must run the following steps:

Let document be this Window object's associated Document.

Find the entry in document's list of animation frame callbacks that is associated with the value given by the method's argument.

If there is such an entry, remove it from document's list of animation frame callbacks.

When the user agent is to run the animation frame callbacks for a Document doc with a timestamp now, it must run the following steps:

Let callbacks be a list of the entries in doc's list of animation frame callbacks, in the order in which they were added to the list.

Set doc's list of animation frame callbacks to the empty list.

For each entry in callbacks, in order: invoke the callback, passing now as the only argument, and if an exception is thrown, report the exception. [WEBIDL]

9 Communication
9.1 The MessageEvent interface
Messages in server-sent events, Web sockets, cross-document messaging, channel messaging, and broadcast channels use the MessageEvent interface for their message events:

[Constructor(DOMString type, optional MessageEventInit eventInitDict), Exposed=(Window,Worker,AudioWorklet)]
interface MessageEvent : Event {
  readonly attribute any data;
  readonly attribute USVString origin;
  readonly attribute DOMString lastEventId;
  readonly attribute MessageEventSource? source;
  readonly attribute FrozenArray<MessagePort> ports;

  void initMessageEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false, optional any data = null, optional USVString origin = "", optional DOMString lastEventId = "", optional MessageEventSource? source = null, optional sequence<MessagePort> ports = []);
};

dictionary MessageEventInit : EventInit {
  any data = null;
  USVString origin = "";
  DOMString lastEventId = "";
  MessageEventSource? source = null;
  sequence<MessagePort> ports = [];
};

typedef (WindowProxy or MessagePort or ServiceWorker) MessageEventSource;
event . data
Returns the data of the message.

event . origin
Returns the origin of the message, for server-sent events and cross-document messaging.

event . lastEventId
Returns the last event ID string, for server-sent events.

event . source
Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.

event . ports
Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.

The data attribute must return the value it was initialized to. It represents the message being sent.

The origin attribute must return the value it was initialized to. It represents, in server-sent events and cross-document messaging, the origin of the document that sent the message (typically the scheme, hostname, and port of the document, but not its path or fragment).

The lastEventId attribute must return the value it was initialized to. It represents, in server-sent events, the last event ID string of the event source.

The source attribute must return the value it was initialized to. It represents, in cross-document messaging, the WindowProxy of the browsing context of the Window object from which the message came; and in the connect events used by shared workers, the newly connecting MessagePort.

The ports attribute must return the value it was initialized to. It represents, in cross-document messaging and channel messaging, the MessagePort array being sent.

The initMessageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method. [DOM]

Various APIs (e.g., WebSocket, EventSource) use the MessageEvent interface for their message event without using the MessagePort API.

9.2 Server-sent events

Support: eventsource
Chrome for Android	64+
Chrome	6+
iOS Safari	4.0+
UC Browser for Android	11.8+
Firefox	6+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	5+
Edge	None
Android Browser	4.4+
Opera	11+

Source: caniuse.com

9.2.1 Introduction
This section is non-normative.

To enable servers to push data to Web pages over HTTP or using dedicated server-push protocols, this specification introduces the EventSource interface.

Using this API consists of creating an EventSource object and registering an event listener.

var source = new EventSource('updates.cgi');
source.onmessage = function (event) {
  alert(event.data);
};
On the server-side, the script ("updates.cgi" in this case) sends messages in the following form, with the text/event-stream MIME type:

data: This is the first message.

data: This is the second message, it
data: has two lines.

data: This is the third message.
Authors can separate events by using different event types. Here is a stream that has two event types, "add" and "remove":

event: add
data: 73857293

event: remove
data: 2153

event: add
data: 113411
The script to handle such a stream would look like this (where addHandler and removeHandler are functions that take one argument, the event):

var source = new EventSource('updates.cgi');
source.addEventListener('add', addHandler, false);
source.addEventListener('remove', removeHandler, false);
The default event type is "message".

Event streams are always decoded as UTF-8. There is no way to specify another character encoding.

Event stream requests can be redirected using HTTP 301 and 307 redirects as with normal HTTP requests. Clients will reconnect if the connection is closed; a client can be told to stop reconnecting using the HTTP 204 No Content response code.

Using this API rather than emulating it using XMLHttpRequest or an iframe allows the user agent to make better use of network resources in cases where the user agent implementer and the network operator are able to coordinate in advance. Amongst other benefits, this can result in significant savings in battery life on portable devices. This is discussed further in the section below on connectionless push.

9.2.2 The EventSource interface
[Constructor(USVString url, optional EventSourceInit eventSourceInitDict), Exposed=(Window,Worker)]
interface EventSource : EventTarget {
  readonly attribute USVString url;
  readonly attribute boolean withCredentials;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSED = 2;
  readonly attribute unsigned short readyState;

  // networking
  attribute EventHandler onopen;
  attribute EventHandler onmessage;
  attribute EventHandler onerror;
  void close();
};

dictionary EventSourceInit {
  boolean withCredentials = false;
};
Each EventSource object has the following associated with it:

A url (a URL record). Set during construction.

A request. This must initially be null.

A reconnection time, in milliseconds. This must initially be a user-agent-defined value, probably in the region of a few seconds.

A last event ID string. This must initially be the empty string.

Apart from url these are not currently exposed on the EventSource object.

source = new EventSource( url [, { withCredentials: true } ])
Creates a new EventSource object.

url is a string giving the URL that will provide the event stream.

Setting withCredentials to true will set the credentials mode for connection requests to url to "include".

source . close()
Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.

source . url
Returns the URL providing the event stream.

source . withCredentials
Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.

source . readyState
Returns the state of this EventSource object's connection. It can have the values described below.

The EventSource(url, eventSourceInitDict) constructor, when invoked, must run these steps:

Let ev be a new EventSource object.

Let settings be ev's relevant settings object.

Let urlRecord be the result of parsing url with settings's API base URL and settings's API URL character encoding.

If urlRecord is failure, then throw a "SyntaxError" DOMException.

Set ev's url to urlRecord.

Let corsAttributeState be Anonymous.

If the value of eventSourceInitDict's withCredentials member is true, then set corsAttributeState to Use Credentials and set ev's withCredentials attribute to true.

Let request be the result of creating a potential-CORS request given urlRecord, the empty string, and corsAttributeState, and with the same-origin fallback flag set.

Set request's client to settings.

User agents may set `Accept`/`text/event-stream` in request's header list.

Set request's cache mode to "no-store".

Set ev's request to request.

Run this step in parallel:

Fetch request.

Return ev.

The url attribute's getter must return the serialization of this EventSource object's url.

The withCredentials attribute must return the value to which it was last initialized. When the object is created, it must be initialized to false.

The readyState attribute represents the state of the connection. It can have the following values:

CONNECTING (numeric value 0)
The connection has not yet been established, or it was closed and the user agent is reconnecting.
OPEN (numeric value 1)
The user agent has an open connection and is dispatching events as it receives them.
CLOSED (numeric value 2)
The connection is not open, and the user agent is not trying to reconnect. Either there was a fatal error or the close() method was invoked.
When the object is created its readyState must be set to CONNECTING (0). The rules given below for handling the connection define when the value changes.

The close() method must abort any instances of the fetch algorithm started for this EventSource object, and must set the readyState attribute to CLOSED.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the EventSource interface:

Event handler	Event handler event type
onopen	open
onmessage	message
onerror	error
9.2.3 Processing model
The resource indicated in the argument to the EventSource constructor is fetched when the constructor is run.

As data is received, the tasks queued by the networking task source to handle the data must act as follows.

HTTP 200 OK responses with a `Content-Type` header specifying the type `text/event-stream`, ignoring any MIME type parameters, must be processed line by line as described below.

When a successful response with a supported MIME type is received, such that the user agent begins parsing the contents of the stream, the user agent must announce the connection.

The task that the networking task source places on the task queue once fetching for such a resource (with the correct MIME type) has completed must cause the user agent to reestablish the connection in parallel. This applies whether the connection is closed gracefully or unexpectedly (but does not apply when fetching is canceled by the user agent, e.g., in response to window.stop(), since in those cases the final task is actually discarded). It doesn't apply for the error conditions listed below except where explicitly specified.

HTTP 200 OK responses that have a Content-Type specifying an unsupported type, or that have no Content-Type at all, must cause the user agent to fail the connection.

Network errors that prevents the connection from being established in the first place (e.g. DNS errors), should cause the user agent to reestablish the connection in parallel, unless the user agent knows that to be futile, in which case the user agent may fail the connection.

Any other HTTP response code not listed here, as well as the cancelation of the fetch algorithm by the user agent (e.g. in response to window.stop() or the user canceling the network connection manually) must cause the user agent to fail the connection.

When a user agent is to announce the connection, the user agent must queue a task which, if the readyState attribute is set to a value other than CLOSED, sets the readyState attribute to OPEN and fires an event named open at the EventSource object.

When a user agent is to reestablish the connection, the user agent must run the following steps. These steps are run in parallel, not as part of a task. (The tasks that it queues, of course, are run like normal tasks and not themselves in parallel.)

Queue a task to run the following steps:

If the readyState attribute is set to CLOSED, abort the task.

Set the readyState attribute to CONNECTING.

Fire an event named error at the EventSource object.

Wait a delay equal to the reconnection time of the event source.

Optionally, wait some more. In particular, if the previous attempt failed, then user agents might introduce an exponential backoff delay to avoid overloading a potentially already overloaded server. Alternatively, if the operating system has reported that there is no network connectivity, user agents might wait for the operating system to announce that the network connection has returned before retrying.

Wait until the aforementioned task has run, if it has not yet run.

Queue a task to run the following steps:

If the EventSource object's readyState attribute is not set to CONNECTING, return.

Let request be the EventSource object's request.

If the EventSource object's last event ID string is not the empty string, set `Last-Event-ID`/last event ID string, encoded as UTF-8, in request's header list.

Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.

When a user agent is to fail the connection, the user agent must queue a task which, if the readyState attribute is set to a value other than CLOSED, sets the readyState attribute to CLOSED and fires an event named error at the EventSource object. Once the user agent has failed the connection, it does not attempt to reconnect!

The task source for any tasks that are queued by EventSource objects is the remote event task source.

9.2.4 Parsing an event stream
This event stream format's MIME type is text/event-stream.

The event stream format is as described by the stream production of the following ABNF, the character set for which is Unicode. [ABNF]

stream        = [ bom ] *event
event         = *( comment / field ) end-of-line
comment       = colon *any-char end-of-line
field         = 1*name-char [ colon [ space ] *any-char ] end-of-line
end-of-line   = ( cr lf / cr / lf )

; characters
lf            = %x000A ; U+000A LINE FEED (LF)
cr            = %x000D ; U+000D CARRIAGE RETURN (CR)
space         = %x0020 ; U+0020 SPACE
colon         = %x003A ; U+003A COLON (:)
bom           = %xFEFF ; U+FEFF BYTE ORDER MARK
name-char     = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF
                ; a scalar value other than U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)
any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF
                ; a scalar value other than U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
Event streams in this format must always be encoded as UTF-8. [ENCODING]

Lines must be separated by either a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character, or a single U+000D CARRIAGE RETURN (CR) character.

Since connections established to remote servers for such resources are expected to be long-lived, UAs should ensure that appropriate buffering is used. In particular, while line buffering with lines are defined to end with a single U+000A LINE FEED (LF) character is safe, block buffering or line buffering with different expected line endings can cause delays in event dispatch.

9.2.5 Interpreting an event stream
Streams must be decoded using the UTF-8 decode algorithm.

The UTF-8 decode algorithm strips one leading UTF-8 Byte Order Mark (BOM), if any.

The stream must then be parsed by reading everything line by line, with a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, and a single U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF) character being the ways in which a line can end.

When a stream is parsed, a data buffer, an event type buffer, and a last event ID buffer must be associated with it. They must be initialized to the empty string

Lines must be processed, in the order they are received, as follows:

If the line is empty (a blank line)
Dispatch the event, as defined below.

If the line starts with a U+003A COLON character (:)
Ignore the line.

If the line contains a U+003A COLON character (:)
Collect the characters on the line before the first U+003A COLON character (:), and let field be that string.

Collect the characters on the line after the first U+003A COLON character (:), and let value be that string. If value starts with a U+0020 SPACE character, remove it from value.

Process the field using the steps described below, using field as the field name and value as the field value.

Otherwise, the string is not empty but does not contain a U+003A COLON character (:)
Process the field using the steps described below, using the whole line as the field name, and the empty string as the field value.

Once the end of the file is reached, any pending data must be discarded. (If the file ends in the middle of an event, before the final empty line, the incomplete event is not dispatched.)

The steps to process the field given a field name and a field value depend on the field name, as given in the following list. Field names must be compared literally, with no case folding performed.

If the field name is "event"
Set the event type buffer to field value.

If the field name is "data"
Append the field value to the data buffer, then append a single U+000A LINE FEED (LF) character to the data buffer.

If the field name is "id"
If the field value does not contain U+0000 NULL, then set the last event ID buffer to the field value. Otherwise, ignore the field.

If the field name is "retry"
If the field value consists of only ASCII digits, then interpret the field value as an integer in base ten, and set the event stream's reconnection time to that integer. Otherwise, ignore the field.

Otherwise
The field is ignored.

When the user agent is required to dispatch the event, the user agent must process the data buffer, the event type buffer, and the last event ID buffer using steps appropriate for the user agent.

For Web browsers, the appropriate steps to dispatch the event are as follows:

Set the last event ID string of the event source to the value of the last event ID buffer. The buffer does not get reset, so the last event ID string of the event source remains set to this value until the next time it is set by the server.

If the data buffer is an empty string, set the data buffer and the event type buffer to the empty string and return.

If the data buffer's last character is a U+000A LINE FEED (LF) character, then remove the last character from the data buffer.

Let event be the result of creating an event using MessageEvent, in the relevant Realm of the EventSource object.

Initialize event's type attribute to message, its data attribute to data, its origin attribute to the serialization of the origin of the event stream's final URL (i.e., the URL after redirects), and its lastEventId attribute to the last event ID string of the event source.

If the event type buffer has a value other than the empty string, change the type of the newly created event to equal the value of the event type buffer.

Set the data buffer and the event type buffer to the empty string.

Queue a task which, if the readyState attribute is set to a value other than CLOSED, dispatches the newly created event at the EventSource object.

If an event doesn't have an "id" field, but an earlier event did set the event source's last event ID string, then the event's lastEventId field will be set to the value of whatever the last seen "id" field was.

For other user agents, the appropriate steps to dispatch the event are implementation dependent, but at a minimum they must set the data and event type buffers to the empty string before returning.

The following event stream, once followed by a blank line:

data: YHOO
data: +2
data: 10
...would cause an event message with the interface MessageEvent to be dispatched on the EventSource object. The event's data attribute would contain the string "YHOO\n+2\n10" (where "\n" represents a newline).

This could be used as follows:

var stocks = new EventSource("https://stocks.example.com/ticker.php");
stocks.onmessage = function (event) {
  var data = event.data.split('\n');
  updateStocks(data[0], data[1], data[2]);
};
...where updateStocks() is a function defined as:

function updateStocks(symbol, delta, value) { ... }
...or some such.

The following stream contains four blocks. The first block has just a comment, and will fire nothing. The second block has two fields with names "data" and "id" respectively; an event will be fired for this block, with the data "first event", and will then set the last event ID to "1" so that if the connection died between this block and the next, the server would be sent a `Last-Event-ID` header with the value "1". The third block fires an event with data "second event", and also has an "id" field, this time with no value, which resets the last event ID to the empty string (meaning no `Last-Event-ID` header will now be sent in the event of a reconnection being attempted). Finally, the last block just fires an event with the data " third event" (with a single leading space character). Note that the last still has to end with a blank line, the end of the stream is not enough to trigger the dispatch of the last event.

: test stream

data: first event
id: 1

data:second event
id

data:  third event
The following stream fires two events:

data

data
data

data:
The first block fires events with the data set to the empty string, as would the last block if it was followed by a blank line. The middle block fires an event with the data set to a single newline character. The last block is discarded because it is not followed by a blank line.

The following stream fires two identical events:

data:test

data: test
This is because the space after the colon is ignored if present.

9.2.6 Authoring notes
Legacy proxy servers are known to, in certain cases, drop HTTP connections after a short timeout. To protect against such proxy servers, authors can include a comment line (one starting with a ':' character) every 15 seconds or so.

Authors wishing to relate event source connections to each other or to specific documents previously served might find that relying on IP addresses doesn't work, as individual clients can have multiple IP addresses (due to having multiple proxy servers) and individual IP addresses can have multiple clients (due to sharing a proxy server). It is better to include a unique identifier in the document when it is served and then pass that identifier as part of the URL when the connection is established.

Authors are also cautioned that HTTP chunking can have unexpected negative effects on the reliability of this protocol, in particular if the chunking is done by a different layer unaware of the timing requirements. If this is a problem, chunking can be disabled for serving event streams.

Clients that support HTTP's per-server connection limitation might run into trouble when opening multiple pages from a site if each page has an EventSource to the same domain. Authors can avoid this using the relatively complex mechanism of using unique domain names per connection, or by allowing the user to enable or disable the EventSource functionality on a per-page basis, or by sharing a single EventSource object using a shared worker.

9.2.7 Connectionless push and other features
User agents running in controlled environments, e.g. browsers on mobile handsets tied to specific carriers, may offload the management of the connection to a proxy on the network. In such a situation, the user agent for the purposes of conformance is considered to include both the handset software and the network proxy.

For example, a browser on a mobile device, after having established a connection, might detect that it is on a supporting network and request that a proxy server on the network take over the management of the connection. The timeline for such a situation might be as follows:

Browser connects to a remote HTTP server and requests the resource specified by the author in the EventSource constructor.
The server sends occasional messages.
In between two messages, the browser detects that it is idle except for the network activity involved in keeping the TCP connection alive, and decides to switch to sleep mode to save power.
The browser disconnects from the server.
The browser contacts a service on the network, and requests that the service, a "push proxy", maintain the connection instead.
The "push proxy" service contacts the remote HTTP server and requests the resource specified by the author in the EventSource constructor (possibly including a `Last-Event-ID` HTTP header, etc).
The browser allows the mobile device to go to sleep.
The server sends another message.
The "push proxy" service uses a technology such as OMA push to convey the event to the mobile device, which wakes only enough to process the event and then returns to sleep.
This can reduce the total data usage, and can therefore result in considerable power savings.

As well as implementing the existing API and text/event-stream wire format as defined by this specification and in more distributed ways as described above, formats of event framing defined by other applicable specifications may be supported. This specification does not define how they are to be parsed or processed.

9.2.8 Garbage collection
While an EventSource object's readyState is CONNECTING, and the object has one or more event listeners registered for open, message or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to the EventSource object itself.

While an EventSource object's readyState is OPEN, and the object has one or more event listeners registered for message or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to the EventSource object itself.

While there is a task queued by an EventSource object on the remote event task source, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to that EventSource object.

If a user agent is to forcibly close an EventSource object (this happens when a Document object goes away permanently), the user agent must abort any instances of the fetch algorithm started for this EventSource object, and must set the readyState attribute to CLOSED.

If an EventSource object is garbage collected while its connection is still open, the user agent must abort any instance of the fetch algorithm opened by this EventSource.

9.2.9 Implementation advice
This section is non-normative.

User agents are strongly urged to provide detailed diagnostic information about EventSource objects and their related network connections in their development consoles, to aid authors in debugging code using this API.

For example, a user agent could have a panel displaying all the EventSource objects a page has created, each listing the constructor's arguments, whether there was a network error, what the CORS status of the connection is and what headers were sent by the client and received from the server to lead to that status, the messages that were received and how they were parsed, and so forth.

Implementations are especially encouraged to report detailed information to their development consoles whenever an error event is fired, since little to no information can be made available in the events themselves.

9.3 Web sockets

Support: websockets
Chrome for Android	64+
Chrome	16+
iOS Safari	6.0+
UC Browser for Android	11.8+
Firefox	11+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	7+
Edge	12+
Android Browser	4.4+
Opera	12.1+

Source: caniuse.com

9.3.1 Introduction
This section is non-normative.

To enable Web applications to maintain bidirectional communications with server-side processes, this specification introduces the WebSocket interface.

This interface does not allow for raw access to the underlying network. For example, this interface could not be used to implement an IRC client without proxying messages through a custom server.

9.3.2 The WebSocket interface
enum BinaryType { "blob", "arraybuffer" };
[Constructor(USVString url, optional (DOMString or sequence<DOMString>) protocols = []), Exposed=(Window,Worker)]
interface WebSocket : EventTarget {
  readonly attribute USVString url;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSING = 2;
  const unsigned short CLOSED = 3;
  readonly attribute unsigned short readyState;
  readonly attribute unsigned long long bufferedAmount;

  // networking
  attribute EventHandler onopen;
  attribute EventHandler onerror;
  attribute EventHandler onclose;
  readonly attribute DOMString extensions;
  readonly attribute DOMString protocol;
  void close(optional [Clamp] unsigned short code, optional USVString reason);

  // messaging
  attribute EventHandler onmessage;
  attribute BinaryType binaryType;
  void send(USVString data);
  void send(Blob data);
  void send(ArrayBuffer data);
  void send(ArrayBufferView data);
};
Each WebSocket object has an associated url (a URL record).

socket = new WebSocket(url [, protocols ] )
Creates a new WebSocket object, immediately establishing the associated WebSocket connection.

url is a string giving the URL over which the connection is established. Only "ws" or "wss" schemes are allowed; others will cause a "SyntaxError" DOMException. URLs with fragments will also cause such an exception.

protocols is either a string or an array of strings. If it is a string, it is equivalent to an array consisting of just that string; if it is omitted, it is equivalent to the empty array. Each string in the array is a subprotocol name. The connection will only be established if the server reports that it has selected one of these subprotocols. The subprotocol names have to match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification. [WSP]

socket . send( data )
Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.

socket . close( [ code ] [, reason ] )
Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.

socket . url
Returns the URL that was used to establish the WebSocket connection.

socket . readyState
Returns the state of the WebSocket object's connection. It can have the values described below.

socket . bufferedAmount
Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but not yet been transmitted to the network.

If the WebSocket connection is closed, this attribute's value will only increase with each call to the send() method. (The number does not reset to zero once the connection closes.)

socket . extensions
Returns the extensions selected by the server, if any.

socket . protocol
Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.

socket . binaryType [ = value ]
Returns a string that indicates how binary data from the WebSocket object is exposed to scripts:

"blob"
Binary data is returned in Blob form.

"arraybuffer"
Binary data is returned in ArrayBuffer form.

Can be set, to change how binary data is returned. The default is "blob".

The WebSocket(url, protocols) constructor, when invoked, must run these steps:

Let urlRecord be the result of applying the URL parser to url.

If urlRecord is failure, then throw a "SyntaxError" DOMException.

If urlRecord's scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.

If urlRecord's fragment is non-null, then throw a "SyntaxError" DOMException.

If protocols is a string, set protocols to a sequence consisting of just that string.

If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification, then throw a "SyntaxError" DOMException. [WSP]

Run this step in parallel:

Establish a WebSocket connection given urlRecord, protocols, and the entry settings object. [FETCH]

If the establish a WebSocket connection algorithm fails, it triggers the fail the WebSocket connection algorithm, which then invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.

Return a new WebSocket object whose url is urlRecord.

The url attribute's getter must return this WebSocket object's url, serialized.

The readyState attribute represents the state of the connection. It can have the following values:

CONNECTING (numeric value 0)
The connection has not yet been established.
OPEN (numeric value 1)
The WebSocket connection is established and communication is possible.
CLOSING (numeric value 2)
The connection is going through the closing handshake, or the close() method has been invoked.
CLOSED (numeric value 3)
The connection has been closed or could not be opened.
When the object is created its readyState must be set to CONNECTING (0).

The extensions attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.

The protocol attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.

The close(code, reason) method, when invoked, must run these steps:

If code is present, but is neither an integer equal to 1000 nor an integer in the range 3000 to 4999, inclusive, throw an "InvalidAccessError" DOMException.

If reason is present, then run these substeps:

Let reasonBytes be the result of encoding reason.

If reasonBytes is longer than 123 bytes, then throw a "SyntaxError" DOMException.

Run the first matching steps from the following list:

If the readyState attribute is in the CLOSING (2) or CLOSED (3) state
Do nothing.

The connection is already closing or is already closed. If it has not already, a close event will eventually fire as described below.

If the WebSocket connection is not yet established [WSP]
Fail the WebSocket connection and set the readyState attribute's value to CLOSING (2). [WSP]

The fail the WebSocket connection algorithm invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.

If the WebSocket closing handshake has not yet been started [WSP]
Start the WebSocket closing handshake and set the readyState attribute's value to CLOSING (2). [WSP]

If neither code nor reason is present, the WebSocket Close message must not have a body.

The WebSocket Protocol specification erroneously states that the status code is required for the start the WebSocket closing handshake algorithm.

If code is present, then the status code to use in the WebSocket Close message must be the integer given by close. [WSP]

If reason is also present, then reasonBytes must be provided in the Close message after the status code. [WSP]

The start the WebSocket closing handshake algorithm eventually invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.

Otherwise
Set the readyState attribute's value to CLOSING (2).

The WebSocket closing handshake is started, and will eventually invoke the close the WebSocket connection algorithm, which will establish that the WebSocket connection is closed, and thus the close event will fire, as described below.

The close() method does not discard previously sent messages before starting the WebSocket closing handshake — even if, in practice, the user agent is still busy sending those messages, the handshake will only start after the messages are sent.

The bufferedAmount attribute must return the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but that, as of the last time the event loop reached step 1, had not yet been transmitted to the network. (This thus includes any text sent during the execution of the current task, regardless of whether the user agent is able to transmit text in the background in parallel with script execution.) This does not include framing overhead incurred by the protocol, or buffering done by the operating system or network hardware.

In this simple example, the bufferedAmount attribute is used to ensure that updates are sent either at the rate of one update every 50ms, if the network can handle that rate, or at whatever rate the network can handle, if that is too fast.

var socket = new WebSocket('ws://game.example.com:12010/updates');
socket.onopen = function () {
  setInterval(function() {
    if (socket.bufferedAmount == 0)
      socket.send(getUpdateData());
  }, 50);
};
The bufferedAmount attribute can also be used to saturate the network without sending the data at a higher rate than the network can handle, though this requires more careful monitoring of the value of the attribute over time.

When a WebSocket object is created, its binaryType IDL attribute must be set to the string "blob". On getting, it must return the last value it was set to. On setting, the user agent must set the IDL attribute to the new value.

User agents can use the binaryType attribute as a hint for how to handle incoming binary data: if the attribute is set to "blob", it is safe to spool it to disk, and if it is set to "arraybuffer", it is likely more efficient to keep the data in memory. Naturally, user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in memory or not, e.g. based on how big the data is or how common it is for a script to change the attribute at the last minute. This latter aspect is important in particular because it is quite possible for the attribute to be changed after the user agent has received the data but before the user agent has fired the event for it.

The send(data) method transmits data using the connection. If the readyState attribute is CONNECTING, it must throw an "InvalidStateError" DOMException. Otherwise, the user agent must run the appropriate set of steps from the following list:

If the argument is a string
If the WebSocket connection is established and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of the data argument using a text frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. Any invocation of this method with a string argument that does not throw an exception must increase the bufferedAmount attribute by the number of bytes needed to express the argument as UTF-8. [UNICODE] [ENCODING] [WSP]

If the argument is a Blob object
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the raw data represented by the Blob object. Any invocation of this method with a Blob argument that does not throw an exception must increase the bufferedAmount attribute by the size of the Blob object's raw data, in bytes. [WSP] [FILEAPI]

If the argument is an ArrayBuffer object
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the buffer described by the ArrayBuffer object. Any invocation of this method with an ArrayBuffer argument that does not throw an exception must increase the bufferedAmount attribute by the length of the ArrayBuffer in bytes. [WSP]

If the argument is an object that matches the ArrayBufferView type definition
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the section of the buffer described by the ArrayBuffer object that data references. Any invocation of this method with this kind of argument that does not throw an exception must increase the bufferedAmount attribute by the length of data's buffer in bytes. [WSP]

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the WebSocket interface:

Event handler	Event handler event type
onopen	open
onmessage	message
onerror	error
onclose	close
9.3.3 Feedback from the protocol
When the WebSocket connection is established, the user agent must queue a task to run these steps:

Change the readyState attribute's value to OPEN (1).

Change the extensions attribute's value to the extensions in use, if it is not the null value. [WSP]

Change the protocol attribute's value to the subprotocol in use, if it is not the null value. [WSP]

Fire an event named open at the WebSocket object.

Since the algorithm above is queued as a task, there is no race condition between the WebSocket connection being established and the script setting up an event listener for the open event.

When a WebSocket message has been received with type type and data data, the user agent must queue a task to follow these steps: [WSP]

If the readyState attribute's value is not OPEN (1), then return.

Let dataForEvent be determined by switching on type and binaryType:

type indicates that the data is Text
a new DOMString containing data
type indicates that the data is Binary and binaryType is "blob"
a new Blob object, created in the relevant Realm of the WebSocket object, that represents data as its raw data [FILEAPI]
type indicates that the data is Binary and binaryType is "arraybuffer"
a new ArrayBuffer object, created in the relevant Realm of the WebSocket object, whose contents are data
Fire an event named message at the WebSocket object, using MessageEvent, with the origin attribute initialized to the serialization of the WebSocket object's url's origin, and the data attribute initialized to dataForEvent.

User agents are encouraged to check if they can perform the above steps efficiently before they run the task, picking tasks from other task queues while they prepare the buffers if not. For example, if the binaryType attribute was set to "blob" when the data arrived, and the user agent spooled all the data to disk, but just before running the above task for this particular message the script switched binaryType to "arraybuffer", the user agent would want to page the data back to RAM before running this task so as to avoid stalling the main thread while it created the ArrayBuffer object.

Here is an example of how to define a handler for the message event in the case of text frames:

mysocket.onmessage = function (event) {
  if (event.data == 'on') {
    turnLampOn();
  } else if (event.data == 'off') {
    turnLampOff();
  }
};
The protocol here is a trivial one, with the server just sending "on" or "off" messages.

When the WebSocket closing handshake is started, the user agent must queue a task to change the readyState attribute's value to CLOSING (2). (If the close() method was called, the readyState attribute's value will already be set to CLOSING (2) when this task runs.) [WSP]

When the WebSocket connection is closed, possibly cleanly, the user agent must queue a task to run the following substeps:

Change the readyState attribute's value to CLOSED (3).

If the user agent was required to fail the WebSocket connection, or if the the WebSocket connection was closed after being flagged as full, fire an event named error at the WebSocket object. [WSP]

Fire an event named close at the WebSocket object, using CloseEvent, with the wasClean attribute initialized to true if the connection closed cleanly and false otherwise, the code attribute initialized to the WebSocket connection close code, and the reason attribute initialized to the result of applying UTF-8 decode without BOM to the WebSocket connection close reason. [WSP]

User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:

A server whose host name could not be resolved.
A server to which packets could not successfully be routed.
A server that refused the connection on the specified port.
A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be verified).
A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).
A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).
A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.
In all of these cases, the the WebSocket connection close code would be 1006, as required by the WebSocket Protocol specification. [WSP]

Allowing a script to distinguish these cases would allow a script to probe the user's local network in preparation for an attack.

In particular, this means the code 1015 is not used by the user agent (unless the server erroneously uses it in its close frame, of course).

The task source for all tasks queued in this section is the WebSocket task source.

9.3.4 Ping and Pong frames
The WebSocket protocol specification defines Ping and Pong frames that can be used for keep-alive, heart-beats, network status probing, latency instrumentation, and so forth. These are not currently exposed in the API.

User agents may send ping and unsolicited pong frames as desired, for example in an attempt to maintain local network NAT mappings, to detect failed connections, or to display latency metrics to the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that servers will solicit pongs whenever appropriate for the server's needs.

9.3.5 The CloseEvent interface
WebSocket objects use the CloseEvent interface for their close events:

[Constructor(DOMString type, optional CloseEventInit eventInitDict), Exposed=(Window,Worker)]
interface CloseEvent : Event {
  readonly attribute boolean wasClean;
  readonly attribute unsigned short code;
  readonly attribute USVString reason;
};

dictionary CloseEventInit : EventInit {
  boolean wasClean = false;
  unsigned short code = 0;
  USVString reason = "";
};
event . wasClean
Returns true if the connection closed cleanly; false otherwise.

event . code
Returns the WebSocket connection close code provided by the server.

event . reason
Returns the WebSocket connection close reason provided by the server.

The wasClean attribute must return the value it was initialized to. It represents whether the connection closed cleanly or not.

The code attribute must return the value it was initialized to. It represents the WebSocket connection close code provided by the server.

The reason attribute must return the value it was initialized to. It represents the WebSocket connection close reason provided by the server.

9.3.6 Garbage collection
A WebSocket object whose readyState attribute's value was set to CONNECTING (0) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for open events, message events, error events, or close events.

A WebSocket object whose readyState attribute's value was set to OPEN (1) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for message events, error, or close events.

A WebSocket object whose readyState attribute's value was set to CLOSING (2) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for error or close events.

A WebSocket object with an established connection that has data queued to be transmitted to the network must not be garbage collected. [WSP]

If a WebSocket object is garbage collected while its connection is still open, the user agent must start the WebSocket closing handshake, with no status code for the Close message. [WSP]

If a user agent is to make disappear a WebSocket object (this happens when a Document object goes away), the user agent must follow the first appropriate set of steps from the following list:

If the WebSocket connection is not yet established [WSP]
Fail the WebSocket connection. [WSP]

If the WebSocket closing handshake has not yet been started [WSP]
Start the WebSocket closing handshake, with the status code to use in the WebSocket Close message being 1001. [WSP]

Otherwise
Do nothing.

9.4 Cross-document messaging

Support: x-doc-messaging
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	3+
Samsung Internet	4+
IE (limited)	8+
Opera Mini	all+
Safari	4+
Edge	12+
Android Browser	2.1+
Opera	9.5+

Source: caniuse.com

Web browsers, for security and privacy reasons, prevent documents in different domains from affecting each other; that is, cross-site scripting is disallowed.

While this is an important security feature, it prevents pages from different domains from communicating even when those pages are not hostile. This section introduces a messaging system that allows documents to communicate with each other regardless of their source domain, in a way designed to not enable cross-site scripting attacks.

This API has some privacy implications that might not be immediately obvious.

The task source for the tasks in cross-document messaging is the posted message task source.

9.4.1 Introduction
This section is non-normative.

For example, if document A contains an iframe element that contains document B, and script in document A calls postMessage() on the Window object of document B, then a message event will be fired on that object, marked as originating from the Window of document A. The script in document A might look like:

var o = document.getElementsByTagName('iframe')[0];
o.contentWindow.postMessage('Hello world', 'https://b.example.org/');
To register an event handler for incoming events, the script would use addEventListener() (or similar mechanisms). For example, the script in document B might look like:

window.addEventListener('message', receiver, false);
function receiver(e) {
  if (e.origin == 'https://example.com') {
    if (e.data == 'Hello world') {
      e.source.postMessage('Hello', e.origin);
    } else {
      alert(e.data);
    }
  }
}
This script first checks the domain is the expected domain, and then looks at the message, which it either displays to the user, or responds to by sending a message back to the document which sent the message in the first place.

9.4.2 Security
9.4.2.1 Authors
Use of this API requires extra care to protect users from hostile entities abusing a site for their own purposes.

Authors should check the origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from. Otherwise, bugs in the author's message handling code could be exploited by hostile sites.

Furthermore, even after checking the origin attribute, authors should also check that the data in question is of the expected format. Otherwise, if the source of the event has been attacked using a cross-site scripting flaw, further unchecked processing of information sent using the postMessage() method could result in the attack being propagated into the receiver.

Authors should not use the wildcard keyword (*) in the targetOrigin argument in messages that contain any confidential information, as otherwise there is no way to guarantee that the message is only delivered to the recipient to which it was intended.

Authors who accept messages from any origin are encouraged to consider the risks of a denial-of-service attack. An attacker could send a high volume of messages; if the receiving page performs expensive computation or causes network traffic to be sent for each such message, the attacker's message could be multiplied into a denial-of-service attack. Authors are encouraged to employ rate limiting (only accepting a certain number of messages per minute) to make such attacks impractical.

9.4.2.2 User agents
The integrity of this API is based on the inability for scripts of one origin to post arbitrary events (using dispatchEvent() or otherwise) to objects in other origins (those that are not the same).

Implementors are urged to take extra care in the implementation of this feature. It allows authors to transmit information from one domain to another domain, which is normally disallowed for security reasons. It also requires that UAs be careful to allow access to certain properties but not others.

User agents are also encouraged to consider rate-limiting message traffic between different origins, to protect naïve sites from denial-of-service attacks.

9.4.3 Posting messages
window . postMessage(message, targetOrigin [, transfer ] )
Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.

Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.

If the origin of the target window doesn't match the given origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*". To restrict the message to same-origin targets only, without needing to explicitly state the origin, set the target origin to "/".

Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.

When posting a message to a Window of a browsing context that has just been navigated to a new Document is likely to result in the message not receiving its intended recipient: the scripts in the target browsing context have to have had time to set up listeners for the messages. Thus, for instance, in situations where a message is to be sent to the Window of newly created child iframe, authors are advised to have the child Document post a message to their parent announcing their readiness to receive messages, and for the parent to wait for this message before beginning posting messages.

The postMessage(message, targetOrigin, transfer) method, when invoked on a Window object must run the following steps:

Let targetWindow be this Window object.

Let targetRealm be targetWindow's Realm.

Let incumbentSettings be the incumbent settings object.

If targetOrigin is a single U+002F SOLIDUS character (/), then set targetOrigin to incumbentSettings's origin.

Otherwise, if targetOrigin is not a single U+002A ASTERISK character (*), then:

Let parsedURL be the result of running the URL parser on targetOrigin.

If parsedURL is failure, then throw a "SyntaxError" DOMException.

Set targetOrigin to parsedURL's origin.

Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.

Queue a task on the posted message task source to run the following steps:

If the targetOrigin argument is not a single literal U+002A ASTERISK character (*) and targetWindow's associated Document's origin is not same origin with targetOrigin, then return.

Let origin be the serialization of incumbentSettings's origin.

Let source be the WindowProxy object's corresponding to incumbentSettings's global object (a Window object).

Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).

If this throws an exception, catch it, fire an event named messageerror at targetWindow, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then return.

Let messageClone be deserializeRecord.[[Deserialized]].

Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.

Fire an event named message at targetWindow, using MessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.

9.5 Channel messaging

Support: channel-messaging
Chrome for Android	64+
Chrome	4+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	41+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	4.4+
Opera	10.6+

Source: caniuse.com

9.5.1 Introduction
This section is non-normative.

To enable independent pieces of code (e.g. running in different browsing contexts) to communicate directly, authors can use channel messaging.

Communication channels in this mechanism are implemented as two-ways pipes, with a port at each end. Messages sent in one port are delivered at the other port, and vice-versa. Messages are delivered as DOM events, without interrupting or blocking running tasks.

To create a connection (two "entangled" ports), the MessageChannel() constructor is called:

var channel = new MessageChannel();
One of the ports is kept as the local port, and the other port is sent to the remote code, e.g. using postMessage():

otherWindow.postMessage('hello', 'https://example.com', [channel.port2]);
To send messages, the postMessage() method on the port is used:

channel.port1.postMessage('hello');
To receive messages, one listens to message events:

channel.port1.onmessage = handleMessage;
function handleMessage(event) {
  // message is in event.data
  // ...
}
Data sent on a port can be structured data; for example here an array of strings is passed on a MessagePort:

port1.postMessage(['hello', 'world']);
9.5.1.1 Examples
This section is non-normative.

In this example, two JavaScript libraries are connected to each other using MessagePorts. This allows the libraries to later be hosted in different frames, or in Worker objects, without any change to the APIs.

<script src="contacts.js"></script> <!-- exposes a contacts object -->
<script src="compose-mail.js"></script> <!-- exposes a composer object -->
<script>
 var channel = new MessageChannel();
 composer.addContactsProvider(channel.port1);
 contacts.registerConsumer(channel.port2);
</script>
Here's what the "addContactsProvider()" function's implementation could look like:

function addContactsProvider(port) {
  port.onmessage = function (event) {
    switch (event.data.messageType) {
      'search-result': handleSearchResult(event.data.results); break;
      'search-done': handleSearchDone(); break;
      'search-error': handleSearchError(event.data.message); break;
      // ...
    }
  };
};
Alternatively, it could be implemented as follows:

function addContactsProvider(port) {
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-result')
      handleSearchResult(event.data.results);
  });
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-done')
      handleSearchDone();
  });
  port.addEventListener('message', function (event) {
    if (event.data.messageType == 'search-error')
      handleSearchError(event.data.message);
  });
  // ...
  port.start();
};
The key difference is that when using addEventListener(), the start() method must also be invoked. When using onmessage, the call to start() is implied.

The start() method, whether called explicitly or implicitly (by setting onmessage), starts the flow of messages: messages posted on message ports are initially paused, so that they don't get dropped on the floor before the script has had a chance to set up its handlers.

9.5.1.2 Ports as the basis of an object-capability model on the Web
This section is non-normative.

Ports can be viewed as a way to expose limited capabilities (in the object-capability model sense) to other actors in the system. This can either be a weak capability system, where the ports are merely used as a convenient model within a particular origin, or as a strong capability model, where they are provided by one origin provider as the only mechanism by which another origin consumer can effect change in or obtain information from provider.

For example, consider a situation in which a social Web site embeds in one iframe the user's e-mail contacts provider (an address book site, from a second origin), and in a second iframe a game (from a third origin). The outer social site and the game in the second iframe cannot access anything inside the first iframe; together they can only:

Navigate the iframe to a new URL, such as the same URL but with a different fragment, causing the Window in the iframe to receive a hashchange event.
Resize the iframe, causing the Window in the iframe to receive a resize event.
Send a message event to the Window in the iframe using the window.postMessage() API.
The contacts provider can use these methods, most particularly the third one, to provide an API that can be accessed by other origins to manipulate the user's address book. For example, it could respond to a message "add-contact Guillaume Tell <tell@pomme.example.net>" by adding the given person and e-mail address to the user's address book.

To avoid any site on the Web being able to manipulate the user's contacts, the contacts provider might only allow certain trusted sites, such as the social site, to do this.

Now suppose the game wanted to add a contact to the user's address book, and that the social site was willing to allow it to do so on its behalf, essentially "sharing" the trust that the contacts provider had with the social site. There are several ways it could do this; most simply, it could just proxy messages between the game site and the contacts site. However, this solution has a number of difficulties: it requires the social site to either completely trust the game site not to abuse the privilege, or it requires that the social site verify each request to make sure it's not a request that it doesn't want to allow (such as adding multiple contacts, reading the contacts, or deleting them); it also requires some additional complexity if there's ever the possibility of multiple games simultaneously trying to interact with the contacts provider.

Using message channels and MessagePort objects, however, all of these problems can go away. When the game tells the social site that it wants to add a contact, the social site can ask the contacts provider not for it to add a contact, but for the capability to add a single contact. The contacts provider then creates a pair of MessagePort objects, and sends one of them back to the social site, who forwards it on to the game. The game and the contacts provider then have a direct connection, and the contacts provider knows to only honor a single "add contact" request, nothing else. In other words, the game has been granted the capability to add a single contact.

9.5.1.3 Ports as the basis of abstracting out service implementations
This section is non-normative.

Continuing the example from the previous section, consider the contacts provider in particular. While an initial implementation might have simply used XMLHttpRequest objects in the service's iframe, an evolution of the service might instead want to use a shared worker with a single WebSocket connection.

If the initial design used MessagePort objects to grant capabilities, or even just to allow multiple simultaneous independent sessions, the service implementation can switch from the XMLHttpRequests-in-each-iframe model to the shared-WebSocket model without changing the API at all: the ports on the service provider side can all be forwarded to the shared worker without it affecting the users of the API in the slightest.

9.5.2 Message channels
[Constructor, Exposed=(Window,Worker)]
interface MessageChannel {
  readonly attribute MessagePort port1;
  readonly attribute MessagePort port2;
};
channel = new MessageChannel()
Returns a new MessageChannel object with two new MessagePort objects.

channel . port1
Returns the first MessagePort object.

channel . port2
Returns the second MessagePort object.

When the MessageChannel() constructor is called, it must run the following algorithm:

Create a new MessagePort object whose owner is the incumbent settings object, and let port1 be that object.

Create a new MessagePort object whose owner is the incumbent settings object, and let port2 be that object.

Entangle the port1 and port2 objects.

Instantiate a new MessageChannel object, and let channel be that object.

Let the port1 attribute of the channel object be port1.

Let the port2 attribute of the channel object be port2.

Return channel.

The port1 and port2 attributes must return the values they were assigned when the MessageChannel object was created.

9.5.3 Message ports
Each channel has two message ports. Data sent through one port is received by the other port, and vice versa.

[Exposed=(Window,Worker,AudioWorklet), Transferable]
interface MessagePort : EventTarget {
  void postMessage(any message, optional sequence<object> transfer = []);
  void start();
  void close();

  // event handlers
  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
};
port . postMessage(message [, transfer] )
Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.

Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or the source or target ports, or if message could not be cloned.

port . start()
Begins dispatching messages received on the port.

port . close()
Disconnects the port, so that it is no longer active.

Each MessagePort object can be entangled with another (a symmetric relationship). Each MessagePort object also has a task source called the port message queue, initially empty. A port message queue can be enabled or disabled, and is initially disabled. Once enabled, a port can never be disabled again (though messages in the queue can get moved to another queue or removed altogether, which has much the same effect). A MessagePort also has a has been shipped flag, which must initially be false, and an owner, which is a settings object set when the object is created, as described below.

When a port's port message queue is enabled, the event loop must use it as one of its task sources. When a port's owner specifies a responsible event loop that is a browsing context event loop, all tasks queued on its port message queue must be associated with the responsible document specified by the port's owner.

If the port's owner specifies a responsible document that is fully active, but the event listeners all have scripts whose settings objects specify responsible documents that are not fully active, then the messages will be lost.

Each event loop has a task source called the unshipped port message queue. This is a virtual task source: it must act as if it contained the tasks of each port message queue of each MessagePort whose has been shipped flag is false, whose port message queue is enabled, and whose owner specifies that event loop as the responsible event loop, in the order in which they were added to their respective task source. When a task would be removed from the unshipped port message queue, it must instead be removed from its port message queue.

When a MessagePort's has been shipped flag is false, its port message queue must be ignored for the purposes of the event loop. (The unshipped port message queue is used instead.)

The has been shipped flag is set to true when a port, its twin, or the object it was cloned from, is or has been transferred. When a MessagePort's has been shipped flag is true, its port message queue acts as a first-class task source, unaffected to any unshipped port message queue.

When the user agent is to create a new MessagePort object with a particular environment settings object as its owner, it must instantiate a new MessagePort object, and let its owner be owner.

When the user agent is to entangle two MessagePort objects, it must run the following steps:

If one of the ports is already entangled, then disentangle it and the port that it was entangled with.

If those two previously entangled ports were the two ports of a MessageChannel object, then that MessageChannel object no longer represents an actual channel: the two ports in that object are no longer entangled.

Associate the two ports to be entangled, so that they form the two parts of a new channel. (There is no MessageChannel object that represents this channel.)

Two ports A and B that have gone through this step are now said to be entangled; one is entangled to the other, and vice versa.

While this specification describes this process as instantaneous, implementations are more likely to implement it via message passing. As with all algorithms, the key is "merely" that the end result be indistinguishable, in a black-box sense, from the specification.

MessagePort objects are transferable objects. Their transfer steps, given value and dataHolder, are:

Set value's has been shipped flag to true.

Set dataHolder.[[PortMessageQueue]] to value's port message queue.

If value is entangled with another port remotePort, then:

Set remotePort's has been shipped flag to true.

Set dataHolder.[[RemotePort]] to remotePort.

Otherwise, set dataHolder.[[RemotePort]] to null.

Their transfer-receiving steps, given dataHolder and value, are:

Set value's has been shipped flag to true.

Set value's owner to value's relevant settings object.

Move all the tasks that are to fire message events in dataHolder.[[PortMessageQueue]] to the port message queue of value, if any, leaving value's port message queue in its initial disabled state, and, if value's owner specifies a responsible event loop that is a browsing context event loop, associating the moved tasks with the responsible document specified by value's owner.

If dataHolder.[[RemotePort]] is not null, then entangle dataHolder.[[RemotePort]] and value. (This will disentangle dataHolder.[[RemotePort]] from the original port that was transferred.)

The postMessage(message, transfer) method, when invoked on a MessagePort object, must run the following steps:

Let targetPort be the port with which this MessagePort is entangled, if any; otherwise let it be null.

If any of the objects in transfer are this MessagePort, then throw a "DataCloneError" DOMException.

Let doomed be false.

If targetPort is not null and any of the objects in transfer are targetPort, then set doomed to true, and optionally report to a developer console that the target port was posted to itself, causing the communication channel to be lost.

Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.

If there is no targetPort (i.e. if this MessagePort is not entangled), or if doomed is true, then return.

Add a task that runs the following steps to the port message queue of targetPort:

Let finalTargetPort be the MessagePort in whose port message queue the task now finds itself.

This can be different from targetPort, if targetPort itself was transferred and thus all its tasks moved along with it.

Let targetRealm be finalTargetPort's relevant Realm.

Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).

If this throws an exception, catch it, fire an event named messageerror at finalTargetPort, using MessageEvent, and then return.

Let messageClone be deserializeRecord.[[Deserialized]].

Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.

Fire an event named message at finalTargetPort, using MessageEvent, with the data attribute initialized to messageClone and the ports attribute initialized to newPorts.

The start() method must enable its port's port message queue, if it is not already enabled.

The close() method, when called on a port local port that is entangled with another port, must cause the user agent to disentangle the two ports. If the method is called on a port that is not entangled, then the method must do nothing.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MessagePort interface:

Event handler	Event handler event type
onmessage	message
onmessageerror	messageerror
The first time a MessagePort object's onmessage IDL attribute is set, the port's port message queue must be enabled, as if the start() method had been called.

9.5.4 Broadcasting to many ports
This section is non-normative.

Broadcasting to many ports is in principle relatively simple: keep an array of MessagePort objects to send messages to, and iterate through the array to send a message. However, this has one rather unfortunate effect: it prevents the ports from being garbage collected, even if the other side has gone away. To avoid this problem, implement a simple protocol whereby the other side acknowledges it still exists. If it doesn't do so after a certain amount of time, assume it's gone, close the MessagePort object, and let it be garbage collected.

9.5.5 Ports and garbage collection
When a MessagePort object o is entangled, user agents must either act as if o's entangled MessagePort object has a strong reference to o, or as if the global object specified by o's owner has a strong reference to o.

Thus, a message port can be received, given an event listener, and then forgotten, and so long as that event listener could receive a message, the channel will be maintained.

Of course, if this was to occur on both sides of the channel, then both ports could be garbage collected, since they would not be reachable from live code, despite having a strong reference to each other.

Furthermore, a MessagePort object must not be garbage collected while there exists an event referenced by a task in a task queue that is to be dispatched on that MessagePort object, or while the MessagePort object's port message queue is enabled and not empty.

Authors are strongly encouraged to explicitly close MessagePort objects to disentangle them, so that their resources can be recollected. Creating many MessagePort objects and discarding them without closing them can lead to high transient memory usage since garbage collection is not necessarily performed promptly, especially for MessagePorts where garbage collection can involve cross-process coordination.

9.6 Broadcasting to other browsing contexts

Support: broadcastchannel
Chrome for Android	64+
Chrome	54+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	38+
Samsung Internet	None
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	62+
Opera	41+

Source: caniuse.com

Pages on a single origin opened by the same user in the same user agent but in different unrelated browsing contexts sometimes need to send notifications to each other, for example "hey, the user logged in over here, check your credentials again".

For elaborate cases, e.g. to manage locking of shared state, to manage synchronization of resources between a server and multiple local clients, to share a WebSocket connection with a remote host, and so forth, shared workers are the most appropriate solution.

For simple cases, though, where a shared worker would be an unreasonable overhead, authors can use the simple channel-based broadcast mechanism described in this section.

[Constructor(DOMString name), Exposed=(Window,Worker)]
interface BroadcastChannel : EventTarget {
  readonly attribute DOMString name;
  void postMessage(any message);
  void close();
  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
};
broadcastChannel = new BroadcastChannel(name)
Returns a new BroadcastChannel object via which messages for the given channel name can be sent and received.

broadcastChannel . name
Returns the channel name (as passed to the constructor).

broadcastChannel . postMessage(message)
Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.

broadcastChannel . close()
Closes the BroadcastChannel object, opening it up to garbage collection.

A BroadcastChannel object has a channel name, a BroadcastChannel settings object, and a closed flag.

The BroadcastChannel() constructor, when invoked, must create and return a BroadcastChannel object whose channel name is the constructor's first argument, whose BroadcastChannel settings object is the incumbent settings object, and whose closed flag is false.

The name attribute must return the channel name.

The postMessage(message) method, when invoked on a BroadcastChannel object, must run the following steps:

Let source be this BroadcastChannel.

Let sourceSettings be source's BroadcastChannel settings object.

If source's closed flag is true, then throw an "InvalidStateError" DOMException.

Let sourceChannel be source's channel name.

Let targetRealm be a user-agent defined Realm.

Let serialized be StructuredSerialize(message). Rethrow any exceptions.

Let destinations be a list of BroadcastChannel objects that match the following criteria:

Their BroadcastChannel settings object specifies either:

a global object that is a Window object and a responsible document that is fully active, or

a global object that is a WorkerGlobalScope object whose closing flag is false and whose worker is not a suspendable worker.

Their BroadcastChannel settings object's origin is same origin with sourceSettings's origin.

Their channel name is a case-sensitive match for sourceChannel.

Their closed flag is false.

Remove source from destinations.

Sort destinations such that all BroadcastChannel objects whose BroadcastChannel settings objects specify the same responsible event loop are sorted in creation order, oldest first. (This does not define a complete ordering. Within this constraint, user agents may sort the list in any user-agent defined manner.)

For each BroadcastChannel object destination in destinations, queue a task that runs the following steps:

Let targetRealm be destination's relevant Realm.

Let data be StructuredDeserialize(serialized, targetRealm).

If this throws an exception, catch it, fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to the serialization of sourceSettings's origin, and then return.

Fire an event named message at destination, using MessageEvent, with the data attribute initialized to data and the origin attribute initialized to the serialization of sourceSettings's origin.

The tasks must use the DOM manipulation task source, and, for those where the event loop specified by the target BroadcastChannel object's BroadcastChannel settings object is a browsing context event loop, must be associated with the responsible document specified by that target BroadcastChannel object's BroadcastChannel settings object.

While a BroadcastChannel object whose closed flag is false has an event listener registered for message events, there must be a strong reference from global object specified by the BroadcastChannel object's BroadcastChannel settings object to the BroadcastChannel object itself.

The close() method must set the closed flag of the BroadcastChannel object on which it was invoked to true.

Authors are strongly encouraged to explicitly close BroadcastChannel objects when they are no longer needed, so that they can be garbage collected. Creating many BroadcastChannel objects and discarding them while leaving them with an event listener and without closing them can lead to an apparent memory leak, since the objects will continue to live for as long as they have an event listener (or until their page or worker is closed).

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the BroadcastChannel interface:

Event handler	Event handler event type
onmessage	message
onmessageerror	messageerror
Suppose a page wants to know when the user logs out, even when the user does so from another tab at the same site:

var authChannel = new BroadcastChannel('auth');
authChannel.onmessage = function (event) {
  if (event.data == 'logout')
    showLogout();
}

function logoutRequested() {
  // called when the user asks us to log them out
  doLogout();
  showLogout();
  authChannel.postMessage('logout');
}

function doLogout() {
  // actually log the user out (e.g. clearing cookies)
  // ...
}

function showLogout() {
  // update the UI to indicate we're logged out
  // ...
}
10 Web workers
10.1 Introduction
10.1.1 Scope
This section is non-normative.

This specification defines an API for running scripts in the background independently of any user interface scripts.

This allows for long-running scripts that are not interrupted by scripts that respond to clicks or other user interactions, and allows long tasks to be executed without yielding to keep the page responsive.

Workers (as these background scripts are called herein) are relatively heavy-weight, and are not intended to be used in large numbers. For example, it would be inappropriate to launch one worker for each pixel of a four megapixel image. The examples below show some appropriate uses of workers.

Generally, workers are expected to be long-lived, have a high start-up performance cost, and a high per-instance memory cost.

10.1.2 Examples
This section is non-normative.

There are a variety of uses that workers can be put to. The following subsections show various examples of this use.

10.1.2.1 A background number-crunching worker
This section is non-normative.

The simplest use of workers is for performing a computationally expensive task without interrupting the user interface.

In this example, the main document spawns a worker to (naïvely) compute prime numbers, and progressively displays the most recently found prime number.

The main page is as follows:

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Worker example: One-core computation</title>
 </head>
 <body>
  <p>The highest prime number discovered so far is: <output id="result"></output></p>
  <script>
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  </script>
 </body>
</html>
The Worker() constructor call creates a worker and returns a Worker object representing that worker, which is used to communicate with the worker. That object's onmessage event handler allows the code to receive messages from the worker.

The worker itself is as follows:

var n = 1;
search: while (true) {
  n += 1;
  for (var i = 2; i <= Math.sqrt(n); i += 1)
    if (n % i == 0)
     continue search;
  // found a prime!
  postMessage(n);
}
The bulk of this code is simply an unoptimized search for a prime number. The postMessage() method is used to send a message back to the page when a prime is found.

View this example online.

10.1.2.2 Using a JavaScript module as a worker
This section is non-normative.

All of our examples so far show workers that run classic scripts. Workers can instead be instantiated using module scripts, which have the usual benefits: the ability to use the JavaScript import statement to import other modules; strict mode by default; and top-level declarations not polluting the worker's global scope.

Note that such module-based workers follow different restrictions regarding cross-origin content, compared to classic workers. Unlike classic workers, module workers can be instantiated using a cross-origin script, as long as that script is exposed using the CORS protocol. Additionally, the importScripts() method will automatically fail inside module workers; the JavaScript import statement is generally a better choice.

In this example, the main document uses a worker to do off-main-thread image manipulation. It imports the filters used from another module.

The main page is as follows:

<!DOCTYPE html>
<meta charset="utf-8">
<title>Worker example: image decoding</title>

<p>
  <label>
    Type an image URL to decode
    <input type="url" id="image-url" list="image-list">
    <datalist id="image-list">
      <option value="https://html.spec.whatwg.org/images/drawImage.png">
      <option value="https://html.spec.whatwg.org/images/robots.jpeg">
      <option value="https://html.spec.whatwg.org/images/arcTo2.png">
    </datalist>
  </label>
</p>

<p>
  <label>
    Choose a filter to apply
    <select id="filter">
      <option value="none">none</option>
      <option value="grayscale">grayscale</option>
      <option value="brighten">brighten by 20%</option>
    </select>
  </label>
</p>

<canvas id="output"></canvas>

<script type="module">
  const worker = new Worker("worker.js", { type: "module" });
  worker.onmessage = receiveFromWorker;

  const url = document.querySelector("#image-url");
  const filter = document.querySelector("#filter");
  const output = document.querySelector("#output");

  url.oninput = updateImage;
  filter.oninput = sendToWorker;

  let imageData, context;

  function updateImage() {
    const img = new Image();
    img.src = url.value;

    img.onload = () => {
      output.innerHTML = "";

      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;

      context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);

      sendToWorker();
      output.appendChild(canvas);
    };
  }

  function sendToWorker() {
    worker.postMessage({ imageData, filter: filter.value });
  }

  function receiveFromWorker(e) {
    context.putImageData(e.data, 0, 0);
  }
</script>
The worker file is then:

import * as filters from "./filters.js";

self.onmessage = e => {
  const { imageData, filter } = e.data;
  filters[filter](imageData);
  self.postMessage(imageData, [imageData.data.buffer]);
};
Which imports the file filters.js:

export function none() {}

export function grayscale({ data: d }) {
  for (let i = 0; i < d.length; i += 4) {
    const [r, g, b] = [d[i], d[i + 1], d[i + 2]];

    // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.
    d[i] = d[i + 1] = d[i + 2] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
};

export function brighten({ data: d }) {
  for (let i = 0; i < d.length; ++i) {
    d[i] *= 1.2;
  }
};
View this example online.

10.1.2.3 Shared workers introduction

Support: sharedworkers
Chrome for Android	None
Chrome	4+
iOS Safari	None
UC Browser for Android	11.8+
Firefox	29+
Samsung Internet	None
IE	None
Opera Mini	None
Safari	None
Edge	None
Android Browser	None
Opera	10.6+

Source: caniuse.com

This section is non-normative.

This section introduces shared workers using a Hello World example. Shared workers use slightly different APIs, since each worker can have multiple connections.

This first example shows how you connect to a worker and how a worker can send a message back to the page when it connects to it. Received messages are displayed in a log.

Here is the HTML page:

<!DOCTYPE HTML>
<meta charset="utf-8">
<title>Shared workers: demo 1</title>
<pre id="log">Log:</pre>
<script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) { // note: not worker.onmessage!
    log.textContent += '\n' + e.data;
  }
</script>
Here is the JavaScript worker:

onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
}
View this example online.

This second example extends the first one by changing two things: first, messages are received using addEventListener() instead of an event handler IDL attribute, and second, a message is sent to the worker, causing the worker to send another message in return. Received messages are again displayed in a log.

Here is the HTML page:

<!DOCTYPE HTML>
<meta charset="utf-8">
<title>Shared workers: demo 2</title>
<pre id="log">Log:</pre>
<script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start(); // note: need this when using addEventListener
  worker.port.postMessage('ping');
</script>
Here is the JavaScript worker:

onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
  port.onmessage = function(e) {
    port.postMessage('pong'); // not e.ports[0].postMessage!
    // e.target.postMessage('pong'); would work also
  }
}
View this example online.

Finally, the example is extended to show how two pages can connect to the same worker; in this case, the second page is merely in an iframe on the first page, but the same principle would apply to an entirely separate page in a separate top-level browsing context.

Here is the outer HTML page:

<!DOCTYPE HTML>
<meta charset="utf-8">
<title>Shared workers: demo 3</title>
<pre id="log">Log:</pre>
<script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start();
  worker.port.postMessage('ping');
</script>
<iframe src="inner.html"></iframe>
Here is the inner HTML page:

<!DOCTYPE HTML>
<meta charset="utf-8">
<title>Shared workers: demo 3 inner frame</title>
<pre id=log>Inner log:</pre>
<script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) {
   log.textContent += '\n' + e.data;
  }
</script>
Here is the JavaScript worker:

var count = 0;
onconnect = function(e) {
  count += 1;
  var port = e.ports[0];
  port.postMessage('Hello World! You are connection #' + count);
  port.onmessage = function(e) {
    port.postMessage('pong');
  }
}
View this example online.

10.1.2.4 Shared state using a shared worker
This section is non-normative.

In this example, multiple windows (viewers) can be opened that are all viewing the same map. All the windows share the same map information, with a single worker coordinating all the viewers. Each viewer can move around independently, but if they set any data on the map, all the viewers are updated.

The main page isn't interesting, it merely provides a way to open the viewers:

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Workers example: Multiviewer</title>
  <script>
   function openViewer() {
     window.open('viewer.html');
   }
  </script>
 </head>
 <body>
  <p><button type=button onclick="openViewer()">Open a new
  viewer</button></p>
  <p>Each viewer opens in a new window. You can have as many viewers
  as you like, they all view the same data.</p>
 </body>
</html>
The viewer is more involved:

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Workers example: Multiviewer viewer</title>
  <script>
   var worker = new SharedWorker('worker.js', 'core');

   // CONFIGURATION
   function configure(event) {
     if (event.data.substr(0, 4) != 'cfg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     // update display to mention our name is name
     document.getElementsByTagName('h1')[0].textContent += ' ' + name;
     // no longer need this listener
     worker.port.removeEventListener('message', configure, false);
   }
   worker.port.addEventListener('message', configure, false);

   // MAP
   function paintMap(event) {
     if (event.data.substr(0, 4) != 'map ') return;
     var data = event.data.substr(4).split(',');
     // display tiles data[0] .. data[8]
     var canvas = document.getElementById('map');
     var context = canvas.getContext('2d');
     for (var y = 0; y < 3; y += 1) {
       for (var x = 0; x < 3; x += 1) {
         var tile = data[y * 3 + x];
         if (tile == '0')
           context.fillStyle = 'green';
         else
           context.fillStyle = 'maroon';
         context.fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   worker.port.addEventListener('message', paintMap, false);

   // PUBLIC CHAT
   function updatePublicChat(event) {
     if (event.data.substr(0, 4) != 'txt ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var message = event.data.substr(4 + name.length + 1);
     // display "<name> message" in public chat
     var public = document.getElementById('public');
     var p = document.createElement('p');
     var n = document.createElement('button');
     n.textContent = '<' + name + '> ';
     n.onclick = function () { worker.port.postMessage('msg ' + name); };
     p.appendChild(n);
     var m = document.createElement('span');
     m.textContent = message;
     p.appendChild(m);
     public.appendChild(p);
   }
   worker.port.addEventListener('message', updatePublicChat, false);

   // PRIVATE CHAT
   function startPrivateChat(event) {
     if (event.data.substr(0, 4) != 'msg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var port = event.ports[0];
     // display a private chat UI
     var ul = document.getElementById('private');
     var li = document.createElement('li');
     var h3 = document.createElement('h3');
     h3.textContent = 'Private chat with ' + name;
     li.appendChild(h3);
     var div = document.createElement('div');
     var addMessage = function(name, message) {
       var p = document.createElement('p');
       var n = document.createElement('strong');
       n.textContent = '<' + name + '> ';
       p.appendChild(n);
       var t = document.createElement('span');
       t.textContent = message;
       p.appendChild(t);
       div.appendChild(p);
     };
     port.onmessage = function (event) {
       addMessage(name, event.data);
     };
     li.appendChild(div);
     var form = document.createElement('form');
     var p = document.createElement('p');
     var input = document.createElement('input');
     input.size = 50;
     p.appendChild(input);
     p.appendChild(document.createTextNode(' '));
     var button = document.createElement('button');
     button.textContent = 'Post';
     p.appendChild(button);
     form.onsubmit = function () {
       port.postMessage(input.value);
       addMessage('me', input.value);
       input.value = '';
       return false;
     };
     form.appendChild(p);
     li.appendChild(form);
     ul.appendChild(li);
   }
   worker.port.addEventListener('message', startPrivateChat, false);

   worker.port.start();
  </script>
 </head>
 <body>
  <h1>Viewer</h1>
  <h2>Map</h2>
  <p><canvas id="map" height=150 width=150></canvas></p>
  <p>
   <button type=button onclick="worker.port.postMessage('mov left')">Left</button>
   <button type=button onclick="worker.port.postMessage('mov up')">Up</button>
   <button type=button onclick="worker.port.postMessage('mov down')">Down</button>
   <button type=button onclick="worker.port.postMessage('mov right')">Right</button>
   <button type=button onclick="worker.port.postMessage('set 0')">Set 0</button>
   <button type=button onclick="worker.port.postMessage('set 1')">Set 1</button>
  </p>
  <h2>Public Chat</h2>
  <div id="public"></div>
  <form onsubmit="worker.port.postMessage('txt ' + message.value); message.value = ''; return false;">
   <p>
    <input type="text" name="message" size="50">
    <button>Post</button>
   </p>
  </form>
  <h2>Private Chat</h2>
  <ul id="private"></ul>
 </body>
</html>
There are several key things worth noting about the way the viewer is written.

Multiple listeners. Instead of a single message processing function, the code here attaches multiple event listeners, each one performing a quick check to see if it is relevant for the message. In this example it doesn't make much difference, but if multiple authors wanted to collaborate using a single port to communicate with a worker, it would allow for independent code instead of changes having to all be made to a single event handling function.

Registering event listeners in this way also allows you to unregister specific listeners when you are done with them, as is done with the configure() method in this example.

Finally, the worker:

var nextName = 0;
function getNextName() {
  // this could use more friendly names
  // but for now just return a number
  return nextName++;
}

var map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(x) {
  if (x < 0) return wrapX(x + map[0].length);
  if (x >= map[0].length) return wrapX(x - map[0].length);
  return x;
}

function wrapY(y) {
  if (y < 0) return wrapY(y + map.length);
  if (y >= map[0].length) return wrapY(y - map.length);
  return y;
}

function wrap(val, min, max) {
  if (val < min)
    return val + (max-min)+1;
  if (val > max)
    return val - (max-min)-1;
  return val;
}

function sendMapData(viewer) {
  var data = '';
  for (var y = viewer.y-1; y <= viewer.y+1; y += 1) {
    for (var x = viewer.x-1; x <= viewer.x+1; x += 1) {
      if (data != '')
        data += ',';
      data += map[wrap(y, 0, map[0].length-1)][wrap(x, 0, map.length-1)];
    }
  }
  viewer.port.postMessage('map ' + data);
}

var viewers = {};
onconnect = function (event) {
  var name = getNextName();
  event.ports[0]._data = { port: event.ports[0], name: name, x: 0, y: 0, };
  viewers[name] = event.ports[0]._data;
  event.ports[0].postMessage('cfg ' + name);
  event.ports[0].onmessage = getMessage;
  sendMapData(event.ports[0]._data);
};

function getMessage(event) {
  switch (event.data.substr(0, 4)) {
    case 'mov ':
      var direction = event.data.substr(4);
      var dx = 0;
      var dy = 0;
      switch (direction) {
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
        case 'left': dx = -1; break;
        case 'right': dx = 1; break;
      }
      event.target._data.x = wrapX(event.target._data.x + dx);
      event.target._data.y = wrapY(event.target._data.y + dy);
      sendMapData(event.target._data);
      break;
    case 'set ':
      var value = event.data.substr(4);
      map[event.target._data.y][event.target._data.x] = value;
      for (var viewer in viewers)
        sendMapData(viewers[viewer]);
      break;
    case 'txt ':
      var name = event.target._data.name;
      var message = event.data.substr(4);
      for (var viewer in viewers)
        viewers[viewer].port.postMessage('txt ' + name + ' ' + message);
      break;
    case 'msg ':
      var party1 = event.target._data;
      var party2 = viewers[event.data.substr(4).split(' ', 1)[0]];
      if (party2) {
        var channel = new MessageChannel();
        party1.port.postMessage('msg ' + party2.name, [channel.port1]);
        party2.port.postMessage('msg ' + party1.name, [channel.port2]);
      }
      break;
  }
}
Connecting to multiple pages. The script uses the onconnect event listener to listen for multiple connections.

Direct channels. When the worker receives a "msg" message from one viewer naming another viewer, it sets up a direct connection between the two, so that the two viewers can communicate directly without the worker having to proxy all the messages.

View this example online.

10.1.2.5 Delegation
This section is non-normative.

With multicore CPUs becoming prevalent, one way to obtain better performance is to split computationally expensive tasks amongst multiple workers. In this example, a computationally expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten subworkers.

The main page is as follows, it just reports the result:

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Worker example: Multicore computation</title>
 </head>
 <body>
  <p>Result: <output id="result"></output></p>
  <script>
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  </script>
 </body>
</html>
The worker itself is as follows:

// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i < num_workers; i += 1) {
  var worker = new Worker('core.js');
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i+1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += 1*event.data;
  pending_workers -= 1;
  if (pending_workers <= 0)
    postMessage(result); // finished!
}
It consists of a loop to start the subworkers, and then a handler that waits for all the subworkers to respond.

The subworkers are implemented as follows:

var start;
onmessage = getStart;
function getStart(event) {
  start = 1*event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = 1*event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i < end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}
They receive two numbers in two events, perform the computation for the range of numbers thus specified, and then report the result back to the parent.

View this example online.

10.1.2.6 Providing libraries
This section is non-normative.

Suppose that a cryptography library is made available that provides three tasks:

Generate a public/private key pair
Takes a port, on which it will send two messages, first the public key and then the private key.
Given a plaintext and a public key, return the corresponding ciphertext
Takes a port, to which any number of messages can be sent, the first giving the public key, and the remainder giving the plaintext, each of which is encrypted and then sent on that same channel as the ciphertext. The user can close the port when it is done encrypting content.
Given a ciphertext and a private key, return the corresponding plaintext
Takes a port, to which any number of messages can be sent, the first giving the private key, and the remainder giving the ciphertext, each of which is decrypted and then sent on that same channel as the plaintext. The user can close the port when it is done decrypting content.
The library itself is as follows:

function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.ports[0]);
  else if (e.data == "encrypt")
    encrypt(e.ports[0]);
  else if (e.data == "decrypt")
    decrypt(e.ports[0]);
}

function genkeys(p) {
  var keys = _generateKeyPair();
  p.postMessage(keys[0]);
  p.postMessage(keys[1]);
}

function encrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_encrypt(key, e.data));
    }
  };
}

function decrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_decrypt(key, e.data));
    }
  };
}

// support being used as a shared worker as well as a dedicated worker
if ('onmessage' in this) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.port.onmessage = handleMessage; }


// the "crypto" functions:

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}
Note that the crypto functions here are just stubs and don't do real cryptography.

This library could be used as follows:

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Worker example: Crypto library</title>
  <script>
   const cryptoLib = new Worker('libcrypto-v1.js'); // or could use 'libcrypto-v2.js'
   function startConversation(source, message) {
     const messageChannel = new MessageChannel();
     source.postMessage(message, [messageChannel.port2]);
     return messageChannel.port1;
   }
   function getKeys() {
     let state = 0;
     startConversation(cryptoLib, "genkeys").onmessage = function (e) {
       if (state === 0)
         document.getElementById('public').value = e.data;
       else if (state === 1)
         document.getElementById('private').value = e.data;
       state += 1;
     };
   }
   function enc() {
     const port = startConversation(cryptoLib, "encrypt");
     port.postMessage(document.getElementById('public').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
   function dec() {
     const port = startConversation(cryptoLib, "decrypt");
     port.postMessage(document.getElementById('private').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
  </script>
  <style>
   textarea { display: block; }
  </style>
 </head>
 <body onload="getKeys()">
  <fieldset>
   <legend>Keys</legend>
   <p><label>Public Key: <textarea id="public"></textarea></label></p>
   <p><label>Private Key: <textarea id="private"></textarea></label></p>
  </fieldset>
  <p><label>Input: <textarea id="input"></textarea></label></p>
  <p><button onclick="enc()">Encrypt</button> <button onclick="dec()">Decrypt</button></p>
 </body>
</html>
A later version of the API, though, might want to offload all the crypto work onto subworkers. This could be done as follows:

function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.ports[0]);
  else if (e.data == "encrypt")
    encrypt(e.ports[0]);
  else if (e.data == "decrypt")
    decrypt(e.ports[0]);
}

function genkeys(p) {
  var generator = new Worker('libcrypto-v2-generator.js');
  generator.postMessage('', [p]);
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var encryptor = new Worker('libcrypto-v2-encryptor.js');
    encryptor.postMessage(key, [p]);
  };
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var decryptor = new Worker('libcrypto-v2-decryptor.js');
    decryptor.postMessage(key, [p]);
  };
}

// support being used as a shared worker as well as a dedicated worker
if ('onmessage' in this) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.ports[0].onmessage = handleMessage };
The little subworkers would then be as follows.

For generating key pairs:

onmessage = function (e) {
  var k = _generateKeyPair();
  e.ports[0].postMessage(k[0]);
  e.ports[0].postMessage(k[1]);
  close();
}

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}
For encrypting:

onmessage = function (e) {
  var key = e.data;
  e.ports[0].onmessage = function (e) {
    var s = e.data;
    postMessage(_encrypt(key, s));
  }
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}
For decrypting:

onmessage = function (e) {
  var key = e.data;
  e.ports[0].onmessage = function (e) {
    var s = e.data;
    postMessage(_decrypt(key, s));
  }
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}
Notice how the users of the API don't have to even know that this is happening — the API hasn't changed; the library can delegate to subworkers without changing its API, even though it is accepting data using message channels.

View this example online.

10.1.3 Tutorials
10.1.3.1 Creating a dedicated worker
This section is non-normative.

Creating a worker requires a URL to a JavaScript file. The Worker() constructor is invoked with the URL to that file as its only argument; a worker is then created and returned:

var worker = new Worker('helper.js');
If you want your worker script to be interpreted as a module script instead of the default classic script, you need to use a slightly different signature:

var worker = new Worker('helper.js', { type: "module" });
10.1.3.2 Communicating with a dedicated worker
This section is non-normative.

Dedicated workers use MessagePort objects behind the scenes, and thus support all the same features, such as sending structured data, transferring binary data, and transferring other ports.

To receive messages from a dedicated worker, use the onmessage event handler IDL attribute on the Worker object:

worker.onmessage = function (event) { ... };
You can also use the addEventListener() method.

The implicit MessagePort used by dedicated workers has its port message queue implicitly enabled when it is created, so there is no equivalent to the MessagePort interface's start() method on the Worker interface.

To send data to a worker, use the postMessage() method. Structured data can be sent over this communication channel. To send ArrayBuffer objects efficiently (by transferring them rather than cloning them), list them in an array in the second argument.

worker.postMessage({
  operation: 'find-edges',
  input: buffer, // an ArrayBuffer object
  threshold: 0.6,
}, [buffer]);
To receive a message inside the worker, the onmessage event handler IDL attribute is used.

onmessage = function (event) { ... };
You can again also use the addEventListener() method.

In either case, the data is provided in the event object's data attribute.

To send messages back, you again use postMessage(). It supports the structured data in the same manner.

postMessage(event.data.input, [event.data.input]); // transfer the buffer back
10.1.3.3 Shared workers
This section is non-normative.

Shared workers are identified by the URL of the script used to create it, optionally with an explicit name. The name allows multiple instances of a particular shared worker to be started.

Shared workers are scoped by origin. Two different sites using the same names will not collide. However, if a page tries to use the same shared worker name as another page on the same site, but with a different script URL, it will fail.

Creating shared workers is done using the SharedWorker() constructor. This constructor takes the URL to the script to use for its first argument, and the name of the worker, if any, as the second argument.

var worker = new SharedWorker('service.js');
Communicating with shared workers is done with explicit MessagePort objects. The object returned by the SharedWorker() constructor holds a reference to the port on its port attribute.

worker.port.onmessage = function (event) { ... };
worker.port.postMessage('some message');
worker.port.postMessage({ foo: 'structured', bar: ['data', 'also', 'possible']});
Inside the shared worker, new clients of the worker are announced using the connect event. The port for the new client is given by the event object's source attribute.

onconnect = function (event) {
  var newPort = event.source;
  // set up a listener
  newPort.onmessage = function (event) { ... };
  // send a message back to the port
  newPort.postMessage('ready!'); // can also send structured data, of course
};
10.2 Infrastructure
There are two kinds of workers; dedicated workers, and shared workers. Dedicated workers, once created, are linked to their creator; but message ports can be used to communicate from a dedicated worker to multiple other browsing contexts or workers. Shared workers, on the other hand, are named, and once created any script running in the same origin can obtain a reference to that worker and communicate with it.

10.2.1 The global scope
The global scope is the "inside" of a worker.

10.2.1.1 The WorkerGlobalScope common interface
[Exposed=Worker]
interface WorkerGlobalScope : EventTarget {
  readonly attribute WorkerGlobalScope self;
  readonly attribute WorkerLocation location;
  readonly attribute WorkerNavigator navigator;
  void importScripts(USVString... urls);

  attribute OnErrorEventHandler onerror;
  attribute EventHandler onlanguagechange;
  attribute EventHandler onoffline;
  attribute EventHandler ononline;
  attribute EventHandler onrejectionhandled;
  attribute EventHandler onunhandledrejection;
};
WorkerGlobalScope serves as the base class for specific types of worker global scope objects, including DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, and ServiceWorkerGlobalScope.

A WorkerGlobalScope object has an associated owner set (a set of Document and WorkerGlobalScope objects). It is initially empty and populated when the worker is created or obtained.

It is a set, instead of a single owner, to accomodate SharedWorkerGlobalScope objects.

A WorkerGlobalScope object has an associated worker set (a set of WorkerGlobalScope objects). It is initially empty and populated when the worker creates or obtains further workers.

A WorkerGlobalScope object has an associated type ("classic" or "module"). It is set during creation.

A WorkerGlobalScope object has an associated url (null or a URL). It is initially null.

A WorkerGlobalScope object has an associated name (a string). It is set during creation.

The name can have different semantics for each subclass of WorkerGlobalScope. For DedicatedWorkerGlobalScope instances, it is simply a developer-supplied name, useful mostly for debugging purposes. For SharedWorkerGlobalScope instances, it allows obtaining a reference to a common shared worker via the SharedWorker() constructor. For ServiceWorkerGlobalScope objects, it doesn't make sense (and as such isn't exposed through the JavaScript API at all).

A WorkerGlobalScope object has an associated HTTPS state (an HTTPS state value). It is initially "none".

A WorkerGlobalScope object has an associated referrer policy (a referrer policy). It is initially the empty string.

A WorkerGlobalScope object has an associated CSP list, which is a CSP list containing all of the Content Security Policy objects active for the worker. It is initially an empty list.

A WorkerGlobalScope object has an associated module map. It is a module map, initially empty.

workerGlobal . self
Returns workerGlobal.
workerGlobal . location
Returns workerGlobal's WorkerLocation object.
workerGlobal . navigator
Returns workerGlobal's WorkerNavigator object.
workerGlobal . importScripts(urls...)
Fetches each URL in urls, executes them one-by-one in the order they are passed, and then returns (or throws if something went amiss).
The self attribute must return the WorkerGlobalScope object itself.

The location attribute must return the WorkerLocation object whose associated WorkerGlobalScope object is the WorkerGlobalScope object.

While the WorkerLocation object is created after the WorkerGlobalScope object, this is not problematic as it cannot be observed from script.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the WorkerGlobalScope interface:

Event handler	Event handler event type
onerror	error
onlanguagechange	languagechange
onoffline	offline
ononline	online
onrejectionhandled	rejectionhandled
onunhandledrejection	unhandledrejection
10.2.1.2 Dedicated workers and the DedicatedWorkerGlobalScope interface
[Global=(Worker,DedicatedWorker),Exposed=DedicatedWorker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  [Replaceable] readonly attribute DOMString name;

  void postMessage(any message, optional sequence<object> transfer = []);

  void close();

  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
};
DedicatedWorkerGlobalScope objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the DedicatedWorkerGlobalScope object.

All messages received by that port must immediately be retargeted at the DedicatedWorkerGlobalScope object.

dedicatedWorkerGlobal . name
Returns dedicatedWorkerGlobal's name, i.e. the value given to the Worker constructor. Primarily useful for debugging.
dedicatedWorkerGlobal . postMessage(message [, transfer ])
Clones message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.
dedicatedWorkerGlobal . close()
Aborts dedicatedWorkerGlobal.
The name attribute must return the DedicatedWorkerGlobalScope object's name. Its value represents the name given to the worker using the Worker constructor, used primarily for debugging purposes.

The postMessage() method on DedicatedWorkerGlobalScope objects must act as if, when invoked, it immediately invoked the method of the same name on the port, with the same arguments, and returned the same return value.

To close a worker, given a workerGlobal, run these steps:

Discard any tasks that have been added to workerGlobal's event loop's task queues.

Set workerGlobal's closing flag to true. (This prevents any further tasks from being queued.)

The close() method, when invoked, must close a worker with this DedicatedWorkerGlobalScope object.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the DedicatedWorkerGlobalScope interface:

Event handler	Event handler event type
onmessage	message
onmessageerror	messageerror
For the purposes of the application cache networking model, a dedicated worker is an extension of the cache host from which it was created.

10.2.1.3 Shared workers and the SharedWorkerGlobalScope interface
[Global=(Worker,SharedWorker),Exposed=SharedWorker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  [Replaceable] readonly attribute DOMString name;

  void close();

  attribute EventHandler onconnect;
};
A SharedWorkerGlobalScope object has an associated constructor origin, and constructor url. They are initialized when the SharedWorkerGlobalScope object is created, in the run a worker algorithm.

Shared workers receive message ports through connect events on their SharedWorkerGlobalScope object for each connection.

sharedWorkerGlobal . name
Returns sharedWorkerGlobal's name, i.e. the value given to the SharedWorker constructor. Multiple SharedWorker objects can correspond to the same shared worker (and SharedWorkerGlobalScope), by reusing the same name.
sharedWorkerGlobal . close()
Aborts sharedWorkerGlobal.
The name attribute must return the SharedWorkerGlobalScope object's name. Its value represents the name that can be used to obtain a reference to the worker using the SharedWorker constructor.

The close() method, when invoked, must close a worker with this SharedWorkerGlobalScope object.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the SharedWorkerGlobalScope interface:

Event handler	Event handler event type
onconnect	connect
10.2.2 The event loop
Each WorkerGlobalScope object has a distinct event loop, separate from those used by units of related similar-origin browsing contexts. This event loop has no associated browsing context, and its task queues only have events, callbacks, and networking activity as tasks. These event loops are created by the run a worker algorithm.

Each WorkerGlobalScope object also has a closing flag, which must be initially false, but which can get set to true by the algorithms in the processing model section below.

Once the WorkerGlobalScope's closing flag is set to true, the event loop's task queues must discard any further tasks that would be added to them (tasks already on the queue are unaffected except where otherwise specified). Effectively, once the closing flag is true, timers stop firing, notifications for all pending background operations are dropped, etc.

10.2.3 The worker's lifetime
Workers communicate with other workers and with browsing contexts through message channels and their MessagePort objects.

Each WorkerGlobalScope object worker global scope has a list of the worker's ports, which consists of all the MessagePort objects that are entangled with another port and that have one (but only one) port owned by worker global scope. This list includes the implicit MessagePort in the case of dedicated workers.

Given an environment settings object o when creating or obtaining a worker, the relevant owner to add depends on the type of global object specified by o. If o specifies a global object that is a WorkerGlobalScope object (i.e., if we are creating a nested worker), then the relevant owner is that global object. Otherwise, o specifies a global object that is a Window object, and the relevant owner is the responsible document specified by o.

A worker is said to be a permissible worker if its WorkerGlobalScope's owner set is not empty or:

its owner set has been empty for no more than a short user-agent-defined timeout value,
its WorkerGlobalScope object is a SharedWorkerGlobalScope object (i.e., the worker is a shared worker), and
the user agent has a browsing context whose Document object is not completely loaded.
The second part of this definition allows a shared worker to survive for a short time while a page is loading, in case that page is going to contact the shared worker again. This can be used by user agents as a way to avoid the cost of restarting a shared worker used by a site when the user is navigating from page to page within that site.

A worker is said to be an active needed worker if any its owners are either Document objects that are fully active or active needed workers.

A worker is said to be a protected worker if it is an active needed worker and either it has outstanding timers, database transactions, or network connections, or its list of the worker's ports is not empty, or its WorkerGlobalScope is actually a SharedWorkerGlobalScope object (i.e. the worker is a shared worker).

A worker is said to be a suspendable worker if it is not an active needed worker but it is a permissible worker.

10.2.4 Processing model
When a user agent is to run a worker for a script with Worker or SharedWorker object worker, URL url, environment settings object outside settings, MessagePort outside port, and a WorkerOptions dictionary options, it must run the following steps.

Create a separate parallel execution environment (i.e. a separate thread or process or equivalent construct), and run the rest of these steps in that context.

For the purposes of timing APIs, this is the official moment of creation of the worker.

Let is shared be true if worker is a SharedWorker object, and false otherwise.

Let owner be the relevant owner to add given outside settings.

Let parent worker global scope be null.

If owner is a WorkerGlobalScope object (i.e., we are creating a nested worker), then set parent worker global scope to owner.

Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:

For the global object, if is shared is true, create a new SharedWorkerGlobalScope object. Otherwise, create a new DedicatedWorkerGlobalScope object.

Let realm execution context be the running JavaScript execution context.

This is the JavaScript execution context created in the previous step.

Let worker global scope be the global object of realm execution context's Realm component.

This is the DedicatedWorkerGlobalScope or SharedWorkerGlobalScope object created when calling InitializeHostDefinedRealm.

Set up a worker environment settings object with realm execution context and outside settings, and let inside settings be the result.

Set worker global scope's name to the value of options's name member.

If is shared is true, then:

Set worker global scope's constructor origin to outside settings's origin.

Set worker global scope's constructor url to url.

Let destination be "sharedworker" if is shared is true, and "worker" otherwise.

Obtain script by switching on the value of options's type member:

"classic"
Fetch a classic worker script given url, outside settings, destination, and inside settings.
"module"
Fetch a module worker script graph given url, outside settings, destination, the value of the credentials member of options, and inside settings.
In both cases, to perform the fetch given request, perform the following steps if the is top-level flag is set:

Set request's reserved client to inside settings.
Fetch request, and asynchronously wait to run the remaining steps as part of fetch's process response for the response response.

Set worker global scope's url to response's url.

Set worker global scope's HTTPS state to response's HTTPS state.

Set worker global scope's referrer policy to the result of parsing the `Referrer-Policy` header of response.

Execute the Initialize a global object's CSP list algorithm on worker global scope and response. [CSP]

Asynchronously complete the perform the fetch steps with response.

If the algorithm asynchronously completes with null, queue a task to fire an event named error at worker, and return. Otherwise, continue the rest of these steps after the algorithm's asynchronous completion, with script being the asynchronous completion value.

Associate worker with worker global scope.

Create a new MessagePort object whose owner is inside settings. Let inside port be this new object.

Associate inside port with worker global scope.

Entangle outside port and inside port.

Append owner to worker global scope's owner set.

If parent worker global scope is not null, then append worker global scope to parent worker global scope's worker set.

Set worker global scope's type to the value of the type member of options.

Create a new WorkerLocation object and associate it with worker global scope.

Closing orphan workers: Start monitoring the worker such that no sooner than it stops being a protected worker, and no later than it stops being a permissible worker, worker global scope's closing flag is set to true.

Suspending workers: Start monitoring the worker, such that whenever worker global scope's closing flag is false and the worker is a suspendable worker, the user agent suspends execution of script in that worker until such time as either the closing flag switches to true or the worker stops being a suspendable worker.

Set inside settings's execution ready flag.

If script is a classic script, then run the classic script script. Otherwise, it is a module script; run the module script script.

In addition to the usual possibilities of returning a value or failing due to an exception, this could be prematurely aborted by the terminate a worker algorithm defined below.

Enable outside port's port message queue.

If is shared is false, enable the port message queue of the worker's implicit port.

If is shared is true, then queue a task, using the DOM manipulation task source, to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing inside port, and the source attribute initialized to inside port.

Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is worker global scope's relevant settings object.

Event loop: Run the responsible event loop specified by inside settings until it is destroyed.

The handling of events or the execution of callbacks by tasks run by the event loop might get prematurely aborted by the terminate a worker algorithm defined below.

The worker processing model remains on this step until the event loop is destroyed, which happens after the closing flag is set to true, as described in the event loop processing model.

Empty the worker global scope's list of active timers.

Disentangle all the ports in the list of the worker's ports.

Empty worker global scope's owner set.

When a user agent is to terminate a worker it must run the following steps in parallel with the worker's main loop (the "run a worker" processing model defined above):

Set the worker's WorkerGlobalScope object's closing flag to true.

If there are any tasks queued in the WorkerGlobalScope object's event loop's task queues, discard them without processing them.

Abort the script currently running in the worker.

If the worker's WorkerGlobalScope object is actually a DedicatedWorkerGlobalScope object (i.e. the worker is a dedicated worker), then empty the port message queue of the port that the worker's implicit port is entangled with.

User agents may invoke the terminate a worker algorithm when a worker stops being an active needed worker and the worker continues executing even after its closing flag was set to true.

The task source for the tasks mentioned above is the DOM manipulation task source.

10.2.5 Runtime script errors
Whenever an uncaught runtime script error occurs in one of the worker's scripts, if the error did not occur while handling a previous script error, the user agent must report the error for that script, with the position (line number and column number) where the error occurred, using the WorkerGlobalScope object as the target.

For shared workers, if the error is still not handled afterwards, the error may be reported to a developer console.

For dedicated workers, if the error is still not handled afterwards, the user agent must queue a task to run these steps:

Let notHandled be the result of firing an event named error at the Worker object associated with the worker, using ErrorEvent, with the cancelable attribute initialized to true, the message, filename, lineno, and colno attributes initialized appropriately, and the error attribute initialized to null.

If notHandled is true, then the user agent must act as if the uncaught runtime script error had occurred in the global scope that the Worker object is in, thus repeating the entire runtime script error reporting process one level up.

If the implicit port connecting the worker to its Worker object has been disentangled (i.e. if the parent worker has been terminated), then the user agent must act as if the Worker object had no error event handler and as if that worker's onerror attribute was null, but must otherwise act as described above.

Thus, error reports propagate up to the chain of dedicated workers up to the original Document, even if some of the workers along this chain have been terminated and garbage collected.

The task source for the task mentioned above is the DOM manipulation task source.

10.2.6 Creating workers
10.2.6.1 The AbstractWorker mixin
interface mixin AbstractWorker {
  attribute EventHandler onerror;
};
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the AbstractWorker interface:

Event handler	Event handler event type
onerror	error
10.2.6.2 Script settings for workers
When the user agent is required to set up a worker environment settings object, given a JavaScript execution context execution context and environment settings object outside settings, it must run the following steps:

Let inherited responsible browsing context be outside settings's responsible browsing context.

Let inherited origin be outside settings's origin.

Let worker event loop be a newly created event loop.

Let realm be the value of execution context's Realm component.

Let worker global scope be realm's global object.

Let settings object be a new environment settings object whose algorithms are defined as follows:

The realm execution context
Return execution context.

The module map
Return worker global scope's module map.

The responsible browsing context
Return inherited responsible browsing context.

The responsible event loop
Return worker event loop.

The responsible document
Not applicable (the responsible event loop is not a browsing context event loop).

The API URL character encoding
Return UTF-8.

The API base URL
Return worker global scope's url.

The origin
Return a unique opaque origin if worker global scope's url's scheme is "data", and inherited origin otherwise.

The HTTPS state
Return worker global scope's HTTPS state.

The referrer policy
Return worker global scope's referrer policy.

Set settings object's id to a new unique opaque string, settings object's creation URL to worker global scope's url, settings object's target browsing context to null, and settings object's active service worker to null.

Set realm's [[HostDefined]] field to settings object.

Return settings object.

10.2.6.3 Dedicated workers and the Worker interface
[Constructor(USVString scriptURL, optional WorkerOptions options), Exposed=(Window,Worker)]
interface Worker : EventTarget {
  void terminate();

  void postMessage(any message, optional sequence<object> transfer = []);
  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
};

dictionary WorkerOptions {
  WorkerType type = "classic";
  RequestCredentials credentials = "omit"; // credentials is only used if type is "module"
  DOMString name = "";
};

enum WorkerType { "classic", "module" };

Worker includes AbstractWorker;
worker = new Worker(scriptURL [, options ])
Returns a new Worker object. scriptURL will be fetched and executed in the background, creating a new global environment for which worker represents the communication channel. options can be used to define the name of that global environment via the name option, primarily for debugging purposes. It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.
worker . terminate()
Aborts worker's associated global environment.
worker . postMessage(message [, transfer ])
Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned.
The terminate() method, when invoked, must cause the terminate a worker algorithm to be run on the worker with which the object is associated.

Worker objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the Worker object.

All messages received by that port must immediately be retargeted at the Worker object.

The postMessage() method on Worker objects must act as if, when invoked, it immediately invoked the method of the same name on the port, with the same arguments, and returned the same return value.

The postMessage() method's first argument can be structured data:

worker.postMessage({opcode: 'activate', device: 1938, parameters: [23, 102]});
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the Worker interface:

Event handler	Event handler event type
onmessage	message
onmessageerror	messageerror
When the Worker(scriptURL, options) constructor is invoked, the user agent must run the following steps:

The user agent may throw a "SecurityError" DOMException if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to start dedicated workers).

Let outside settings be the current settings object.

Parse the scriptURL argument relative to outside settings.

If this fails, throw a "SyntaxError" DOMException.

Let worker URL be the resulting URL record.

Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.

Let worker be a new Worker object.

Create a new MessagePort object whose owner is outside settings. Let this be the outside port.

Associate the outside port with worker.

Run this step in parallel:

Run a worker given worker, worker URL, outside settings, outside port, and options.

Return worker.

10.2.6.4 Shared workers and the SharedWorker interface
[Constructor(USVString scriptURL, optional (DOMString or WorkerOptions) options),
 Exposed=(Window,Worker)]
interface SharedWorker : EventTarget {
  readonly attribute MessagePort port;
};
SharedWorker includes AbstractWorker;
sharedWorker = new SharedWorker(scriptURL [, name ])
Returns a new SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global environment for which sharedWorker represents the communication channel. name can be used to define the name of that global environment.
sharedWorker = new SharedWorker(scriptURL [, options ])
Returns a new SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global environment for which sharedWorker represents the communication channel. options can be used to define the name of that global environment via the name option. It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.
sharedWorker . port
Returns sharedWorker's MessagePort object which can be used to communicate with the global environment.
The port attribute must return the value it was assigned by the object's constructor. It represents the MessagePort for communicating with the shared worker.

A user agent has an associated shared worker manager which is the result of starting a new parallel queue.

Each user agent has a single shared worker manager for simplicity. Implementations could use one per origin; that would not be observably different and enables more concurrency.

When the SharedWorker(scriptURL, options) constructor is invoked:

Optionally, throw a "SecurityError" DOMException if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to start shared workers).

If options is a DOMString, set options to a new WorkerOptions dictionary whose name member is set to the value of options and whose other members are set to their default values.

Let outside settings be the current settings object.

Parse scriptURL relative to outside settings.

If this fails, throw a "SyntaxError" DOMException.

Otherwise, let urlRecord be the resulting URL record.

Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.

Let worker be a new SharedWorker object.

Create a new MessagePort object whose owner is outside settings. Let this be the outside port.

Assign outside port to the port attribute of worker.

Let callerIsSecureContext be the result of executing Is environment settings object a secure context? on outside settings.

Enqueue the following steps to the shared worker manager:

Let worker global scope be null.

If there exists a SharedWorkerGlobalScope object whose closing flag is false, constructor origin is same origin with outside settings's origin, constructor url equals urlRecord, and name equals the value of options's name member, then set worker global scope to that SharedWorkerGlobalScope object.

data: URLs create a worker with an opaque origin. Both the constructor origin and constructor url are compared so the same data: URL can be used within an origin to get to the same SharedWorkerGlobalScope object, but cannot be used to bypass the same origin restriction.

If worker global scope is not null, but the user agent has been configured to disallow communication between the worker represented by the worker global scope and the scripts whose settings object is outside settings, then set worker global scope to null.

For example, a user agent could have a development mode that isolates a particular top-level browsing context from all other pages, and scripts in that development mode could be blocked from connecting to shared workers running in the normal browser mode.

If worker global scope is not null, then run these subsubsteps:

Let settings object be the relevant settings object for worker global scope.

Let workerIsSecureContext be the result of executing Is environment settings object a secure context? on settings object.

If workerIsSecureContext is not callerIsSecureContext, then queue a task to fire an event named error at worker and abort these subsubsteps. [SECURE-CONTEXTS]

Associate worker with worker global scope.

Create a new MessagePort object whose owner is settings object. Let this be the inside port.

Entangle outside port and inside port.

Queue a task, using the DOM manipulation task source, to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing only inside port, and the source attribute initialized to inside port.

Append the relevant owner to add given outside settings to worker global scope's owner set.

If outside settings's global object is a WorkerGlobalScope object, then append worker global scope to outside settings's global object's worker set.

Otherwise, in parallel, run a worker given worker, urlRecord, outside settings, outside port, and options.

Return worker.

10.2.7 Concurrent hardware capabilities

Support: hardwareconcurrency
Chrome for Android	64+
Chrome	37+
iOS Safari	10.3+
UC Browser for Android	11.8+
Firefox	48+
Samsung Internet	4+
IE	None
Opera Mini	None
Safari	10.1+
Edge	15+
Android Browser	62+
Opera	24+

Source: caniuse.com

interface mixin NavigatorConcurrentHardware {
  readonly attribute unsigned long long hardwareConcurrency;
};
self . navigator . hardwareConcurrency
Returns the number of logical processors potentially available to the user agent.

The navigator.hardwareConcurrency attribute's getter must return a number between 1 and the number of logical processors potentially available to the user agent. If this cannot be determined, the getter must return 1.

User agents should err toward exposing the number of logical processors available, using lower values only in cases where there are user-agent specific limits in place (such as a limitation on the number of workers that can be created) or when the user agent desires to limit fingerprinting possibilities.

10.3 APIs available to workers
10.3.1 Importing scripts and libraries
When a script invokes the importScripts(urls) method on a WorkerGlobalScope object, the user agent must import scripts into worker global scope given this WorkerGlobalScope object and urls.

To import scripts into worker global scope, given a WorkerGlobalScope object worker global scope and a sequence<DOMString> urls, run these steps. The algorithm may optionally be customized by supplying custom perform the fetch hooks, which if provided will be used when invoking fetch a classic worker-imported script.

If worker global scope's type is "module", throw a TypeError exception.

Let settings object be the current settings object.

If urls is empty, return.

Parse each value in urls relative to settings object. If any fail, throw a "SyntaxError" DOMException.

For each url in the resulting URL records, run these substeps:

Fetch a classic worker-imported script given url and settings object, passing along any custom perform the fetch steps provided. If this succeeds, let script be the result. Otherwise, rethrow the exception.

Run the classic script script, with the rethrow errors argument set to true.

script will run until it either returns, fails to parse, fails to catch an exception, or gets prematurely aborted by the terminate a worker algorithm defined above.

If an exception was thrown or if the script was prematurely aborted, then abort all these steps, letting the exception or aborting continue to be processed by the calling script.

Service Workers is an example of a specification that runs this algorithm with its own options for the perform the fetch hook. [SW]

10.3.2 The WorkerNavigator interface
The navigator attribute of the WorkerGlobalScope interface must return an instance of the WorkerNavigator interface, which represents the identity and state of the user agent (the client):

[Exposed=Worker]
interface WorkerNavigator {};
WorkerNavigator includes NavigatorID;
WorkerNavigator includes NavigatorLanguage;
WorkerNavigator includes NavigatorOnLine;
WorkerNavigator includes NavigatorConcurrentHardware;
10.3.3 The WorkerLocation interface
[Exposed=Worker]
interface WorkerLocation {
  stringifier readonly attribute USVString href;
  readonly attribute USVString origin;
  readonly attribute USVString protocol;
  readonly attribute USVString host;
  readonly attribute USVString hostname;
  readonly attribute USVString port;
  readonly attribute USVString pathname;
  readonly attribute USVString search;
  readonly attribute USVString hash;
};
A WorkerLocation object has an associated WorkerGlobalScope object (a WorkerGlobalScope object).

The href attribute's getter must return the associated WorkerGlobalScope object's url, serialized.

The origin attribute's getter must return the serialization of the associated WorkerGlobalScope object's url's origin.

The protocol attribute's getter must return the associated WorkerGlobalScope object's url's scheme, followed by ":".

The host attribute's getter must run these steps:

Let url be the associated WorkerGlobalScope object's url.

If url's host is null, return the empty string.

If url's port is null, return url's host, serialized.

Return url's host, serialized, followed by ":" and url's port, serialized.

The hostname attribute's getter must run these steps:

Let host be the associated WorkerGlobalScope object's url's host.

If host is null, return the empty string.

Return host, serialized.

The port attribute's getter must run these steps:

Let port be the associated WorkerGlobalScope object's url's port.

If port is null, return the empty string.

Return port, serialized.

The pathname attribute's getter must run these steps:

Let url be the associated WorkerGlobalScope object's url.

If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The search attribute's getter must run these steps:

Let query be the associated WorkerGlobalScope object's url's query.

If query is either null or the empty string, return the empty string.

Return "?", followed by query.

The hash attribute's getter must run these steps:

Let fragment be the associated WorkerGlobalScope object's url's fragment.

If fragment is either null or the empty string, return the empty string.

Return "#", followed by fragment.

11 Web storage
11.1 Introduction
This section is non-normative.

This specification introduces two related mechanisms, similar to HTTP session cookies, for storing name-value pairs on the client side. [COOKIES]

The first is designed for scenarios where the user is carrying out a single transaction, but could be carrying out multiple transactions in different windows at the same time.

Cookies don't really handle this case well. For example, a user could be buying plane tickets in two different windows, using the same site. If the site used cookies to keep track of which ticket the user was buying, then as the user clicked from page to page in both windows, the ticket currently being purchased would "leak" from one window to the other, potentially causing the user to buy two tickets for the same flight without really noticing.

To address this, this specification introduces the sessionStorage IDL attribute. Sites can add data to the session storage, and it will be accessible to any page from the same site opened in that window.

For example, a page could have a checkbox that the user ticks to indicate that they want insurance:

<label>
 <input type="checkbox" onchange="sessionStorage.insurance = checked ? 'true' : ''">
  I want insurance on this trip.
</label>
A later page could then check, from script, whether the user had checked the checkbox or not:

if (sessionStorage.insurance) { ... }
If the user had multiple windows opened on the site, each one would have its own individual copy of the session storage object.

The second storage mechanism is designed for storage that spans multiple windows, and lasts beyond the current session. In particular, Web applications might wish to store megabytes of user data, such as entire user-authored documents or a user's mailbox, on the client side for performance reasons.

Again, cookies do not handle this case well, because they are transmitted with every request.

The localStorage IDL attribute is used to access a page's local storage area.

The site at example.com can display a count of how many times the user has loaded its page by putting the following at the bottom of its page:

<p>
  You have viewed this page
  <span id="count">an untold number of</span>
  time(s).
</p>
<script>
  if (!localStorage.pageLoadCount)
    localStorage.pageLoadCount = 0;
  localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;
  document.getElementById('count').textContent = localStorage.pageLoadCount;
</script>
Each site has its own separate storage area.

11.2 The API

Support: namevalue-storage
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	3.5+
Samsung Internet	4+
IE	8+
Opera Mini	None
Safari	4+
Edge	12+
Android Browser	2.1+
Opera	10.5+

Source: caniuse.com

11.2.1 The Storage interface
[Exposed=Window]
interface Storage {
  readonly attribute unsigned long length;
  DOMString? key(unsigned long index);
  getter DOMString? getItem(DOMString key);
  setter void setItem(DOMString key, DOMString value);
  deleter void removeItem(DOMString key);
  void clear();
};
Each Storage object provides access to a list of key/value pairs, which are sometimes called items. Keys are strings. Any string (including the empty string) is a valid key. Values are similarly strings.

Each Storage object is associated with a list of key/value pairs when it is created, as defined in the sections on the sessionStorage and localStorage attributes. Multiple separate objects implementing the Storage interface can all be associated with the same list of key/value pairs simultaneously.

storage . length
Returns the number of key/value pairs currently present in the list associated with the object.

storage . key ( n )
Returns the name of the nth key in the list, or null if n is greater than or equal to the number of key/value pairs in the object.

value = storage . getItem ( key )
value = storage[key]
Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.

storage . setItem ( key, value )
storage[key] = value
Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.

Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)

storage . removeItem ( key )
delete storage[key]
Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.

storage . clear()
Empties the list associated with the object of all key/value pairs, if there are any.

The length attribute must return the number of key/value pairs currently present in the list associated with the object.

The key(n) method must return the name of the nth key in the list. The order of keys is user-agent defined, but must be consistent within an object so long as the number of keys doesn't change. (Thus, adding or removing a key may change the order of the keys, but merely changing the value of an existing key must not.) If n is greater than or equal to the number of key/value pairs in the object, then this method must return null.

The supported property names on a Storage object are the keys of each key/value pair currently present in the list associated with the object, in the order that the keys were last added to the storage area.

The getItem(key) method must return the current value associated with the given key. If the given key does not exist in the list associated with the object then this method must return null.

The setItem(key, value) method must first check if a key/value pair with the given key already exists in the list associated with the object.

If it does not, then a new key/value pair must be added to the list, with the given key and with its value set to value.

If the given key does exist in the list, and its value is not equal to value, then it must have its value updated to value. If its previous value is equal to value, then the method must do nothing.

If it couldn't set the new value, the method must throw a "QuotaExceededError" DOMException exception.

The removeItem(key) method must cause the key/value pair with the given key to be removed from the list associated with the object, if it exists. If no item with that key exists, the method must do nothing.

The setItem() and removeItem() methods must be atomic with respect to failure. In the case of failure, the method does nothing. That is, changes to the data storage area must either be successful, or the data storage area must not be changed at all.

The clear() method must atomically cause the list associated with the object to be emptied of all key/value pairs, if there are any. If there are none, then the method must do nothing.

When the setItem(), removeItem(), and clear() methods are invoked, events are fired on the Window objects of other Documents that can access the newly stored or removed data, as defined in the sections on the sessionStorage and localStorage attributes.

This specification does not require that the above methods wait until the data has been physically written to disk. Only consistency in what different scripts accessing the same underlying list of key/value pairs see is required.

11.2.2 The sessionStorage attribute
interface mixin WindowSessionStorage {
  readonly attribute Storage sessionStorage;
};
Window includes WindowSessionStorage;
The sessionStorage attribute represents the set of storage areas specific to the current top-level browsing context.

window . sessionStorage
Returns the Storage object associated with that origin's session storage area.

Each top-level browsing context has a unique set of session storage areas, one for each origin.

User agents should not expire data from a browsing context's session storage areas, but may do so when the user requests that such data be deleted, or when the UA detects that it has limited storage space, or for security reasons. User agents should always avoid deleting data while a script that could access that data is running. When a top-level browsing context is destroyed (and therefore permanently inaccessible to the user) the data stored in its session storage areas can be discarded with it, as the API described in this specification provides no way for that data to ever be subsequently retrieved.

The lifetime of a browsing context can be unrelated to the lifetime of the actual user agent process itself, as the user agent can support resuming sessions after a restart.

When a new Document is created in a browsing context which has a top-level browsing context, the user agent must check to see if that top-level browsing context has a session storage area for that document's origin. If it does, then that is the Document's assigned session storage area. If it does not, a new storage area for that document's origin must be created, and then that is the Document's assigned session storage area. A Document's assigned storage area does not change during the lifetime of a Document.

In the case of an iframe being moved to another Document, the nested browsing context is destroyed and a new one created.

The sessionStorage attribute must return a Storage object associated with the Document's assigned session storage area. Each Document object must have a separate object for its Window's sessionStorage attribute.

While creating a new browsing context, the session storage area is sometimes copied over.

When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a session storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose Window object's sessionStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.

11.2.3 The localStorage attribute
interface mixin WindowLocalStorage {
  readonly attribute Storage localStorage;
};
Window includes WindowLocalStorage;
The localStorage object provides a Storage object for an origin.
window . localStorage
Returns the Storage object associated with that origin's local storage area.

Throws a "SecurityError" DOMException if the Document's origin is an opaque origin or if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to persist data).

User agents must have a set of local storage areas, one for each origin.

User agents should expire data from the local storage areas only for security reasons or when requested to do so by the user. User agents should always avoid deleting data while a script that could access that data is running.

When the localStorage attribute is accessed, the user agent must run the following steps, which are known as the Storage object initialization steps:

If the request violates a policy decision (e.g. if the user agent is configured to not allow the page to persist data), the user agent may throw a "SecurityError" DOMException instead of returning a Storage object

If the Document's origin is an opaque origin, then throw a "SecurityError" DOMException.

Check to see if the user agent has allocated a local storage area for the origin of the Document of the Window object on which the attribute was accessed. If it has not, create a new storage area for that origin.

Return the Storage object associated with that origin's local storage area. Each Document object must have a separate object for its Window's localStorage attribute.

When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a local storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose Window object's localStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.

The localStorage attribute provides access to shared state. This specification does not define the interaction with other browsing contexts in a multiprocess user agent, and authors are encouraged to assume that there is no locking mechanism. A site could, for instance, try to read the value of a key, increment its value, then write it back out, using the new value as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.

11.2.4 The storage event
The storage event is fired on a Document's Window object when a storage area changes, as described in the previous two sections (for session storage, for local storage).

When a user agent is to send a storage notification for a Document, the user agent must queue a task to fire an event named storage at the Document object's Window object, using StorageEvent.

Such a Document object is not necessarily fully active, but events fired on such objects are ignored by the event loop until the Document becomes fully active again.

The task source for these tasks is the DOM manipulation task source.

If the event is being fired due to an invocation of the setItem() or removeItem() methods, the event must have its key attribute initialized to the name of the key in question, its oldValue attribute initialized to the old value of the key in question, or null if the key is newly added, and its newValue attribute initialized to the new value of the key in question, or null if the key was removed.

Otherwise, if the event is being fired due to an invocation of the clear() method, the event must have its key, oldValue, and newValue attributes initialized to null.

In addition, the event must have its url attribute initialized to the URL of the document whose Storage object was affected; and its storageArea attribute initialized to the Storage object from the Window object of the target Document that represents the same kind of Storage area as was affected (i.e. session or local).

11.2.4.1 The StorageEvent interface
[Exposed=Window,
 Constructor(DOMString type, optional StorageEventInit eventInitDict)]
interface StorageEvent : Event {
  readonly attribute DOMString? key;
  readonly attribute DOMString? oldValue;
  readonly attribute DOMString? newValue;
  readonly attribute USVString url;
  readonly attribute Storage? storageArea;
};

dictionary StorageEventInit : EventInit {
  DOMString? key = null;
  DOMString? oldValue = null;
  DOMString? newValue = null;
  USVString url = "";
  Storage? storageArea = null;
};
event . key
Returns the key of the storage item being changed.

event . oldValue
Returns the old value of the key of the storage item whose value is being changed.

event . newValue
Returns the new value of the key of the storage item whose value is being changed.

event . url
Returns the URL of the document whose storage item changed.

event . storageArea
Returns the Storage object that was affected.

The key, oldValue, newValue, url, and storageArea attributes must return the values they were initialized to.

11.3 Disk space
User agents should limit the total amount of space allowed for storage areas, because hostile authors could otherwise use this feature to exhaust the user's available disk space.

User agents should guard against sites storing data under their origin's other affiliated sites, e.g. storing up to the limit in a1.example.com, a2.example.com, a3.example.com, etc, circumventing the main example.com storage limit.

User agents may prompt the user when quotas are reached, allowing the user to grant a site more space. This enables sites to store many user-created documents on the user's computer, for instance.

User agents should allow users to see how much space each domain is using.

A mostly arbitrary limit of five megabytes per origin is suggested. Implementation feedback is welcome and will be used to update this suggestion in the future.

For predictability, quotas should be based on the uncompressed size of data stored.

11.4 Privacy
11.4.1 User tracking
A third-party advertiser (or any entity capable of getting content distributed to multiple sites) could use a unique identifier stored in its local storage area to track a user across multiple sessions, building a profile of the user's interests to allow for highly targeted advertising. In conjunction with a site that is aware of the user's real identity (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.

There are a number of techniques that can be used to mitigate the risk of user tracking:

Blocking third-party storage
User agents may restrict access to the localStorage objects to scripts originating at the domain of the active document of the top-level browsing context, for instance denying access to the API for pages from other domains running in iframes.

Expiring stored data
User agents may, possibly in a manner configured by the user, automatically delete stored data after a period of time.

For example, a user agent could be configured to treat third-party local storage areas as session-only storage, deleting the data once the user had closed all the browsing contexts that could access it.

This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when they authenticate with the site itself (e.g. by making a purchase or logging in to a service).

However, this also reduces the usefulness of the API as a long-term storage mechanism. It can also put the user's data at risk, if the user does not fully understand the implications of data expiration.

Treating persistent storage as cookies
If users attempt to protect their privacy by clearing cookies without also clearing data stored in the local storage area, sites can defeat those attempts by using the two features as redundant backup for each other. User agents should present the interfaces for clearing these in a way that helps users to understand this possibility and enables them to delete data in all persistent storage features simultaneously. [COOKIES]

Site-specific safelisting of access to local storage areas
User agents may allow sites to access session storage areas in an unrestricted manner, but require the user to authorize access to local storage areas.

Origin-tracking of stored data
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.

If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that they trust.

Shared blocklists
User agents may allow users to share their persistent storage domain blocklists.

This would allow communities to act together to protect their privacy.

While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.

However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.

11.4.2 Sensitivity of data
User agents should treat persistently stored data as potentially sensitive; it's quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.

To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.

11.5 Security
11.5.1 DNS spoofing attacks
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only the user, software working on behalf of the user, and other pages using TLS that have certificates identifying them as being from the same domain, can access their storage areas.

11.5.2 Cross-directory attacks
Different authors sharing one host name, for example users hosting content on the now defunct geocities.com, all share one local storage object. There is no feature to restrict the access by pathname. Authors on shared hosts are therefore urged to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.

Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.

11.5.3 Implementation risks
The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.

Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user's shopping wishlist on one domain could be used by another domain for targeted advertising; or a user's work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.

Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add items to a user's wishlist; or a hostile site could set a user's session identifier to a known ID that the hostile site can then use to track the user's actions on the victim site.

Thus, strictly following the origin model described in this specification is important for user security.

12 The HTML syntax
This section only describes the rules for resources labeled with an HTML MIME type. Rules for XML resources are discussed in the section below entitled "The XML syntax".

12.1 Writing HTML documents
This section only applies to documents, authoring tools, and markup generators. In particular, it does not apply to conformance checkers; conformance checkers must use the requirements given in the next section ("parsing HTML documents").

Documents must consist of the following parts, in the given order:

Optionally, a single U+FEFF BYTE ORDER MARK (BOM) character.
Any number of comments and ASCII whitespace.
A DOCTYPE.
Any number of comments and ASCII whitespace.
The document element, in the form of an html element.
Any number of comments and ASCII whitespace.
The various types of content mentioned above are described in the next few sections.

In addition, there are some restrictions on how character encoding declarations are to be serialized, as discussed in the section on that topic.

ASCII whitespace before the html element, at the start of the html element and before the head element, will be dropped when the document is parsed; ASCII whitespace after the html element will be parsed as if it were at the end of the body element. Thus, ASCII whitespace around the document element does not round-trip.

It is suggested that newlines be inserted after the DOCTYPE, after any comments that are before the document element, after the html element's start tag (if it is not omitted), and after any comments that are inside the html element but before the head element.

Many strings in the HTML syntax (e.g. the names of elements and their attributes) are case-insensitive, but only for ASCII upper alphas and ASCII lower alphas. For convenience, in this section this is just referred to as "case-insensitive".

12.1.1 The DOCTYPE
A DOCTYPE is a required preamble.

DOCTYPEs are required for legacy reasons. When omitted, browsers tend to use a different rendering mode that is incompatible with some specifications. Including the DOCTYPE in a document ensures that the browser makes a best-effort attempt at following the relevant specifications.

A DOCTYPE must consist of the following components, in this order:

A string that is an ASCII case-insensitive match for the string "<!DOCTYPE".
One or more ASCII whitespace.
A string that is an ASCII case-insensitive match for the string "html".
Optionally, a DOCTYPE legacy string.
Zero or more ASCII whitespace.
A U+003E GREATER-THAN SIGN character (>).
In other words, <!DOCTYPE html>, case-insensitively.

For the purposes of HTML generators that cannot output HTML markup with the short DOCTYPE "<!DOCTYPE html>", a DOCTYPE legacy string may be inserted into the DOCTYPE (in the position defined above). This string must consist of:

One or more ASCII whitespace.
A string that is an ASCII case-insensitive match for the string "SYSTEM".
One or more ASCII whitespace.
A U+0022 QUOTATION MARK or U+0027 APOSTROPHE character (the quote mark).
The literal string "about:legacy-compat".
A matching U+0022 QUOTATION MARK or U+0027 APOSTROPHE character (i.e. the same character as in the earlier step labeled quote mark).
In other words, <!DOCTYPE html SYSTEM "about:legacy-compat"> or <!DOCTYPE html SYSTEM 'about:legacy-compat'>, case-insensitively except for the part in single or double quotes.

The DOCTYPE legacy string should not be used unless the document is generated from a system that cannot output the shorter string.

12.1.2 Elements
There are six different kinds of elements: void elements, the template element, raw text elements, escapable raw text elements, foreign elements, and normal elements.

Void elements
area, base, br, col, embed, hr, img, input, link, meta, param, source, track, wbr
The template element
template
Raw text elements
script, style
escapable raw text elements
textarea, title
Foreign elements
Elements from the MathML namespace and the SVG namespace.
Normal elements
All other allowed HTML elements are normal elements.
Tags are used to delimit the start and end of elements in the markup. Raw text, escapable raw text, and normal elements have a start tag to indicate where they begin, and an end tag to indicate where they end. The start and end tags of certain normal elements can be omitted, as described below in the section on optional tags. Those that cannot be omitted must not be omitted. Void elements only have a start tag; end tags must not be specified for void elements. Foreign elements must either have a start tag and an end tag, or a start tag that is marked as self-closing, in which case they must not have an end tag.

The contents of the element must be placed between just after the start tag (which might be implied, in certain cases) and just before the end tag (which again, might be implied in certain cases). The exact allowed contents of each individual element depend on the content model of that element, as described earlier in this specification. Elements must not contain content that their content model disallows. In addition to the restrictions placed on the contents by those content models, however, the five types of elements have additional syntactic requirements.

Void elements can't have any contents (since there's no end tag, no content can be put between the start tag and the end tag).

The template element can have template contents, but such template contents are not children of the template element itself. Instead, they are stored in a DocumentFragment associated with a different Document — without a browsing context — so as to avoid the template contents interfering with the main Document. The markup for the template contents of a template element is placed just after the template element's start tag and just before template element's end tag (as with other elements), and may consist of any text, character references, elements, and comments, but but the text must not contain the character U+003C LESS-THAN SIGN (<) or an ambiguous ampersand.

Raw text elements can have text, though it has restrictions described below.

Escapable raw text elements can have text and character references, but the text must not contain an ambiguous ampersand. There are also further restrictions described below.

Foreign elements whose start tag is marked as self-closing can't have any contents (since, again, as there's no end tag, no content can be put between the start tag and the end tag). Foreign elements whose start tag is not marked as self-closing can have text, character references, CDATA sections, other elements, and comments, but the text must not contain the character U+003C LESS-THAN SIGN (<) or an ambiguous ampersand.

The HTML syntax does not support namespace declarations, even in foreign elements.

For instance, consider the following HTML fragment:

<p>
 <svg>
  <metadata>
   <!-- this is invalid -->
   <cdr:license xmlns:cdr="https://www.example.com/cdr/metadata" name="MIT"/>
  </metadata>
 </svg>
</p>
The innermost element, cdr:license, is actually in the SVG namespace, as the "xmlns:cdr" attribute has no effect (unlike in XML). In fact, as the comment in the fragment above says, the fragment is actually non-conforming. This is because the SVG specification does not define any elements called "cdr:license" in the SVG namespace.

Normal elements can have text, character references, other elements, and comments, but the text must not contain the character U+003C LESS-THAN SIGN (<) or an ambiguous ampersand. Some normal elements also have yet more restrictions on what content they are allowed to hold, beyond the restrictions imposed by the content model and those described in this paragraph. Those restrictions are described below.

Tags contain a tag name, giving the element's name. HTML elements all have names that only use ASCII alphanumerics. In the HTML syntax, tag names, even those for foreign elements, may be written with any mix of lower- and uppercase letters that, when converted to all-lowercase, matches the element's tag name; tag names are case-insensitive.

12.1.2.1 Start tags
Start tags must have the following format:

The first character of a start tag must be a U+003C LESS-THAN SIGN character (<).
The next few characters of a start tag must be the element's tag name.
If there are to be any attributes in the next step, there must first be one or more ASCII whitespace.
Then, the start tag may have a number of attributes, the syntax for which is described below. Attributes must be separated from each other by one or more ASCII whitespace.
After the attributes, or after the tag name if there are no attributes, there may be one or more ASCII whitespace. (Some attributes are required to be followed by a space. See the attributes section below.)
Then, if the element is one of the void elements, or if the element is a foreign element, then there may be a single U+002F SOLIDUS character (/). This character has no effect on void elements, but on foreign elements it marks the start tag as self-closing.
Finally, start tags must be closed by a U+003E GREATER-THAN SIGN character (>).
12.1.2.2 End tags
End tags must have the following format:

The first character of an end tag must be a U+003C LESS-THAN SIGN character (<).
The second character of an end tag must be a U+002F SOLIDUS character (/).
The next few characters of an end tag must be the element's tag name.
After the tag name, there may be one or more ASCII whitespace.
Finally, end tags must be closed by a U+003E GREATER-THAN SIGN character (>).
12.1.2.3 Attributes
Attributes for an element are expressed inside the element's start tag.

Attributes have a name and a value. Attribute names must consist of one or more characters other than controls, U+0020 SPACE, U+0022 ("), U+0027 ('), U+003E (>), U+002F (/), U+003D (=), and noncharacters. In the HTML syntax, attribute names, even those for foreign elements, may be written with any mix of ASCII lower and ASCII upper alphas.

Attribute values are a mixture of text and character references, except with the additional restriction that the text cannot contain an ambiguous ampersand.

Attributes can be specified in four different ways:

Empty attribute syntax
Just the attribute name. The value is implicitly the empty string.

In the following example, the disabled attribute is given with the empty attribute syntax:

<input disabled>
If an attribute using the empty attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

Unquoted attribute value syntax
The attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed by zero or more ASCII whitespace, followed by the attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal ASCII whitespace, any U+0022 QUOTATION MARK characters ("), U+0027 APOSTROPHE characters ('), U+003D EQUALS SIGN characters (=), U+003C LESS-THAN SIGN characters (<), U+003E GREATER-THAN SIGN characters (>), or U+0060 GRAVE ACCENT characters (`), and must not be the empty string.

In the following example, the value attribute is given with the unquoted attribute value syntax:

<input value=yes>
If an attribute using the unquoted attribute syntax is to be followed by another attribute or by the optional U+002F SOLIDUS character (/) allowed in step 6 of the start tag syntax above, then there must be ASCII whitespace separating the two.

Single-quoted attribute value syntax
The attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed by zero or more ASCII whitespace, followed by a single U+0027 APOSTROPHE character ('), followed by the attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal U+0027 APOSTROPHE characters ('), and finally followed by a second single U+0027 APOSTROPHE character (').

In the following example, the type attribute is given with the single-quoted attribute value syntax:

<input type='checkbox'>
If an attribute using the single-quoted attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

Double-quoted attribute value syntax
The attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed by zero or more ASCII whitespace, followed by a single U+0022 QUOTATION MARK character ("), followed by the attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal U+0022 QUOTATION MARK characters ("), and finally followed by a second single U+0022 QUOTATION MARK character (").

In the following example, the name attribute is given with the double-quoted attribute value syntax:

<input name="be evil">
If an attribute using the double-quoted attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

There must never be two or more attributes on the same start tag whose names are an ASCII case-insensitive match for each other.

When a foreign element has one of the namespaced attributes given by the local name and namespace of the first and second cells of a row from the following table, it must be written using the name given by the third cell from the same row.

Local name	Namespace	Attribute name
actuate	XLink namespace	xlink:actuate
arcrole	XLink namespace	xlink:arcrole
href	XLink namespace	xlink:href
role	XLink namespace	xlink:role
show	XLink namespace	xlink:show
title	XLink namespace	xlink:title
type	XLink namespace	xlink:type
lang	XML namespace	xml:lang
space	XML namespace	xml:space
xmlns	XMLNS namespace	xmlns
xlink	XMLNS namespace	xmlns:xlink
No other namespaced attribute can be expressed in the HTML syntax.

Whether the attributes in the table above are conforming or not is defined by other specifications (e.g. the SVG and MathML specifications); this section only describes the syntax rules if the attributes are serialized using the HTML syntax.

12.1.2.4 Optional tags
Certain tags can be omitted.

Omitting an element's start tag in the situations described below does not mean the element is not present; it is implied, but it is still there. For example, an HTML document always has a root html element, even if the string <html> doesn't appear anywhere in the markup.

An html element's start tag may be omitted if the first thing inside the html element is not a comment.

For example, in the following case it's ok to remove the "<html>" tag:

<!DOCTYPE HTML>
<html>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
Doing so would make the document look like this:

<!DOCTYPE HTML>

  <head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
This has the exact same DOM. In particular, note that whitespace around the document element is ignored by the parser. The following example would also have the exact same DOM:

<!DOCTYPE HTML><head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
However, in the following example, removing the start tag moves the comment to before the html element:

<!DOCTYPE HTML>
<html>
  <!-- where is this comment in the DOM? -->
  <head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
With the tag removed, the document actually turns into the same as this:

<!DOCTYPE HTML>
<!-- where is this comment in the DOM? -->
<html>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
This is why the tag can only be removed if it is not followed by a comment: removing the tag when there is a comment there changes the document's resulting parse tree. Of course, if the position of the comment does not matter, then the tag can be omitted, as if the comment had been moved to before the start tag in the first place.

An html element's end tag may be omitted if the html element is not immediately followed by a comment.

A head element's start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.

A head element's end tag may be omitted if the head element is not immediately followed by ASCII whitespace or a comment.

A body element's start tag may be omitted if the element is empty, or if the first thing inside the body element is not ASCII whitespace or a comment, except if the first thing inside the body element is a meta, link, script, style, or template element.

A body element's end tag may be omitted if the body element is not immediately followed by a comment.

Note that in the example above, the head element start and end tags, and the body element start tag, can't be omitted, because they are surrounded by whitespace:

<!DOCTYPE HTML>
<html>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <p>Welcome to this example.</p>
  </body>
</html>
(The body and html element end tags could be omitted without trouble; any spaces after those get parsed into the body element anyway.)

Usually, however, whitespace isn't an issue. If we first remove the whitespace we don't care about:

<!DOCTYPE HTML><html><head><title>Hello</title></head><body><p>Welcome to this example.</p></body></html>
Then we can omit a number of tags without affecting the DOM:

<!DOCTYPE HTML><title>Hello</title><p>Welcome to this example.</p>
At that point, we can also add some whitespace back:

<!DOCTYPE HTML>
<title>Hello</title>
<p>Welcome to this example.</p>
This would be equivalent to this document, with the omitted tags shown in their parser-implied positions; the only whitespace text node that results from this is the newline at the end of the head element:

<!DOCTYPE HTML>
<html><head><title>Hello</title>
</head><body><p>Welcome to this example.</p></body></html>
An li element's end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.

A dt element's end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.

A dd element's end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.

A p element's end tag may be omitted if the p element is immediately followed by an address, article, aside, blockquote, details, div, dl, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hgroup, hr, main, menu, nav, ol, p, pre, section, table, or ul element, or if there is no more content in the parent element and the parent element is an HTML element that is not an a, audio, del, ins, map, noscript, or video element, or an autonomous custom element.

We can thus simplify the earlier example further:

<!DOCTYPE HTML><title>Hello</title><p>Welcome to this example.</p>
An rt element's end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

An rp element's end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

An optgroup element's end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.

An option element's end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.

A colgroup element's start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can't be omitted if the element is empty.)

A colgroup element's end tag may be omitted if the colgroup element is not immediately followed by ASCII whitespace or a comment.

A caption element's end tag may be omitted if the caption element is not immediately followed by ASCII whitespace or a comment.

A thead element's end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.

A tbody element's start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can't be omitted if the element is empty.)

A tbody element's end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.

A tfoot element's end tag may be omitted if there is no more content in the parent element.

A tr element's end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.

A td element's end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.

A th element's end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.

The ability to omit all these table-related tags makes table markup much terser.

Take this example:

<table>
 <caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)</caption>
 <colgroup><col><col><col></colgroup>
 <thead>
  <tr>
   <th>Function</th>
   <th>Control Unit</th>
   <th>Central Station</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Headlights</td>
   <td>✔</td>
   <td>✔</td>
  </tr>
  <tr>
   <td>Interior Lights</td>
   <td>✔</td>
   <td>✔</td>
  </tr>
  <tr>
   <td>Electric locomotive operating sounds</td>
   <td>✔</td>
   <td>✔</td>
  </tr>
  <tr>
   <td>Engineer's cab lighting</td>
   <td></td>
   <td>✔</td>
  </tr>
  <tr>
   <td>Station Announcements - Swiss</td>
   <td></td>
   <td>✔</td>
  </tr>
 </tbody>
</table>
The exact same table, modulo some whitespace differences, could be marked up as follows:

<table>
 <caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)
 <colgroup><col><col><col>
 <thead>
  <tr>
   <th>Function
   <th>Control Unit
   <th>Central Station
 <tbody>
  <tr>
   <td>Headlights
   <td>✔
   <td>✔
  <tr>
   <td>Interior Lights
   <td>✔
   <td>✔
  <tr>
   <td>Electric locomotive operating sounds
   <td>✔
   <td>✔
  <tr>
   <td>Engineer's cab lighting
   <td>
   <td>✔
  <tr>
   <td>Station Announcements - Swiss
   <td>
   <td>✔
</table>
Since the cells take up much less room this way, this can be made even terser by having each row on one line:

<table>
 <caption>37547 TEE Electric Powered Rail Car Train Functions (Abbreviated)
 <colgroup><col><col><col>
 <thead>
  <tr> <th>Function                              <th>Control Unit     <th>Central Station
 <tbody>
  <tr> <td>Headlights                            <td>✔                <td>✔
  <tr> <td>Interior Lights                       <td>✔                <td>✔
  <tr> <td>Electric locomotive operating sounds  <td>✔                <td>✔
  <tr> <td>Engineer's cab lighting               <td>                 <td>✔
  <tr> <td>Station Announcements - Swiss         <td>                 <td>✔
</table>
The only differences between these tables, at the DOM level, is with the precise position of the (in any case semantically-neutral) whitespace.

However, a start tag must never be omitted if it has any attributes.

Returning to the earlier example with all the whitespace removed and then all the optional tags removed:

<!DOCTYPE HTML><title>Hello</title><p>Welcome to this example.
If the body element in this example had to have a class attribute and the html element had to have a lang attribute, the markup would have to become:

<!DOCTYPE HTML><html lang="en"><title>Hello</title><body class="demo"><p>Welcome to this example.
This section assumes that the document is conforming, in particular, that there are no content model violations. Omitting tags in the fashion described in this section in a document that does not conform to the content models described in this specification is likely to result in unexpected DOM differences (this is, in part, what the content models are designed to avoid).

12.1.2.5 Restrictions on content models
For historical reasons, certain elements have extra restrictions beyond even the restrictions given by their content model.

A table element must not contain tr elements, even though these elements are technically allowed inside table elements according to the content models described in this specification. (If a tr element is put inside a table in the markup, it will in fact imply a tbody start tag before it.)

A single newline may be placed immediately after the start tag of pre and textarea elements. This does not affect the processing of the element. The otherwise optional newline must be included if the element's contents themselves start with a newline (because otherwise the leading newline in the contents would be treated like the optional newline, and ignored).

The following two pre blocks are equivalent:

<pre>Hello</pre>
<pre>
Hello</pre>
12.1.2.6 Restrictions on the contents of raw text and escapable raw text elements
The text in raw text and escapable raw text elements must not contain any occurrences of the string "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS) followed by characters that case-insensitively match the tag name of the element followed by one of U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), U+0020 SPACE, U+003E GREATER-THAN SIGN (>), or U+002F SOLIDUS (/).

12.1.3 Text
Text is allowed inside elements, attribute values, and comments. Extra constraints are placed on what is and what is not allowed in text based on where the text is to be put, as described in the other sections.

12.1.3.1 Newlines
Newlines in HTML may be represented either as U+000D CARRIAGE RETURN (CR) characters, U+000A LINE FEED (LF) characters, or pairs of U+000D CARRIAGE RETURN (CR), U+000A LINE FEED (LF) characters in that order.

Where character references are allowed, a character reference of a U+000A LINE FEED (LF) character (but not a U+000D CARRIAGE RETURN (CR) character) also represents a newline.

12.1.4 Character references
In certain cases described in other sections, text may be mixed with character references. These can be used to escape characters that couldn't otherwise legally be included in text.

Character references must start with a U+0026 AMPERSAND character (&). Following this, there are three possible kinds of character references:

Named character references
The ampersand must be followed by one of the names given in the named character references section, using the same case. The name must be one that is terminated by a U+003B SEMICOLON character (;).
Decimal numeric character reference
The ampersand must be followed by a U+0023 NUMBER SIGN character (#), followed by one or more ASCII digits, representing a base-ten integer that corresponds to a code point that is allowed according to the definition below. The digits must then be followed by a U+003B SEMICOLON character (;).
Hexadecimal numeric character reference
The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by one or more ASCII hex digits, representing a hexadecimal integer that corresponds to a code point that is allowed according to the definition below. The digits must then be followed by a U+003B SEMICOLON character (;).
The numeric character reference forms described above are allowed to reference any code point excluding U+000D CR, noncharacters, and controls other than ASCII whitespace.

An ambiguous ampersand is a U+0026 AMPERSAND character (&) that is followed by one or more ASCII alphanumerics, followed by a U+003B SEMICOLON character (;), where these characters do not match any of the names given in the named character references section.

12.1.5 CDATA sections
CDATA sections must consist of the following components, in this order:

The string "<![CDATA[".
Optionally, text, with the additional restriction that the text must not contain the string "]]>".
The string "]]>".
CDATA sections can only be used in foreign content (MathML or SVG). In this example, a CDATA section is used to escape the contents of a MathML ms element:

<p>You can add a string to a number, but this stringifies the number:</p>
<math>
 <ms><![CDATA[x<y]]></ms>
 <mo>+</mo>
 <mn>3</mn>
 <mo>=</mo>
 <ms><![CDATA[x<y3]]></ms>
</math>
12.1.6 Comments
Comments must have the following format:

The string "<!--".
Optionally, text, with the additional restriction that the text must not start with the string ">", nor start with the string "->", nor contain the strings "<!--", "-->", or "--!>", nor end with the string "<!-".
The string "-->".
The text is allowed to end with the string "<!", as in <!--My favorite operators are > and <!-->.

12.2 Parsing HTML documents
This section only applies to user agents, data mining tools, and conformance checkers.

The rules for parsing XML documents into DOM trees are covered by the next section, entitled "The XML syntax".

User agents must use the parsing rules described in this section to generate the DOM trees from text/html resources. Together, these rules define what is referred to as the HTML parser.

While the HTML syntax described in this specification bears a close resemblance to SGML and XML, it is a separate language with its own parsing rules.

Some earlier versions of HTML (in particular from HTML2 to HTML4) were based on SGML and used SGML parsing rules. However, few (if any) web browsers ever implemented true SGML parsing for HTML documents; the only user agents to strictly handle HTML as an SGML application have historically been validators. The resulting confusion — with validators claiming documents to have one representation while widely deployed Web browsers interoperably implemented a different representation — has wasted decades of productivity. This version of HTML thus returns to a non-SGML basis.

Authors interested in using SGML tools in their authoring pipeline are encouraged to use XML tools and the XML serialization of HTML.

For the purposes of conformance checkers, if a resource is determined to be in the HTML syntax, then it is an HTML document.

As stated in the terminology section, references to element types that do not explicitly specify a namespace always refer to elements in the HTML namespace. For example, if the spec talks about "a menu element", then that is an element with the local name "menu", the namespace "http://www.w3.org/1999/xhtml", and the interface HTMLMenuElement. Where possible, references to such elements are hyperlinked to their definition.

12.2.1 Overview of the parsing model

The input to the HTML parsing process consists of a stream of code points, which is passed through a tokenization stage followed by a tree construction stage. The output is a Document object.

Implementations that do not support scripting do not have to actually create a DOM Document object, but the DOM tree in such cases is still used as the model for the rest of the specification.

In the common case, the data handled by the tokenization stage comes from the network, but it can also come from script running in the user agent, e.g. using the document.write() API.

There is only one set of states for the tokenizer stage and the tree construction stage, but the tree construction stage is reentrant, meaning that while the tree construction stage is handling one token, the tokenizer might be resumed, causing further tokens to be emitted and processed before the first token's processing is complete.

In the following example, the tree construction stage will be called upon to handle a "p" start tag token while handling the "script" end tag token:

...
<script>
 document.write('<p>');
</script>
...
To handle these cases, parsers have a script nesting level, which must be initially set to zero, and a parser pause flag, which must be initially set to false.

12.2.2 Parse errors
This specification defines the parsing rules for HTML documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be parse errors. The error handling for parse errors is well-defined (that's the processing rules described throughout this specification), but user agents, while parsing an HTML document, may abort the parser at the first parse error that they encounter for which they do not wish to apply the rules described in this specification.

Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document.

Parse errors are only errors with the syntax of HTML. In addition to checking for parse errors, conformance checkers will also verify that the document obeys all the other conformance requirements described in this specification.

Some parse errors have dedicated codes outlined in the table below that should be used by conformance checkers in reports.

Error descriptions in the table below are non-normative.

Code	Description
abrupt-closing-of-empty-comment
This error occurs if the parser encounters an empty comment that is abruptly closed by a U+003E (>) code point (i.e., <!--> or <!--->). The parser behaves as if the comment is closed correctly.

abrupt-doctype-public-identifier
This error occurs if the parser encounters a U+003E (>) code point in the DOCTYPE public identifier (e.g., <!DOCTYPE html PUBLIC "foo>). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

abrupt-doctype-system-identifier
This error occurs if the parser encounters a U+003E (>) code point in the DOCTYPE system identifier (e.g., <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "foo>). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

absence-of-digits-in-numeric-character-reference
This error occurs if the parser encounters a numeric character reference that doesn't contain any digits (e.g., &#qux;). In this case the parser doesn't resolve the character reference.

cdata-in-html-content
This error occurs if the parser encounters a CDATA section outside of foreign content (SVG or MathML). The parser treats such CDATA sections (including leading "[CDATA[" and trailing "]]" strings) as comments.

character-reference-outside-unicode-range
This error occurs if the parser encounters a numeric character reference that references a code point that is greater than the valid Unicode range. The parser resolves such a character reference to a U+FFFD REPLACEMENT CHARACTER.

control-character-in-input-stream
This error occurs if the input stream contains a control code point that is not ASCII whitespace or U+0000 NULL. Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.

control-character-reference
This error occurs if the parser encounters a numeric character reference that references a control code point that is not ASCII whitespace, a U+000D CARRIAGE RETURN, or U+0000 NULL. The parser resolves such character references as-is except C1 control references that are replaced according to the numeric character reference end state.

end-tag-with-attributes
This error occurs if the parser encounters an end tag with attributes. Attributes in end tags are completely ignored and do not make their way into the DOM.

duplicate-attribute
This error occurs if the parser encounters an attribute in a tag that already has an attribute with the same name. The parser ignores all such duplicate occurrences of the attribute.

end-tag-with-trailing-solidus
This error occurs if the parser encounters an end tag that has a U+002F (/) code point right before the closing U+003E (>) code point (e.g., </div/>). Such a tag is treated as a regular end tag.

eof-before-tag-name
This error occurs if the parser encounters the end of the input stream where a tag name is expected. In this case the parser treats the beginning of a start tag (i.e., <) or an end tag (i.e., </) as text content.

eof-in-cdata
This error occurs if the parser encounters the end of the input stream in a CDATA section. The parser treats such CDATA sections as if they are closed immediately before the end of the input stream.

eof-in-comment
This error occurs if the parser encounters the end of the input stream in a comment. The parser treats such comments as if they are closed immediately before the end of the input stream.

eof-in-doctype
This error occurs if the parser encounters the end of the input stream in a DOCTYPE. In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

eof-in-script-html-comment-like-text
This error occurs if the parser encounters the end of the input stream in text that resembles an HTML comment inside script element content (e.g., <script><!-- foo).

Syntactic structures that resemble HTML comments in script elements are parsed as text content. They can be a part of a scripting language-specific syntactic structure or be treated as an HTML-like comment, if the scripting language supports them (e.g., parsing rules for HTML-like comments can be found in Annex B of the JavaScript specification). The common reason for this error is a violation of the restrictions for contents of script elements. [JAVASCRIPT]

eof-in-tag
This error occurs if the parser encounters the end of the input stream in a start tag or an end tag (e.g., <div id=). Such a tag is completely ignored.

incorrectly-closed-comment
This error occurs if the parser encounters a comment that is closed by the "--!>" code point sequence. The parser treats such comments as if they are correctly closed by the "-->" code point sequence.

incorrectly-opened-comment
This error occurs if the parser encounters the "<!" code point sequence that is not immidiately followed by two U+002D (-) code points and that is not the start of a DOCTYPE or a CDATA section. All content that follows the "<!" code point sequence up to a U+003E (>) code point (if present) or to the end of the input stream is treated as a comment.

One possible cause of this error is using an XML markup declaration (e.g., <!ELEMENT br EMPTY>) in HTML.

invalid-character-sequence-after-doctype-name
This error occurs if the parser encounters any code point sequence other than "PUBLIC" and "SYSTEM" keywords after a DOCTYPE name. In such a case, the parser ignores any following public or system identifiers, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.

invalid-first-character-of-tag-name
This error occurs if the parser encounters a code point that is not an ASCII alpha where first code point of a start tag name or an end tag name is expected. If a start tag was expected such code point and a preceding U+003C (<) is treated as text content, and all content that follows is treated as markup. Whereas, if an end tag was expected, such code point and all content that follows up to a U+003E (>) code point (if present) or to the end of the input stream is treated as a comment.

For example, consider the following markup:

<42></42>
This will be parsed into:

html
head
body
#text: <42>
#comment: 42
While the first code point of a tag name is limited to an ASCII alpha, a wide range of code points (including ASCII digits) is allowed in subsequent positions.

missing-attribute-value
This error occurs if the parser encounters a U+003E (>) code point where an attribute value is expected (e.g., <div id=>). The parser treats the attribute as having an empty value.

missing-doctype-name
This error occurs if the parser encounters a DOCTYPE that is missing a name (e.g., <!DOCTYPE>). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

missing-doctype-public-identifier
This error occurs if the parser encounters a U+003E (>) code point where start of the DOCTYPE public identifier is expected (e.g., <!DOCTYPE html PUBLIC >). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

missing-doctype-system-identifier
This error occurs if the parser encounters a U+003E (>) code point where start of the DOCTYPE system identifier is expected (e.g., <!DOCTYPE html SYSTEM >). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.

missing-end-tag-name
This error occurs if the parser encounters a U+003E (>) code point where an end tag name is expected, i.e., </>. The parser completely ignores whole "</>" code point sequence.

missing-quote-before-doctype-public-identifier
This error occurs if the parser encounters the DOCTYPE public identifier that is not preceded by a quote (e.g., <!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01//EN">). In such a case, the parser ignores the public identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.

missing-quote-before-doctype-system-identifier
This error occurs if the parser encounters the DOCTYPE system identifier that is not preceded by a quote (e.g., <!DOCTYPE html SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">). In such a case, the parser ignores the system identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.

missing-semicolon-after-character-reference
This error occurs if the parser encounters a character reference that is not terminated by a U+003B (;) code point. Usually the parser behaves as if character reference is terminated by the U+003B (;) code point; however, there are some ambiguous cases in which the parser includes subsequent code points in the character reference.

For example, &not;in will be parsed as "¬in" whereas &notin will be parsed as "∉".

missing-whitespace-after-doctype-public-keyword
This error occurs if the parser encounters a DOCTYPE whose "PUBLIC" keyword and public identifier are not separated by ASCII whitespace. In this case the parser behaves as if ASCII whitespace is present.

missing-whitespace-after-doctype-system-keyword
This error occurs if the parser encounters a DOCTYPE whose "SYSTEM" keyword and system identifier are not separated by ASCII whitespace. In this case the parser behaves as if ASCII whitespace is present.

missing-whitespace-before-doctype-name
This error occurs if the parser encounters a DOCTYPE whose "DOCTYPE" keyword and name are not separated by ASCII whitespace. In this case the parser behaves as if ASCII whitespace is present.

missing-whitespace-between-attributes
This error occurs if the parser encounters attributes that are not separated by ASCII whitespace (e.g., <div id="foo"class="bar">). In this case the parser behaves as if ASCII whitespace is present.

missing-whitespace-between-doctype-public-and-system-identifiers
This error occurs if the parser encounters a DOCTYPE whose public and system identifiers are not separated by ASCII whitespace. In this case the parser behaves as if ASCII whitespace is present.

nested-comment
This error occurs if the parser encounters a nested comment (e.g., <!-- <!-- nested --> -->). Such a comment will be closed by the first occuring "-->" code point sequence and everything that follows will be treated as markup.

noncharacter-character-reference
This error occurs if the parser encounters a numeric character reference that references a noncharacter. The parser resolves such character references as-is.

noncharacter-in-input-stream
This error occurs if the input stream contains a noncharacter. Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.

non-void-html-element-start-tag-with-trailing-solidus
This error occurs if the parser encounters a start tag for an element that is not in the list of void elements or is not a part of foreign content (i.e., not an SVG or MathML element) that has a U+002F (/) code point right before the closing U+003E (>) code point. The parser behaves as if the U+002F (/) is not present.

For example, consider the following markup:

<div/><span></span><span></span>
This will be parsed into:

html
head
body
div
span
span
The trailing U+002F (/) in a start tag name can be used only in foreign content to specify self-closing tags. (Self-closing tags don't exist in HTML.) It is also allowed for void elements, but doesn't have any effect in this case.

null-character-reference
This error occurs if the parser encounters a numeric character reference that references a U+0000 NULL code point. The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.

surrogate-character-reference
This error occurs if the parser encounters a numeric character reference that references a surrogate. The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.

surrogate-in-input-stream
This error occurs if the input stream contains a surrogate. Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.

Surrogates can only find their way into the input stream via script APIs such as document.write().

unexpected-character-after-doctype-system-identifier
This error occurs if the parser encounters any code points other than ASCII whitespace or closing U+003E (>) after the DOCTYPE system identifier. The parser ignores these code points.

unexpected-character-in-attribute-name
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), or U+003C (<) code point in an attribute name. The parser includes such code points in the attribute name.

Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute name.

For example, consider the following markup:

<div foo<div>
Due to a forgotten U+003E (>) code point after foo the parser treats this markup as a single div element with a "foo<div" attribute.

As another example of this error, consider the following markup:

<div id'bar'>
Due to a forgotten U+003D (=) code point between an attribute name and value the parser treats this markup as a div element with the attribute "id'bar'" that has an empty value.

unexpected-character-in-unquoted-attribute-value
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), U+003C (<), U+003D (=), or U+0060 (`) code point in an unquoted attribute value. The parser includes such code points in the attribute value.

Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute value.

U+0060 (`) is in the list of code points that trigger this error because certain legacy user agents treat it as a quote.

For example, consider the following markup:

<div foo=b'ar'>
Due to a misplaced U+0027 (') code point the parser sets the value of the "foo" attribute to "b'ar'".

unexpected-equals-sign-before-attribute-name
This error occurs if the parser encounters a U+003D (=) code point before an attribute name. In this case the parser treats U+003D (=) as the first code point of the attribute name.

The common reason for this error is a forgotten attribute name.

For example, consider the following markup:

<div foo="bar" ="baz">
Due to a forgotten attribute name the parser treats this markup as a div element with two attributes: a "foo" attribute with a "bar" value and a "="baz"" attribute with an empty value.

unexpected-null-character
This error occurs if the parser encounters a U+0000 NULL code point in the input stream in certain positions. In general, such code points are either completely ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER.

unexpected-question-mark-instead-of-tag-name
This error occurs if the parser encounters a U+003F (?) code point where first code point of a start tag name is expected. The U+003F (?) and all content that follows up to a U+003E (>) code point (if present) or to the end of the input stream is treated as a comment.

For example, consider the following markup:

<?xml-stylesheet type="text/css" href="style.css"?>
This will be parsed into:

#comment: ?xml-stylesheet type="text/css" href="style.css"?
html
head
body
The common reason for this error is an XML processing instruction (e.g., <?xml-stylesheet type="text/css" href="style.css"?>) or an XML declaration (e.g., <?xml version="1.0" encoding="UTF-8"?>) being used in HTML.

unexpected-solidus-in-tag
This error occurs if the parser encounters a U+002F (/) code point that is not a part of a quoted attribute value and not immediately followed by a U+003E (>) code point in a tag (e.g., <div / id="foo">). In this case the parser behaves as if it encountered ASCII whitespace.

unknown-named-character-reference
This error occurs if the parser encounters an ambiguous ampersand. In this case the parser doesn't resolve the character reference.

12.2.3 The input byte stream
The stream of code points that comprises the input to the tokenization stage will be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). The bytes encode the actual characters according to a particular character encoding, which the user agent uses to decode the bytes into characters.

For XML documents, the algorithm user agents are required to use to determine the character encoding is given by the XML specification. This section does not apply to XML documents. [XML]

Usually, the encoding sniffing algorithm defined below is used to determine the character encoding.

Given a character encoding, the bytes in the input byte stream must be converted to characters for the tokenizer's input stream, by passing the input byte stream and character encoding to decode.

A leading Byte Order Mark (BOM) causes the character encoding argument to be ignored and will itself be skipped.

Bytes or sequences of bytes in the original byte stream that did not conform to the Encoding standard (e.g. invalid UTF-8 byte sequences in a UTF-8 input byte stream) are errors that conformance checkers are expected to report. [ENCODING]

The decoder algorithms describe how to handle invalid input; for security reasons, it is imperative that those rules be followed precisely. Differences in how invalid byte sequences are handled can result in, amongst other problems, script injection vulnerabilities ("XSS").

When the HTML parser is decoding an input byte stream, it uses a character encoding and a confidence. The confidence is either tentative, certain, or irrelevant. The encoding used, and whether the confidence in that encoding is tentative or certain, is used during the parsing to determine whether to change the encoding. If no encoding is necessary, e.g. because the parser is operating on a Unicode stream and doesn't have to use a character encoding at all, then the confidence is irrelevant.

Some algorithms feed the parser by directly adding characters to the input stream rather than adding bytes to the input byte stream.

12.2.3.1 Parsing with a known character encoding
When the HTML parser is to operate on an input byte stream that has a known definite encoding, then the character encoding is that encoding and the confidence is certain.

12.2.3.2 Determining the character encoding
In some cases, it might be impractical to unambiguously determine the encoding before parsing the document. Because of this, this specification provides for a two-pass mechanism with an optional pre-scan. Implementations are allowed, as described below, to apply a simplified parsing algorithm to whatever bytes they have available before beginning to parse the document. Then, the real parser is started, using a tentative encoding derived from this pre-parse and other out-of-band metadata. If, while the document is being loaded, the user agent discovers a character encoding declaration that conflicts with this information, then the parser can get reinvoked to perform a parse of the document with the real encoding.

User agents must use the following algorithm, called the encoding sniffing algorithm, to determine the character encoding to use when decoding a document in the first pass. This algorithm takes as input any out-of-band metadata available to the user agent (e.g. the Content-Type metadata of the document) and all the bytes available so far, and returns a character encoding and a confidence that is either tentative or certain.

If the user has explicitly instructed the user agent to override the document's character encoding with a specific encoding, optionally return that encoding with the confidence certain.

Typically, user agents remember such user requests across sessions, and in some cases apply them to documents in iframes as well.

The user agent may wait for more bytes of the resource to be available, either in this step or at any later step in this algorithm. For instance, a user agent might wait 500ms or 1024 bytes, whichever came first. In general preparsing the source to find the encoding improves performance, as it reduces the need to throw away the data structures used when parsing upon finding the encoding information. However, if the user agent delays too long to obtain data to determine the encoding, then the cost of the delay could outweigh any performance improvements from the preparse.

The authoring conformance requirements for character encoding declarations limit them to only appearing in the first 1024 bytes. User agents are therefore encouraged to use the prescan algorithm below (as invoked by these steps) on the first 1024 bytes, but not to stall beyond that.

If the transport layer specifies a character encoding, and it is supported, return that encoding with the confidence certain.

Optionally prescan the byte stream to determine its encoding. The end condition is that the user agent decides that scanning further bytes would not be efficient. User agents are encouraged to only prescan the first 1024 bytes. User agents may decide that scanning any bytes is not efficient, in which case these substeps are entirely skipped.

The aforementioned algorithm either aborts unsuccessfully or returns a character encoding. If it returns a character encoding, then return the same encoding, with confidence tentative.

If the HTML parser for which this algorithm is being run is associated with a Document that is itself in a nested browsing context, run these substeps:

Let new document be the Document with which the HTML parser is associated.

Let parent document be the Document through which new document is nested (the active document of the parent browsing context of new document).

If parent document's origin is same origin with new document's origin, and parent document's character encoding is an ASCII-compatible encoding, then return parent document's character encoding, with the confidence tentative.

Otherwise, if the user agent has information on the likely encoding for this page, e.g. based on the encoding of the page when it was last visited, then return that encoding, with the confidence tentative.

The user agent may attempt to autodetect the character encoding from applying frequency analysis or other algorithms to the data stream. Such algorithms may use information about the resource other than the resource's contents, including the address of the resource. If autodetection succeeds in determining a character encoding, and that encoding is a supported encoding, then return that encoding, with the confidence tentative. [UNIVCHARDET]

User agents are generally discouraged from attempting to autodetect encodings for resources obtained over the network, since doing so involves inherently non-interoperable heuristics. Attempting to detect encodings based on an HTML document's preamble is especially tricky since HTML markup typically uses only ASCII characters, and HTML documents tend to begin with a lot of markup rather than with text content.

The UTF-8 encoding has a highly detectable bit pattern. Files from the local file system that contain bytes with values greater than 0x7F which match the UTF-8 pattern are very likely to be UTF-8, while documents with byte sequences that do not match it are very likely not. When a user agent can examine the whole file, rather than just the preamble, detecting for UTF-8 specifically can be especially effective. [PPUTF8] [UTF8DET]

Otherwise, return an implementation-defined or user-specified default character encoding, with the confidence tentative.

In controlled environments or in environments where the encoding of documents can be prescribed (for example, for user agents intended for dedicated use in new networks), the comprehensive UTF-8 encoding is suggested.

In other environments, the default encoding is typically dependent on the user's locale (an approximation of the languages, and thus often encodings, of the pages that the user is likely to frequent). The following table gives suggested defaults based on the user's locale, for compatibility with legacy content. Locales are identified by BCP 47 language tags. [BCP47] [ENCODING]

Locale language	Suggested default encoding
ar	Arabic	windows-1256
ba	Bashkir	windows-1251
be	Belarusian	windows-1251
bg	Bulgarian	windows-1251
cs	Czech	windows-1250
el	Greek	ISO-8859-7
et	Estonian	windows-1257
fa	Persian	windows-1256
he	Hebrew	windows-1255
hr	Croatian	windows-1250
hu	Hungarian	ISO-8859-2
ja	Japanese	Shift_JIS
kk	Kazakh	windows-1251
ko	Korean	EUC-KR
ku	Kurdish	windows-1254
ky	Kyrgyz	windows-1251
lt	Lithuanian	windows-1257
lv	Latvian	windows-1257
mk	Macedonian	windows-1251
pl	Polish	ISO-8859-2
ru	Russian	windows-1251
sah	Yakut	windows-1251
sk	Slovak	windows-1250
sl	Slovenian	ISO-8859-2
sr	Serbian	windows-1251
tg	Tajik	windows-1251
th	Thai	windows-874
tr	Turkish	windows-1254
tt	Tatar	windows-1251
uk	Ukrainian	windows-1251
vi	Vietnamese	windows-1258
zh-CN	Chinese (People's Republic of China)	gb18030
zh-TW	Chinese (Taiwan)	Big5
All other locales	windows-1252
The contents of this table are derived from the intersection of Windows, Chrome, and Firefox defaults.

The document's character encoding must immediately be set to the value returned from this algorithm, at the same time as the user agent uses the returned value to select the decoder to use for the input byte stream.

When an algorithm requires a user agent to prescan a byte stream to determine its encoding, given some defined end condition, then it must run the following steps. These steps either abort unsuccessfully or return a character encoding. If at any point during these steps (including during instances of the get an attribute algorithm invoked by this one) the user agent either runs out of bytes (meaning the position pointer created in the first step below goes beyond the end of the byte stream obtained so far) or reaches its end condition, then abort the prescan a byte stream to determine its encoding algorithm unsuccessfully.

Let position be a pointer to a byte in the input byte stream, initially pointing at the first byte.

Loop: If position points to:

A sequence of bytes starting with: 0x3C 0x21 0x2D 0x2D (`<!--`)
Advance the position pointer so that it points at the first 0x3E byte which is preceded by two 0x2D bytes (i.e. at the end of an ASCII '-->' sequence) and comes after the 0x3C byte that was found. (The two 0x2D bytes can be the same as those in the '<!--' sequence.)

A sequence of bytes starting with: 0x3C, 0x4D or 0x6D, 0x45 or 0x65, 0x54 or 0x74, 0x41 or 0x61, and one of 0x09, 0x0A, 0x0C, 0x0D, 0x20, 0x2F (case-insensitive ASCII '<meta' followed by a space or slash)
Advance the position pointer so that it points at the next 0x09, 0x0A, 0x0C, 0x0D, 0x20, or 0x2F byte (the one in sequence of characters matched above).

Let attribute list be an empty list of strings.

Let got pragma be false.

Let need pragma be null.

Let charset be the null value (which, for the purposes of this algorithm, is distinct from an unrecognized encoding or the empty string).

Attributes: Get an attribute and its value. If no attribute was sniffed, then jump to the processing step below.

If the attribute's name is already in attribute list, then return to the step labeled attributes.

Add the attribute's name to attribute list.

Run the appropriate step from the following list, if one applies:

If the attribute's name is "http-equiv"
If the attribute's value is "content-type", then set got pragma to true.

If the attribute's name is "content"
Apply the algorithm for extracting a character encoding from a meta element, giving the attribute's value as the string to parse. If a character encoding is returned, and if charset is still set to null, let charset be the encoding returned, and set need pragma to true.

If the attribute's name is "charset"
Let charset be the result of getting an encoding from the attribute's value, and set need pragma to false.

Return to the step labeled attributes.

Processing: If need pragma is null, then jump to the step below labeled next byte.

If need pragma is true but got pragma is false, then jump to the step below labeled next byte.

If charset is failure, then jump to the step below labeled next byte.

If charset is a UTF-16 encoding, then set charset to UTF-8.

If charset is x-user-defined, then set charset to windows-1252.

Abort the prescan a byte stream to determine its encoding algorithm, returning the encoding given by charset.

A sequence of bytes starting with a 0x3C byte (<), optionally a 0x2F byte (/), and finally a byte in the range 0x41-0x5A or 0x61-0x7A (A-Z or a-z)
Advance the position pointer so that it points at the next 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x3E (>) byte.

Repeatedly get an attribute until no further attributes can be found, then jump to the step below labeled next byte.

A sequence of bytes starting with: 0x3C 0x21 (`<!`)
A sequence of bytes starting with: 0x3C 0x2F (`</`)
A sequence of bytes starting with: 0x3C 0x3F (`<?`)
Advance the position pointer so that it points at the first 0x3E byte (>) that comes after the 0x3C byte that was found.

Any other byte
Do nothing with that byte.

Next byte: Move position so it points at the next byte in the input byte stream, and return to the step above labeled loop.
When the prescan a byte stream to determine its encoding algorithm says to get an attribute, it means doing this:

If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x2F (/) then advance position to the next byte and redo this step.

If the byte at position is 0x3E (>), then abort the get an attribute algorithm. There isn't one.

Otherwise, the byte at position is the start of the attribute name. Let attribute name and attribute value be the empty string.

Process the byte at position as follows:

If it is 0x3D (=), and the attribute name is longer than the empty string
Advance position to the next byte and jump to the step below labeled value.
If it is 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP)
Jump to the step below labeled spaces.
If it is 0x2F (/) or 0x3E (>)
Abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.
If it is in the range 0x41 (A) to 0x5A (Z)
Append the code point b+0x20 to attribute name (where b is the value of the byte at position). (This converts the input to lowercase.)
Anything else
Append the code point with the same value as the byte at position to attribute name. (It doesn't actually matter how bytes outside the ASCII range are handled here, since only ASCII bytes can contribute to the detection of a character encoding.)
Advance position to the next byte and return to the previous step.

Spaces: If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP) then advance position to the next byte, then, repeat this step.

If the byte at position is not 0x3D (=), abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.

Advance position past the 0x3D (=) byte.

Value: If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP) then advance position to the next byte, then, repeat this step.

Process the byte at position as follows:

If it is 0x22 (") or 0x27 (')
Let b be the value of the byte at position.
Quote loop: Advance position to the next byte.
If the value of the byte at position is the value of b, then advance position to the next byte and abort the "get an attribute" algorithm. The attribute's name is the value of attribute name, and its value is the value of attribute value.
Otherwise, if the value of the byte at position is in the range 0x41 (A) to 0x5A (Z), then append a code point to attribute value whose value is 0x20 more than the value of the byte at position.
Otherwise, append a code point to attribute value whose value is the same as the value of the byte at position.
Return to the step above labeled quote loop.
If it is 0x3E (>)
Abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.
If it is in the range 0x41 (A) to 0x5A (Z)
Append a code point b+0x20 to attribute value (where b is the value of the byte at position). Advance position to the next byte.
Anything else
Append a code point with the same value as the byte at position to attribute value. Advance position to the next byte.
Process the byte at position as follows:

If it is 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x3E (>)
Abort the get an attribute algorithm. The attribute's name is the value of attribute name and its value is the value of attribute value.
If it is in the range 0x41 (A) to 0x5A (Z)
Append a code point b+0x20 to attribute value (where b is the value of the byte at position).
Anything else
Append a code point with the same value as the byte at position to attribute value.
Advance position to the next byte and return to the previous step.

For the sake of interoperability, user agents should not use a pre-scan algorithm that returns different results than the one described above. (But, if you do, please at least let us know, so that we can improve this algorithm and benefit everyone...)

12.2.3.3 Character encodings
User agents must support the encodings defined in the WHATWG Encoding standard, including, but not limited to, UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows-1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE, and x-user-defined. User agents must not support other encodings.

The above prohibits supporting, for example, CESU-8, UTF-7, BOCU-1, SCSU, EBCDIC, and UTF-32. This specification does not make any attempt to support prohibited encodings in its algorithms; support and use of prohibited encodings would thus lead to unexpected behavior. [CESU8] [UTF7] [BOCU1] [SCSU]

12.2.3.4 Changing the encoding while parsing
When the parser requires the user agent to change the encoding, it must run the following steps. This might happen if the encoding sniffing algorithm described above failed to find a character encoding, or if it found a character encoding that was not the actual encoding of the file.

If the encoding that is already being used to interpret the input stream is a UTF-16 encoding, then set the confidence to certain and return. The new encoding is ignored; if it was anything but the same encoding, then it would be clearly incorrect.

If the new encoding is a UTF-16 encoding, then change it to UTF-8.

If the new encoding is x-user-defined, then change it to windows-1252.

If the new encoding is identical or equivalent to the encoding that is already being used to interpret the input stream, then set the confidence to certain and return. This happens when the encoding information found in the file matches what the encoding sniffing algorithm determined to be the encoding, and in the second pass through the parser if the first pass found that the encoding sniffing algorithm described in the earlier section failed to find the right encoding.

If all the bytes up to the last byte converted by the current decoder have the same Unicode interpretations in both the current encoding and the new encoding, and if the user agent supports changing the converter on the fly, then the user agent may change to the new converter for the encoding on the fly. Set the document's character encoding and the encoding used to convert the input stream to the new encoding, set the confidence to certain, and return.

Otherwise, navigate to the document again, with replacement enabled, and using the same source browsing context, but this time skip the encoding sniffing algorithm and instead just set the encoding to the new encoding and the confidence to certain. Whenever possible, this should be done without actually contacting the network layer (the bytes should be re-parsed from memory), even if, e.g., the document is marked as not being cacheable. If this is not possible and contacting the network layer would involve repeating a request that uses a method other than `GET`), then instead set the confidence to certain and ignore the new encoding. The resource will be misinterpreted. User agents may notify the user of the situation, to aid in application development.

This algorithm is only invoked when a new encoding is found declared on a meta element.

12.2.3.5 Preprocessing the input stream
The input stream consists of the characters pushed into it as the input byte stream is decoded or from the various APIs that directly manipulate the input stream.

Any occurrences of surrogates are surrogate-in-input-stream parse errors. Any occurrences of noncharacters are noncharacter-in-input-stream parse errors and any occurrences of controls other than ASCII whitespace and U+0000 NULL characters are control-character-in-input-stream parse errors.

The handling of U+0000 NULL characters varies based on where the characters are found and happens at the later stages of the parsing. They are either ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER. This handling is, by necessity, spread across both the tokenization stage and the tree construction stage.

U+000D CARRIAGE RETURN (CR) characters and U+000A LINE FEED (LF) characters are treated specially. Any LF character that immediately follows a CR character must be ignored, and all CR characters must then be converted to LF characters. Thus, newlines in HTML DOMs are represented by LF characters, and there are never any CR characters in the input to the tokenization stage.

The next input character is the first character in the input stream that has not yet been consumed or explicitly ignored by the requirements in this section. Initially, the next input character is the first character in the input. The current input character is the last character to have been consumed.

The insertion point is the position (just before a character or just before the end of the input stream) where content inserted using document.write() is actually inserted. The insertion point is relative to the position of the character immediately after it, it is not an absolute offset into the input stream. Initially, the insertion point is undefined.

The "EOF" character in the tables below is a conceptual character representing the end of the input stream. If the parser is a script-created parser, then the end of the input stream is reached when an explicit "EOF" character (inserted by the document.close() method) is consumed. Otherwise, the "EOF" character is not a real character in the stream, but rather the lack of any further characters.

12.2.4 Parse state
12.2.4.1 The insertion mode
The insertion mode is a state variable that controls the primary operation of the tree construction stage.

Initially, the insertion mode is "initial". It can change to "before html", "before head", "in head", "in head noscript", "after head", "in body", "text", "in table", "in table text", "in caption", "in column group", "in table body", "in row", "in cell", "in select", "in select in table", "in template", "after body", "in frameset", "after frameset", "after after body", and "after after frameset" during the course of the parsing, as described in the tree construction stage. The insertion mode affects how tokens are processed and whether CDATA sections are supported.

Several of these modes, namely "in head", "in body", "in table", and "in select", are special, in that the other modes defer to them at various times. When the algorithm below says that the user agent is to do something "using the rules for the m insertion mode", where m is one of these modes, the user agent must use the rules described under the m insertion mode's section, but must leave the insertion mode unchanged unless the rules in m themselves switch the insertion mode to a new value.

When the insertion mode is switched to "text" or "in table text", the original insertion mode is also set. This is the insertion mode to which the tree construction stage will return.

Similarly, to parse nested template elements, a stack of template insertion modes is used. It is initially empty. The current template insertion mode is the insertion mode that was most recently added to the stack of template insertion modes. The algorithms in the sections below will push insertion modes onto this stack, meaning that the specified insertion mode is to be added to the stack, and pop insertion modes from the stack, which means that the most recently added insertion mode must be removed from the stack.

When the steps below require the UA to reset the insertion mode appropriately, it means the UA must follow these steps:

Let last be false.

Let node be the last node in the stack of open elements.

Loop: If node is the first node in the stack of open elements, then set last to true, and, if the parser was originally created as part of the HTML fragment parsing algorithm (fragment case), set node to the context element passed to that algorithm.

If node is a select element, run these substeps:

If last is true, jump to the step below labeled done.

Let ancestor be node.

Loop: If ancestor is the first node in the stack of open elements, jump to the step below labeled done.

Let ancestor be the node before ancestor in the stack of open elements.

If ancestor is a template node, jump to the step below labeled done.

If ancestor is a table node, switch the insertion mode to "in select in table" and return.

Jump back to the step labeled loop.

Done: Switch the insertion mode to "in select" and return.

If node is a td or th element and last is false, then switch the insertion mode to "in cell" and return.

If node is a tr element, then switch the insertion mode to "in row" and return.

If node is a tbody, thead, or tfoot element, then switch the insertion mode to "in table body" and return.

If node is a caption element, then switch the insertion mode to "in caption" and return.

If node is a colgroup element, then switch the insertion mode to "in column group" and return.

If node is a table element, then switch the insertion mode to "in table" and return.

If node is a template element, then switch the insertion mode to the current template insertion mode and return.

If node is a head element and last is false, then switch the insertion mode to "in head" and return.

If node is a body element, then switch the insertion mode to "in body" and return.

If node is a frameset element, then switch the insertion mode to "in frameset" and return. (fragment case)

If node is an html element, run these substeps:

If the head element pointer is null, switch the insertion mode to "before head" and return. (fragment case)

Otherwise, the head element pointer is not null, switch the insertion mode to "after head" and return.

If last is true, then switch the insertion mode to "in body" and return. (fragment case)

Let node now be the node before node in the stack of open elements.

Return to the step labeled loop.

12.2.4.2 The stack of open elements
Initially, the stack of open elements is empty. The stack grows downwards; the topmost node on the stack is the first one added to the stack, and the bottommost node of the stack is the most recently added node in the stack (notwithstanding when the stack is manipulated in a random access fashion as part of the handling for misnested tags).

The "before html" insertion mode creates the html document element, which is then added to the stack.

In the fragment case, the stack of open elements is initialized to contain an html element that is created as part of that algorithm. (The fragment case skips the "before html" insertion mode.)

The html node, however it is created, is the topmost node of the stack. It only gets popped off the stack when the parser finishes.

The current node is the bottommost node in this stack of open elements.

The adjusted current node is the context element if the parser was created by the HTML fragment parsing algorithm and the stack of open elements has only one element in it (fragment case); otherwise, the adjusted current node is the current node.


Spec bugs: 27314

Elements in the stack of open elements fall into the following categories:

Special
The following elements have varying levels of special parsing rules: HTML's address, applet, area, article, aside, base, basefont, bgsound, blockquote, body, br, button, caption, center, col, colgroup, dd, details, dir, div, dl, dt, embed, fieldset, figcaption, figure, footer, form, frame, frameset, h1, h2, h3, h4, h5, h6, head, header, hgroup, hr, html, iframe, img, input, keygen, li, link, listing, main, marquee, menu, meta, nav, noembed, noframes, noscript, object, ol, p, param, plaintext, pre, script, section, select, source, style, summary, table, tbody, td, template, textarea, tfoot, th, thead, title, tr, track, ul, wbr, xmp; MathML mi, MathML mo, MathML mn, MathML ms, MathML mtext, and MathML annotation-xml; and SVG foreignObject, SVG desc, and SVG title.

An image start tag token is handled by the tree builder, but it is not in this list because it is not an element; it gets turned into an img element.

Formatting
The following HTML elements are those that end up in the list of active formatting elements: a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, and u.

Ordinary
All other elements found while parsing an HTML document.

Typically, the special elements have the start and end tag tokens handled specifically, while ordinary elements' tokens fall into "any other start tag" and "any other end tag" clauses, and some parts of the tree builder check if a particular element in the stack of open elements is in the special category. However, some elements (e.g., the option element) have their start or end tag tokens handled specifically, but are still not in the special category, so that they get the ordinary handling elsewhere.

The stack of open elements is said to have an element target node in a specific scope consisting of a list of element types list when the following algorithm terminates in a match state:

Initialize node to be the current node (the bottommost node of the stack).

If node is the target node, terminate in a match state.

Otherwise, if node is one of the element types in list, terminate in a failure state.

Otherwise, set node to the previous entry in the stack of open elements and return to step 2. (This will never fail, since the loop will always terminate in the previous step if the top of the stack — an html element — is reached.)

The stack of open elements is said to have a particular element in scope when it has that element in the specific scope consisting of the following element types:

applet
caption
html
table
td
th
marquee
object
template
MathML mi
MathML mo
MathML mn
MathML ms
MathML mtext
MathML annotation-xml
SVG foreignObject
SVG desc
SVG title
The stack of open elements is said to have a particular element in list item scope when it has that element in the specific scope consisting of the following element types:

All the element types listed above for the has an element in scope algorithm.
ol in the HTML namespace
ul in the HTML namespace
The stack of open elements is said to have a particular element in button scope when it has that element in the specific scope consisting of the following element types:

All the element types listed above for the has an element in scope algorithm.
button in the HTML namespace
The stack of open elements is said to have a particular element in table scope when it has that element in the specific scope consisting of the following element types:

html in the HTML namespace
table in the HTML namespace
template in the HTML namespace
The stack of open elements is said to have a particular element in select scope when it has that element in the specific scope consisting of all element types except the following:

optgroup in the HTML namespace
option in the HTML namespace
Nothing happens if at any time any of the elements in the stack of open elements are moved to a new location in, or removed from, the Document tree. In particular, the stack is not changed in this situation. This can cause, amongst other strange effects, content to be appended to nodes that are no longer in the DOM.

In some cases (namely, when closing misnested formatting elements), the stack is manipulated in a random-access fashion.

12.2.4.3 The list of active formatting elements
Initially, the list of active formatting elements is empty. It is used to handle mis-nested formatting element tags.

The list contains elements in the formatting category, and markers. The markers are inserted when entering applet, object, marquee, template, td, th, and caption elements, and are used to prevent formatting from "leaking" into applet, object, marquee, template, td, th, and caption elements.

In addition, each element in the list of active formatting elements is associated with the token for which it was created, so that further elements can be created for that token if necessary.

When the steps below require the UA to push onto the list of active formatting elements an element element, the UA must perform the following steps:

If there are already three elements in the list of active formatting elements after the last marker, if any, or anywhere in the list if there are no markers, that have the same tag name, namespace, and attributes as element, then remove the earliest such element from the list of active formatting elements. For these purposes, the attributes must be compared as they were when the elements were created by the parser; two elements have the same attributes if all their parsed attributes can be paired such that the two attributes in each pair have identical names, namespaces, and values (the order of the attributes does not matter).

This is the Noah's Ark clause. But with three per family instead of two.

Add element to the list of active formatting elements.

When the steps below require the UA to reconstruct the active formatting elements, the UA must perform the following steps:

If there are no entries in the list of active formatting elements, then there is nothing to reconstruct; stop this algorithm.

If the last (most recently added) entry in the list of active formatting elements is a marker, or if it is an element that is in the stack of open elements, then there is nothing to reconstruct; stop this algorithm.

Let entry be the last (most recently added) element in the list of active formatting elements.

Rewind: If there are no entries before entry in the list of active formatting elements, then jump to the step labeled create.

Let entry be the entry one earlier than entry in the list of active formatting elements.

If entry is neither a marker nor an element that is also in the stack of open elements, go to the step labeled rewind.

Advance: Let entry be the element one later than entry in the list of active formatting elements.

Create: Insert an HTML element for the token for which the element entry was created, to obtain new element.

Replace the entry for entry in the list with an entry for new element.

If the entry for new element in the list of active formatting elements is not the last entry in the list, return to the step labeled advance.

This has the effect of reopening all the formatting elements that were opened in the current body, cell, or caption (whichever is youngest) that haven't been explicitly closed.

The way this specification is written, the list of active formatting elements always consists of elements in chronological order with the least recently added element first and the most recently added element last (except for while steps 7 to 10 of the above algorithm are being executed, of course).

When the steps below require the UA to clear the list of active formatting elements up to the last marker, the UA must perform the following steps:

Let entry be the last (most recently added) entry in the list of active formatting elements.

Remove entry from the list of active formatting elements.

If entry was a marker, then stop the algorithm at this point. The list has been cleared up to the last marker.

Go to step 1.

12.2.4.4 The element pointers
Initially, the head element pointer and the form element pointer are both null.

Once a head element has been parsed (whether implicitly or explicitly) the head element pointer gets set to point to this node.

The form element pointer points to the last form element that was opened and whose end tag has not yet been seen. It is used to make form controls associate with forms in the face of dramatically bad markup, for historical reasons. It is ignored inside template elements.

12.2.4.5 Other parsing state flags
The scripting flag is set to "enabled" if scripting was enabled for the Document with which the parser is associated when the parser was created, and "disabled" otherwise.

The scripting flag can be enabled even when the parser was originally created for the HTML fragment parsing algorithm, even though script elements don't execute in that case.

The frameset-ok flag is set to "ok" when the parser is created. It is set to "not ok" after certain tokens are seen.

12.2.5 Tokenization
Implementations must act as if they used the following state machine to tokenize HTML. The state machine must start in the data state. Most states consume a single character, which may have various side-effects, and either switches the state machine to a new state to reconsume the current input character, or switches it to a new state to consume the next character, or stays in the same state to consume the next character. Some states have more complicated behavior and can consume several characters before switching to another state. In some cases, the tokenizer state is also changed by the tree construction stage.

When a state says to reconsume a matched character in a specified state, that means to switch to that state, but when it attempts to consume the next input character, provide it with the current input character instead.

The exact behavior of certain states depends on the insertion mode and the stack of open elements. Certain states also use a temporary buffer to track progress, and the character reference state uses a return state to return to the state it was invoked from.

The output of the tokenization step is a series of zero or more of the following tokens: DOCTYPE, start tag, end tag, comment, character, end-of-file. DOCTYPE tokens have a name, a public identifier, a system identifier, and a force-quirks flag. When a DOCTYPE token is created, its name, public identifier, and system identifier must be marked as missing (which is a distinct state from the empty string), and the force-quirks flag must be set to off (its other state is on). Start and end tag tokens have a tag name, a self-closing flag, and a list of attributes, each of which has a name and a value. When a start or end tag token is created, its self-closing flag must be unset (its other state is that it be set), and its attributes list must be empty. Comment and character tokens have data.

When a token is emitted, it must immediately be handled by the tree construction stage. The tree construction stage can affect the state of the tokenization stage, and can insert additional characters into the stream. (For example, the script element can result in scripts executing and using the dynamic markup insertion APIs to insert characters into the stream being tokenized.)

Creating a token and emitting it are distinct actions. It is possible for a token to be created but implicitly abandoned (never emitted), e.g. if the file ends unexpectedly while processing the characters that are being parsed into a start tag token.

When a start tag token is emitted with its self-closing flag set, if the flag is not acknowledged when it is processed by the tree construction stage, that is a non-void-html-element-start-tag-with-trailing-solidus parse error.

When an end tag token is emitted with attributes, that is an end-tag-with-attributes parse error.

When an end tag token is emitted with its self-closing flag set, that is an end-tag-with-trailing-solidus parse error.

An appropriate end tag token is an end tag token whose tag name matches the tag name of the last start tag to have been emitted from this tokenizer, if any. If no start tag has been emitted from this tokenizer, then no end tag token is appropriate.

A character reference is said to be consumed as part of an attribute if the return state is either attribute value (double-quoted) state, attribute value (single-quoted) state or attribute value (unquoted) state.

When a state says to flush code points consumed as a character reference, it means that for each code point in the temporary buffer (in the order they were added to the buffer) user agent must append the code point from the buffer to the current attribute's value if the character reference was consumed as part of an attribute, or emit the code point as a character token otherwise.

Before each step of the tokenizer, the user agent must first check the parser pause flag. If it is true, then the tokenizer must abort the processing of any nested invocations of the tokenizer, yielding control back to the caller.

The tokenizer state machine consists of the states defined in the following subsections.

12.2.5.1 Data state
Consume the next input character:

U+0026 AMPERSAND (&)
Set the return state to the data state. Switch to the character reference state.
U+003C LESS-THAN SIGN (<)
Switch to the tag open state.
U+0000 NULL
This is an unexpected-null-character parse error. Emit the current input character as a character token.
EOF
Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.2 RCDATA state
Consume the next input character:

U+0026 AMPERSAND (&)
Set the return state to the RCDATA state. Switch to the character reference state.
U+003C LESS-THAN SIGN (<)
Switch to the RCDATA less-than sign state.
U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.3 RAWTEXT state
Consume the next input character:

U+003C LESS-THAN SIGN (<)
Switch to the RAWTEXT less-than sign state.
U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.4 Script data state
Consume the next input character:

U+003C LESS-THAN SIGN (<)
Switch to the script data less-than sign state.
U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.5 PLAINTEXT state
Consume the next input character:

U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.6 Tag open state
Consume the next input character:

U+0021 EXCLAMATION MARK (!)
Switch to the markup declaration open state.
U+002F SOLIDUS (/)
Switch to the end tag open state.
ASCII alpha
Create a new start tag token, set its tag name to the empty string. Reconsume in the tag name state.
U+003F QUESTION MARK (?)
This is an unexpected-question-mark-instead-of-tag-name parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
EOF
This is an eof-before-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token and an end-of-file token.
Anything else
This is an invalid-first-character-of-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the data state.
12.2.5.7 End tag open state
Consume the next input character:

ASCII alpha
Create a new end tag token, set its tag name to the empty string. Reconsume in the tag name state.
U+003E GREATER-THAN SIGN (>)
This is a missing-end-tag-name parse error. Switch to the data state.
EOF
This is an eof-before-tag-name parse error. Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token and an end-of-file token.
Anything else
This is an invalid-first-character-of-tag-name parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
12.2.5.8 Tag name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before attribute name state.
U+002F SOLIDUS (/)
Switch to the self-closing start tag state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current tag token.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token's tag name.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
Append the current input character to the current tag token's tag name.
12.2.5.9 RCDATA less-than sign state
Consume the next input character:

U+002F SOLIDUS (/)
Set the temporary buffer to the empty string. Switch to the RCDATA end tag open state.
Anything else
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RCDATA state.
12.2.5.10 RCDATA end tag open state
Consume the next input character:

ASCII alpha
Create a new end tag token, set its tag name to the empty string. Reconsume in the RCDATA end tag name state.
Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RCDATA state.
12.2.5.11 RCDATA end tag name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
U+003E GREATER-THAN SIGN (>)
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
ASCII lower alpha
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
Anything else
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RCDATA state.
12.2.5.12 RAWTEXT less-than sign state
Consume the next input character:

U+002F SOLIDUS (/)
Set the temporary buffer to the empty string. Switch to the RAWTEXT end tag open state.
Anything else
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RAWTEXT state.
12.2.5.13 RAWTEXT end tag open state
Consume the next input character:

ASCII alpha
Create a new end tag token, set its tag name to the empty string. Reconsume in the RAWTEXT end tag name state.
Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RAWTEXT state.
12.2.5.14 RAWTEXT end tag name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
U+003E GREATER-THAN SIGN (>)
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
ASCII lower alpha
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
Anything else
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RAWTEXT state.
12.2.5.15 Script data less-than sign state
Consume the next input character:

U+002F SOLIDUS (/)
Set the temporary buffer to the empty string. Switch to the script data end tag open state.
U+0021 EXCLAMATION MARK (!)
Switch to the script data escape start state. Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token.
Anything else
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data state.
12.2.5.16 Script data end tag open state
Consume the next input character:

ASCII alpha
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data end tag name state.
Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data state.
12.2.5.17 Script data end tag name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
U+003E GREATER-THAN SIGN (>)
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
ASCII lower alpha
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
Anything else
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data state.
12.2.5.18 Script data escape start state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data escape start dash state. Emit a U+002D HYPHEN-MINUS character token.
Anything else
Reconsume in the script data state.
12.2.5.19 Script data escape start dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
Anything else
Reconsume in the script data state.
12.2.5.20 Script data escaped state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data escaped less-than sign state.
U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.21 Script data escaped dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data escaped less-than sign state.
U+0000 NULL
This is an unexpected-null-character parse error. Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Switch to the script data escaped state. Emit the current input character as a character token.
12.2.5.22 Script data escaped dash dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data escaped less-than sign state.
U+003E GREATER-THAN SIGN (>)
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
U+0000 NULL
This is an unexpected-null-character parse error. Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Switch to the script data escaped state. Emit the current input character as a character token.
12.2.5.23 Script data escaped less-than sign state
Consume the next input character:

U+002F SOLIDUS (/)
Set the temporary buffer to the empty string. Switch to the script data escaped end tag open state.
ASCII alpha
Set the temporary buffer to the empty string. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data double escape start state.
Anything else
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data escaped state.
12.2.5.24 Script data escaped end tag open state
Consume the next input character:

ASCII alpha
Create a new end tag token. Reconsume in the script data escaped end tag name state. (Don't emit the token yet; further details will be filled in before it is emitted.)
Anything else
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data escaped state.
12.2.5.25 Script data escaped end tag name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
U+002F SOLIDUS (/)
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
U+003E GREATER-THAN SIGN (>)
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
ASCII lower alpha
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
Anything else
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data escaped state.
12.2.5.26 Script data double escape start state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
U+002F SOLIDUS (/)
U+003E GREATER-THAN SIGN (>)
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
ASCII lower alpha
Append the current input character to the temporary buffer. Emit the current input character as a character token.
Anything else
Reconsume in the script data escaped state.
12.2.5.27 Script data double escaped state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data double escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
U+0000 NULL
This is an unexpected-null-character parse error. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
12.2.5.28 Script data double escaped dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the script data double escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
U+0000 NULL
This is an unexpected-null-character parse error. Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Switch to the script data double escaped state. Emit the current input character as a character token.
12.2.5.29 Script data double escaped dash dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Emit a U+002D HYPHEN-MINUS character token.
U+003C LESS-THAN SIGN (<)
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
U+003E GREATER-THAN SIGN (>)
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
U+0000 NULL
This is an unexpected-null-character parse error. Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
EOF
This is an eof-in-script-html-comment-like-text parse error. Emit an end-of-file token.
Anything else
Switch to the script data double escaped state. Emit the current input character as a character token.
12.2.5.30 Script data double escaped less-than sign state
Consume the next input character:

U+002F SOLIDUS (/)
Set the temporary buffer to the empty string. Switch to the script data double escape end state. Emit a U+002F SOLIDUS character token.
Anything else
Reconsume in the script data double escaped state.
12.2.5.31 Script data double escape end state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
U+002F SOLIDUS (/)
U+003E GREATER-THAN SIGN (>)
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
ASCII lower alpha
Append the current input character to the temporary buffer. Emit the current input character as a character token.
Anything else
Reconsume in the script data double escaped state.
12.2.5.32 Before attribute name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+002F SOLIDUS (/)
U+003E GREATER-THAN SIGN (>)
EOF
Reconsume in the after attribute name state.
U+003D EQUALS SIGN (=)
This is an unexpected-equals-sign-before-attribute-name parse error. Start a new attribute in the current tag token. Set that attribute's name to the current input character, and its value to the empty string. Switch to the attribute name state.
Anything else
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
12.2.5.33 Attribute name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
U+002F SOLIDUS (/)
U+003E GREATER-THAN SIGN (>)
EOF
Reconsume in the after attribute name state.
U+003D EQUALS SIGN (=)
Switch to the before attribute value state.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current attribute's name.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's name.
U+0022 QUOTATION MARK (")
U+0027 APOSTROPHE (')
U+003C LESS-THAN SIGN (<)
This is an unexpected-character-in-attribute-name parse error. Treat it as per the "anything else" entry below.
Anything else
Append the current input character to the current attribute's name.
When the user agent leaves the attribute name state (and before emitting the tag token, if appropriate), the complete attribute's name must be compared to the other attributes on the same token; if there is already an attribute on the token with the exact same name, then this is a duplicate-attribute parse error and the new attribute must be removed from the token.

If an attribute is so removed from a token, it, and the value that gets associated with it, if any, are never subsequently used by the parser, and are therefore effectively discarded. Removing the attribute in this way does not change its status as the "current attribute" for the purposes of the tokenizer, however.

12.2.5.34 After attribute name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+002F SOLIDUS (/)
Switch to the self-closing start tag state.
U+003D EQUALS SIGN (=)
Switch to the before attribute value state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current tag token.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
12.2.5.35 Before attribute value state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+0022 QUOTATION MARK (")
Switch to the attribute value (double-quoted) state.
U+0027 APOSTROPHE (')
Switch to the attribute value (single-quoted) state.
U+003E GREATER-THAN SIGN (>)
This is a missing-attribute-value parse error. Switch to the data state. Emit the current tag token.
Anything else
Reconsume in the attribute value (unquoted) state.
12.2.5.36 Attribute value (double-quoted) state
Consume the next input character:

U+0022 QUOTATION MARK (")
Switch to the after attribute value (quoted) state.
U+0026 AMPERSAND (&)
Set the return state to the attribute value (double-quoted) state. Switch to the character reference state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
Append the current input character to the current attribute's value.
12.2.5.37 Attribute value (single-quoted) state
Consume the next input character:

U+0027 APOSTROPHE (')
Switch to the after attribute value (quoted) state.
U+0026 AMPERSAND (&)
Set the return state to the attribute value (single-quoted) state. Switch to the character reference state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
Append the current input character to the current attribute's value.
12.2.5.38 Attribute value (unquoted) state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before attribute name state.
U+0026 AMPERSAND (&)
Set the return state to the attribute value (unquoted) state. Switch to the character reference state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current tag token.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
U+0022 QUOTATION MARK (")
U+0027 APOSTROPHE (')
U+003C LESS-THAN SIGN (<)
U+003D EQUALS SIGN (=)
U+0060 GRAVE ACCENT (`)
This is an unexpected-character-in-unquoted-attribute-value parse error. Treat it as per the "anything else" entry below.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
Append the current input character to the current attribute's value.
12.2.5.39 After attribute value (quoted) state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before attribute name state.
U+002F SOLIDUS (/)
Switch to the self-closing start tag state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current tag token.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
This is a missing-whitespace-between-attributes parse error. Reconsume in the before attribute name state.
12.2.5.40 Self-closing start tag state
Consume the next input character:

U+003E GREATER-THAN SIGN (>)
Set the self-closing flag of the current tag token. Switch to the data state. Emit the current tag token.
EOF
This is an eof-in-tag parse error. Emit an end-of-file token.
Anything else
This is an unexpected-solidus-in-tag parse error. Reconsume in the before attribute name state.
12.2.5.41 Bogus comment state
Consume the next input character:

U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the comment token.
EOF
Emit the comment. Emit an end-of-file token.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
Anything else
Append the current input character to the comment token's data.
12.2.5.42 Markup declaration open state
If the next few characters are:

Two U+002D HYPHEN-MINUS characters (-)
Consume those two characters, create a comment token whose data is the empty string, and switch to the comment start state.
ASCII case-insensitive match for the word "DOCTYPE"
Consume those characters and switch to the DOCTYPE state.
Case-sensitive match for the string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after)
Consume those characters. If there is an adjusted current node and it is not an element in the HTML namespace, then switch to the CDATA section state. Otherwise, this is a cdata-in-html-content parse error. Create a comment token whose data is the "[CDATA[" string. Switch to the bogus comment state.
Anything else
This is an incorrectly-opened-comment parse error. Create a comment token whose data is the empty string. Switch to the bogus comment state (don't consume anything in the current state).
12.2.5.43 Comment start state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the comment start dash state.
U+003E GREATER-THAN SIGN (>)
This is an abrupt-closing-of-empty-comment parse error. Switch to the data state. Emit the comment token.
Anything else
Reconsume in the comment state.
12.2.5.44 Comment start dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the comment end state
U+003E GREATER-THAN SIGN (>)
This is an abrupt-closing-of-empty-comment parse error. Switch to the data state. Emit the comment token.
EOF
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
Anything else
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
12.2.5.45 Comment state
Consume the next input character:

U+003C LESS-THAN SIGN (<)
Append the current input character to the comment token's data. Switch to the comment less-than sign state.
U+002D HYPHEN-MINUS (-)
Switch to the comment end dash state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
EOF
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
Anything else
Append the current input character to the comment token's data.
12.2.5.46 Comment less-than sign state
Consume the next input character:

U+0021 EXCLAMATION MARK (!)
Append the current input character to the comment token's data. Switch to the comment less-than sign bang state.
U+003C LESS-THAN SIGN (<)
Append the current input character to the comment token's data.
Anything else
Reconsume in the comment state.
12.2.5.47 Comment less-than sign bang state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the comment less-than sign bang dash state.
Anything else
Reconsume in the comment state.
12.2.5.48 Comment less-than sign bang dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the comment less-than sign bang dash dash state.
Anything else
Reconsume in the comment end dash state.
12.2.5.49 Comment less-than sign bang dash dash state
Consume the next input character:

U+003E GREATER-THAN SIGN (>)
EOF
Reconsume in the comment end state.
Anything else
This is a nested-comment parse error. Reconsume in the comment end state.
12.2.5.50 Comment end dash state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Switch to the comment end state
EOF
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
Anything else
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
12.2.5.51 Comment end state
Consume the next input character:

U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the comment token.
U+0021 EXCLAMATION MARK (!)
Switch to the comment end bang state.
U+002D HYPHEN-MINUS (-)
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data.
EOF
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
Anything else
Append two U+002D HYPHEN-MINUS characters (-) to the comment token's data. Reconsume in the comment state.
12.2.5.52 Comment end bang state
Consume the next input character:

U+002D HYPHEN-MINUS (-)
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Switch to the comment end dash state.
U+003E GREATER-THAN SIGN (>)
This is an incorrectly-closed-comment parse error. Switch to the data state. Emit the comment token.
EOF
This is an eof-in-comment parse error. Emit the comment token. Emit an end-of-file token.
Anything else
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Reconsume in the comment state.
12.2.5.53 DOCTYPE state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before DOCTYPE name state.
U+003E GREATER-THAN SIGN (>)
Reconsume in the before DOCTYPE name state.
EOF
This is an eof-in-doctype parse error. Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the token. Emit an end-of-file token.
Anything else
This is a missing-whitespace-before-doctype-name parse error. Reconsume in the before DOCTYPE name state.
12.2.5.54 Before DOCTYPE name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
ASCII upper alpha
Create a new DOCTYPE token. Set the token's name to the lowercase version of the current input character (add 0x0020 to the character's code point). Switch to the DOCTYPE name state.
U+0000 NULL
This is an unexpected-null-character parse error. Create a new DOCTYPE token. Set the token's name to a U+FFFD REPLACEMENT CHARACTER character. Switch to the DOCTYPE name state.
U+003E GREATER-THAN SIGN (>)
This is a missing-doctype-name parse error. Create a new DOCTYPE token. Set its force-quirks flag to on. Switch to the data state. Emit the token.
EOF
This is an eof-in-doctype parse error. Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the token. Emit an end-of-file token.
Anything else
Create a new DOCTYPE token. Set the token's name to the current input character. Switch to the DOCTYPE name state.
12.2.5.55 DOCTYPE name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the after DOCTYPE name state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current DOCTYPE token.
ASCII upper alpha
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current DOCTYPE token's name.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's name.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
Append the current input character to the current DOCTYPE token's name.
12.2.5.56 After DOCTYPE name state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
If the six characters starting from the current input character are an ASCII case-insensitive match for the word "PUBLIC", then consume those characters and switch to the after DOCTYPE public keyword state.

Otherwise, if the six characters starting from the current input character are an ASCII case-insensitive match for the word "SYSTEM", then consume those characters and switch to the after DOCTYPE system keyword state.

Otherwise, this is an invalid-character-sequence-after-doctype-name parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.

12.2.5.57 After DOCTYPE public keyword state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before DOCTYPE public identifier state.
U+0022 QUOTATION MARK (")
This is a missing-whitespace-after-doctype-public-keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
U+0027 APOSTROPHE (')
This is a missing-whitespace-after-doctype-public-keyword parse error. Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
U+003E GREATER-THAN SIGN (>)
This is a missing-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.58 Before DOCTYPE public identifier state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+0022 QUOTATION MARK (")
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
U+0027 APOSTROPHE (')
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
U+003E GREATER-THAN SIGN (>)
This is a missing-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.59 DOCTYPE public identifier (double-quoted) state
Consume the next input character:

U+0022 QUOTATION MARK (")
Switch to the after DOCTYPE public identifier state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
U+003E GREATER-THAN SIGN (>)
This is an abrupt-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
Append the current input character to the current DOCTYPE token's public identifier.
12.2.5.60 DOCTYPE public identifier (single-quoted) state
Consume the next input character:

U+0027 APOSTROPHE (')
Switch to the after DOCTYPE public identifier state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
U+003E GREATER-THAN SIGN (>)
This is an abrupt-doctype-public-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
Append the current input character to the current DOCTYPE token's public identifier.
12.2.5.61 After DOCTYPE public identifier state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the between DOCTYPE public and system identifiers state.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current DOCTYPE token.
U+0022 QUOTATION MARK (")
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
U+0027 APOSTROPHE (')
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.62 Between DOCTYPE public and system identifiers state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current DOCTYPE token.
U+0022 QUOTATION MARK (")
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
U+0027 APOSTROPHE (')
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.63 After DOCTYPE system keyword state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Switch to the before DOCTYPE system identifier state.
U+0022 QUOTATION MARK (")
This is a missing-whitespace-after-doctype-system-keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
U+0027 APOSTROPHE (')
This is a missing-whitespace-after-doctype-system-keyword parse error. Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
U+003E GREATER-THAN SIGN (>)
This is a missing-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.64 Before DOCTYPE system identifier state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+0022 QUOTATION MARK (")
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
U+0027 APOSTROPHE (')
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
U+003E GREATER-THAN SIGN (>)
This is a missing-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is a missing-quote-before-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
12.2.5.65 DOCTYPE system identifier (double-quoted) state
Consume the next input character:

U+0022 QUOTATION MARK (")
Switch to the after DOCTYPE system identifier state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
U+003E GREATER-THAN SIGN (>)
This is an abrupt-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
Append the current input character to the current DOCTYPE token's system identifier.
12.2.5.66 DOCTYPE system identifier (single-quoted) state
Consume the next input character:

U+0027 APOSTROPHE (')
Switch to the after DOCTYPE system identifier state.
U+0000 NULL
This is an unexpected-null-character parse error. Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
U+003E GREATER-THAN SIGN (>)
This is an abrupt-doctype-system-identifier parse error. Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
Append the current input character to the current DOCTYPE token's system identifier.
12.2.5.67 After DOCTYPE system identifier state
Consume the next input character:

U+0009 CHARACTER TABULATION (tab)
U+000A LINE FEED (LF)
U+000C FORM FEED (FF)
U+0020 SPACE
Ignore the character.
U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the current DOCTYPE token.
EOF
This is an eof-in-doctype parse error. Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
Anything else
This is an unexpected-character-after-doctype-system-identifier parse error. Reconsume in the bogus DOCTYPE state. (This does not set the DOCTYPE token's force-quirks flag to on.)
12.2.5.68 Bogus DOCTYPE state
Consume the next input character:

U+003E GREATER-THAN SIGN (>)
Switch to the data state. Emit the DOCTYPE token.
U+0000 NULL
This is an unexpected-null-character parse error. Ignore the character.
EOF
Emit the DOCTYPE token. Emit an end-of-file token.
Anything else
Ignore the character.
12.2.5.69 CDATA section state
Consume the next input character:

U+005D RIGHT SQUARE BRACKET (])
Switch to the CDATA section bracket state.
EOF
This is an eof-in-cdata parse error. Emit an end-of-file token.
Anything else
Emit the current input character as a character token.
U+0000 NULL characters are handled in the tree construction stage, as part of the in foreign content insertion mode, which is the only place where CDATA sections can appear.

12.2.5.70 CDATA section bracket state
Consume the next input character:

U+005D RIGHT SQUARE BRACKET (])
Switch to the CDATA section end state.
Anything else
Emit a U+005D RIGHT SQUARE BRACKET character token. Reconsume in the CDATA section state.
12.2.5.71 CDATA section end state
Consume the next input character:

U+005D RIGHT SQUARE BRACKET (])
Emit a U+005D RIGHT SQUARE BRACKET character token.
U+003E GREATER-THAN SIGN character
Switch to the data state.
Anything else
Emit two U+005D RIGHT SQUARE BRACKET character tokens. Reconsume in the CDATA section state.
12.2.5.72 Character reference state
Set the temporary buffer to the empty string. Append a U+0026 AMPERSAND (&) character to the temporary buffer. Consume the next input character:

ASCII alphanumeric
Reconsume in the named character reference state.
U+0023 NUMBER SIGN (#)
Append the current input character to the temporary buffer. Switch to the numeric character reference state.
Anything else
Flush code points consumed as a character reference. Reconsume in the return state.
12.2.5.73 Named character reference state
Consume the maximum number of characters possible, with the consumed characters matching one of the identifiers in the first column of the named character references table (in a case-sensitive manner). Append each character to the temporary buffer when it's consumed.

If there is a match
If the character reference was consumed as part of an attribute, and the last character matched is not a U+003B SEMICOLON character (;), and the next input character is either a U+003D EQUALS SIGN character (=) or an ASCII alphanumeric, then, for historical reasons, flush code points consumed as a character reference and switch to the return state.

Otherwise:

If the last character matched is not a U+003B SEMICOLON character (;), then this is a missing-semicolon-after-character-reference parse error.

Set the temporary buffer to the empty string. Append one or two characters corresponding to the character reference name (as given by the second column of the named character references table) to the temporary buffer.

Flush code points consumed as a character reference. Switch to the return state.
Otherwise
Flush code points consumed as a character reference. Switch to the ambiguous ampersand state.
If the markup contains (not in an attribute) the string I'm &notit; I tell you, the character reference is parsed as "not", as in, I'm ¬it; I tell you (and this is a parse error). But if the markup was I'm &notin; I tell you, the character reference would be parsed as "notin;", resulting in I'm ∉ I tell you (and no parse error).

However, if the markup contains the string I'm &notit; I tell you in an attribute, no character reference is parsed and string remains intact (and there is no parse error).

12.2.5.74 Ambiguous ampersand state
Consume the next input character:

ASCII alphanumeric
If the character reference was consumed as part of an attribute, then append the current input character to the current attribute's value. Otherwise, emit the current input character as a character token.
U+003B SEMICOLON (;)
This is an unknown-named-character-reference parse error. Reconsume in the return state.
Anything else
Reconsume in the return state.
12.2.5.75 Numeric character reference state
Set the character reference code to zero (0).

Consume the next input character:

U+0078 LATIN SMALL LETTER X
U+0058 LATIN CAPITAL LETTER X
Append the current input character to the temporary buffer. Switch to the hexademical character reference start state.
Anything else
Reconsume in the decimal character reference start state.
12.2.5.76 Hexademical character reference start state
Consume the next input character:

ASCII hex digit
Reconsume in the hexademical character reference state.
Anything else
This is an absence-of-digits-in-numeric-character-reference parse error. Flush code points consumed as a character reference. Reconsume in the return state.
12.2.5.77 Decimal character reference start state
Consume the next input character:

ASCII digit
Reconsume in the decimal character reference state.
Anything else
This is an absence-of-digits-in-numeric-character-reference parse error. Flush code points consumed as a character reference. Reconsume in the return state.
12.2.5.78 Hexademical character reference state
Consume the next input character:

ASCII digit
Multiply the character reference code by 16. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
ASCII upper hex digit
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexademical digit (subtract 0x0037 from the character's code point) to the character reference code.
ASCII lower hex digit
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexademical digit (subtract 0x0057 from the character's code point) to the character reference code.
U+003B SEMICOLON
Switch to the numeric character reference end state.
Anything else
This is a missing-semicolon-after-character-reference parse error. Reconsume in the numeric character reference end state.
12.2.5.79 Decimal character reference state
Consume the next input character:

ASCII digit
Multiply the character reference code by 10. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
U+003B SEMICOLON
Switch to the numeric character reference end state.
Anything else
This is a missing-semicolon-after-character-reference parse error. Reconsume in the numeric character reference end state.
12.2.5.80 Numeric character reference end state
Check the character reference code:

If the number is 0x00, then this is a null-character-reference parse error. Set the character reference code to 0xFFFD.

If the number is greater than 0x10FFFF, then this is a character-reference-outside-unicode-range parse error. Set the character reference code to 0xFFFD.

If the number is a surrogate, then this is a surrogate-character-reference parse error. Set the character reference code to 0xFFFD.

If the number is a noncharacter, then this is a noncharacter-character-reference parse error.

If the number is 0x0D, or a control that's not ASCII whitespace, then this is a control-character-reference parse error. If the number is one of the numbers in the first column of the following table, then find the row with that number in the first column, and set the character reference code to the number in the second column of that row.

Number	Code point
0x80	0x20AC	EURO SIGN (€)
0x82	0x201A	SINGLE LOW-9 QUOTATION MARK (‚)
0x83	0x0192	LATIN SMALL LETTER F WITH HOOK (ƒ)
0x84	0x201E	DOUBLE LOW-9 QUOTATION MARK („)
0x85	0x2026	HORIZONTAL ELLIPSIS (…)
0x86	0x2020	DAGGER (†)
0x87	0x2021	DOUBLE DAGGER (‡)
0x88	0x02C6	MODIFIER LETTER CIRCUMFLEX ACCENT (ˆ)
0x89	0x2030	PER MILLE SIGN (‰)
0x8A	0x0160	LATIN CAPITAL LETTER S WITH CARON (Š)
0x8B	0x2039	SINGLE LEFT-POINTING ANGLE QUOTATION MARK (‹)
0x8C	0x0152	LATIN CAPITAL LIGATURE OE (Œ)
0x8E	0x017D	LATIN CAPITAL LETTER Z WITH CARON (Ž)
0x91	0x2018	LEFT SINGLE QUOTATION MARK (‘)
0x92	0x2019	RIGHT SINGLE QUOTATION MARK (’)
0x93	0x201C	LEFT DOUBLE QUOTATION MARK (“)
0x94	0x201D	RIGHT DOUBLE QUOTATION MARK (”)
0x95	0x2022	BULLET (•)
0x96	0x2013	EN DASH (–)
0x97	0x2014	EM DASH (—)
0x98	0x02DC	SMALL TILDE (˜)
0x99	0x2122	TRADE MARK SIGN (™)
0x9A	0x0161	LATIN SMALL LETTER S WITH CARON (š)
0x9B	0x203A	SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (›)
0x9C	0x0153	LATIN SMALL LIGATURE OE (œ)
0x9E	0x017E	LATIN SMALL LETTER Z WITH CARON (ž)
0x9F	0x0178	LATIN CAPITAL LETTER Y WITH DIAERESIS (Ÿ)
Set the temporary buffer to the empty string. Append a code point equal to the character reference code to the temporary buffer. Flush code points consumed as a character reference. Switch to the return state.

12.2.6 Tree construction
The input to the tree construction stage is a sequence of tokens from the tokenization stage. The tree construction stage is associated with a DOM Document object when a parser is created. The "output" of this stage consists of dynamically modifying or extending that document's DOM tree.

This specification does not define when an interactive user agent has to render the Document so that it is available to the user, or when it has to begin accepting user input.

As each token is emitted from the tokenizer, the user agent must follow the appropriate steps from the following list, known as the tree construction dispatcher:

If the stack of open elements is empty
If the adjusted current node is an element in the HTML namespace
If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither "mglyph" nor "malignmark"
If the adjusted current node is a MathML text integration point and the token is a character token
If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is "svg"
If the adjusted current node is an HTML integration point and the token is a start tag
If the adjusted current node is an HTML integration point and the token is a character token
If the token is an end-of-file token
Process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
Otherwise
Process the token according to the rules given in the section for parsing tokens in foreign content.
The next token is the token that is about to be processed by the tree construction dispatcher (even if the token is subsequently just ignored).

A node is a MathML text integration point if it is one of the following elements:

A MathML mi element
A MathML mo element
A MathML mn element
A MathML ms element
A MathML mtext element
A node is an HTML integration point if it is one of the following elements:

A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "text/html"
A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "application/xhtml+xml"
An SVG foreignObject element
An SVG desc element
An SVG title element
If the node in question is the context element passed to the HTML fragment parsing algorithm, then the start tag token for that element is the "fake" token created during by that HTML fragment parsing algorithm.

Not all of the tag names mentioned below are conformant tag names in this specification; many are included to handle legacy content. They still form part of the algorithm that implementations are required to implement to claim conformance.

The algorithm described below places no limit on the depth of the DOM tree generated, or on the length of tag names, attribute names, attribute values, Text nodes, etc. While implementers are encouraged to avoid arbitrary limits, it is recognized that practical concerns will likely force user agents to impose nesting depth constraints.

12.2.6.1 Creating and inserting nodes
While the parser is processing a token, it can enable or disable foster parenting. This affects the following algorithm.

The appropriate place for inserting a node, optionally using a particular override target, is the position in an element returned by running the following steps:

If there was an override target specified, then let target be the override target.

Otherwise, let target be the current node.

Determine the adjusted insertion location using the first matching steps from the following list:

If foster parenting is enabled and target is a table, tbody, tfoot, thead, or tr element
Foster parenting happens when content is misnested in tables.

Run these substeps:

Let last template be the last template element in the stack of open elements, if any.

Let last table be the last table element in the stack of open elements, if any.

If there is a last template and either there is no last table, or there is one, but last template is lower (more recently added) than last table in the stack of open elements, then: let adjusted insertion location be inside last template's template contents, after its last child (if any), and abort these substeps.

If there is no last table, then let adjusted insertion location be inside the first element in the stack of open elements (the html element), after its last child (if any), and abort these substeps. (fragment case)

If last table has a parent node, then let adjusted insertion location be inside last table's parent node, immediately before last table, and abort these substeps.

Let previous element be the element immediately above last table in the stack of open elements.

Let adjusted insertion location be inside previous element, after its last child (if any).

These steps are involved in part because it's possible for elements, the table element in this case in particular, to have been moved by a script around in the DOM, or indeed removed from the DOM entirely, after the element was inserted by the parser.

Otherwise
Let adjusted insertion location be inside target, after its last child (if any).

If the adjusted insertion location is inside a template element, let it instead be inside the template element's template contents, after its last child (if any).

Return the adjusted insertion location.

When the steps below require the UA to create an element for a token in a particular given namespace and with a particular intended parent, the UA must run the following steps:

Let document be intended parent's node document.

Let local name be the tag name of the token.

Let is be the value of the "is" attribute in the given token, if such an attribute exists, or null otherwise.

Let definition be the result of looking up a custom element definition given document, given namespace, local name, and is.

If definition is non-null and the parser was not originally created for the HTML fragment parsing algorithm, then let will execute script be true. Otherwise, let it be false.

If will execute script is true, then:

Increment document's throw-on-dynamic-markup-insertion counter.

If the JavaScript execution context stack is empty, then perform a microtask checkpoint.

Push a new element queue onto the custom element reactions stack.

Let element be the result of creating an element given document, localName, given namespace, null, and is. If will execute script is true, set the synchronous custom elements flag; otherwise, leave it unset.

This will cause custom element constructors to run, if will execute script is true. However, since we incremented the throw-on-dynamic-markup-insertion counter, this cannot cause new characters to be inserted into the tokenizer, or the document to be blown away.

Append each attribute in the given token to element.

This can enqueue a custom element callback reaction for the attributeChangedCallback, which might run immediately (in the next step).

Even though the is attribute governs the creation of a customized built-in element, it is not present during the execution of the relevant custom element constructor; it is appended in this step, along with all other attributes.

If will execute script is true, then:

Let queue be the result of popping the current element queue from the custom element reactions stack. (This will be the same element queue as was pushed above.)

Invoke custom element reactions in queue.

Decrement document's throw-on-dynamic-markup-insertion counter.

If element has an xmlns attribute in the XMLNS namespace whose value is not exactly the same as the element's namespace, that is a parse error. Similarly, if element has an xmlns:xlink attribute in the XMLNS namespace whose value is not the XLink Namespace, that is a parse error.

If element is a resettable element, invoke its reset algorithm. (This initializes the element's value and checkedness based on the element's attributes.)

If element is a form-associated element, the form element pointer is not null, there is no template element on the stack of open elements, element is either not listed or doesn't have a form attribute, and the intended parent is in the same tree as the element pointed to by the form element pointer, then associate element with the form element pointed to by the form element pointer and set element's parser inserted flag.

Return element.

When the steps below require the user agent to insert a foreign element for a token in a given namespace, the user agent must run these steps:

Let the adjusted insertion location be the appropriate place for inserting a node.

Let element be the result of creating an element for the token in the given namespace, with the intended parent being the element in which the adjusted insertion location finds itself.

If it is possible to insert element at the adjusted insertion location, then:

Push a new element queue onto the custom element reactions stack.

Insert element at the adjusted insertion location.

Pop the element queue from the custom element reactions stack, and invoke custom element reactions in that queue.

If the adjusted insertion location cannot accept more elements, e.g. because it's a Document that already has an element child, then element is dropped on the floor.

Push element onto the stack of open elements so that it is the new current node.

Return element.

When the steps below require the user agent to insert an HTML element for a token, the user agent must insert a foreign element for the token, in the HTML namespace.

When the steps below require the user agent to adjust MathML attributes for a token, then, if the token has an attribute named definitionurl, change its name to definitionURL (note the case difference).

When the steps below require the user agent to adjust SVG attributes for a token, then, for each attribute on the token whose attribute name is one of the ones in the first column of the following table, change the attribute's name to the name given in the corresponding cell in the second column. (This fixes the case of SVG attributes that are not all lowercase.)

Attribute name on token	Attribute name on element
attributename	attributeName
attributetype	attributeType
basefrequency	baseFrequency
baseprofile	baseProfile
calcmode	calcMode
clippathunits	clipPathUnits
diffuseconstant	diffuseConstant
edgemode	edgeMode
filterunits	filterUnits
glyphref	glyphRef
gradienttransform	gradientTransform
gradientunits	gradientUnits
kernelmatrix	kernelMatrix
kernelunitlength	kernelUnitLength
keypoints	keyPoints
keysplines	keySplines
keytimes	keyTimes
lengthadjust	lengthAdjust
limitingconeangle	limitingConeAngle
markerheight	markerHeight
markerunits	markerUnits
markerwidth	markerWidth
maskcontentunits	maskContentUnits
maskunits	maskUnits
numoctaves	numOctaves
pathlength	pathLength
patterncontentunits	patternContentUnits
patterntransform	patternTransform
patternunits	patternUnits
pointsatx	pointsAtX
pointsaty	pointsAtY
pointsatz	pointsAtZ
preservealpha	preserveAlpha
preserveaspectratio	preserveAspectRatio
primitiveunits	primitiveUnits
refx	refX
refy	refY
repeatcount	repeatCount
repeatdur	repeatDur
requiredextensions	requiredExtensions
requiredfeatures	requiredFeatures
specularconstant	specularConstant
specularexponent	specularExponent
spreadmethod	spreadMethod
startoffset	startOffset
stddeviation	stdDeviation
stitchtiles	stitchTiles
surfacescale	surfaceScale
systemlanguage	systemLanguage
tablevalues	tableValues
targetx	targetX
targety	targetY
textlength	textLength
viewbox	viewBox
viewtarget	viewTarget
xchannelselector	xChannelSelector
ychannelselector	yChannelSelector
zoomandpan	zoomAndPan
When the steps below require the user agent to adjust foreign attributes for a token, then, if any of the attributes on the token match the strings given in the first column of the following table, let the attribute be a namespaced attribute, with the prefix being the string given in the corresponding cell in the second column, the local name being the string given in the corresponding cell in the third column, and the namespace being the namespace given in the corresponding cell in the fourth column. (This fixes the use of namespaced attributes, in particular lang attributes in the XML namespace.)

Attribute name	Prefix	Local name	Namespace
xlink:actuate	xlink	actuate	XLink namespace
xlink:arcrole	xlink	arcrole	XLink namespace
xlink:href	xlink	href	XLink namespace
xlink:role	xlink	role	XLink namespace
xlink:show	xlink	show	XLink namespace
xlink:title	xlink	title	XLink namespace
xlink:type	xlink	type	XLink namespace
xml:lang	xml	lang	XML namespace
xml:space	xml	space	XML namespace
xmlns	(none)	xmlns	XMLNS namespace
xmlns:xlink	xmlns	xlink	XMLNS namespace
When the steps below require the user agent to insert a character while processing a token, the user agent must run the following steps:

Let data be the characters passed to the algorithm, or, if no characters were explicitly specified, the character of the character token being processed.

Let the adjusted insertion location be the appropriate place for inserting a node.

If the adjusted insertion location is in a Document node, then return.

The DOM will not let Document nodes have Text node children, so they are dropped on the floor.

If there is a Text node immediately before the adjusted insertion location, then append data to that Text node's data.

Otherwise, create a new Text node whose data is data and whose node document is the same as that of the element in which the adjusted insertion location finds itself, and insert the newly created node at the adjusted insertion location.

Here are some sample inputs to the parser and the corresponding number of Text nodes that they result in, assuming a user agent that executes scripts.

Input	Number of Text nodes
A<script>
var script = document.getElementsByTagName('script')[0];
document.body.removeChild(script);
</script>B
One Text node in the document, containing "AB".
A<script>
var text = document.createTextNode('B');
document.body.appendChild(text);
</script>C
Three Text nodes; "A" before the script, the script's contents, and "BC" after the script (the parser appends to the Text node created by the script).
A<script>
var text = document.getElementsByTagName('script')[0].firstChild;
text.data = 'B';
document.body.appendChild(text);
</script>C
Two adjacent Text nodes in the document, containing "A" and "BC".
A<table>B<tr>C</tr>D</table>
One Text node before the table, containing "ABCD". (This is caused by foster parenting.)
A<table><tr> B</tr> C</table>
One Text node before the table, containing "A B C" (A-space-B-space-C). (This is caused by foster parenting.)
A<table><tr> B</tr> </em>C</table>
One Text node before the table, containing "A BC" (A-space-B-C), and one Text node inside the table (as a child of a tbody) with a single space character. (Space characters separated from non-space characters by non-character tokens are not affected by foster parenting, even if those other tokens then get ignored.)
When the steps below require the user agent to insert a comment while processing a comment token, optionally with an explicitly insertion position position, the user agent must run the following steps:

Let data be the data given in the comment token being processed.

If position was specified, then let the adjusted insertion location be position. Otherwise, let adjusted insertion location be the appropriate place for inserting a node.

Create a Comment node whose data attribute is set to data and whose node document is the same as that of the node in which the adjusted insertion location finds itself.

Insert the newly created node at the adjusted insertion location.

DOM mutation events must not fire for changes caused by the UA parsing the document. This includes the parsing of any content inserted using document.write() and document.writeln() calls. [UIEVENTS]

However, mutation observers do fire, as required by the WHATWG DOM Standard.

12.2.6.2 Parsing elements that contain only text
The generic raw text element parsing algorithm and the generic RCDATA element parsing algorithm consist of the following steps. These algorithms are always invoked in response to a start tag token.

Insert an HTML element for the token.

If the algorithm that was invoked is the generic raw text element parsing algorithm, switch the tokenizer to the RAWTEXT state; otherwise the algorithm invoked was the generic RCDATA element parsing algorithm, switch the tokenizer to the RCDATA state.

Let the original insertion mode be the current insertion mode.

Then, switch the insertion mode to "text".

12.2.6.3 Closing elements that have implied end tags
When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.

If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.

When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.

12.2.6.4 The rules for parsing tokens in HTML content
12.2.6.4.1 The "initial" insertion mode
When the user agent is to apply the rules for the "initial" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Ignore the token.

A comment token
Insert a comment as the last child of the Document object.

A DOCTYPE token
If the DOCTYPE token's name is not a case-sensitive match for the string "html", or the token's public identifier is not missing, or the token's system identifier is neither missing nor a case-sensitive match for the string "about:legacy-compat", then there is a parse error.

Append a DocumentType node to the Document node, with the name attribute set to the name given in the DOCTYPE token, or the empty string if the name was missing; the publicId attribute set to the public identifier given in the DOCTYPE token, or the empty string if the public identifier was missing; the systemId attribute set to the system identifier given in the DOCTYPE token, or the empty string if the system identifier was missing; and the other attributes specific to DocumentType objects set to null and empty lists as appropriate. Associate the DocumentType node with the Document object so that it is returned as the value of the doctype attribute of the Document object.

Then, if the document is not an iframe srcdoc document, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to quirks mode:

The force-quirks flag is set to on.
The name is set to anything other than "html" (compared case-sensitively).
The public identifier is set to: "-//W3O//DTD W3 HTML Strict 3.0//EN//"
The public identifier is set to: "-/W3C/DTD HTML 4.0 Transitional/EN"
The public identifier is set to: "HTML"
The system identifier is set to: "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"
The public identifier starts with: "+//Silmaril//dtd html Pro v0r11 19970101//"
The public identifier starts with: "-//AS//DTD HTML 3.0 asWedit + extensions//"
The public identifier starts with: "-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//"
The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 1//"
The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 2//"
The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 1//"
The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 2//"
The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict//"
The public identifier starts with: "-//IETF//DTD HTML 2.0//"
The public identifier starts with: "-//IETF//DTD HTML 2.1E//"
The public identifier starts with: "-//IETF//DTD HTML 3.0//"
The public identifier starts with: "-//IETF//DTD HTML 3.2 Final//"
The public identifier starts with: "-//IETF//DTD HTML 3.2//"
The public identifier starts with: "-//IETF//DTD HTML 3//"
The public identifier starts with: "-//IETF//DTD HTML Level 0//"
The public identifier starts with: "-//IETF//DTD HTML Level 1//"
The public identifier starts with: "-//IETF//DTD HTML Level 2//"
The public identifier starts with: "-//IETF//DTD HTML Level 3//"
The public identifier starts with: "-//IETF//DTD HTML Strict Level 0//"
The public identifier starts with: "-//IETF//DTD HTML Strict Level 1//"
The public identifier starts with: "-//IETF//DTD HTML Strict Level 2//"
The public identifier starts with: "-//IETF//DTD HTML Strict Level 3//"
The public identifier starts with: "-//IETF//DTD HTML Strict//"
The public identifier starts with: "-//IETF//DTD HTML//"
The public identifier starts with: "-//Metrius//DTD Metrius Presentational//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 Tables//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML//"
The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 Tables//"
The public identifier starts with: "-//Netscape Comm. Corp.//DTD HTML//"
The public identifier starts with: "-//Netscape Comm. Corp.//DTD Strict HTML//"
The public identifier starts with: "-//O'Reilly and Associates//DTD HTML 2.0//"
The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended 1.0//"
The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended Relaxed 1.0//"
The public identifier starts with: "-//SQ//DTD HTML 2.0 HoTMetaL + extensions//"
The public identifier starts with: "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//"
The public identifier starts with: "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//"
The public identifier starts with: "-//Spyglass//DTD HTML 2.0 Extended//"
The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava HTML//"
The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava Strict HTML//"
The public identifier starts with: "-//W3C//DTD HTML 3 1995-03-24//"
The public identifier starts with: "-//W3C//DTD HTML 3.2 Draft//"
The public identifier starts with: "-//W3C//DTD HTML 3.2 Final//"
The public identifier starts with: "-//W3C//DTD HTML 3.2//"
The public identifier starts with: "-//W3C//DTD HTML 3.2S Draft//"
The public identifier starts with: "-//W3C//DTD HTML 4.0 Frameset//"
The public identifier starts with: "-//W3C//DTD HTML 4.0 Transitional//"
The public identifier starts with: "-//W3C//DTD HTML Experimental 19960712//"
The public identifier starts with: "-//W3C//DTD HTML Experimental 970421//"
The public identifier starts with: "-//W3C//DTD W3 HTML//"
The public identifier starts with: "-//W3O//DTD W3 HTML 3.0//"
The public identifier starts with: "-//WebTechs//DTD Mozilla HTML 2.0//"
The public identifier starts with: "-//WebTechs//DTD Mozilla HTML//"
The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//"
Otherwise, if the document is not an iframe srcdoc document, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to limited-quirks mode:

The public identifier starts with: "-//W3C//DTD XHTML 1.0 Frameset//"
The public identifier starts with: "-//W3C//DTD XHTML 1.0 Transitional//"
The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//"
The system identifier and public identifier strings must be compared to the values given in the lists above in an ASCII case-insensitive manner. A system identifier whose value is the empty string is not considered missing for the purposes of the conditions above.

Then, switch the insertion mode to "before html".

Anything else
If the document is not an iframe srcdoc document, then this is a parse error; set the Document to quirks mode.

In any case, switch the insertion mode to "before html", then reprocess the token.

12.2.6.4.2 The "before html" insertion mode
When the user agent is to apply the rules for the "before html" insertion mode, the user agent must handle the token as follows:

A DOCTYPE token
Parse error. Ignore the token.

A comment token
Insert a comment as the last child of the Document object.

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Ignore the token.

A start tag whose tag name is "html"
Create an element for the token in the HTML namespace, with the Document as the intended parent. Append it to the Document object. Put this element in the stack of open elements.

If the Document is being loaded as part of navigation of a browsing context, run these steps:

If the result of running match service worker registration for the document's URL is non-null, run the application cache selection algorithm passing the Document object with no manifest.

Otherwise, run these substeps:

If the newly created element has a manifest attribute whose value is not the empty string, then parse the value of that attribute, relative to the newly created element's node document, and if that is successful, run the application cache selection algorithm passing the Document object with the result of applying the URL serializer algorithm to the resulting URL record with the exclude fragment flag set.

Otherwise, run the application cache selection algorithm passing the Document object with no manifest.

Switch the insertion mode to "before head".

An end tag whose tag name is one of: "head", "body", "html", "br"
Act as described in the "anything else" entry below.

Any other end tag
Parse error. Ignore the token.

Anything else
Create an html element whose node document is the Document object. Append it to the Document object. Put this element in the stack of open elements.

If the Document is being loaded as part of navigation of a browsing context, then: run the application cache selection algorithm with no manifest, passing it the Document object.

Switch the insertion mode to "before head", then reprocess the token.

The document element can end up being removed from the Document object, e.g. by scripts; nothing in particular happens in such cases, content continues being appended to the nodes as described in the next section.

12.2.6.4.3 The "before head" insertion mode
When the user agent is to apply the rules for the "before head" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Ignore the token.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is "head"
Insert an HTML element for the token.

Set the head element pointer to the newly created head element.

Switch the insertion mode to "in head".

An end tag whose tag name is one of: "head", "body", "html", "br"
Act as described in the "anything else" entry below.

Any other end tag
Parse error. Ignore the token.

Anything else
Insert an HTML element for a "head" start tag token with no attributes.

Set the head element pointer to the newly created head element.

Switch the insertion mode to "in head".

Reprocess the current token.

12.2.6.4.4 The "in head" insertion mode
When the user agent is to apply the rules for the "in head" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is one of: "base", "basefont", "bgsound", "link"
Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

A start tag whose tag name is "meta"
Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

If the element has a charset attribute, and getting an encoding from its value results in an encoding, and the confidence is currently tentative, then change the encoding to the resulting encoding.

Otherwise, if the element has an http-equiv attribute whose value is an ASCII case-insensitive match for the string "Content-Type", and the element has a content attribute, and applying the algorithm for extracting a character encoding from a meta element to that attribute's value returns an encoding, and the confidence is currently tentative, then change the encoding to the extracted encoding.

A start tag whose tag name is "title"
Follow the generic RCDATA element parsing algorithm.

A start tag whose tag name is "noscript", if the scripting flag is enabled
A start tag whose tag name is one of: "noframes", "style"
Follow the generic raw text element parsing algorithm.

A start tag whose tag name is "noscript", if the scripting flag is disabled
Insert an HTML element for the token.

Switch the insertion mode to "in head noscript".

A start tag whose tag name is "script"
Run these steps:

Let the adjusted insertion location be the appropriate place for inserting a node.

Create an element for the token in the HTML namespace, with the intended parent being the element in which the adjusted insertion location finds itself.

Mark the element as being "parser-inserted" and unset the element's "non-blocking" flag.

This ensures that, if the script is external, any document.write() calls in the script will execute in-line, instead of blowing the document away, as would happen in most other cases. It also prevents the script from executing until the end tag is seen.

If the parser was originally created for the HTML fragment parsing algorithm, then mark the script element as "already started". (fragment case)

If the parser was invoked via the document.write() or document.writeln() methods, then optionally mark the script element as "already started". (For example, the user agent might use this clause to prevent execution of cross-origin scripts inserted via document.write() under slow network conditions, or when the page has already taken a long time to load.)

Insert the newly created element at the adjusted insertion location.

Push the element onto the stack of open elements so that it is the new current node.

Switch the tokenizer to the script data state.

Let the original insertion mode be the current insertion mode.

Switch the insertion mode to "text".

An end tag whose tag name is "head"
Pop the current node (which will be the head element) off the stack of open elements.

Switch the insertion mode to "after head".

An end tag whose tag name is one of: "body", "html", "br"
Act as described in the "anything else" entry below.

A start tag whose tag name is "template"
Insert an HTML element for the token.

Insert a marker at the end of the list of active formatting elements.

Set the frameset-ok flag to "not ok".

Switch the insertion mode to "in template".

Push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.

An end tag whose tag name is "template"
If there is no template element on the stack of open elements, then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate all implied end tags thoroughly.

If the current node is not a template element, then this is a parse error.

Pop elements from the stack of open elements until a template element has been popped from the stack.

Clear the list of active formatting elements up to the last marker.
Pop the current template insertion mode off the stack of template insertion modes.

Reset the insertion mode appropriately.

A start tag whose tag name is "head"
Any other end tag
Parse error. Ignore the token.

Anything else
Pop the current node (which will be the head element) off the stack of open elements.

Switch the insertion mode to "after head".

Reprocess the token.

12.2.6.4.5 The "in head noscript" insertion mode
When the user agent is to apply the rules for the "in head noscript" insertion mode, the user agent must handle the token as follows:

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

An end tag whose tag name is "noscript"
Pop the current node (which will be a noscript element) from the stack of open elements; the new current node will be a head element.

Switch the insertion mode to "in head".

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
A comment token
A start tag whose tag name is one of: "basefont", "bgsound", "link", "meta", "noframes", "style"
Process the token using the rules for the "in head" insertion mode.

An end tag whose tag name is "br"
Act as described in the "anything else" entry below.

A start tag whose tag name is one of: "head", "noscript"
Any other end tag
Parse error. Ignore the token.

Anything else
Parse error.

Pop the current node (which will be a noscript element) from the stack of open elements; the new current node will be a head element.

Switch the insertion mode to "in head".

Reprocess the token.

12.2.6.4.6 The "after head" insertion mode
When the user agent is to apply the rules for the "after head" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is "body"
Insert an HTML element for the token.

Set the frameset-ok flag to "not ok".

Switch the insertion mode to "in body".

A start tag whose tag name is "frameset"
Insert an HTML element for the token.

Switch the insertion mode to "in frameset".

A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
Parse error.

Push the node pointed to by the head element pointer onto the stack of open elements.

Process the token using the rules for the "in head" insertion mode.

Remove the node pointed to by the head element pointer from the stack of open elements. (It might not be the current node at this point.)

The head element pointer cannot be null at this point.

An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

An end tag whose tag name is one of: "body", "html", "br"
Act as described in the "anything else" entry below.

A start tag whose tag name is "head"
Any other end tag
Parse error. Ignore the token.

Anything else
Insert an HTML element for a "body" start tag token with no attributes.

Switch the insertion mode to "in body".

Reprocess the current token.

12.2.6.4.7 The "in body" insertion mode
When the user agent is to apply the rules for the "in body" insertion mode, the user agent must handle the token as follows:

A character token that is U+0000 NULL
Parse error. Ignore the token.

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Reconstruct the active formatting elements, if any.

Insert the token's character.

Any other character token
Reconstruct the active formatting elements, if any.

Insert the token's character.

Set the frameset-ok flag to "not ok".

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Parse error.

If there is a template element on the stack of open elements, then ignore the token.

Otherwise, for each attribute on the token, check to see if the attribute is already present on the top element of the stack of open elements. If it is not, add the attribute and its corresponding value to that element.

A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

A start tag whose tag name is "body"
Parse error.

If the second element on the stack of open elements is not a body element, if the stack of open elements has only one node on it, or if there is a template element on the stack of open elements, then ignore the token. (fragment case)

Otherwise, set the frameset-ok flag to "not ok"; then, for each attribute on the token, check to see if the attribute is already present on the body element (the second element) on the stack of open elements, and if it is not, add the attribute and its corresponding value to that element.

A start tag whose tag name is "frameset"
Parse error.

If the stack of open elements has only one node on it, or if the second element on the stack of open elements is not a body element, then ignore the token. (fragment case)

If the frameset-ok flag is set to "not ok", ignore the token.

Otherwise, run the following steps:

Remove the second element on the stack of open elements from its parent node, if it has one.

Pop all the nodes from the bottom of the stack of open elements, from the current node up to, but not including, the root html element.

Insert an HTML element for the token.

Switch the insertion mode to "in frameset".

An end-of-file token
If the stack of template insertion modes is not empty, then process the token using the rules for the "in template" insertion mode.

Otherwise, follow these steps:

If there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.

Stop parsing.

An end tag whose tag name is "body"
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.

Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.

Switch the insertion mode to "after body".

An end tag whose tag name is "html"
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.

Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.

Switch the insertion mode to "after body".

Reprocess the token.

A start tag whose tag name is one of: "address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p", "section", "summary", "ul"
If the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token.

A start tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
If the stack of open elements has a p element in button scope, then close a p element.

If the current node is an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; pop the current node off the stack of open elements.

Insert an HTML element for the token.

A start tag whose tag name is one of: "pre", "listing"
If the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token.

If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)

Set the frameset-ok flag to "not ok".

A start tag whose tag name is "form"
If the form element pointer is not null, and there is no template element on the stack of open elements, then this is a parse error; ignore the token.

Otherwise:

If the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token, and, if there is no template element on the stack of open elements, set the form element pointer to point to the element created.

A start tag whose tag name is "li"
Run these steps:

Set the frameset-ok flag to "not ok".

Initialize node to be the current node (the bottommost node of the stack).

Loop: If node is an li element, then run these substeps:

Generate implied end tags, except for li elements.

If the current node is not an li element, then this is a parse error.

Pop elements from the stack of open elements until an li element has been popped from the stack.

Jump to the step labeled done below.

If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.

Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.

Done: If the stack of open elements has a p element in button scope, then close a p element.

Finally, insert an HTML element for the token.

A start tag whose tag name is one of: "dd", "dt"
Run these steps:

Set the frameset-ok flag to "not ok".

Initialize node to be the current node (the bottommost node of the stack).

Loop: If node is a dd element, then run these substeps:

Generate implied end tags, except for dd elements.

If the current node is not a dd element, then this is a parse error.

Pop elements from the stack of open elements until a dd element has been popped from the stack.

Jump to the step labeled done below.

If node is a dt element, then run these substeps:

Generate implied end tags, except for dt elements.

If the current node is not a dt element, then this is a parse error.

Pop elements from the stack of open elements until a dt element has been popped from the stack.

Jump to the step labeled done below.

If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.

Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.

Done: If the stack of open elements has a p element in button scope, then close a p element.

Finally, insert an HTML element for the token.

A start tag whose tag name is "plaintext"
If the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token.

Switch the tokenizer to the PLAINTEXT state.

Once a start tag with the tag name "plaintext" has been seen, that will be the last token ever seen other than character tokens (and the end-of-file token), because there is no way to switch out of the PLAINTEXT state.

A start tag whose tag name is "button"
If the stack of open elements has a button element in scope, then run these substeps:

Parse error.

Generate implied end tags.

Pop elements from the stack of open elements until a button element has been popped from the stack.

Reconstruct the active formatting elements, if any.

Insert an HTML element for the token.

Set the frameset-ok flag to "not ok".

An end tag whose tag name is one of: "address", "article", "aside", "blockquote", "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre", "section", "summary", "ul"
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate implied end tags.

If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.

Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.

An end tag whose tag name is "form"
If there is no template element on the stack of open elements, then run these substeps:

Let node be the element that the form element pointer is set to, or null if it is not set to an element.

Set the form element pointer to null.

If node is null or if the stack of open elements does not have node in scope, then this is a parse error; return and ignore the token.

Generate implied end tags.

If the current node is not node, then this is a parse error.

Remove node from the stack of open elements.

If there is a template element on the stack of open elements, then run these substeps instead:

If the stack of open elements does not have a form element in scope, then this is a parse error; return and ignore the token.

Generate implied end tags.

If the current node is not a form element, then this is a parse error.

Pop elements from the stack of open elements until a form element has been popped from the stack.

An end tag whose tag name is "p"
If the stack of open elements does not have a p element in button scope, then this is a parse error; insert an HTML element for a "p" start tag token with no attributes.

Close a p element.

An end tag whose tag name is "li"
If the stack of open elements does not have an li element in list item scope, then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate implied end tags, except for li elements.

If the current node is not an li element, then this is a parse error.

Pop elements from the stack of open elements until an li element has been popped from the stack.

An end tag whose tag name is one of: "dd", "dt"
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate implied end tags, except for HTML elements with the same tag name as the token.

If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.

Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.

An end tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
If the stack of open elements does not have an element in scope that is an HTML element and whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate implied end tags.

If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.

Pop elements from the stack of open elements until an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6" has been popped from the stack.

An end tag whose tag name is "sarcasm"
Take a deep breath, then act as described in the "any other end tag" entry below.

A start tag whose tag name is "a"
If the list of active formatting elements contains an a element between the end of the list and the last marker on the list (or the start of the list if there is no marker on the list), then this is a parse error; run the adoption agency algorithm for the token, then remove that element from the list of active formatting elements and the stack of open elements if the adoption agency algorithm didn't already remove it (it might not have if the element is not in table scope).

In the non-conforming stream <a href="a">a<table><a href="b">b</table>x, the first a element would be closed upon seeing the second one, and the "x" character would be inside a link to "b", not to "a". This is despite the fact that the outer a element is not in table scope (meaning that a regular </a> end tag at the start of the table wouldn't close the outer a element). The result is that the two a elements are indirectly nested inside each other — non-conforming markup will often result in non-conforming DOMs when parsed.

Reconstruct the active formatting elements, if any.

Insert an HTML element for the token. Push onto the list of active formatting elements that element.

A start tag whose tag name is one of: "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u"
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token. Push onto the list of active formatting elements that element.

A start tag whose tag name is "nobr"
Reconstruct the active formatting elements, if any.

If the stack of open elements has a nobr element in scope, then this is a parse error; run the adoption agency algorithm for the token, then once again reconstruct the active formatting elements, if any.

Insert an HTML element for the token. Push onto the list of active formatting elements that element.

An end tag whose tag name is one of: "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u"
Run the adoption agency algorithm for the token.

A start tag whose tag name is one of: "applet", "marquee", "object"
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token.

Insert a marker at the end of the list of active formatting elements.

Set the frameset-ok flag to "not ok".

An end tag token whose tag name is one of: "applet", "marquee", "object"
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.

Otherwise, run these steps:

Generate implied end tags.

If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.

Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.

Clear the list of active formatting elements up to the last marker.
A start tag whose tag name is "table"
If the Document is not set to quirks mode, and the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token.

Set the frameset-ok flag to "not ok".

Switch the insertion mode to "in table".

An end tag whose tag name is "br"
Parse error. Drop the attributes from the token, and act as described in the next entry; i.e. act as if this was a "br" start tag token with no attributes, rather than the end tag token that it actually is.

A start tag whose tag name is one of: "area", "br", "embed", "img", "keygen", "wbr"
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

Set the frameset-ok flag to "not ok".

A start tag whose tag name is "input"
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then: set the frameset-ok flag to "not ok".

A start tag whose tag name is one of: "param", "source", "track"
Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

A start tag whose tag name is "hr"
If the stack of open elements has a p element in button scope, then close a p element.

Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

Set the frameset-ok flag to "not ok".

A start tag whose tag name is "image"
Parse error. Change the token's tag name to "img" and reprocess it. (Don't ask.)

A start tag whose tag name is "textarea"
Run these steps:

Insert an HTML element for the token.

If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)

Switch the tokenizer to the RCDATA state.

Let the original insertion mode be the current insertion mode.

Set the frameset-ok flag to "not ok".

Switch the insertion mode to "text".

A start tag whose tag name is "xmp"
If the stack of open elements has a p element in button scope, then close a p element.

Reconstruct the active formatting elements, if any.

Set the frameset-ok flag to "not ok".

Follow the generic raw text element parsing algorithm.

A start tag whose tag name is "iframe"
Set the frameset-ok flag to "not ok".

Follow the generic raw text element parsing algorithm.

A start tag whose tag name is "noembed"
A start tag whose tag name is "noscript", if the scripting flag is enabled
Follow the generic raw text element parsing algorithm.

A start tag whose tag name is "select"
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token.

Set the frameset-ok flag to "not ok".

If the insertion mode is one of "in table", "in caption", "in table body", "in row", or "in cell", then switch the insertion mode to "in select in table". Otherwise, switch the insertion mode to "in select".

A start tag whose tag name is one of: "optgroup", "option"
If the current node is an option element, then pop the current node off the stack of open elements.

Reconstruct the active formatting elements, if any.

Insert an HTML element for the token.

A start tag whose tag name is one of: "rb", "rtc"
If the stack of open elements has a ruby element in scope, then generate implied end tags. If the current node is not now a ruby element, this is a parse error.

Insert an HTML element for the token.

A start tag whose tag name is one of: "rp", "rt"
If the stack of open elements has a ruby element in scope, then generate implied end tags, except for rtc elements. If the current node is not now a rtc element or a ruby element, this is a parse error.

Insert an HTML element for the token.

A start tag whose tag name is "math"
Reconstruct the active formatting elements, if any.

Adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)

Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink.)

Insert a foreign element for the token, in the MathML namespace.

If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.

A start tag whose tag name is "svg"
Reconstruct the active formatting elements, if any.

Adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)

Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)

Insert a foreign element for the token, in the SVG namespace.

If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.

A start tag whose tag name is one of: "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr"
Parse error. Ignore the token.

Any other start tag
Reconstruct the active formatting elements, if any.

Insert an HTML element for the token.

This element will be an ordinary element.

Any other end tag
Run these steps:

Initialize node to be the current node (the bottommost node of the stack).

Loop: If node is an HTML element with the same tag name as the token, then:

Generate implied end tags, except for HTML elements with the same tag name as the token.

If node is not the current node, then this is a parse error.

Pop all the nodes from the current node up to node, including node, then stop these steps.

Otherwise, if node is in the special category, then this is a parse error; ignore the token, and return.

Set node to the previous entry in the stack of open elements.

Return to the step labeled loop.

When the steps above say the user agent is to close a p element, it means that the user agent must run the following steps:

Generate implied end tags, except for p elements.

If the current node is not a p element, then this is a parse error.

Pop elements from the stack of open elements until a p element has been popped from the stack.

The adoption agency algorithm, which takes as its only argument a token token for which the algorithm is being run, consists of the following steps:

Let subject be token's tag name.

If the current node is an HTML element whose tag name is subject, and the current node is not in the list of active formatting elements, then pop the current node off the stack of open elements, and return.

Let outer loop counter be zero.

Outer loop: If outer loop counter is greater than or equal to eight, then return.

Increment outer loop counter by one.

Let formatting element be the last element in the list of active formatting elements that:

is between the end of the list and the last marker in the list, if any, or the start of the list otherwise, and
has the tag name subject.
If there is no such element, then return and instead act as described in the "any other end tag" entry above.

If formatting element is not in the stack of open elements, then this is a parse error; remove the element from the list, and return.

If formatting element is in the stack of open elements, but the element is not in scope, then this is a parse error; return.

If formatting element is not the current node, this is a parse error. (But do not return.)

Let furthest block be the topmost node in the stack of open elements that is lower in the stack than formatting element, and is an element in the special category. There might not be one.

If there is no furthest block, then the UA must first pop all the nodes from the bottom of the stack of open elements, from the current node up to and including formatting element, then remove formatting element from the list of active formatting elements, and finally return.

Let common ancestor be the element immediately above formatting element in the stack of open elements.

Let a bookmark note the position of formatting element in the list of active formatting elements relative to the elements on either side of it in the list.

Let node and last node be furthest block. Follow these steps:

Let inner loop counter be zero.

Inner loop: Increment inner loop counter by one.

Let node be the element immediately above node in the stack of open elements, or if node is no longer in the stack of open elements (e.g. because it got removed by this algorithm), the element that was immediately above node in the stack of open elements before node was removed.

If node is formatting element, then go to the next step in the overall algorithm.

If inner loop counter is greater than three and node is in the list of active formatting elements, then remove node from the list of active formatting elements.

If node is not in the list of active formatting elements, then remove node from the stack of open elements and then go back to the step labeled inner loop.

Create an element for the token for which the element node was created, in the HTML namespace, with common ancestor as the intended parent; replace the entry for node in the list of active formatting elements with an entry for the new element, replace the entry for node in the stack of open elements with an entry for the new element, and let node be the new element.

If last node is furthest block, then move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.

Insert last node into node, first removing it from its previous parent node if any.

Let last node be node.

Return to the step labeled inner loop.

Insert whatever last node ended up being in the previous step at the appropriate place for inserting a node, but using common ancestor as the override target.

Create an element for the token for which formatting element was created, in the HTML namespace, with furthest block as the intended parent.

Take all of the child nodes of furthest block and append them to the element created in the last step.

Append that new element to furthest block.

Remove formatting element from the list of active formatting elements, and insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.

Remove formatting element from the stack of open elements, and insert the new element into the stack of open elements immediately below the position of furthest block in that stack.

Jump back to the step labeled outer loop.

This algorithm's name, the "adoption agency algorithm", comes from the way it causes elements to change parents, and is in contrast with other possible algorithms for dealing with misnested content.

12.2.6.4.8 The "text" insertion mode
When the user agent is to apply the rules for the "text" insertion mode, the user agent must handle the token as follows:

A character token
Insert the token's character.

This can never be a U+0000 NULL character; the tokenizer converts those to U+FFFD REPLACEMENT CHARACTER characters.

An end-of-file token
Parse error.

If the current node is a script element, mark the script element as "already started".

Pop the current node off the stack of open elements.

Switch the insertion mode to the original insertion mode and reprocess the token.

An end tag whose tag name is "script"
If the JavaScript execution context stack is empty, perform a microtask checkpoint.

Let script be the current node (which will be a script element).

Pop the current node off the stack of open elements.

Switch the insertion mode to the original insertion mode.

Let the old insertion point have the same value as the current insertion point. Let the insertion point be just before the next input character.

Increment the parser's script nesting level by one.

Prepare the script. This might cause some script to execute, which might cause new characters to be inserted into the tokenizer, and might cause the tokenizer to output more tokens, resulting in a reentrant invocation of the parser.

Decrement the parser's script nesting level by one. If the parser's script nesting level is zero, then set the parser pause flag to false.

Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)

At this stage, if there is a pending parsing-blocking script, then:

If the script nesting level is not zero:
Set the parser pause flag to true, and abort the processing of any nested invocations of the tokenizer, yielding control back to the caller. (Tokenization will resume when the caller returns to the "outer" tree construction stage.)

The tree construction stage of this particular parser is being called reentrantly, say from a call to document.write().

Otherwise:
Run these steps:

Let the script be the pending parsing-blocking script. There is no longer a pending parsing-blocking script.

Block the tokenizer for this instance of the HTML parser, such that the event loop will not run tasks that invoke the tokenizer.

If the parser's Document has a style sheet that is blocking scripts or the script's "ready to be parser-executed" flag is not set: spin the event loop until the parser's Document has no style sheet that is blocking scripts and the script's "ready to be parser-executed" flag is set.

If this parser has been aborted in the meantime, return.

This could happen if, e.g., while the spin the event loop algorithm is running, the browsing context gets closed, or the document.open() method gets invoked on the Document.

Unblock the tokenizer for this instance of the HTML parser, such that tasks that invoke the tokenizer can again be run.

Let the insertion point be just before the next input character.

Increment the parser's script nesting level by one (it should be zero before this step, so this sets it to one).

Execute the script.

Decrement the parser's script nesting level by one. If the parser's script nesting level is zero (which it always should be at this point), then set the parser pause flag to false.

Let the insertion point be undefined again.

If there is once again a pending parsing-blocking script, then repeat these steps from step 1.

Any other end tag
Pop the current node off the stack of open elements.

Switch the insertion mode to the original insertion mode.

12.2.6.4.9 The "in table" insertion mode
When the user agent is to apply the rules for the "in table" insertion mode, the user agent must handle the token as follows:

A character token, if the current node is table, tbody, tfoot, thead, or tr element
Let the pending table character tokens be an empty list of tokens.

Let the original insertion mode be the current insertion mode.

Switch the insertion mode to "in table text" and reprocess the token.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "caption"
Clear the stack back to a table context. (See below.)

Insert a marker at the end of the list of active formatting elements.

Insert an HTML element for the token, then switch the insertion mode to "in caption".

A start tag whose tag name is "colgroup"
Clear the stack back to a table context. (See below.)

Insert an HTML element for the token, then switch the insertion mode to "in column group".

A start tag whose tag name is "col"
Clear the stack back to a table context. (See below.)

Insert an HTML element for a "colgroup" start tag token with no attributes, then switch the insertion mode to "in column group".

Reprocess the current token.

A start tag whose tag name is one of: "tbody", "tfoot", "thead"
Clear the stack back to a table context. (See below.)

Insert an HTML element for the token, then switch the insertion mode to "in table body".

A start tag whose tag name is one of: "td", "th", "tr"
Clear the stack back to a table context. (See below.)

Insert an HTML element for a "tbody" start tag token with no attributes, then switch the insertion mode to "in table body".

Reprocess the current token.

A start tag whose tag name is "table"
Parse error.

If the stack of open elements does not have a table element in table scope, ignore the token.

Otherwise:

Pop elements from this stack until a table element has been popped from the stack.

Reset the insertion mode appropriately.

Reprocess the token.

An end tag whose tag name is "table"
If the stack of open elements does not have a table element in table scope, this is a parse error; ignore the token.

Otherwise:

Pop elements from this stack until a table element has been popped from the stack.

Reset the insertion mode appropriately.

An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
Parse error. Ignore the token.

A start tag whose tag name is one of: "style", "script", "template"
An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

A start tag whose tag name is "input"
If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then: act as described in the "anything else" entry below.

Otherwise:

Parse error.

Insert an HTML element for the token.

Pop that input element off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

A start tag whose tag name is "form"
Parse error.

If there is a template element on the stack of open elements, or if the form element pointer is not null, ignore the token.

Otherwise:

Insert an HTML element for the token, and set the form element pointer to point to the element created.

Pop that form element off the stack of open elements.

An end-of-file token
Process the token using the rules for the "in body" insertion mode.

Anything else
Parse error. Enable foster parenting, process the token using the rules for the "in body" insertion mode, and then disable foster parenting.

When the steps above require the UA to clear the stack back to a table context, it means that the UA must, while the current node is not a table, template, or html element, pop elements from the stack of open elements.

This is the same list of elements as used in the has an element in table scope steps.

The current node being an html element after this process is a fragment case.

12.2.6.4.10 The "in table text" insertion mode
When the user agent is to apply the rules for the "in table text" insertion mode, the user agent must handle the token as follows:

A character token that is U+0000 NULL
Parse error. Ignore the token.

Any other character token
Append the character token to the pending table character tokens list.

Anything else
If any of the tokens in the pending table character tokens list are character tokens that are not ASCII whitespace, then this is a parse error: reprocess the character tokens in the pending table character tokens list using the rules given in the "anything else" entry in the "in table" insertion mode.

Otherwise, insert the characters given by the pending table character tokens list.

Switch the insertion mode to the original insertion mode and reprocess the token.

12.2.6.4.11 The "in caption" insertion mode
When the user agent is to apply the rules for the "in caption" insertion mode, the user agent must handle the token as follows:

An end tag whose tag name is "caption"
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)

Otherwise:

Generate implied end tags.

Now, if the current node is not a caption element, then this is a parse error.

Pop elements from this stack until a caption element has been popped from the stack.

Clear the list of active formatting elements up to the last marker.

Switch the insertion mode to "in table".

A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
An end tag whose tag name is "table"
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)

Otherwise:

Generate implied end tags.

Now, if the current node is not a caption element, then this is a parse error.

Pop elements from this stack until a caption element has been popped from the stack.

Clear the list of active formatting elements up to the last marker.

Switch the insertion mode to "in table".

Reprocess the token.

An end tag whose tag name is one of: "body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
Parse error. Ignore the token.

Anything else
Process the token using the rules for the "in body" insertion mode.

12.2.6.4.12 The "in column group" insertion mode
When the user agent is to apply the rules for the "in column group" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is "col"
Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

An end tag whose tag name is "colgroup"
If the current node is not a colgroup element, then this is a parse error; ignore the token.

Otherwise, pop the current node from the stack of open elements. Switch the insertion mode to "in table".

An end tag whose tag name is "col"
Parse error. Ignore the token.

A start tag whose tag name is "template"
An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

An end-of-file token
Process the token using the rules for the "in body" insertion mode.

Anything else
If the current node is not a colgroup element, then this is a parse error; ignore the token.

Otherwise, pop the current node from the stack of open elements.

Switch the insertion mode to "in table".

Reprocess the token.

12.2.6.4.13 The "in table body" insertion mode
When the user agent is to apply the rules for the "in table body" insertion mode, the user agent must handle the token as follows:

A start tag whose tag name is "tr"
Clear the stack back to a table body context. (See below.)

Insert an HTML element for the token, then switch the insertion mode to "in row".

A start tag whose tag name is one of: "th", "td"
Parse error.

Clear the stack back to a table body context. (See below.)

Insert an HTML element for a "tr" start tag token with no attributes, then switch the insertion mode to "in row".

Reprocess the current token.

An end tag whose tag name is one of: "tbody", "tfoot", "thead"
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.

Otherwise:

Clear the stack back to a table body context. (See below.)

Pop the current node from the stack of open elements. Switch the insertion mode to "in table".

A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead"
An end tag whose tag name is "table"
If the stack of open elements does not have a tbody, thead, or tfoot element in table scope, this is a parse error; ignore the token.

Otherwise:

Clear the stack back to a table body context. (See below.)

Pop the current node from the stack of open elements. Switch the insertion mode to "in table".

Reprocess the token.

An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th", "tr"
Parse error. Ignore the token.

Anything else
Process the token using the rules for the "in table" insertion mode.

When the steps above require the UA to clear the stack back to a table body context, it means that the UA must, while the current node is not a tbody, tfoot, thead, template, or html element, pop elements from the stack of open elements.

The current node being an html element after this process is a fragment case.

12.2.6.4.14 The "in row" insertion mode
When the user agent is to apply the rules for the "in row" insertion mode, the user agent must handle the token as follows:

A start tag whose tag name is one of: "th", "td"
Clear the stack back to a table row context. (See below.)

Insert an HTML element for the token, then switch the insertion mode to "in cell".

Insert a marker at the end of the list of active formatting elements.

An end tag whose tag name is "tr"
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.

Otherwise:

Clear the stack back to a table row context. (See below.)

Pop the current node (which will be a tr element) from the stack of open elements. Switch the insertion mode to "in table body".

A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr"
An end tag whose tag name is "table"
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.

Otherwise:

Clear the stack back to a table row context. (See below.)

Pop the current node (which will be a tr element) from the stack of open elements. Switch the insertion mode to "in table body".

Reprocess the token.

An end tag whose tag name is one of: "tbody", "tfoot", "thead"
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.

If the stack of open elements does not have a tr element in table scope, ignore the token.

Otherwise:

Clear the stack back to a table row context. (See below.)

Pop the current node (which will be a tr element) from the stack of open elements. Switch the insertion mode to "in table body".

Reprocess the token.

An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th"
Parse error. Ignore the token.

Anything else
Process the token using the rules for the "in table" insertion mode.

When the steps above require the UA to clear the stack back to a table row context, it means that the UA must, while the current node is not a tr, template, or html element, pop elements from the stack of open elements.

The current node being an html element after this process is a fragment case.

12.2.6.4.15 The "in cell" insertion mode
When the user agent is to apply the rules for the "in cell" insertion mode, the user agent must handle the token as follows:

An end tag whose tag name is one of: "td", "th"
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.

Otherwise:

Generate implied end tags.

Now, if the current node is not an HTML element with the same tag name as the token, then this is a parse error.

Pop elements from the stack of open elements stack until an HTML element with the same tag name as the token has been popped from the stack.

Clear the list of active formatting elements up to the last marker.

Switch the insertion mode to "in row".

A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
If the stack of open elements does not have a td or th element in table scope, then this is a parse error; ignore the token. (fragment case)

Otherwise, close the cell (see below) and reprocess the token.

An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html"
Parse error. Ignore the token.

An end tag whose tag name is one of: "table", "tbody", "tfoot", "thead", "tr"
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.

Otherwise, close the cell (see below) and reprocess the token.

Anything else
Process the token using the rules for the "in body" insertion mode.

Where the steps above say to close the cell, they mean to run the following algorithm:

Generate implied end tags.

If the current node is not now a td element or a th element, then this is a parse error.

Pop elements from the stack of open elements stack until a td element or a th element has been popped from the stack.

Clear the list of active formatting elements up to the last marker.

Switch the insertion mode to "in row".

The stack of open elements cannot have both a td and a th element in table scope at the same time, nor can it have neither when the close the cell algorithm is invoked.

12.2.6.4.16 The "in select" insertion mode
When the user agent is to apply the rules for the "in select" insertion mode, the user agent must handle the token as follows:

A character token that is U+0000 NULL
Parse error. Ignore the token.

Any other character token
Insert the token's character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is "option"
If the current node is an option element, pop that node from the stack of open elements.

Insert an HTML element for the token.

A start tag whose tag name is "optgroup"
If the current node is an option element, pop that node from the stack of open elements.

If the current node is an optgroup element, pop that node from the stack of open elements.

Insert an HTML element for the token.

An end tag whose tag name is "optgroup"
First, if the current node is an option element, and the node immediately before it in the stack of open elements is an optgroup element, then pop the current node from the stack of open elements.

If the current node is an optgroup element, then pop that node from the stack of open elements. Otherwise, this is a parse error; ignore the token.

An end tag whose tag name is "option"
If the current node is an option element, then pop that node from the stack of open elements. Otherwise, this is a parse error; ignore the token.

An end tag whose tag name is "select"
If the stack of open elements does not have a select element in select scope, this is a parse error; ignore the token. (fragment case)

Otherwise:

Pop elements from the stack of open elements until a select element has been popped from the stack.

Reset the insertion mode appropriately.

A start tag whose tag name is "select"
Parse error.

If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)

Otherwise:

Pop elements from the stack of open elements until a select element has been popped from the stack.

Reset the insertion mode appropriately.

It just gets treated like an end tag.

A start tag whose tag name is one of: "input", "keygen", "textarea"
Parse error.

If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)

Otherwise:

Pop elements from the stack of open elements until a select element has been popped from the stack.

Reset the insertion mode appropriately.

Reprocess the token.

A start tag whose tag name is one of: "script", "template"
An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

An end-of-file token
Process the token using the rules for the "in body" insertion mode.

Anything else
Parse error. Ignore the token.

12.2.6.4.17 The "in select in table" insertion mode
When the user agent is to apply the rules for the "in select in table" insertion mode, the user agent must handle the token as follows:

A start tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"
Parse error.

Pop elements from the stack of open elements until a select element has been popped from the stack.

Reset the insertion mode appropriately.

Reprocess the token.

An end tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"
Parse error.

If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then ignore the token.

Otherwise:

Pop elements from the stack of open elements until a select element has been popped from the stack.

Reset the insertion mode appropriately.

Reprocess the token.

Anything else
Process the token using the rules for the "in select" insertion mode.

12.2.6.4.18 The "in template" insertion mode
When the user agent is to apply the rules for the "in template" insertion mode, the user agent must handle the token as follows:

A character token
A comment token
A DOCTYPE token
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
An end tag whose tag name is "template"
Process the token using the rules for the "in head" insertion mode.

A start tag whose tag name is one of: "caption", "colgroup", "tbody", "tfoot", "thead"
Pop the current template insertion mode off the stack of template insertion modes.

Push "in table" onto the stack of template insertion modes so that it is the new current template insertion mode.

Switch the insertion mode to "in table", and reprocess the token.

A start tag whose tag name is "col"
Pop the current template insertion mode off the stack of template insertion modes.

Push "in column group" onto the stack of template insertion modes so that it is the new current template insertion mode.

Switch the insertion mode to "in column group", and reprocess the token.

A start tag whose tag name is "tr"
Pop the current template insertion mode off the stack of template insertion modes.

Push "in table body" onto the stack of template insertion modes so that it is the new current template insertion mode.

Switch the insertion mode to "in table body", and reprocess the token.

A start tag whose tag name is one of: "td", "th"
Pop the current template insertion mode off the stack of template insertion modes.

Push "in row" onto the stack of template insertion modes so that it is the new current template insertion mode.

Switch the insertion mode to "in row", and reprocess the token.

Any other start tag
Pop the current template insertion mode off the stack of template insertion modes.

Push "in body" onto the stack of template insertion modes so that it is the new current template insertion mode.

Switch the insertion mode to "in body", and reprocess the token.

Any other end tag
Parse error. Ignore the token.

An end-of-file token
If there is no template element on the stack of open elements, then stop parsing. (fragment case)

Otherwise, this is a parse error.

Pop elements from the stack of open elements until a template element has been popped from the stack.

Clear the list of active formatting elements up to the last marker.

Pop the current template insertion mode off the stack of template insertion modes.

Reset the insertion mode appropriately.

Reprocess the token.

12.2.6.4.19 The "after body" insertion mode
When the user agent is to apply the rules for the "after body" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Process the token using the rules for the "in body" insertion mode.

A comment token
Insert a comment as the last child of the first element in the stack of open elements (the html element).

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

An end tag whose tag name is "html"
If the parser was originally created as part of the HTML fragment parsing algorithm, this is a parse error; ignore the token. (fragment case)

Otherwise, switch the insertion mode to "after after body".

An end-of-file token
Stop parsing.

Anything else
Parse error. Switch the insertion mode to "in body" and reprocess the token.

12.2.6.4.20 The "in frameset" insertion mode
When the user agent is to apply the rules for the "in frameset" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

A start tag whose tag name is "frameset"
Insert an HTML element for the token.

An end tag whose tag name is "frameset"
If the current node is the root html element, then this is a parse error; ignore the token. (fragment case)

Otherwise, pop the current node from the stack of open elements.

If the parser was not originally created as part of the HTML fragment parsing algorithm (fragment case), and the current node is no longer a frameset element, then switch the insertion mode to "after frameset".

A start tag whose tag name is "frame"
Insert an HTML element for the token. Immediately pop the current node off the stack of open elements.

Acknowledge the token's self-closing flag, if it is set.

A start tag whose tag name is "noframes"
Process the token using the rules for the "in head" insertion mode.

An end-of-file token
If the current node is not the root html element, then this is a parse error.

The current node can only be the root html element in the fragment case.

Stop parsing.

Anything else
Parse error. Ignore the token.

12.2.6.4.21 The "after frameset" insertion mode
When the user agent is to apply the rules for the "after frameset" insertion mode, the user agent must handle the token as follows:

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the character.

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

An end tag whose tag name is "html"
Switch the insertion mode to "after after frameset".

A start tag whose tag name is "noframes"
Process the token using the rules for the "in head" insertion mode.

An end-of-file token
Stop parsing.

Anything else
Parse error. Ignore the token.

12.2.6.4.22 The "after after body" insertion mode
When the user agent is to apply the rules for the "after after body" insertion mode, the user agent must handle the token as follows:

A comment token
Insert a comment as the last child of the Document object.

A DOCTYPE token
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

An end-of-file token
Stop parsing.

Anything else
Parse error. Switch the insertion mode to "in body" and reprocess the token.

12.2.6.4.23 The "after after frameset" insertion mode
When the user agent is to apply the rules for the "after after frameset" insertion mode, the user agent must handle the token as follows:

A comment token
Insert a comment as the last child of the Document object.

A DOCTYPE token
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
A start tag whose tag name is "html"
Process the token using the rules for the "in body" insertion mode.

An end-of-file token
Stop parsing.

A start tag whose tag name is "noframes"
Process the token using the rules for the "in head" insertion mode.

Anything else
Parse error. Ignore the token.

12.2.6.5 The rules for parsing tokens in foreign content
When the user agent is to apply the rules for parsing tokens in foreign content, the user agent must handle the token as follows:

A character token that is U+0000 NULL
Parse error. Insert a U+FFFD REPLACEMENT CHARACTER character.

A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
Insert the token's character.

Any other character token
Insert the token's character.

Set the frameset-ok flag to "not ok".

A comment token
Insert a comment.

A DOCTYPE token
Parse error. Ignore the token.

A start tag whose tag name is one of: "b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "menu", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"
A start tag whose tag name is "font", if the token has any attributes named "color", "face", or "size"
Parse error.

If the parser was originally created for the HTML fragment parsing algorithm, then act as described in the "any other start tag" entry below. (fragment case)

Otherwise:

Pop an element from the stack of open elements, and then keep popping more elements from the stack of open elements until the current node is a MathML text integration point, an HTML integration point, or an element in the HTML namespace.

Then, reprocess the token.

Any other start tag
If the adjusted current node is an element in the MathML namespace, adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)

If the adjusted current node is an element in the SVG namespace, and the token's tag name is one of the ones in the first column of the following table, change the tag name to the name given in the corresponding cell in the second column. (This fixes the case of SVG elements that are not all lowercase.)

Tag name	Element name
altglyph	altGlyph
altglyphdef	altGlyphDef
altglyphitem	altGlyphItem
animatecolor	animateColor
animatemotion	animateMotion
animatetransform	animateTransform
clippath	clipPath
feblend	feBlend
fecolormatrix	feColorMatrix
fecomponenttransfer	feComponentTransfer
fecomposite	feComposite
feconvolvematrix	feConvolveMatrix
fediffuselighting	feDiffuseLighting
fedisplacementmap	feDisplacementMap
fedistantlight	feDistantLight
fedropshadow	feDropShadow
feflood	feFlood
fefunca	feFuncA
fefuncb	feFuncB
fefuncg	feFuncG
fefuncr	feFuncR
fegaussianblur	feGaussianBlur
feimage	feImage
femerge	feMerge
femergenode	feMergeNode
femorphology	feMorphology
feoffset	feOffset
fepointlight	fePointLight
fespecularlighting	feSpecularLighting
fespotlight	feSpotLight
fetile	feTile
feturbulence	feTurbulence
foreignobject	foreignObject
glyphref	glyphRef
lineargradient	linearGradient
radialgradient	radialGradient
textpath	textPath
If the adjusted current node is an element in the SVG namespace, adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)

Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)

Insert a foreign element for the token, in the same namespace as the adjusted current node.

If the token has its self-closing flag set, then run the appropriate steps from the following list:

If the token's tag name is "script", and the new current node is in the SVG namespace
Acknowledge the token's self-closing flag, and then act as described in the steps for a "script" end tag below.

Otherwise
Pop the current node off the stack of open elements and acknowledge the token's self-closing flag.

An end tag whose tag name is "script", if the current node is an SVG script element
Pop the current node off the stack of open elements.

Let the old insertion point have the same value as the current insertion point. Let the insertion point be just before the next input character.

Increment the parser's script nesting level by one. Set the parser pause flag to true.

Process the SVG script element according to the SVG rules, if the user agent supports SVG. [SVG]

Even if this causes new characters to be inserted into the tokenizer, the parser will not be executed reentrantly, since the parser pause flag is true.

Decrement the parser's script nesting level by one. If the parser's script nesting level is zero, then set the parser pause flag to false.

Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)

Any other end tag
Run these steps:

Initialize node to be the current node (the bottommost node of the stack).

If node's tag name, converted to ASCII lowercase, is not the same as the tag name of the token, then this is a parse error.

Loop: If node is the topmost element in the stack of open elements, then return. (fragment case)

If node's tag name, converted to ASCII lowercase, is the same as the tag name of the token, pop elements from the stack of open elements until node has been popped from the stack, and then return.

Set node to the previous entry in the stack of open elements.

If node is not an element in the HTML namespace, return to the step labeled loop.

Otherwise, process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.

12.2.7 The end
Once the user agent stops parsing the document, the user agent must run the following steps:


Support: domcontentloaded
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	9+
Opera Mini	all+
Safari	3.1+
Edge	12+
Android Browser	2.1+
Opera	9+

Source: caniuse.com

Set the current document readiness to "interactive" and the insertion point to undefined.

Pop all the nodes off the stack of open elements.

If the list of scripts that will execute when the document has finished parsing is not empty, run these substeps:

Spin the event loop until the first script in the list of scripts that will execute when the document has finished parsing has its "ready to be parser-executed" flag set and the parser's Document has no style sheet that is blocking scripts.

Execute the first script in the list of scripts that will execute when the document has finished parsing.

Remove the first script element from the list of scripts that will execute when the document has finished parsing (i.e. shift out the first entry in the list).

If the list of scripts that will execute when the document has finished parsing is still not empty, repeat these substeps again from substep 1.

Queue a task to run the following substeps:

Fire an event named DOMContentLoaded at the Document object, with its bubbles attribute initialized to true.

Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is the Document object's relevant settings object.

Spin the event loop until the set of scripts that will execute as soon as possible and the list of scripts that will execute in order as soon as possible are empty.

Spin the event loop until there is nothing that delays the load event in the Document.

Queue a task to run the following substeps:

Set the current document readiness to "complete".

Load event: If the Document has a browsing context, then fire an event named load at the Document object's Window object, with legacy target override flag set.

If the Document has a browsing context, then queue a task to run the following substeps:

If the Document's page showing flag is true, then return (i.e. don't fire the event below).

Set the Document's page showing flag to true.

Fire an event named pageshow at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to false, and legacy target override flag set.

If the Document has any pending application cache download process tasks, then queue each such task in the order they were added to the list of pending application cache download process tasks, and then empty the list of pending application cache download process tasks. The task source for these tasks is the networking task source.

If the Document's print when loaded flag is set, then run the printing steps.

The Document is now ready for post-load tasks.

Queue a task to mark the Document as completely loaded.

When the user agent is to abort a parser, it must run the following steps:

Throw away any pending content in the input stream, and discard any future content that would have been added to it.

Set the current document readiness to "interactive".

Pop all the nodes off the stack of open elements.

Set the current document readiness to "complete".

Except where otherwise specified, the task source for the tasks mentioned in this section is the DOM manipulation task source.

12.2.8 Coercing an HTML DOM into an infoset
When an application uses an HTML parser in conjunction with an XML pipeline, it is possible that the constructed DOM is not compatible with the XML tool chain in certain subtle ways. For example, an XML toolchain might not be able to represent attributes with the name xmlns, since they conflict with the Namespaces in XML syntax. There is also some data that the HTML parser generates that isn't included in the DOM itself. This section specifies some rules for handling these issues.

If the XML API being used doesn't support DOCTYPEs, the tool may drop DOCTYPEs altogether.

If the XML API doesn't support attributes in no namespace that are named "xmlns", attributes whose names start with "xmlns:", or attributes in the XMLNS namespace, then the tool may drop such attributes.

The tool may annotate the output with any namespace declarations required for proper operation.

If the XML API being used restricts the allowable characters in the local names of elements and attributes, then the tool may map all element and attribute local names that the API wouldn't support to a set of names that are allowed, by replacing any character that isn't supported with the uppercase letter U and the six digits of the character's code point when expressed in hexadecimal, using digits 0-9 and capital letters A-F as the symbols, in increasing numeric order.

For example, the element name foo<bar, which can be output by the HTML parser, though it is neither a legal HTML element name nor a well-formed XML element name, would be converted into fooU00003Cbar, which is a well-formed XML element name (though it's still not legal in HTML by any means).

As another example, consider the attribute xlink:href. Used on a MathML element, it becomes, after being adjusted, an attribute with a prefix "xlink" and a local name "href". However, used on an HTML element, it becomes an attribute with no prefix and the local name "xlink:href", which is not a valid NCName, and thus might not be accepted by an XML API. It could thus get converted, becoming "xlinkU00003Ahref".

The resulting names from this conversion conveniently can't clash with any attribute generated by the HTML parser, since those are all either lowercase or those listed in the adjust foreign attributes algorithm's table.

If the XML API restricts comments from having two consecutive U+002D HYPHEN-MINUS characters (--), the tool may insert a single U+0020 SPACE character between any such offending characters.

If the XML API restricts comments from ending in a U+002D HYPHEN-MINUS character (-), the tool may insert a single U+0020 SPACE character at the end of such comments.

If the XML API restricts allowed characters in character data, attribute values, or comments, the tool may replace any U+000C FORM FEED (FF) character with a U+0020 SPACE character, and any other literal non-XML character with a U+FFFD REPLACEMENT CHARACTER.

If the tool has no way to convey out-of-band information, then the tool may drop the following information:

Whether the document is set to no-quirks mode, limited-quirks mode, or quirks mode
The association between form controls and forms that aren't their nearest form element ancestor (use of the form element pointer in the parser)
The template contents of any template elements.
The mutations allowed by this section apply after the HTML parser's rules have been applied. For example, a <a::> start tag will be closed by a </a::> end tag, and never by a </aU00003AU00003A> end tag, even if the user agent is using the rules above to then generate an actual element in the DOM with the name aU00003AU00003A for that start tag.

12.2.9 An introduction to error handling and strange cases in the parser
This section is non-normative.

This section examines some erroneous markup and discusses how the HTML parser handles these cases.

12.2.9.1 Misnested tags: <b><i></b></i>
This section is non-normative.

The most-often discussed example of erroneous markup is as follows:

<p>1<b>2<i>3</b>4</i>5</p>
The parsing of this markup is straightforward up to the "3". At this point, the DOM looks like this:

html
head
body
p
#text: 1
b
#text: 2
i
#text: 3
Here, the stack of open elements has five elements on it: html, body, p, b, and i. The list of active formatting elements just has two: b and i. The insertion mode is "in body".

Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked. This is a simple case, in that the formatting element is the b element, and there is no furthest block. Thus, the stack of open elements ends up with just three elements: html, body, and p, while the list of active formatting elements has just one: i. The DOM tree is unmodified at this point.

The next token is a character ("4"), triggers the reconstruction of the active formatting elements, in this case just the i element. A new i element is thus created for the "4" Text node. After the end tag token for the "i" is also received, and the "5" Text node is inserted, the DOM looks as follows:

html
head
body
p
#text: 1
b
#text: 2
i
#text: 3
i
#text: 4
#text: 5
12.2.9.2 Misnested tags: <b><p></b></p>
This section is non-normative.

A case similar to the previous one is the following:

<b>1<p>2</b>3</p>
Up to the "2" the parsing here is straightforward:

html
head
body
b
#text: 1
p
#text: 2
The interesting part is when the end tag token with the tag name "b" is parsed.

Before that token is seen, the stack of open elements has four elements on it: html, body, b, and p. The list of active formatting elements just has the one: b. The insertion mode is "in body".

Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked, as in the previous example. However, in this case, there is a furthest block, namely the p element. Thus, this time the adoption agency algorithm isn't skipped over.

The common ancestor is the body element. A conceptual "bookmark" marks the position of the b in the list of active formatting elements, but since that list has only one element in it, the bookmark won't have much effect.

As the algorithm progresses, node ends up set to the formatting element (b), and last node ends up set to the furthest block (p).

The last node gets appended (moved) to the common ancestor, so that the DOM looks like:

html
head
body
b
#text: 1
p
#text: 2
A new b element is created, and the children of the p element are moved to it:

html
head
body
b
#text: 1
p
b
#text: 2
Finally, the new b element is appended to the p element, so that the DOM looks like:

html
head
body
b
#text: 1
p
b
#text: 2
The b element is removed from the list of active formatting elements and the stack of open elements, so that when the "3" is parsed, it is appended to the p element:

html
head
body
b
#text: 1
p
b
#text: 2
#text: 3
12.2.9.3 Unexpected markup in tables
This section is non-normative.

Error handling in tables is, for historical reasons, especially strange. For example, consider the following markup:

<table><b><tr><td>aaa</td></tr>bbb</table>ccc
The highlighted b element start tag is not allowed directly inside a table like that, and the parser handles this case by placing the element before the table. (This is called foster parenting.) This can be seen by examining the DOM tree as it stands just after the table element's start tag has been seen:

html
head
body
table
...and then immediately after the b element start tag has been seen:

html
head
body
b
table
At this point, the stack of open elements has on it the elements html, body, table, and b (in that order, despite the resulting DOM tree); the list of active formatting elements just has the b element in it; and the insertion mode is "in table".

The tr start tag causes the b element to be popped off the stack and a tbody start tag to be implied; the tbody and tr elements are then handled in a rather straight-forward manner, taking the parser through the "in table body" and "in row" insertion modes, after which the DOM looks as follows:

html
head
body
b
table
tbody
tr
Here, the stack of open elements has on it the elements html, body, table, tbody, and tr; the list of active formatting elements still has the b element in it; and the insertion mode is "in row".

The td element start tag token, after putting a td element on the tree, puts a marker on the list of active formatting elements (it also switches to the "in cell" insertion mode).

html
head
body
b
table
tbody
tr
td
The marker means that when the "aaa" character tokens are seen, no b element is created to hold the resulting Text node:

html
head
body
b
table
tbody
tr
td
#text: aaa
The end tags are handled in a straight-forward manner; after handling them, the stack of open elements has on it the elements html, body, table, and tbody; the list of active formatting elements still has the b element in it (the marker having been removed by the "td" end tag token); and the insertion mode is "in table body".

Thus it is that the "bbb" character tokens are found. These trigger the "in table text" insertion mode to be used (with the original insertion mode set to "in table body"). The character tokens are collected, and when the next token (the table element end tag) is seen, they are processed as a group. Since they are not all spaces, they are handled as per the "anything else" rules in the "in table" insertion mode, which defer to the "in body" insertion mode but with foster parenting.

When the active formatting elements are reconstructed, a b element is created and foster parented, and then the "bbb" Text node is appended to it:

html
head
body
b
b
#text: bbb
table
tbody
tr
td
#text: aaa
The stack of open elements has on it the elements html, body, table, tbody, and the new b (again, note that this doesn't match the resulting tree!); the list of active formatting elements has the new b element in it; and the insertion mode is still "in table body".

Had the character tokens been only ASCII whitespace instead of "bbb", then that ASCII whitespace would just be appended to the tbody element.

Finally, the table is closed by a "table" end tag. This pops all the nodes from the stack of open elements up to and including the table element, but it doesn't affect the list of active formatting elements, so the "ccc" character tokens after the table result in yet another b element being created, this time after the table:

html
head
body
b
b
#text: bbb
table
tbody
tr
td
#text: aaa
b
#text: ccc
12.2.9.4 Scripts that modify the page as it is being parsed
This section is non-normative.

Consider the following markup, which for this example we will assume is the document with URL https://example.com/inner, being rendered as the content of an iframe in another document with the URL https://example.com/outer:

<div id=a>
 <script>
  var div = document.getElementById('a');
  parent.document.body.appendChild(div);
 </script>
 <script>
  alert(document.URL);
 </script>
</div>
<script>
 alert(document.URL);
</script>
Up to the first "script" end tag, before the script is parsed, the result is relatively straightforward:

html
head
body
div id="a"
#text:
script
#text: var div = document.getElementById('a'); ⏎ parent.document.body.appendChild(div);
After the script is parsed, though, the div element and its child script element are gone:

html
head
body
They are, at this point, in the Document of the aforementioned outer browsing context. However, the stack of open elements still contains the div element.

Thus, when the second script element is parsed, it is inserted into the outer Document object.

Those parsed into different Documents than the one the parser was created for do not execute, so the first alert does not show.

Once the div element's end tag is parsed, the div element is popped off the stack, and so the next script element is in the inner Document:

html
head
body
script
#text: alert(document.URL);
This script does execute, resulting in an alert that says "https://example.com/inner".

12.2.9.5 The execution of scripts that are moving across multiple documents
This section is non-normative.

Elaborating on the example in the previous section, consider the case where the second script element is an external script (i.e. one with a src attribute). Since the element was not in the parser's Document when it was created, that external script is not even downloaded.

In a case where a script element with a src attribute is parsed normally into its parser's Document, but while the external script is being downloaded, the element is moved to another document, the script continues to download, but does not execute.

In general, moving script elements between Documents is considered a bad practice.

12.2.9.6 Unclosed formatting elements
This section is non-normative.

The following markup shows how nested formatting elements (such as b) get collected and continue to be applied even as the elements they are contained in are closed, but that excessive duplicates are thrown away.

<!DOCTYPE html>
<p><b class=x><b class=x><b><b class=x><b class=x><b>X
<p>X
<p><b><b class=x><b>X
<p></b></b></b></b></b></b>X
The resulting DOM tree is as follows:

DOCTYPE: html
html
head
body
p
b class="x"
b class="x"
b
b class="x"
b class="x"
b
#text: X⏎
p
b class="x"
b
b class="x"
b class="x"
b
#text: X⏎
p
b class="x"
b
b class="x"
b class="x"
b
b
b class="x"
b
#text: X⏎
p
#text: X⏎
Note how the second p element in the markup has no explicit b elements, but in the resulting DOM, up to three of each kind of formatting element (in this case three b elements with the class attribute, and two unadorned b elements) get reconstructed before the element's "X".

Also note how this means that in the final paragraph only six b end tags are needed to completely clear the list of active formatting elements, even though nine b start tags have been seen up to this point.

12.3 Serializing HTML fragments
The following steps form the HTML fragment serialization algorithm. The algorithm takes as input a DOM Element, Document, or DocumentFragment referred to as the node, and returns a string.

This algorithm serializes the children of the node being serialized, not the node itself.

Let s be a string, and initialize it to the empty string.

If the node is a template element, then let the node instead be the template element's template contents (a DocumentFragment node).

For each child node of the node, in tree order, run the following steps:

Let current node be the child node being processed.

Append the appropriate string from the following list to s:

If current node is an Element
If current node is an element in the HTML namespace, the MathML namespace, or the SVG namespace, then let tagname be current node's local name. Otherwise, let tagname be current node's qualified name.

Append a U+003C LESS-THAN SIGN character (<), followed by tagname.

For HTML elements created by the HTML parser or createElement(), tagname will be lowercase.

If current node's is value is not null, and the element does not have an is attribute in its attribute list, then append the string " is="", followed by current node's is value escaped as described below in attribute mode, followed by a U+0022 QUOTATION MARK character (").

For each attribute that the element has, append a U+0020 SPACE character, the attribute's serialized name as described below, a U+003D EQUALS SIGN character (=), a U+0022 QUOTATION MARK character ("), the attribute's value, escaped as described below in attribute mode, and a second U+0022 QUOTATION MARK character (").

An attribute's serialized name for the purposes of the previous paragraph must be determined as follows:

If the attribute has no namespace
The attribute's serialized name is the attribute's local name.

For attributes on HTML elements set by the HTML parser or by Element.setAttribute(), the local name will be lowercase.

If the attribute is in the XML namespace
The attribute's serialized name is the string "xml:" followed by the attribute's local name.

If the attribute is in the XMLNS namespace and the attribute's local name is xmlns
The attribute's serialized name is the string "xmlns".

If the attribute is in the XMLNS namespace and the attribute's local name is not xmlns
The attribute's serialized name is the string "xmlns:" followed by the attribute's local name.

If the attribute is in the XLink namespace
The attribute's serialized name is the string "xlink:" followed by the attribute's local name.

If the attribute is in some other namespace
The attribute's serialized name is the attribute's qualified name.

While the exact order of attributes is UA-defined, and may depend on factors such as the order that the attributes were given in the original markup, the sort order must be stable, such that consecutive invocations of this algorithm serialize an element's attributes in the same order.

Append a U+003E GREATER-THAN SIGN character (>).

If current node is an area, base, basefont, bgsound, br, col, embed, frame, hr, img, input, keygen, link, meta, param, source, track or wbr element, then continue on to the next child node at this point.

Append the value of running the HTML fragment serialization algorithm on the current node element (thus recursing into this algorithm for that element), followed by a U+003C LESS-THAN SIGN character (<), a U+002F SOLIDUS character (/), tagname again, and finally a U+003E GREATER-THAN SIGN character (>).

If current node is a Text node
If the parent of current node is a style, script, xmp, iframe, noembed, noframes, or plaintext element, or if the parent of current node is a noscript element and scripting is enabled for the node, then append the value of current node's data IDL attribute literally.

Otherwise, append the value of current node's data IDL attribute, escaped as described below.

If current node is a Comment
Append the literal string "<!--" (U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS), followed by the value of current node's data IDL attribute, followed by the literal string "-->" (U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN).

If current node is a ProcessingInstruction
Append the literal string "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK), followed by the value of current node's target IDL attribute, followed by a single U+0020 SPACE character, followed by the value of current node's data IDL attribute, followed by a single U+003E GREATER-THAN SIGN character (>).

If current node is a DocumentType
Append the literal string "<!DOCTYPE" (U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+0044 LATIN CAPITAL LETTER D, U+004F LATIN CAPITAL LETTER O, U+0043 LATIN CAPITAL LETTER C, U+0054 LATIN CAPITAL LETTER T, U+0059 LATIN CAPITAL LETTER Y, U+0050 LATIN CAPITAL LETTER P, U+0045 LATIN CAPITAL LETTER E), followed by a space (U+0020 SPACE), followed by the value of current node's name IDL attribute, followed by the literal string ">" (U+003E GREATER-THAN SIGN).

The result of the algorithm is the string s.

It is possible that the output of this algorithm, if parsed with an HTML parser, will not return the original tree structure. Tree structures that do not roundtrip a serialize and reparse step can also be produced by the HTML parser itself, although such cases are typically non-conforming.

For instance, if a textarea element to which a Comment node has been appended is serialized and the output is then reparsed, the comment will end up being displayed in the text control. Similarly, if, as a result of DOM manipulation, an element contains a comment that contains the literal string "-->", then when the result of serializing the element is parsed, the comment will be truncated at that point and the rest of the comment will be interpreted as markup. More examples would be making a script element contain a Text node with the text string "</script>", or having a p element that contains a ul element (as the ul element's start tag would imply the end tag for the p).

This can enable cross-site scripting attacks. An example of this would be a page that lets the user enter some font family names that are then inserted into a CSS style block via the DOM and which then uses the innerHTML IDL attribute to get the HTML serialization of that style element: if the user enters "</style><script>attack</script>" as a font family name, innerHTML will return markup that, if parsed in a different context, would contain a script node, even though no script node existed in the original DOM.

For example, consider the following markup:

<form id="outer"><div></form><form id="inner"><input>
This will be parsed into:

html
head
body
form id="outer"
div
form id="inner"
input
The input element will be associated with the inner form element. Now, if this tree structure is serialized and reparsed, the <form id="inner"> start tag will be ignored, and so the input element will be associated with the outer form element instead.

<html><head></head><body><form id="outer"><div><form id="inner"><input></form></div></form></body></html>
html
head
body
form id="outer"
div
input
As another example, consider the following markup:

<a><table><a>
This will be parsed into:

html
head
body
a
a
table
That is, the a elements are nested, because the second a element is foster parented. After a serialize-reparse roundtrip, the a elements and the table element would all be siblings, because the second <a> start tag implicitly closes the first a element.

<html><head></head><body><a><a></a><table></table></a></body></html>
html
head
body
a
a
table
For historical reasons, this algorithm does not round-trip an initial U+000A LINE FEED (LF) character in pre, textarea, or listing elements, even though (in the first two cases) the markup being round-tripped can be conforming. The HTML parser will drop such a character during parsing, but this algorithm does not serialize an extra U+000A LINE FEED (LF) character.

For example, consider the following markup:

<pre>

Hello.</pre>
When this document is first parsed, the pre element's child text content starts with a single newline character. After a serialize-reparse roundtrip, the pre element's child text content is simply "Hello.".

Because of the special role of the is attribute in signaling the creation of customized built-in elements, in that it provides a mechanism for parsed HTML to set the element's is value, we special-case its handling during serialization.This ensures that an element's is value is preserved through serialize-parse roundtrips.

When creating a customized built-in element via the parser, a developer uses the is attribute directly; in such cases serialize-parse roundtrips work fine.

<script>
window.SuperP = class extends HTMLParagraphElement {};
customElements.define("super-p", SuperP, { extends: "p" });
</script>

<div id="container"><p is="super-p">Superb!</p></div>

<script>
console.log(container.innerHTML); // <p is="super-p">
container.innerHTML = container.innerHTML;
console.log(container.innerHTML); // <p is="super-p">
console.assert(container.firstChild instanceof SuperP);
</script>
But when creating a customized built-in element via its constructor or via createElement(), the is attribute is not added. Instead, the is value (which is what the custom elements machinery uses) is set without intermediating through an attribute.

<script>
container.innerHTML = "";
const p = document.createElement("p", { is: "super-p" });
container.appendChild(p);

// The is attribute is not present in the DOM:
console.assert(!p.hasAttribute("is"));

// But the element is still a super-p:
console.assert(p instanceof SuperP);
</script>
To ensure that serialize-parse roundtrips still work, the serialization process explicitly writes out the element's is value as an is attribute:

<script>
console.log(container.innerHTML); // <p is="super-p">
container.innerHTML = container.innerHTML;
console.log(container.innerHTML); // <p is="super-p">
console.assert(container.firstChild instanceof SuperP);
</script>
Escaping a string (for the purposes of the algorithm above) consists of running the following steps:

Replace any occurrence of the "&" character by the string "&amp;".

Replace any occurrences of the U+00A0 NO-BREAK SPACE character by the string "&nbsp;".

If the algorithm was invoked in the attribute mode, replace any occurrences of the """ character by the string "&quot;".

If the algorithm was not invoked in the attribute mode, replace any occurrences of the "<" character by the string "&lt;", and any occurrences of the ">" character by the string "&gt;".

12.4 Parsing HTML fragments
The following steps form the HTML fragment parsing algorithm. The algorithm takes as input an Element node, referred to as the context element, which gives the context for the parser, as well as input, a string to parse, and returns a list of zero or more nodes.

Parts marked fragment case in algorithms in the parser section are parts that only occur if the parser was created for the purposes of this algorithm. The algorithms have been annotated with such markings for informational purposes only; such markings have no normative weight. If it is possible for a condition described as a fragment case to occur even when the parser wasn't created for the purposes of handling this algorithm, then that is an error in the specification.

Create a new Document node, and mark it as being an HTML document.

If the node document of the context element is in quirks mode, then let the Document be in quirks mode. Otherwise, the node document of the context element is in limited-quirks mode, then let the Document be in limited-quirks mode. Otherwise, leave the Document in no-quirks mode.

Create a new HTML parser, and associate it with the just created Document node.

Set the state of the HTML parser's tokenization stage as follows, switching on the context element:

title
textarea
Switch the tokenizer to the RCDATA state.
style
xmp
iframe
noembed
noframes
Switch the tokenizer to the RAWTEXT state.
script
Switch the tokenizer to the script data state.
noscript
If the scripting flag is enabled, switch the tokenizer to the RAWTEXT state. Otherwise, leave the tokenizer in the data state.
plaintext
Switch the tokenizer to the PLAINTEXT state.
Any other element
Leave the tokenizer in the data state.
For performance reasons, an implementation that does not report errors and that uses the actual state machine described in this specification directly could use the PLAINTEXT state instead of the RAWTEXT and script data states where those are mentioned in the list above. Except for rules regarding parse errors, they are equivalent, since there is no appropriate end tag token in the fragment case, yet they involve far fewer state transitions.

Let root be a new html element with no attributes.

Append the element root to the Document node created above.

Set up the parser's stack of open elements so that it contains just the single element root.

If the context element is a template element, push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.

Create a start tag token whose name is the local name of context and whose attributes are the attributes of context.

Let this start tag token be the start tag token of the context node, e.g. for the purposes of determining if it is an HTML integration point.

Reset the parser's insertion mode appropriately.

The parser will reference the context element as part of that algorithm.

Set the parser's form element pointer to the nearest node to the context element that is a form element (going straight up the ancestor chain, and including the element itself, if it is a form element), if any. (If there is no such form element, the form element pointer keeps its initial value, null.)

Place the input into the input stream for the HTML parser just created. The encoding confidence is irrelevant.

Start the parser and let it run until it has consumed all the characters just inserted into the input stream.

Return the child nodes of root, in tree order.

12.5 Named character references
This table lists the character reference names that are supported by HTML, and the code points to which they refer. It is referenced by the previous sections.

Name	Character(s)	Glyph
Aacute;	U+000C1	Á
Aacute	U+000C1	Á
aacute;	U+000E1	á
aacute	U+000E1	á
Abreve;	U+00102	Ă
abreve;	U+00103	ă
ac;	U+0223E	∾
acd;	U+0223F	∿
acE;	U+0223E U+00333	∾̳
Acirc;	U+000C2	Â
Acirc	U+000C2	Â
acirc;	U+000E2	â
acirc	U+000E2	â
acute;	U+000B4	´
acute	U+000B4	´
Acy;	U+00410	А
acy;	U+00430	а
AElig;	U+000C6	Æ
AElig	U+000C6	Æ
aelig;	U+000E6	æ
aelig	U+000E6	æ
af;	U+02061	⁡
Afr;	U+1D504	𝔄
afr;	U+1D51E	𝔞
Agrave;	U+000C0	À
Agrave	U+000C0	À
agrave;	U+000E0	à
agrave	U+000E0	à
alefsym;	U+02135	ℵ
aleph;	U+02135	ℵ
Alpha;	U+00391	Α
alpha;	U+003B1	α
Amacr;	U+00100	Ā
amacr;	U+00101	ā
amalg;	U+02A3F	⨿
AMP;	U+00026	&
AMP	U+00026	&
amp;	U+00026	&
amp	U+00026	&
And;	U+02A53	⩓
and;	U+02227	∧
andand;	U+02A55	⩕
andd;	U+02A5C	⩜
andslope;	U+02A58	⩘
andv;	U+02A5A	⩚
ang;	U+02220	∠
ange;	U+029A4	⦤
angle;	U+02220	∠
angmsd;	U+02221	∡
angmsdaa;	U+029A8	⦨
angmsdab;	U+029A9	⦩
angmsdac;	U+029AA	⦪
angmsdad;	U+029AB	⦫
angmsdae;	U+029AC	⦬
angmsdaf;	U+029AD	⦭
angmsdag;	U+029AE	⦮
angmsdah;	U+029AF	⦯
angrt;	U+0221F	∟
angrtvb;	U+022BE	⊾
angrtvbd;	U+0299D	⦝
angsph;	U+02222	∢
angst;	U+000C5	Å
angzarr;	U+0237C	⍼
Aogon;	U+00104	Ą
aogon;	U+00105	ą
Aopf;	U+1D538	𝔸
aopf;	U+1D552	𝕒
ap;	U+02248	≈
apacir;	U+02A6F	⩯
apE;	U+02A70	⩰
ape;	U+0224A	≊
apid;	U+0224B	≋
apos;	U+00027	'
ApplyFunction;	U+02061	⁡
approx;	U+02248	≈
approxeq;	U+0224A	≊
Aring;	U+000C5	Å
Aring	U+000C5	Å
aring;	U+000E5	å
aring	U+000E5	å
Ascr;	U+1D49C	𝒜
ascr;	U+1D4B6	𝒶
Assign;	U+02254	≔
ast;	U+0002A	*
asymp;	U+02248	≈
asympeq;	U+0224D	≍
Atilde;	U+000C3	Ã
Atilde	U+000C3	Ã
atilde;	U+000E3	ã
atilde	U+000E3	ã
Auml;	U+000C4	Ä
Auml	U+000C4	Ä
auml;	U+000E4	ä
auml	U+000E4	ä
awconint;	U+02233	∳
awint;	U+02A11	⨑
backcong;	U+0224C	≌
backepsilon;	U+003F6	϶
backprime;	U+02035	‵
backsim;	U+0223D	∽
backsimeq;	U+022CD	⋍
Backslash;	U+02216	∖
Barv;	U+02AE7	⫧
barvee;	U+022BD	⊽
Barwed;	U+02306	⌆
barwed;	U+02305	⌅
barwedge;	U+02305	⌅
bbrk;	U+023B5	⎵
bbrktbrk;	U+023B6	⎶
bcong;	U+0224C	≌
Bcy;	U+00411	Б
bcy;	U+00431	б
bdquo;	U+0201E	„
becaus;	U+02235	∵
Because;	U+02235	∵
because;	U+02235	∵
bemptyv;	U+029B0	⦰
bepsi;	U+003F6	϶
bernou;	U+0212C	ℬ
Bernoullis;	U+0212C	ℬ
Beta;	U+00392	Β
beta;	U+003B2	β
beth;	U+02136	ℶ
between;	U+0226C	≬
Bfr;	U+1D505	𝔅
bfr;	U+1D51F	𝔟
bigcap;	U+022C2	⋂
bigcirc;	U+025EF	◯
bigcup;	U+022C3	⋃
bigodot;	U+02A00	⨀
bigoplus;	U+02A01	⨁
bigotimes;	U+02A02	⨂
bigsqcup;	U+02A06	⨆
bigstar;	U+02605	★
bigtriangledown;	U+025BD	▽
bigtriangleup;	U+025B3	△
biguplus;	U+02A04	⨄
bigvee;	U+022C1	⋁
bigwedge;	U+022C0	⋀
bkarow;	U+0290D	⤍
blacklozenge;	U+029EB	⧫
blacksquare;	U+025AA	▪
blacktriangle;	U+025B4	▴
blacktriangledown;	U+025BE	▾
blacktriangleleft;	U+025C2	◂
blacktriangleright;	U+025B8	▸
blank;	U+02423	␣
blk12;	U+02592	▒
blk14;	U+02591	░
blk34;	U+02593	▓
block;	U+02588	█
bne;	U+0003D U+020E5	=⃥
bnequiv;	U+02261 U+020E5	≡⃥
bNot;	U+02AED	⫭
bnot;	U+02310	⌐
Bopf;	U+1D539	𝔹
bopf;	U+1D553	𝕓
bot;	U+022A5	⊥
bottom;	U+022A5	⊥
bowtie;	U+022C8	⋈
boxbox;	U+029C9	⧉
boxDL;	U+02557	╗
boxDl;	U+02556	╖
boxdL;	U+02555	╕
boxdl;	U+02510	┐
boxDR;	U+02554	╔
boxDr;	U+02553	╓
boxdR;	U+02552	╒
boxdr;	U+0250C	┌
boxH;	U+02550	═
boxh;	U+02500	─
boxHD;	U+02566	╦
boxHd;	U+02564	╤
boxhD;	U+02565	╥
boxhd;	U+0252C	┬
boxHU;	U+02569	╩
boxHu;	U+02567	╧
boxhU;	U+02568	╨
boxhu;	U+02534	┴
boxminus;	U+0229F	⊟
boxplus;	U+0229E	⊞
boxtimes;	U+022A0	⊠
boxUL;	U+0255D	╝
boxUl;	U+0255C	╜
boxuL;	U+0255B	╛
boxul;	U+02518	┘
boxUR;	U+0255A	╚
boxUr;	U+02559	╙
boxuR;	U+02558	╘
boxur;	U+02514	└
boxV;	U+02551	║
boxv;	U+02502	│
boxVH;	U+0256C	╬
boxVh;	U+0256B	╫
boxvH;	U+0256A	╪
boxvh;	U+0253C	┼
boxVL;	U+02563	╣
boxVl;	U+02562	╢
boxvL;	U+02561	╡
boxvl;	U+02524	┤
boxVR;	U+02560	╠
boxVr;	U+0255F	╟
boxvR;	U+0255E	╞
boxvr;	U+0251C	├
bprime;	U+02035	‵
Breve;	U+002D8	˘
breve;	U+002D8	˘
brvbar;	U+000A6	¦
brvbar	U+000A6	¦
Bscr;	U+0212C	ℬ
bscr;	U+1D4B7	𝒷
bsemi;	U+0204F	⁏
bsim;	U+0223D	∽
bsime;	U+022CD	⋍
bsol;	U+0005C	\
bsolb;	U+029C5	⧅
bsolhsub;	U+027C8	⟈
bull;	U+02022	•
bullet;	U+02022	•
bump;	U+0224E	≎
bumpE;	U+02AAE	⪮
bumpe;	U+0224F	≏
Bumpeq;	U+0224E	≎
bumpeq;	U+0224F	≏
Cacute;	U+00106	Ć
cacute;	U+00107	ć
Cap;	U+022D2	⋒
cap;	U+02229	∩
capand;	U+02A44	⩄
capbrcup;	U+02A49	⩉
capcap;	U+02A4B	⩋
capcup;	U+02A47	⩇
capdot;	U+02A40	⩀
CapitalDifferentialD;	U+02145	ⅅ
caps;	U+02229 U+0FE00	∩︀
caret;	U+02041	⁁
caron;	U+002C7	ˇ
Cayleys;	U+0212D	ℭ
ccaps;	U+02A4D	⩍
Ccaron;	U+0010C	Č
ccaron;	U+0010D	č
Ccedil;	U+000C7	Ç
Ccedil	U+000C7	Ç
ccedil;	U+000E7	ç
ccedil	U+000E7	ç
Ccirc;	U+00108	Ĉ
ccirc;	U+00109	ĉ
Cconint;	U+02230	∰
ccups;	U+02A4C	⩌
ccupssm;	U+02A50	⩐
Cdot;	U+0010A	Ċ
cdot;	U+0010B	ċ
cedil;	U+000B8	¸
cedil	U+000B8	¸
Cedilla;	U+000B8	¸
cemptyv;	U+029B2	⦲
cent;	U+000A2	¢
cent	U+000A2	¢
CenterDot;	U+000B7	·
centerdot;	U+000B7	·
Cfr;	U+0212D	ℭ
cfr;	U+1D520	𝔠
CHcy;	U+00427	Ч
chcy;	U+00447	ч
check;	U+02713	✓
checkmark;	U+02713	✓
Chi;	U+003A7	Χ
chi;	U+003C7	χ
cir;	U+025CB	○
circ;	U+002C6	ˆ
circeq;	U+02257	≗
circlearrowleft;	U+021BA	↺
circlearrowright;	U+021BB	↻
circledast;	U+0229B	⊛
circledcirc;	U+0229A	⊚
circleddash;	U+0229D	⊝
CircleDot;	U+02299	⊙
circledR;	U+000AE	®
circledS;	U+024C8	Ⓢ
CircleMinus;	U+02296	⊖
CirclePlus;	U+02295	⊕
CircleTimes;	U+02297	⊗
cirE;	U+029C3	⧃
cire;	U+02257	≗
cirfnint;	U+02A10	⨐
cirmid;	U+02AEF	⫯
cirscir;	U+029C2	⧂
ClockwiseContourIntegral;	U+02232	∲
CloseCurlyDoubleQuote;	U+0201D	”
CloseCurlyQuote;	U+02019	’
clubs;	U+02663	♣
clubsuit;	U+02663	♣
Colon;	U+02237	∷
colon;	U+0003A	:
Colone;	U+02A74	⩴
colone;	U+02254	≔
coloneq;	U+02254	≔
comma;	U+0002C	,
commat;	U+00040	@
comp;	U+02201	∁
compfn;	U+02218	∘
complement;	U+02201	∁
complexes;	U+02102	ℂ
cong;	U+02245	≅
congdot;	U+02A6D	⩭
Congruent;	U+02261	≡
Conint;	U+0222F	∯
conint;	U+0222E	∮
ContourIntegral;	U+0222E	∮
Copf;	U+02102	ℂ
copf;	U+1D554	𝕔
coprod;	U+02210	∐
Coproduct;	U+02210	∐
COPY;	U+000A9	©
COPY	U+000A9	©
copy;	U+000A9	©
copy	U+000A9	©
copysr;	U+02117	℗
CounterClockwiseContourIntegral;	U+02233	∳
crarr;	U+021B5	↵
Cross;	U+02A2F	⨯
cross;	U+02717	✗
Cscr;	U+1D49E	𝒞
cscr;	U+1D4B8	𝒸
csub;	U+02ACF	⫏
csube;	U+02AD1	⫑
csup;	U+02AD0	⫐
csupe;	U+02AD2	⫒
ctdot;	U+022EF	⋯
cudarrl;	U+02938	⤸
cudarrr;	U+02935	⤵
cuepr;	U+022DE	⋞
cuesc;	U+022DF	⋟
cularr;	U+021B6	↶
cularrp;	U+0293D	⤽
Cup;	U+022D3	⋓
cup;	U+0222A	∪
cupbrcap;	U+02A48	⩈
CupCap;	U+0224D	≍
cupcap;	U+02A46	⩆
cupcup;	U+02A4A	⩊
cupdot;	U+0228D	⊍
cupor;	U+02A45	⩅
cups;	U+0222A U+0FE00	∪︀
curarr;	U+021B7	↷
curarrm;	U+0293C	⤼
curlyeqprec;	U+022DE	⋞
curlyeqsucc;	U+022DF	⋟
curlyvee;	U+022CE	⋎
curlywedge;	U+022CF	⋏
curren;	U+000A4	¤
curren	U+000A4	¤
curvearrowleft;	U+021B6	↶
curvearrowright;	U+021B7	↷
cuvee;	U+022CE	⋎
cuwed;	U+022CF	⋏
cwconint;	U+02232	∲
cwint;	U+02231	∱
cylcty;	U+0232D	⌭
Dagger;	U+02021	‡
dagger;	U+02020	†
daleth;	U+02138	ℸ
Darr;	U+021A1	↡
dArr;	U+021D3	⇓
darr;	U+02193	↓
dash;	U+02010	‐
Dashv;	U+02AE4	⫤
dashv;	U+022A3	⊣
dbkarow;	U+0290F	⤏
dblac;	U+002DD	˝
Dcaron;	U+0010E	Ď
dcaron;	U+0010F	ď
Dcy;	U+00414	Д
dcy;	U+00434	д
DD;	U+02145	ⅅ
dd;	U+02146	ⅆ
ddagger;	U+02021	‡
ddarr;	U+021CA	⇊
DDotrahd;	U+02911	⤑
ddotseq;	U+02A77	⩷
deg;	U+000B0	°
deg	U+000B0	°
Del;	U+02207	∇
Delta;	U+00394	Δ
delta;	U+003B4	δ
demptyv;	U+029B1	⦱
dfisht;	U+0297F	⥿
Dfr;	U+1D507	𝔇
dfr;	U+1D521	𝔡
dHar;	U+02965	⥥
dharl;	U+021C3	⇃
dharr;	U+021C2	⇂
DiacriticalAcute;	U+000B4	´
DiacriticalDot;	U+002D9	˙
DiacriticalDoubleAcute;	U+002DD	˝
DiacriticalGrave;	U+00060	`
DiacriticalTilde;	U+002DC	˜
diam;	U+022C4	⋄
Diamond;	U+022C4	⋄
diamond;	U+022C4	⋄
diamondsuit;	U+02666	♦
diams;	U+02666	♦
die;	U+000A8	¨
DifferentialD;	U+02146	ⅆ
digamma;	U+003DD	ϝ
disin;	U+022F2	⋲
div;	U+000F7	÷
divide;	U+000F7	÷
divide	U+000F7	÷
divideontimes;	U+022C7	⋇
divonx;	U+022C7	⋇
DJcy;	U+00402	Ђ
djcy;	U+00452	ђ
dlcorn;	U+0231E	⌞
dlcrop;	U+0230D	⌍
dollar;	U+00024	$
Dopf;	U+1D53B	𝔻
dopf;	U+1D555	𝕕
Dot;	U+000A8	¨
dot;	U+002D9	˙
DotDot;	U+020DC	◌⃜
doteq;	U+02250	≐
doteqdot;	U+02251	≑
DotEqual;	U+02250	≐
dotminus;	U+02238	∸
dotplus;	U+02214	∔
dotsquare;	U+022A1	⊡
doublebarwedge;	U+02306	⌆
DoubleContourIntegral;	U+0222F	∯
DoubleDot;	U+000A8	¨
DoubleDownArrow;	U+021D3	⇓
DoubleLeftArrow;	U+021D0	⇐
DoubleLeftRightArrow;	U+021D4	⇔
DoubleLeftTee;	U+02AE4	⫤
DoubleLongLeftArrow;	U+027F8	⟸
DoubleLongLeftRightArrow;	U+027FA	⟺
DoubleLongRightArrow;	U+027F9	⟹
DoubleRightArrow;	U+021D2	⇒
DoubleRightTee;	U+022A8	⊨
DoubleUpArrow;	U+021D1	⇑
DoubleUpDownArrow;	U+021D5	⇕
DoubleVerticalBar;	U+02225	∥
DownArrow;	U+02193	↓
Downarrow;	U+021D3	⇓
downarrow;	U+02193	↓
DownArrowBar;	U+02913	⤓
DownArrowUpArrow;	U+021F5	⇵
DownBreve;	U+00311	◌̑
downdownarrows;	U+021CA	⇊
downharpoonleft;	U+021C3	⇃
downharpoonright;	U+021C2	⇂
DownLeftRightVector;	U+02950	⥐
DownLeftTeeVector;	U+0295E	⥞
DownLeftVector;	U+021BD	↽
DownLeftVectorBar;	U+02956	⥖
DownRightTeeVector;	U+0295F	⥟
DownRightVector;	U+021C1	⇁
DownRightVectorBar;	U+02957	⥗
DownTee;	U+022A4	⊤
DownTeeArrow;	U+021A7	↧
drbkarow;	U+02910	⤐
drcorn;	U+0231F	⌟
drcrop;	U+0230C	⌌
Dscr;	U+1D49F	𝒟
dscr;	U+1D4B9	𝒹
DScy;	U+00405	Ѕ
dscy;	U+00455	ѕ
dsol;	U+029F6	⧶
Dstrok;	U+00110	Đ
dstrok;	U+00111	đ
dtdot;	U+022F1	⋱
dtri;	U+025BF	▿
dtrif;	U+025BE	▾
duarr;	U+021F5	⇵
duhar;	U+0296F	⥯
dwangle;	U+029A6	⦦
DZcy;	U+0040F	Џ
dzcy;	U+0045F	џ
dzigrarr;	U+027FF	⟿
Eacute;	U+000C9	É
Eacute	U+000C9	É
eacute;	U+000E9	é
eacute	U+000E9	é
easter;	U+02A6E	⩮
Ecaron;	U+0011A	Ě
ecaron;	U+0011B	ě
ecir;	U+02256	≖
Ecirc;	U+000CA	Ê
Ecirc	U+000CA	Ê
ecirc;	U+000EA	ê
ecirc	U+000EA	ê
ecolon;	U+02255	≕
Ecy;	U+0042D	Э
ecy;	U+0044D	э
eDDot;	U+02A77	⩷
Edot;	U+00116	Ė
eDot;	U+02251	≑
edot;	U+00117	ė
ee;	U+02147	ⅇ
efDot;	U+02252	≒
Efr;	U+1D508	𝔈
efr;	U+1D522	𝔢
eg;	U+02A9A	⪚
Egrave;	U+000C8	È
Egrave	U+000C8	È
egrave;	U+000E8	è
egrave	U+000E8	è
egs;	U+02A96	⪖
egsdot;	U+02A98	⪘
el;	U+02A99	⪙
Element;	U+02208	∈
elinters;	U+023E7	⏧
ell;	U+02113	ℓ
els;	U+02A95	⪕
elsdot;	U+02A97	⪗
Emacr;	U+00112	Ē
emacr;	U+00113	ē
empty;	U+02205	∅
emptyset;	U+02205	∅
EmptySmallSquare;	U+025FB	◻
emptyv;	U+02205	∅
EmptyVerySmallSquare;	U+025AB	▫
emsp;	U+02003	 
emsp13;	U+02004	 
emsp14;	U+02005	 
ENG;	U+0014A	Ŋ
eng;	U+0014B	ŋ
ensp;	U+02002	 
Eogon;	U+00118	Ę
eogon;	U+00119	ę
Eopf;	U+1D53C	𝔼
eopf;	U+1D556	𝕖
epar;	U+022D5	⋕
eparsl;	U+029E3	⧣
eplus;	U+02A71	⩱
epsi;	U+003B5	ε
Epsilon;	U+00395	Ε
epsilon;	U+003B5	ε
epsiv;	U+003F5	ϵ
eqcirc;	U+02256	≖
eqcolon;	U+02255	≕
eqsim;	U+02242	≂
eqslantgtr;	U+02A96	⪖
eqslantless;	U+02A95	⪕
Equal;	U+02A75	⩵
equals;	U+0003D	=
EqualTilde;	U+02242	≂
equest;	U+0225F	≟
Equilibrium;	U+021CC	⇌
equiv;	U+02261	≡
equivDD;	U+02A78	⩸
eqvparsl;	U+029E5	⧥
erarr;	U+02971	⥱
erDot;	U+02253	≓
Escr;	U+02130	ℰ
escr;	U+0212F	ℯ
esdot;	U+02250	≐
Esim;	U+02A73	⩳
esim;	U+02242	≂
Eta;	U+00397	Η
eta;	U+003B7	η
ETH;	U+000D0	Ð
ETH	U+000D0	Ð
eth;	U+000F0	ð
eth	U+000F0	ð
Euml;	U+000CB	Ë
Euml	U+000CB	Ë
euml;	U+000EB	ë
euml	U+000EB	ë
euro;	U+020AC	€
excl;	U+00021	!
exist;	U+02203	∃
Exists;	U+02203	∃
expectation;	U+02130	ℰ
ExponentialE;	U+02147	ⅇ
exponentiale;	U+02147	ⅇ
fallingdotseq;	U+02252	≒
Fcy;	U+00424	Ф
fcy;	U+00444	ф
female;	U+02640	♀
ffilig;	U+0FB03	ﬃ
fflig;	U+0FB00	ﬀ
ffllig;	U+0FB04	ﬄ
Ffr;	U+1D509	𝔉
ffr;	U+1D523	𝔣
filig;	U+0FB01	ﬁ
FilledSmallSquare;	U+025FC	◼
FilledVerySmallSquare;	U+025AA	▪
fjlig;	U+00066 U+0006A	fj
flat;	U+0266D	♭
fllig;	U+0FB02	ﬂ
fltns;	U+025B1	▱
fnof;	U+00192	ƒ
Fopf;	U+1D53D	𝔽
fopf;	U+1D557	𝕗
ForAll;	U+02200	∀
forall;	U+02200	∀
fork;	U+022D4	⋔
forkv;	U+02AD9	⫙
Fouriertrf;	U+02131	ℱ
fpartint;	U+02A0D	⨍
frac12;	U+000BD	½
frac12	U+000BD	½
frac13;	U+02153	⅓
frac14;	U+000BC	¼
frac14	U+000BC	¼
frac15;	U+02155	⅕
frac16;	U+02159	⅙
frac18;	U+0215B	⅛
frac23;	U+02154	⅔
frac25;	U+02156	⅖
frac34;	U+000BE	¾
frac34	U+000BE	¾
frac35;	U+02157	⅗
frac38;	U+0215C	⅜
frac45;	U+02158	⅘
frac56;	U+0215A	⅚
frac58;	U+0215D	⅝
frac78;	U+0215E	⅞
frasl;	U+02044	⁄
frown;	U+02322	⌢
Fscr;	U+02131	ℱ
fscr;	U+1D4BB	𝒻
gacute;	U+001F5	ǵ
Gamma;	U+00393	Γ
gamma;	U+003B3	γ
Gammad;	U+003DC	Ϝ
gammad;	U+003DD	ϝ
gap;	U+02A86	⪆
Gbreve;	U+0011E	Ğ
gbreve;	U+0011F	ğ
Gcedil;	U+00122	Ģ
Gcirc;	U+0011C	Ĝ
gcirc;	U+0011D	ĝ
Gcy;	U+00413	Г
gcy;	U+00433	г
Gdot;	U+00120	Ġ
gdot;	U+00121	ġ
gE;	U+02267	≧
ge;	U+02265	≥
gEl;	U+02A8C	⪌
gel;	U+022DB	⋛
geq;	U+02265	≥
geqq;	U+02267	≧
geqslant;	U+02A7E	⩾
ges;	U+02A7E	⩾
gescc;	U+02AA9	⪩
gesdot;	U+02A80	⪀
gesdoto;	U+02A82	⪂
gesdotol;	U+02A84	⪄
gesl;	U+022DB U+0FE00	⋛︀
gesles;	U+02A94	⪔
Gfr;	U+1D50A	𝔊
gfr;	U+1D524	𝔤
Gg;	U+022D9	⋙
gg;	U+0226B	≫
ggg;	U+022D9	⋙
gimel;	U+02137	ℷ
GJcy;	U+00403	Ѓ
gjcy;	U+00453	ѓ
gl;	U+02277	≷
gla;	U+02AA5	⪥
glE;	U+02A92	⪒
glj;	U+02AA4	⪤
gnap;	U+02A8A	⪊
gnapprox;	U+02A8A	⪊
gnE;	U+02269	≩
gne;	U+02A88	⪈
gneq;	U+02A88	⪈
gneqq;	U+02269	≩
gnsim;	U+022E7	⋧
Gopf;	U+1D53E	𝔾
gopf;	U+1D558	𝕘
grave;	U+00060	`
GreaterEqual;	U+02265	≥
GreaterEqualLess;	U+022DB	⋛
GreaterFullEqual;	U+02267	≧
GreaterGreater;	U+02AA2	⪢
GreaterLess;	U+02277	≷
GreaterSlantEqual;	U+02A7E	⩾
GreaterTilde;	U+02273	≳
Gscr;	U+1D4A2	𝒢
gscr;	U+0210A	ℊ
gsim;	U+02273	≳
gsime;	U+02A8E	⪎
gsiml;	U+02A90	⪐
GT;	U+0003E	>
GT	U+0003E	>
Gt;	U+0226B	≫
gt;	U+0003E	>
gt	U+0003E	>
gtcc;	U+02AA7	⪧
gtcir;	U+02A7A	⩺
gtdot;	U+022D7	⋗
gtlPar;	U+02995	⦕
gtquest;	U+02A7C	⩼
gtrapprox;	U+02A86	⪆
gtrarr;	U+02978	⥸
gtrdot;	U+022D7	⋗
gtreqless;	U+022DB	⋛
gtreqqless;	U+02A8C	⪌
gtrless;	U+02277	≷
gtrsim;	U+02273	≳
gvertneqq;	U+02269 U+0FE00	≩︀
gvnE;	U+02269 U+0FE00	≩︀
Hacek;	U+002C7	ˇ
hairsp;	U+0200A	 
half;	U+000BD	½
hamilt;	U+0210B	ℋ
HARDcy;	U+0042A	Ъ
hardcy;	U+0044A	ъ
hArr;	U+021D4	⇔
harr;	U+02194	↔
harrcir;	U+02948	⥈
harrw;	U+021AD	↭
Hat;	U+0005E	^
hbar;	U+0210F	ℏ
Hcirc;	U+00124	Ĥ
hcirc;	U+00125	ĥ
hearts;	U+02665	♥
heartsuit;	U+02665	♥
hellip;	U+02026	…
hercon;	U+022B9	⊹
Hfr;	U+0210C	ℌ
hfr;	U+1D525	𝔥
HilbertSpace;	U+0210B	ℋ
hksearow;	U+02925	⤥
hkswarow;	U+02926	⤦
hoarr;	U+021FF	⇿
homtht;	U+0223B	∻
hookleftarrow;	U+021A9	↩
hookrightarrow;	U+021AA	↪
Hopf;	U+0210D	ℍ
hopf;	U+1D559	𝕙
horbar;	U+02015	―
HorizontalLine;	U+02500	─
Hscr;	U+0210B	ℋ
hscr;	U+1D4BD	𝒽
hslash;	U+0210F	ℏ
Hstrok;	U+00126	Ħ
hstrok;	U+00127	ħ
HumpDownHump;	U+0224E	≎
HumpEqual;	U+0224F	≏
hybull;	U+02043	⁃
hyphen;	U+02010	‐
Iacute;	U+000CD	Í
Iacute	U+000CD	Í
iacute;	U+000ED	í
iacute	U+000ED	í
ic;	U+02063	⁣
Icirc;	U+000CE	Î
Icirc	U+000CE	Î
icirc;	U+000EE	î
icirc	U+000EE	î
Icy;	U+00418	И
icy;	U+00438	и
Idot;	U+00130	İ
IEcy;	U+00415	Е
iecy;	U+00435	е
iexcl;	U+000A1	¡
iexcl	U+000A1	¡
iff;	U+021D4	⇔
Ifr;	U+02111	ℑ
ifr;	U+1D526	𝔦
Igrave;	U+000CC	Ì
Igrave	U+000CC	Ì
igrave;	U+000EC	ì
igrave	U+000EC	ì
ii;	U+02148	ⅈ
iiiint;	U+02A0C	⨌
iiint;	U+0222D	∭
iinfin;	U+029DC	⧜
iiota;	U+02129	℩
IJlig;	U+00132	Ĳ
ijlig;	U+00133	ĳ
Im;	U+02111	ℑ
Imacr;	U+0012A	Ī
imacr;	U+0012B	ī
image;	U+02111	ℑ
ImaginaryI;	U+02148	ⅈ
imagline;	U+02110	ℐ
imagpart;	U+02111	ℑ
imath;	U+00131	ı
imof;	U+022B7	⊷
imped;	U+001B5	Ƶ
Implies;	U+021D2	⇒
in;	U+02208	∈
incare;	U+02105	℅
infin;	U+0221E	∞
infintie;	U+029DD	⧝
inodot;	U+00131	ı
Int;	U+0222C	∬
int;	U+0222B	∫
intcal;	U+022BA	⊺
integers;	U+02124	ℤ
Integral;	U+0222B	∫
intercal;	U+022BA	⊺
Intersection;	U+022C2	⋂
intlarhk;	U+02A17	⨗
intprod;	U+02A3C	⨼
InvisibleComma;	U+02063	⁣
InvisibleTimes;	U+02062	⁢
IOcy;	U+00401	Ё
iocy;	U+00451	ё
Iogon;	U+0012E	Į
iogon;	U+0012F	į
Iopf;	U+1D540	𝕀
iopf;	U+1D55A	𝕚
Iota;	U+00399	Ι
iota;	U+003B9	ι
iprod;	U+02A3C	⨼
iquest;	U+000BF	¿
iquest	U+000BF	¿
Iscr;	U+02110	ℐ
iscr;	U+1D4BE	𝒾
isin;	U+02208	∈
isindot;	U+022F5	⋵
isinE;	U+022F9	⋹
isins;	U+022F4	⋴
isinsv;	U+022F3	⋳
isinv;	U+02208	∈
it;	U+02062	⁢
Itilde;	U+00128	Ĩ
itilde;	U+00129	ĩ
Iukcy;	U+00406	І
iukcy;	U+00456	і
Iuml;	U+000CF	Ï
Iuml	U+000CF	Ï
iuml;	U+000EF	ï
iuml	U+000EF	ï
Jcirc;	U+00134	Ĵ
jcirc;	U+00135	ĵ
Jcy;	U+00419	Й
jcy;	U+00439	й
Jfr;	U+1D50D	𝔍
jfr;	U+1D527	𝔧
jmath;	U+00237	ȷ
Jopf;	U+1D541	𝕁
jopf;	U+1D55B	𝕛
Jscr;	U+1D4A5	𝒥
jscr;	U+1D4BF	𝒿
Jsercy;	U+00408	Ј
jsercy;	U+00458	ј
Jukcy;	U+00404	Є
jukcy;	U+00454	є
Kappa;	U+0039A	Κ
kappa;	U+003BA	κ
kappav;	U+003F0	ϰ
Kcedil;	U+00136	Ķ
kcedil;	U+00137	ķ
Kcy;	U+0041A	К
kcy;	U+0043A	к
Kfr;	U+1D50E	𝔎
kfr;	U+1D528	𝔨
kgreen;	U+00138	ĸ
KHcy;	U+00425	Х
khcy;	U+00445	х
KJcy;	U+0040C	Ќ
kjcy;	U+0045C	ќ
Kopf;	U+1D542	𝕂
kopf;	U+1D55C	𝕜
Kscr;	U+1D4A6	𝒦
kscr;	U+1D4C0	𝓀
lAarr;	U+021DA	⇚
Lacute;	U+00139	Ĺ
lacute;	U+0013A	ĺ
laemptyv;	U+029B4	⦴
lagran;	U+02112	ℒ
Lambda;	U+0039B	Λ
lambda;	U+003BB	λ
Lang;	U+027EA	⟪
lang;	U+027E8	⟨
langd;	U+02991	⦑
langle;	U+027E8	⟨
lap;	U+02A85	⪅
Laplacetrf;	U+02112	ℒ
laquo;	U+000AB	«
laquo	U+000AB	«
Larr;	U+0219E	↞
lArr;	U+021D0	⇐
larr;	U+02190	←
larrb;	U+021E4	⇤
larrbfs;	U+0291F	⤟
larrfs;	U+0291D	⤝
larrhk;	U+021A9	↩
larrlp;	U+021AB	↫
larrpl;	U+02939	⤹
larrsim;	U+02973	⥳
larrtl;	U+021A2	↢
lat;	U+02AAB	⪫
lAtail;	U+0291B	⤛
latail;	U+02919	⤙
late;	U+02AAD	⪭
lates;	U+02AAD U+0FE00	⪭︀
lBarr;	U+0290E	⤎
lbarr;	U+0290C	⤌
lbbrk;	U+02772	❲
lbrace;	U+0007B	{
lbrack;	U+0005B	[
lbrke;	U+0298B	⦋
lbrksld;	U+0298F	⦏
lbrkslu;	U+0298D	⦍
Lcaron;	U+0013D	Ľ
lcaron;	U+0013E	ľ
Lcedil;	U+0013B	Ļ
lcedil;	U+0013C	ļ
lceil;	U+02308	⌈
lcub;	U+0007B	{
Lcy;	U+0041B	Л
lcy;	U+0043B	л
ldca;	U+02936	⤶
ldquo;	U+0201C	“
ldquor;	U+0201E	„
ldrdhar;	U+02967	⥧
ldrushar;	U+0294B	⥋
ldsh;	U+021B2	↲
lE;	U+02266	≦
le;	U+02264	≤
LeftAngleBracket;	U+027E8	⟨
LeftArrow;	U+02190	←
Leftarrow;	U+021D0	⇐
leftarrow;	U+02190	←
LeftArrowBar;	U+021E4	⇤
LeftArrowRightArrow;	U+021C6	⇆
leftarrowtail;	U+021A2	↢
LeftCeiling;	U+02308	⌈
LeftDoubleBracket;	U+027E6	⟦
LeftDownTeeVector;	U+02961	⥡
LeftDownVector;	U+021C3	⇃
LeftDownVectorBar;	U+02959	⥙
LeftFloor;	U+0230A	⌊
leftharpoondown;	U+021BD	↽
leftharpoonup;	U+021BC	↼
leftleftarrows;	U+021C7	⇇
LeftRightArrow;	U+02194	↔
Leftrightarrow;	U+021D4	⇔
leftrightarrow;	U+02194	↔
leftrightarrows;	U+021C6	⇆
leftrightharpoons;	U+021CB	⇋
leftrightsquigarrow;	U+021AD	↭
LeftRightVector;	U+0294E	⥎
LeftTee;	U+022A3	⊣
LeftTeeArrow;	U+021A4	↤
LeftTeeVector;	U+0295A	⥚
leftthreetimes;	U+022CB	⋋
LeftTriangle;	U+022B2	⊲
LeftTriangleBar;	U+029CF	⧏
LeftTriangleEqual;	U+022B4	⊴
LeftUpDownVector;	U+02951	⥑
LeftUpTeeVector;	U+02960	⥠
LeftUpVector;	U+021BF	↿
LeftUpVectorBar;	U+02958	⥘
LeftVector;	U+021BC	↼
LeftVectorBar;	U+02952	⥒
lEg;	U+02A8B	⪋
leg;	U+022DA	⋚
leq;	U+02264	≤
leqq;	U+02266	≦
leqslant;	U+02A7D	⩽
les;	U+02A7D	⩽
lescc;	U+02AA8	⪨
lesdot;	U+02A7F	⩿
lesdoto;	U+02A81	⪁
lesdotor;	U+02A83	⪃
lesg;	U+022DA U+0FE00	⋚︀
lesges;	U+02A93	⪓
lessapprox;	U+02A85	⪅
lessdot;	U+022D6	⋖
lesseqgtr;	U+022DA	⋚
lesseqqgtr;	U+02A8B	⪋
LessEqualGreater;	U+022DA	⋚
LessFullEqual;	U+02266	≦
LessGreater;	U+02276	≶
lessgtr;	U+02276	≶
LessLess;	U+02AA1	⪡
lesssim;	U+02272	≲
LessSlantEqual;	U+02A7D	⩽
LessTilde;	U+02272	≲
lfisht;	U+0297C	⥼
lfloor;	U+0230A	⌊
Lfr;	U+1D50F	𝔏
lfr;	U+1D529	𝔩
lg;	U+02276	≶
lgE;	U+02A91	⪑
lHar;	U+02962	⥢
lhard;	U+021BD	↽
lharu;	U+021BC	↼
lharul;	U+0296A	⥪
lhblk;	U+02584	▄
LJcy;	U+00409	Љ
ljcy;	U+00459	љ
Ll;	U+022D8	⋘
ll;	U+0226A	≪
llarr;	U+021C7	⇇
llcorner;	U+0231E	⌞
Lleftarrow;	U+021DA	⇚
llhard;	U+0296B	⥫
lltri;	U+025FA	◺
Lmidot;	U+0013F	Ŀ
lmidot;	U+00140	ŀ
lmoust;	U+023B0	⎰
lmoustache;	U+023B0	⎰
lnap;	U+02A89	⪉
lnapprox;	U+02A89	⪉
lnE;	U+02268	≨
lne;	U+02A87	⪇
lneq;	U+02A87	⪇
lneqq;	U+02268	≨
lnsim;	U+022E6	⋦
loang;	U+027EC	⟬
loarr;	U+021FD	⇽
lobrk;	U+027E6	⟦
LongLeftArrow;	U+027F5	⟵
Longleftarrow;	U+027F8	⟸
longleftarrow;	U+027F5	⟵
LongLeftRightArrow;	U+027F7	⟷
Longleftrightarrow;	U+027FA	⟺
longleftrightarrow;	U+027F7	⟷
longmapsto;	U+027FC	⟼
LongRightArrow;	U+027F6	⟶
Longrightarrow;	U+027F9	⟹
longrightarrow;	U+027F6	⟶
looparrowleft;	U+021AB	↫
looparrowright;	U+021AC	↬
lopar;	U+02985	⦅
Lopf;	U+1D543	𝕃
lopf;	U+1D55D	𝕝
loplus;	U+02A2D	⨭
lotimes;	U+02A34	⨴
lowast;	U+02217	∗
lowbar;	U+0005F	_
LowerLeftArrow;	U+02199	↙
LowerRightArrow;	U+02198	↘
loz;	U+025CA	◊
lozenge;	U+025CA	◊
lozf;	U+029EB	⧫
lpar;	U+00028	(
lparlt;	U+02993	⦓
lrarr;	U+021C6	⇆
lrcorner;	U+0231F	⌟
lrhar;	U+021CB	⇋
lrhard;	U+0296D	⥭
lrm;	U+0200E	‎
lrtri;	U+022BF	⊿
lsaquo;	U+02039	‹
Lscr;	U+02112	ℒ
lscr;	U+1D4C1	𝓁
Lsh;	U+021B0	↰
lsh;	U+021B0	↰
lsim;	U+02272	≲
lsime;	U+02A8D	⪍
lsimg;	U+02A8F	⪏
lsqb;	U+0005B	[
lsquo;	U+02018	‘
lsquor;	U+0201A	‚
Lstrok;	U+00141	Ł
lstrok;	U+00142	ł
LT;	U+0003C	<
LT	U+0003C	<
Lt;	U+0226A	≪
lt;	U+0003C	<
lt	U+0003C	<
ltcc;	U+02AA6	⪦
ltcir;	U+02A79	⩹
ltdot;	U+022D6	⋖
lthree;	U+022CB	⋋
ltimes;	U+022C9	⋉
ltlarr;	U+02976	⥶
ltquest;	U+02A7B	⩻
ltri;	U+025C3	◃
ltrie;	U+022B4	⊴
ltrif;	U+025C2	◂
ltrPar;	U+02996	⦖
lurdshar;	U+0294A	⥊
luruhar;	U+02966	⥦
lvertneqq;	U+02268 U+0FE00	≨︀
lvnE;	U+02268 U+0FE00	≨︀
macr;	U+000AF	¯
macr	U+000AF	¯
male;	U+02642	♂
malt;	U+02720	✠
maltese;	U+02720	✠
Map;	U+02905	⤅
map;	U+021A6	↦
mapsto;	U+021A6	↦
mapstodown;	U+021A7	↧
mapstoleft;	U+021A4	↤
mapstoup;	U+021A5	↥
marker;	U+025AE	▮
mcomma;	U+02A29	⨩
Mcy;	U+0041C	М
mcy;	U+0043C	м
mdash;	U+02014	—
mDDot;	U+0223A	∺
measuredangle;	U+02221	∡
MediumSpace;	U+0205F	 
Mellintrf;	U+02133	ℳ
Mfr;	U+1D510	𝔐
mfr;	U+1D52A	𝔪
mho;	U+02127	℧
micro;	U+000B5	µ
micro	U+000B5	µ
mid;	U+02223	∣
midast;	U+0002A	*
midcir;	U+02AF0	⫰
middot;	U+000B7	·
middot	U+000B7	·
minus;	U+02212	−
minusb;	U+0229F	⊟
minusd;	U+02238	∸
minusdu;	U+02A2A	⨪
MinusPlus;	U+02213	∓
mlcp;	U+02ADB	⫛
mldr;	U+02026	…
mnplus;	U+02213	∓
models;	U+022A7	⊧
Mopf;	U+1D544	𝕄
mopf;	U+1D55E	𝕞
mp;	U+02213	∓
Mscr;	U+02133	ℳ
mscr;	U+1D4C2	𝓂
mstpos;	U+0223E	∾
Mu;	U+0039C	Μ
mu;	U+003BC	μ
multimap;	U+022B8	⊸
mumap;	U+022B8	⊸
nabla;	U+02207	∇
Nacute;	U+00143	Ń
nacute;	U+00144	ń
nang;	U+02220 U+020D2	∠⃒
nap;	U+02249	≉
napE;	U+02A70 U+00338	⩰̸
napid;	U+0224B U+00338	≋̸
napos;	U+00149	ŉ
napprox;	U+02249	≉
natur;	U+0266E	♮
natural;	U+0266E	♮
naturals;	U+02115	ℕ
nbsp;	U+000A0	 
nbsp	U+000A0	 
nbump;	U+0224E U+00338	≎̸
nbumpe;	U+0224F U+00338	≏̸
ncap;	U+02A43	⩃
Ncaron;	U+00147	Ň
ncaron;	U+00148	ň
Ncedil;	U+00145	Ņ
ncedil;	U+00146	ņ
ncong;	U+02247	≇
ncongdot;	U+02A6D U+00338	⩭̸
ncup;	U+02A42	⩂
Ncy;	U+0041D	Н
ncy;	U+0043D	н
ndash;	U+02013	–
ne;	U+02260	≠
nearhk;	U+02924	⤤
neArr;	U+021D7	⇗
nearr;	U+02197	↗
nearrow;	U+02197	↗
nedot;	U+02250 U+00338	≐̸
NegativeMediumSpace;	U+0200B	​
NegativeThickSpace;	U+0200B	​
NegativeThinSpace;	U+0200B	​
NegativeVeryThinSpace;	U+0200B	​
nequiv;	U+02262	≢
nesear;	U+02928	⤨
nesim;	U+02242 U+00338	≂̸
NestedGreaterGreater;	U+0226B	≫
NestedLessLess;	U+0226A	≪
NewLine;	U+0000A	␊
nexist;	U+02204	∄
nexists;	U+02204	∄
Nfr;	U+1D511	𝔑
nfr;	U+1D52B	𝔫
ngE;	U+02267 U+00338	≧̸
nge;	U+02271	≱
ngeq;	U+02271	≱
ngeqq;	U+02267 U+00338	≧̸
ngeqslant;	U+02A7E U+00338	⩾̸
nges;	U+02A7E U+00338	⩾̸
nGg;	U+022D9 U+00338	⋙̸
ngsim;	U+02275	≵
nGt;	U+0226B U+020D2	≫⃒
ngt;	U+0226F	≯
ngtr;	U+0226F	≯
nGtv;	U+0226B U+00338	≫̸
nhArr;	U+021CE	⇎
nharr;	U+021AE	↮
nhpar;	U+02AF2	⫲
ni;	U+0220B	∋
nis;	U+022FC	⋼
nisd;	U+022FA	⋺
niv;	U+0220B	∋
NJcy;	U+0040A	Њ
njcy;	U+0045A	њ
nlArr;	U+021CD	⇍
nlarr;	U+0219A	↚
nldr;	U+02025	‥
nlE;	U+02266 U+00338	≦̸
nle;	U+02270	≰
nLeftarrow;	U+021CD	⇍
nleftarrow;	U+0219A	↚
nLeftrightarrow;	U+021CE	⇎
nleftrightarrow;	U+021AE	↮
nleq;	U+02270	≰
nleqq;	U+02266 U+00338	≦̸
nleqslant;	U+02A7D U+00338	⩽̸
nles;	U+02A7D U+00338	⩽̸
nless;	U+0226E	≮
nLl;	U+022D8 U+00338	⋘̸
nlsim;	U+02274	≴
nLt;	U+0226A U+020D2	≪⃒
nlt;	U+0226E	≮
nltri;	U+022EA	⋪
nltrie;	U+022EC	⋬
nLtv;	U+0226A U+00338	≪̸
nmid;	U+02224	∤
NoBreak;	U+02060	⁠
NonBreakingSpace;	U+000A0	 
Nopf;	U+02115	ℕ
nopf;	U+1D55F	𝕟
Not;	U+02AEC	⫬
not;	U+000AC	¬
not	U+000AC	¬
NotCongruent;	U+02262	≢
NotCupCap;	U+0226D	≭
NotDoubleVerticalBar;	U+02226	∦
NotElement;	U+02209	∉
NotEqual;	U+02260	≠
NotEqualTilde;	U+02242 U+00338	≂̸
NotExists;	U+02204	∄
NotGreater;	U+0226F	≯
NotGreaterEqual;	U+02271	≱
NotGreaterFullEqual;	U+02267 U+00338	≧̸
NotGreaterGreater;	U+0226B U+00338	≫̸
NotGreaterLess;	U+02279	≹
NotGreaterSlantEqual;	U+02A7E U+00338	⩾̸
NotGreaterTilde;	U+02275	≵
NotHumpDownHump;	U+0224E U+00338	≎̸
NotHumpEqual;	U+0224F U+00338	≏̸
notin;	U+02209	∉
notindot;	U+022F5 U+00338	⋵̸
notinE;	U+022F9 U+00338	⋹̸
notinva;	U+02209	∉
notinvb;	U+022F7	⋷
notinvc;	U+022F6	⋶
NotLeftTriangle;	U+022EA	⋪
NotLeftTriangleBar;	U+029CF U+00338	⧏̸
NotLeftTriangleEqual;	U+022EC	⋬
NotLess;	U+0226E	≮
NotLessEqual;	U+02270	≰
NotLessGreater;	U+02278	≸
NotLessLess;	U+0226A U+00338	≪̸
NotLessSlantEqual;	U+02A7D U+00338	⩽̸
NotLessTilde;	U+02274	≴
NotNestedGreaterGreater;	U+02AA2 U+00338	⪢̸
NotNestedLessLess;	U+02AA1 U+00338	⪡̸
notni;	U+0220C	∌
notniva;	U+0220C	∌
notnivb;	U+022FE	⋾
notnivc;	U+022FD	⋽
NotPrecedes;	U+02280	⊀
NotPrecedesEqual;	U+02AAF U+00338	⪯̸
NotPrecedesSlantEqual;	U+022E0	⋠
NotReverseElement;	U+0220C	∌
NotRightTriangle;	U+022EB	⋫
NotRightTriangleBar;	U+029D0 U+00338	⧐̸
NotRightTriangleEqual;	U+022ED	⋭
NotSquareSubset;	U+0228F U+00338	⊏̸
NotSquareSubsetEqual;	U+022E2	⋢
NotSquareSuperset;	U+02290 U+00338	⊐̸
NotSquareSupersetEqual;	U+022E3	⋣
NotSubset;	U+02282 U+020D2	⊂⃒
NotSubsetEqual;	U+02288	⊈
NotSucceeds;	U+02281	⊁
NotSucceedsEqual;	U+02AB0 U+00338	⪰̸
NotSucceedsSlantEqual;	U+022E1	⋡
NotSucceedsTilde;	U+0227F U+00338	≿̸
NotSuperset;	U+02283 U+020D2	⊃⃒
NotSupersetEqual;	U+02289	⊉
NotTilde;	U+02241	≁
NotTildeEqual;	U+02244	≄
NotTildeFullEqual;	U+02247	≇
NotTildeTilde;	U+02249	≉
NotVerticalBar;	U+02224	∤
npar;	U+02226	∦
nparallel;	U+02226	∦
nparsl;	U+02AFD U+020E5	⫽⃥
npart;	U+02202 U+00338	∂̸
npolint;	U+02A14	⨔
npr;	U+02280	⊀
nprcue;	U+022E0	⋠
npre;	U+02AAF U+00338	⪯̸
nprec;	U+02280	⊀
npreceq;	U+02AAF U+00338	⪯̸
nrArr;	U+021CF	⇏
nrarr;	U+0219B	↛
nrarrc;	U+02933 U+00338	⤳̸
nrarrw;	U+0219D U+00338	↝̸
nRightarrow;	U+021CF	⇏
nrightarrow;	U+0219B	↛
nrtri;	U+022EB	⋫
nrtrie;	U+022ED	⋭
nsc;	U+02281	⊁
nsccue;	U+022E1	⋡
nsce;	U+02AB0 U+00338	⪰̸
Nscr;	U+1D4A9	𝒩
nscr;	U+1D4C3	𝓃
nshortmid;	U+02224	∤
nshortparallel;	U+02226	∦
nsim;	U+02241	≁
nsime;	U+02244	≄
nsimeq;	U+02244	≄
nsmid;	U+02224	∤
nspar;	U+02226	∦
nsqsube;	U+022E2	⋢
nsqsupe;	U+022E3	⋣
nsub;	U+02284	⊄
nsubE;	U+02AC5 U+00338	⫅̸
nsube;	U+02288	⊈
nsubset;	U+02282 U+020D2	⊂⃒
nsubseteq;	U+02288	⊈
nsubseteqq;	U+02AC5 U+00338	⫅̸
nsucc;	U+02281	⊁
nsucceq;	U+02AB0 U+00338	⪰̸
nsup;	U+02285	⊅
nsupE;	U+02AC6 U+00338	⫆̸
nsupe;	U+02289	⊉
nsupset;	U+02283 U+020D2	⊃⃒
nsupseteq;	U+02289	⊉
nsupseteqq;	U+02AC6 U+00338	⫆̸
ntgl;	U+02279	≹
Ntilde;	U+000D1	Ñ
Ntilde	U+000D1	Ñ
ntilde;	U+000F1	ñ
ntilde	U+000F1	ñ
ntlg;	U+02278	≸
ntriangleleft;	U+022EA	⋪
ntrianglelefteq;	U+022EC	⋬
ntriangleright;	U+022EB	⋫
ntrianglerighteq;	U+022ED	⋭
Nu;	U+0039D	Ν
nu;	U+003BD	ν
num;	U+00023	#
numero;	U+02116	№
numsp;	U+02007	 
nvap;	U+0224D U+020D2	≍⃒
nVDash;	U+022AF	⊯
nVdash;	U+022AE	⊮
nvDash;	U+022AD	⊭
nvdash;	U+022AC	⊬
nvge;	U+02265 U+020D2	≥⃒
nvgt;	U+0003E U+020D2	>⃒
nvHarr;	U+02904	⤄
nvinfin;	U+029DE	⧞
nvlArr;	U+02902	⤂
nvle;	U+02264 U+020D2	≤⃒
nvlt;	U+0003C U+020D2	<⃒
nvltrie;	U+022B4 U+020D2	⊴⃒
nvrArr;	U+02903	⤃
nvrtrie;	U+022B5 U+020D2	⊵⃒
nvsim;	U+0223C U+020D2	∼⃒
nwarhk;	U+02923	⤣
nwArr;	U+021D6	⇖
nwarr;	U+02196	↖
nwarrow;	U+02196	↖
nwnear;	U+02927	⤧
Oacute;	U+000D3	Ó
Oacute	U+000D3	Ó
oacute;	U+000F3	ó
oacute	U+000F3	ó
oast;	U+0229B	⊛
ocir;	U+0229A	⊚
Ocirc;	U+000D4	Ô
Ocirc	U+000D4	Ô
ocirc;	U+000F4	ô
ocirc	U+000F4	ô
Ocy;	U+0041E	О
ocy;	U+0043E	о
odash;	U+0229D	⊝
Odblac;	U+00150	Ő
odblac;	U+00151	ő
odiv;	U+02A38	⨸
odot;	U+02299	⊙
odsold;	U+029BC	⦼
OElig;	U+00152	Œ
oelig;	U+00153	œ
ofcir;	U+029BF	⦿
Ofr;	U+1D512	𝔒
ofr;	U+1D52C	𝔬
ogon;	U+002DB	˛
Ograve;	U+000D2	Ò
Ograve	U+000D2	Ò
ograve;	U+000F2	ò
ograve	U+000F2	ò
ogt;	U+029C1	⧁
ohbar;	U+029B5	⦵
ohm;	U+003A9	Ω
oint;	U+0222E	∮
olarr;	U+021BA	↺
olcir;	U+029BE	⦾
olcross;	U+029BB	⦻
oline;	U+0203E	‾
olt;	U+029C0	⧀
Omacr;	U+0014C	Ō
omacr;	U+0014D	ō
Omega;	U+003A9	Ω
omega;	U+003C9	ω
Omicron;	U+0039F	Ο
omicron;	U+003BF	ο
omid;	U+029B6	⦶
ominus;	U+02296	⊖
Oopf;	U+1D546	𝕆
oopf;	U+1D560	𝕠
opar;	U+029B7	⦷
OpenCurlyDoubleQuote;	U+0201C	“
OpenCurlyQuote;	U+02018	‘
operp;	U+029B9	⦹
oplus;	U+02295	⊕
Or;	U+02A54	⩔
or;	U+02228	∨
orarr;	U+021BB	↻
ord;	U+02A5D	⩝
order;	U+02134	ℴ
orderof;	U+02134	ℴ
ordf;	U+000AA	ª
ordf	U+000AA	ª
ordm;	U+000BA	º
ordm	U+000BA	º
origof;	U+022B6	⊶
oror;	U+02A56	⩖
orslope;	U+02A57	⩗
orv;	U+02A5B	⩛
oS;	U+024C8	Ⓢ
Oscr;	U+1D4AA	𝒪
oscr;	U+02134	ℴ
Oslash;	U+000D8	Ø
Oslash	U+000D8	Ø
oslash;	U+000F8	ø
oslash	U+000F8	ø
osol;	U+02298	⊘
Otilde;	U+000D5	Õ
Otilde	U+000D5	Õ
otilde;	U+000F5	õ
otilde	U+000F5	õ
Otimes;	U+02A37	⨷
otimes;	U+02297	⊗
otimesas;	U+02A36	⨶
Ouml;	U+000D6	Ö
Ouml	U+000D6	Ö
ouml;	U+000F6	ö
ouml	U+000F6	ö
ovbar;	U+0233D	⌽
OverBar;	U+0203E	‾
OverBrace;	U+023DE	⏞
OverBracket;	U+023B4	⎴
OverParenthesis;	U+023DC	⏜
par;	U+02225	∥
para;	U+000B6	¶
para	U+000B6	¶
parallel;	U+02225	∥
parsim;	U+02AF3	⫳
parsl;	U+02AFD	⫽
part;	U+02202	∂
PartialD;	U+02202	∂
Pcy;	U+0041F	П
pcy;	U+0043F	п
percnt;	U+00025	%
period;	U+0002E	.
permil;	U+02030	‰
perp;	U+022A5	⊥
pertenk;	U+02031	‱
Pfr;	U+1D513	𝔓
pfr;	U+1D52D	𝔭
Phi;	U+003A6	Φ
phi;	U+003C6	φ
phiv;	U+003D5	ϕ
phmmat;	U+02133	ℳ
phone;	U+0260E	☎
Pi;	U+003A0	Π
pi;	U+003C0	π
pitchfork;	U+022D4	⋔
piv;	U+003D6	ϖ
planck;	U+0210F	ℏ
planckh;	U+0210E	ℎ
plankv;	U+0210F	ℏ
plus;	U+0002B	+
plusacir;	U+02A23	⨣
plusb;	U+0229E	⊞
pluscir;	U+02A22	⨢
plusdo;	U+02214	∔
plusdu;	U+02A25	⨥
pluse;	U+02A72	⩲
PlusMinus;	U+000B1	±
plusmn;	U+000B1	±
plusmn	U+000B1	±
plussim;	U+02A26	⨦
plustwo;	U+02A27	⨧
pm;	U+000B1	±
Poincareplane;	U+0210C	ℌ
pointint;	U+02A15	⨕
Popf;	U+02119	ℙ
popf;	U+1D561	𝕡
pound;	U+000A3	£
pound	U+000A3	£
Pr;	U+02ABB	⪻
pr;	U+0227A	≺
prap;	U+02AB7	⪷
prcue;	U+0227C	≼
prE;	U+02AB3	⪳
pre;	U+02AAF	⪯
prec;	U+0227A	≺
precapprox;	U+02AB7	⪷
preccurlyeq;	U+0227C	≼
Precedes;	U+0227A	≺
PrecedesEqual;	U+02AAF	⪯
PrecedesSlantEqual;	U+0227C	≼
PrecedesTilde;	U+0227E	≾
preceq;	U+02AAF	⪯
precnapprox;	U+02AB9	⪹
precneqq;	U+02AB5	⪵
precnsim;	U+022E8	⋨
precsim;	U+0227E	≾
Prime;	U+02033	″
prime;	U+02032	′
primes;	U+02119	ℙ
prnap;	U+02AB9	⪹
prnE;	U+02AB5	⪵
prnsim;	U+022E8	⋨
prod;	U+0220F	∏
Product;	U+0220F	∏
profalar;	U+0232E	⌮
profline;	U+02312	⌒
profsurf;	U+02313	⌓
prop;	U+0221D	∝
Proportion;	U+02237	∷
Proportional;	U+0221D	∝
propto;	U+0221D	∝
prsim;	U+0227E	≾
prurel;	U+022B0	⊰
Pscr;	U+1D4AB	𝒫
pscr;	U+1D4C5	𝓅
Psi;	U+003A8	Ψ
psi;	U+003C8	ψ
puncsp;	U+02008	 
Qfr;	U+1D514	𝔔
qfr;	U+1D52E	𝔮
qint;	U+02A0C	⨌
Qopf;	U+0211A	ℚ
qopf;	U+1D562	𝕢
qprime;	U+02057	⁗
Qscr;	U+1D4AC	𝒬
qscr;	U+1D4C6	𝓆
quaternions;	U+0210D	ℍ
quatint;	U+02A16	⨖
quest;	U+0003F	?
questeq;	U+0225F	≟
QUOT;	U+00022	"
QUOT	U+00022	"
quot;	U+00022	"
quot	U+00022	"
rAarr;	U+021DB	⇛
race;	U+0223D U+00331	∽̱
Racute;	U+00154	Ŕ
racute;	U+00155	ŕ
radic;	U+0221A	√
raemptyv;	U+029B3	⦳
Rang;	U+027EB	⟫
rang;	U+027E9	⟩
rangd;	U+02992	⦒
range;	U+029A5	⦥
rangle;	U+027E9	⟩
raquo;	U+000BB	»
raquo	U+000BB	»
Rarr;	U+021A0	↠
rArr;	U+021D2	⇒
rarr;	U+02192	→
rarrap;	U+02975	⥵
rarrb;	U+021E5	⇥
rarrbfs;	U+02920	⤠
rarrc;	U+02933	⤳
rarrfs;	U+0291E	⤞
rarrhk;	U+021AA	↪
rarrlp;	U+021AC	↬
rarrpl;	U+02945	⥅
rarrsim;	U+02974	⥴
Rarrtl;	U+02916	⤖
rarrtl;	U+021A3	↣
rarrw;	U+0219D	↝
rAtail;	U+0291C	⤜
ratail;	U+0291A	⤚
ratio;	U+02236	∶
rationals;	U+0211A	ℚ
RBarr;	U+02910	⤐
rBarr;	U+0290F	⤏
rbarr;	U+0290D	⤍
rbbrk;	U+02773	❳
rbrace;	U+0007D	}
rbrack;	U+0005D	]
rbrke;	U+0298C	⦌
rbrksld;	U+0298E	⦎
rbrkslu;	U+02990	⦐
Rcaron;	U+00158	Ř
rcaron;	U+00159	ř
Rcedil;	U+00156	Ŗ
rcedil;	U+00157	ŗ
rceil;	U+02309	⌉
rcub;	U+0007D	}
Rcy;	U+00420	Р
rcy;	U+00440	р
rdca;	U+02937	⤷
rdldhar;	U+02969	⥩
rdquo;	U+0201D	”
rdquor;	U+0201D	”
rdsh;	U+021B3	↳
Re;	U+0211C	ℜ
real;	U+0211C	ℜ
realine;	U+0211B	ℛ
realpart;	U+0211C	ℜ
reals;	U+0211D	ℝ
rect;	U+025AD	▭
REG;	U+000AE	®
REG	U+000AE	®
reg;	U+000AE	®
reg	U+000AE	®
ReverseElement;	U+0220B	∋
ReverseEquilibrium;	U+021CB	⇋
ReverseUpEquilibrium;	U+0296F	⥯
rfisht;	U+0297D	⥽
rfloor;	U+0230B	⌋
Rfr;	U+0211C	ℜ
rfr;	U+1D52F	𝔯
rHar;	U+02964	⥤
rhard;	U+021C1	⇁
rharu;	U+021C0	⇀
rharul;	U+0296C	⥬
Rho;	U+003A1	Ρ
rho;	U+003C1	ρ
rhov;	U+003F1	ϱ
RightAngleBracket;	U+027E9	⟩
RightArrow;	U+02192	→
Rightarrow;	U+021D2	⇒
rightarrow;	U+02192	→
RightArrowBar;	U+021E5	⇥
RightArrowLeftArrow;	U+021C4	⇄
rightarrowtail;	U+021A3	↣
RightCeiling;	U+02309	⌉
RightDoubleBracket;	U+027E7	⟧
RightDownTeeVector;	U+0295D	⥝
RightDownVector;	U+021C2	⇂
RightDownVectorBar;	U+02955	⥕
RightFloor;	U+0230B	⌋
rightharpoondown;	U+021C1	⇁
rightharpoonup;	U+021C0	⇀
rightleftarrows;	U+021C4	⇄
rightleftharpoons;	U+021CC	⇌
rightrightarrows;	U+021C9	⇉
rightsquigarrow;	U+0219D	↝
RightTee;	U+022A2	⊢
RightTeeArrow;	U+021A6	↦
RightTeeVector;	U+0295B	⥛
rightthreetimes;	U+022CC	⋌
RightTriangle;	U+022B3	⊳
RightTriangleBar;	U+029D0	⧐
RightTriangleEqual;	U+022B5	⊵
RightUpDownVector;	U+0294F	⥏
RightUpTeeVector;	U+0295C	⥜
RightUpVector;	U+021BE	↾
RightUpVectorBar;	U+02954	⥔
RightVector;	U+021C0	⇀
RightVectorBar;	U+02953	⥓
ring;	U+002DA	˚
risingdotseq;	U+02253	≓
rlarr;	U+021C4	⇄
rlhar;	U+021CC	⇌
rlm;	U+0200F	‏
rmoust;	U+023B1	⎱
rmoustache;	U+023B1	⎱
rnmid;	U+02AEE	⫮
roang;	U+027ED	⟭
roarr;	U+021FE	⇾
robrk;	U+027E7	⟧
ropar;	U+02986	⦆
Ropf;	U+0211D	ℝ
ropf;	U+1D563	𝕣
roplus;	U+02A2E	⨮
rotimes;	U+02A35	⨵
RoundImplies;	U+02970	⥰
rpar;	U+00029	)
rpargt;	U+02994	⦔
rppolint;	U+02A12	⨒
rrarr;	U+021C9	⇉
Rrightarrow;	U+021DB	⇛
rsaquo;	U+0203A	›
Rscr;	U+0211B	ℛ
rscr;	U+1D4C7	𝓇
Rsh;	U+021B1	↱
rsh;	U+021B1	↱
rsqb;	U+0005D	]
rsquo;	U+02019	’
rsquor;	U+02019	’
rthree;	U+022CC	⋌
rtimes;	U+022CA	⋊
rtri;	U+025B9	▹
rtrie;	U+022B5	⊵
rtrif;	U+025B8	▸
rtriltri;	U+029CE	⧎
RuleDelayed;	U+029F4	⧴
ruluhar;	U+02968	⥨
rx;	U+0211E	℞
Sacute;	U+0015A	Ś
sacute;	U+0015B	ś
sbquo;	U+0201A	‚
Sc;	U+02ABC	⪼
sc;	U+0227B	≻
scap;	U+02AB8	⪸
Scaron;	U+00160	Š
scaron;	U+00161	š
sccue;	U+0227D	≽
scE;	U+02AB4	⪴
sce;	U+02AB0	⪰
Scedil;	U+0015E	Ş
scedil;	U+0015F	ş
Scirc;	U+0015C	Ŝ
scirc;	U+0015D	ŝ
scnap;	U+02ABA	⪺
scnE;	U+02AB6	⪶
scnsim;	U+022E9	⋩
scpolint;	U+02A13	⨓
scsim;	U+0227F	≿
Scy;	U+00421	С
scy;	U+00441	с
sdot;	U+022C5	⋅
sdotb;	U+022A1	⊡
sdote;	U+02A66	⩦
searhk;	U+02925	⤥
seArr;	U+021D8	⇘
searr;	U+02198	↘
searrow;	U+02198	↘
sect;	U+000A7	§
sect	U+000A7	§
semi;	U+0003B	;
seswar;	U+02929	⤩
setminus;	U+02216	∖
setmn;	U+02216	∖
sext;	U+02736	✶
Sfr;	U+1D516	𝔖
sfr;	U+1D530	𝔰
sfrown;	U+02322	⌢
sharp;	U+0266F	♯
SHCHcy;	U+00429	Щ
shchcy;	U+00449	щ
SHcy;	U+00428	Ш
shcy;	U+00448	ш
ShortDownArrow;	U+02193	↓
ShortLeftArrow;	U+02190	←
shortmid;	U+02223	∣
shortparallel;	U+02225	∥
ShortRightArrow;	U+02192	→
ShortUpArrow;	U+02191	↑
shy;	U+000AD
shy	U+000AD
Sigma;	U+003A3	Σ
sigma;	U+003C3	σ
sigmaf;	U+003C2	ς
sigmav;	U+003C2	ς
sim;	U+0223C	∼
simdot;	U+02A6A	⩪
sime;	U+02243	≃
simeq;	U+02243	≃
simg;	U+02A9E	⪞
simgE;	U+02AA0	⪠
siml;	U+02A9D	⪝
simlE;	U+02A9F	⪟
simne;	U+02246	≆
simplus;	U+02A24	⨤
simrarr;	U+02972	⥲
slarr;	U+02190	←
SmallCircle;	U+02218	∘
smallsetminus;	U+02216	∖
smashp;	U+02A33	⨳
smeparsl;	U+029E4	⧤
smid;	U+02223	∣
smile;	U+02323	⌣
smt;	U+02AAA	⪪
smte;	U+02AAC	⪬
smtes;	U+02AAC U+0FE00	⪬︀
SOFTcy;	U+0042C	Ь
softcy;	U+0044C	ь
sol;	U+0002F	/
solb;	U+029C4	⧄
solbar;	U+0233F	⌿
Sopf;	U+1D54A	𝕊
sopf;	U+1D564	𝕤
spades;	U+02660	♠
spadesuit;	U+02660	♠
spar;	U+02225	∥
sqcap;	U+02293	⊓
sqcaps;	U+02293 U+0FE00	⊓︀
sqcup;	U+02294	⊔
sqcups;	U+02294 U+0FE00	⊔︀
Sqrt;	U+0221A	√
sqsub;	U+0228F	⊏
sqsube;	U+02291	⊑
sqsubset;	U+0228F	⊏
sqsubseteq;	U+02291	⊑
sqsup;	U+02290	⊐
sqsupe;	U+02292	⊒
sqsupset;	U+02290	⊐
sqsupseteq;	U+02292	⊒
squ;	U+025A1	□
Square;	U+025A1	□
square;	U+025A1	□
SquareIntersection;	U+02293	⊓
SquareSubset;	U+0228F	⊏
SquareSubsetEqual;	U+02291	⊑
SquareSuperset;	U+02290	⊐
SquareSupersetEqual;	U+02292	⊒
SquareUnion;	U+02294	⊔
squarf;	U+025AA	▪
squf;	U+025AA	▪
srarr;	U+02192	→
Sscr;	U+1D4AE	𝒮
sscr;	U+1D4C8	𝓈
ssetmn;	U+02216	∖
ssmile;	U+02323	⌣
sstarf;	U+022C6	⋆
Star;	U+022C6	⋆
star;	U+02606	☆
starf;	U+02605	★
straightepsilon;	U+003F5	ϵ
straightphi;	U+003D5	ϕ
strns;	U+000AF	¯
Sub;	U+022D0	⋐
sub;	U+02282	⊂
subdot;	U+02ABD	⪽
subE;	U+02AC5	⫅
sube;	U+02286	⊆
subedot;	U+02AC3	⫃
submult;	U+02AC1	⫁
subnE;	U+02ACB	⫋
subne;	U+0228A	⊊
subplus;	U+02ABF	⪿
subrarr;	U+02979	⥹
Subset;	U+022D0	⋐
subset;	U+02282	⊂
subseteq;	U+02286	⊆
subseteqq;	U+02AC5	⫅
SubsetEqual;	U+02286	⊆
subsetneq;	U+0228A	⊊
subsetneqq;	U+02ACB	⫋
subsim;	U+02AC7	⫇
subsub;	U+02AD5	⫕
subsup;	U+02AD3	⫓
succ;	U+0227B	≻
succapprox;	U+02AB8	⪸
succcurlyeq;	U+0227D	≽
Succeeds;	U+0227B	≻
SucceedsEqual;	U+02AB0	⪰
SucceedsSlantEqual;	U+0227D	≽
SucceedsTilde;	U+0227F	≿
succeq;	U+02AB0	⪰
succnapprox;	U+02ABA	⪺
succneqq;	U+02AB6	⪶
succnsim;	U+022E9	⋩
succsim;	U+0227F	≿
SuchThat;	U+0220B	∋
Sum;	U+02211	∑
sum;	U+02211	∑
sung;	U+0266A	♪
Sup;	U+022D1	⋑
sup;	U+02283	⊃
sup1;	U+000B9	¹
sup1	U+000B9	¹
sup2;	U+000B2	²
sup2	U+000B2	²
sup3;	U+000B3	³
sup3	U+000B3	³
supdot;	U+02ABE	⪾
supdsub;	U+02AD8	⫘
supE;	U+02AC6	⫆
supe;	U+02287	⊇
supedot;	U+02AC4	⫄
Superset;	U+02283	⊃
SupersetEqual;	U+02287	⊇
suphsol;	U+027C9	⟉
suphsub;	U+02AD7	⫗
suplarr;	U+0297B	⥻
supmult;	U+02AC2	⫂
supnE;	U+02ACC	⫌
supne;	U+0228B	⊋
supplus;	U+02AC0	⫀
Supset;	U+022D1	⋑
supset;	U+02283	⊃
supseteq;	U+02287	⊇
supseteqq;	U+02AC6	⫆
supsetneq;	U+0228B	⊋
supsetneqq;	U+02ACC	⫌
supsim;	U+02AC8	⫈
supsub;	U+02AD4	⫔
supsup;	U+02AD6	⫖
swarhk;	U+02926	⤦
swArr;	U+021D9	⇙
swarr;	U+02199	↙
swarrow;	U+02199	↙
swnwar;	U+0292A	⤪
szlig;	U+000DF	ß
szlig	U+000DF	ß
Tab;	U+00009	␉
target;	U+02316	⌖
Tau;	U+003A4	Τ
tau;	U+003C4	τ
tbrk;	U+023B4	⎴
Tcaron;	U+00164	Ť
tcaron;	U+00165	ť
Tcedil;	U+00162	Ţ
tcedil;	U+00163	ţ
Tcy;	U+00422	Т
tcy;	U+00442	т
tdot;	U+020DB	◌⃛
telrec;	U+02315	⌕
Tfr;	U+1D517	𝔗
tfr;	U+1D531	𝔱
there4;	U+02234	∴
Therefore;	U+02234	∴
therefore;	U+02234	∴
Theta;	U+00398	Θ
theta;	U+003B8	θ
thetasym;	U+003D1	ϑ
thetav;	U+003D1	ϑ
thickapprox;	U+02248	≈
thicksim;	U+0223C	∼
ThickSpace;	U+0205F U+0200A	  
thinsp;	U+02009	 
ThinSpace;	U+02009	 
thkap;	U+02248	≈
thksim;	U+0223C	∼
THORN;	U+000DE	Þ
THORN	U+000DE	Þ
thorn;	U+000FE	þ
thorn	U+000FE	þ
Tilde;	U+0223C	∼
tilde;	U+002DC	˜
TildeEqual;	U+02243	≃
TildeFullEqual;	U+02245	≅
TildeTilde;	U+02248	≈
times;	U+000D7	×
times	U+000D7	×
timesb;	U+022A0	⊠
timesbar;	U+02A31	⨱
timesd;	U+02A30	⨰
tint;	U+0222D	∭
toea;	U+02928	⤨
top;	U+022A4	⊤
topbot;	U+02336	⌶
topcir;	U+02AF1	⫱
Topf;	U+1D54B	𝕋
topf;	U+1D565	𝕥
topfork;	U+02ADA	⫚
tosa;	U+02929	⤩
tprime;	U+02034	‴
TRADE;	U+02122	™
trade;	U+02122	™
triangle;	U+025B5	▵
triangledown;	U+025BF	▿
triangleleft;	U+025C3	◃
trianglelefteq;	U+022B4	⊴
triangleq;	U+0225C	≜
triangleright;	U+025B9	▹
trianglerighteq;	U+022B5	⊵
tridot;	U+025EC	◬
trie;	U+0225C	≜
triminus;	U+02A3A	⨺
TripleDot;	U+020DB	◌⃛
triplus;	U+02A39	⨹
trisb;	U+029CD	⧍
tritime;	U+02A3B	⨻
trpezium;	U+023E2	⏢
Tscr;	U+1D4AF	𝒯
tscr;	U+1D4C9	𝓉
TScy;	U+00426	Ц
tscy;	U+00446	ц
TSHcy;	U+0040B	Ћ
tshcy;	U+0045B	ћ
Tstrok;	U+00166	Ŧ
tstrok;	U+00167	ŧ
twixt;	U+0226C	≬
twoheadleftarrow;	U+0219E	↞
twoheadrightarrow;	U+021A0	↠
Uacute;	U+000DA	Ú
Uacute	U+000DA	Ú
uacute;	U+000FA	ú
uacute	U+000FA	ú
Uarr;	U+0219F	↟
uArr;	U+021D1	⇑
uarr;	U+02191	↑
Uarrocir;	U+02949	⥉
Ubrcy;	U+0040E	Ў
ubrcy;	U+0045E	ў
Ubreve;	U+0016C	Ŭ
ubreve;	U+0016D	ŭ
Ucirc;	U+000DB	Û
Ucirc	U+000DB	Û
ucirc;	U+000FB	û
ucirc	U+000FB	û
Ucy;	U+00423	У
ucy;	U+00443	у
udarr;	U+021C5	⇅
Udblac;	U+00170	Ű
udblac;	U+00171	ű
udhar;	U+0296E	⥮
ufisht;	U+0297E	⥾
Ufr;	U+1D518	𝔘
ufr;	U+1D532	𝔲
Ugrave;	U+000D9	Ù
Ugrave	U+000D9	Ù
ugrave;	U+000F9	ù
ugrave	U+000F9	ù
uHar;	U+02963	⥣
uharl;	U+021BF	↿
uharr;	U+021BE	↾
uhblk;	U+02580	▀
ulcorn;	U+0231C	⌜
ulcorner;	U+0231C	⌜
ulcrop;	U+0230F	⌏
ultri;	U+025F8	◸
Umacr;	U+0016A	Ū
umacr;	U+0016B	ū
uml;	U+000A8	¨
uml	U+000A8	¨
UnderBar;	U+0005F	_
UnderBrace;	U+023DF	⏟
UnderBracket;	U+023B5	⎵
UnderParenthesis;	U+023DD	⏝
Union;	U+022C3	⋃
UnionPlus;	U+0228E	⊎
Uogon;	U+00172	Ų
uogon;	U+00173	ų
Uopf;	U+1D54C	𝕌
uopf;	U+1D566	𝕦
UpArrow;	U+02191	↑
Uparrow;	U+021D1	⇑
uparrow;	U+02191	↑
UpArrowBar;	U+02912	⤒
UpArrowDownArrow;	U+021C5	⇅
UpDownArrow;	U+02195	↕
Updownarrow;	U+021D5	⇕
updownarrow;	U+02195	↕
UpEquilibrium;	U+0296E	⥮
upharpoonleft;	U+021BF	↿
upharpoonright;	U+021BE	↾
uplus;	U+0228E	⊎
UpperLeftArrow;	U+02196	↖
UpperRightArrow;	U+02197	↗
Upsi;	U+003D2	ϒ
upsi;	U+003C5	υ
upsih;	U+003D2	ϒ
Upsilon;	U+003A5	Υ
upsilon;	U+003C5	υ
UpTee;	U+022A5	⊥
UpTeeArrow;	U+021A5	↥
upuparrows;	U+021C8	⇈
urcorn;	U+0231D	⌝
urcorner;	U+0231D	⌝
urcrop;	U+0230E	⌎
Uring;	U+0016E	Ů
uring;	U+0016F	ů
urtri;	U+025F9	◹
Uscr;	U+1D4B0	𝒰
uscr;	U+1D4CA	𝓊
utdot;	U+022F0	⋰
Utilde;	U+00168	Ũ
utilde;	U+00169	ũ
utri;	U+025B5	▵
utrif;	U+025B4	▴
uuarr;	U+021C8	⇈
Uuml;	U+000DC	Ü
Uuml	U+000DC	Ü
uuml;	U+000FC	ü
uuml	U+000FC	ü
uwangle;	U+029A7	⦧
vangrt;	U+0299C	⦜
varepsilon;	U+003F5	ϵ
varkappa;	U+003F0	ϰ
varnothing;	U+02205	∅
varphi;	U+003D5	ϕ
varpi;	U+003D6	ϖ
varpropto;	U+0221D	∝
vArr;	U+021D5	⇕
varr;	U+02195	↕
varrho;	U+003F1	ϱ
varsigma;	U+003C2	ς
varsubsetneq;	U+0228A U+0FE00	⊊︀
varsubsetneqq;	U+02ACB U+0FE00	⫋︀
varsupsetneq;	U+0228B U+0FE00	⊋︀
varsupsetneqq;	U+02ACC U+0FE00	⫌︀
vartheta;	U+003D1	ϑ
vartriangleleft;	U+022B2	⊲
vartriangleright;	U+022B3	⊳
Vbar;	U+02AEB	⫫
vBar;	U+02AE8	⫨
vBarv;	U+02AE9	⫩
Vcy;	U+00412	В
vcy;	U+00432	в
VDash;	U+022AB	⊫
Vdash;	U+022A9	⊩
vDash;	U+022A8	⊨
vdash;	U+022A2	⊢
Vdashl;	U+02AE6	⫦
Vee;	U+022C1	⋁
vee;	U+02228	∨
veebar;	U+022BB	⊻
veeeq;	U+0225A	≚
vellip;	U+022EE	⋮
Verbar;	U+02016	‖
verbar;	U+0007C	|
Vert;	U+02016	‖
vert;	U+0007C	|
VerticalBar;	U+02223	∣
VerticalLine;	U+0007C	|
VerticalSeparator;	U+02758	❘
VerticalTilde;	U+02240	≀
VeryThinSpace;	U+0200A	 
Vfr;	U+1D519	𝔙
vfr;	U+1D533	𝔳
vltri;	U+022B2	⊲
vnsub;	U+02282 U+020D2	⊂⃒
vnsup;	U+02283 U+020D2	⊃⃒
Vopf;	U+1D54D	𝕍
vopf;	U+1D567	𝕧
vprop;	U+0221D	∝
vrtri;	U+022B3	⊳
Vscr;	U+1D4B1	𝒱
vscr;	U+1D4CB	𝓋
vsubnE;	U+02ACB U+0FE00	⫋︀
vsubne;	U+0228A U+0FE00	⊊︀
vsupnE;	U+02ACC U+0FE00	⫌︀
vsupne;	U+0228B U+0FE00	⊋︀
Vvdash;	U+022AA	⊪
vzigzag;	U+0299A	⦚
Wcirc;	U+00174	Ŵ
wcirc;	U+00175	ŵ
wedbar;	U+02A5F	⩟
Wedge;	U+022C0	⋀
wedge;	U+02227	∧
wedgeq;	U+02259	≙
weierp;	U+02118	℘
Wfr;	U+1D51A	𝔚
wfr;	U+1D534	𝔴
Wopf;	U+1D54E	𝕎
wopf;	U+1D568	𝕨
wp;	U+02118	℘
wr;	U+02240	≀
wreath;	U+02240	≀
Wscr;	U+1D4B2	𝒲
wscr;	U+1D4CC	𝓌
xcap;	U+022C2	⋂
xcirc;	U+025EF	◯
xcup;	U+022C3	⋃
xdtri;	U+025BD	▽
Xfr;	U+1D51B	𝔛
xfr;	U+1D535	𝔵
xhArr;	U+027FA	⟺
xharr;	U+027F7	⟷
Xi;	U+0039E	Ξ
xi;	U+003BE	ξ
xlArr;	U+027F8	⟸
xlarr;	U+027F5	⟵
xmap;	U+027FC	⟼
xnis;	U+022FB	⋻
xodot;	U+02A00	⨀
Xopf;	U+1D54F	𝕏
xopf;	U+1D569	𝕩
xoplus;	U+02A01	⨁
xotime;	U+02A02	⨂
xrArr;	U+027F9	⟹
xrarr;	U+027F6	⟶
Xscr;	U+1D4B3	𝒳
xscr;	U+1D4CD	𝓍
xsqcup;	U+02A06	⨆
xuplus;	U+02A04	⨄
xutri;	U+025B3	△
xvee;	U+022C1	⋁
xwedge;	U+022C0	⋀
Yacute;	U+000DD	Ý
Yacute	U+000DD	Ý
yacute;	U+000FD	ý
yacute	U+000FD	ý
YAcy;	U+0042F	Я
yacy;	U+0044F	я
Ycirc;	U+00176	Ŷ
ycirc;	U+00177	ŷ
Ycy;	U+0042B	Ы
ycy;	U+0044B	ы
yen;	U+000A5	¥
yen	U+000A5	¥
Yfr;	U+1D51C	𝔜
yfr;	U+1D536	𝔶
YIcy;	U+00407	Ї
yicy;	U+00457	ї
Yopf;	U+1D550	𝕐
yopf;	U+1D56A	𝕪
Yscr;	U+1D4B4	𝒴
yscr;	U+1D4CE	𝓎
YUcy;	U+0042E	Ю
yucy;	U+0044E	ю
Yuml;	U+00178	Ÿ
yuml;	U+000FF	ÿ
yuml	U+000FF	ÿ
Zacute;	U+00179	Ź
zacute;	U+0017A	ź
Zcaron;	U+0017D	Ž
zcaron;	U+0017E	ž
Zcy;	U+00417	З
zcy;	U+00437	з
Zdot;	U+0017B	Ż
zdot;	U+0017C	ż
zeetrf;	U+02128	ℨ
ZeroWidthSpace;	U+0200B	​
Zeta;	U+00396	Ζ
zeta;	U+003B6	ζ
Zfr;	U+02128	ℨ
zfr;	U+1D537	𝔷
ZHcy;	U+00416	Ж
zhcy;	U+00436	ж
zigrarr;	U+021DD	⇝
Zopf;	U+02124	ℤ
zopf;	U+1D56B	𝕫
Zscr;	U+1D4B5	𝒵
zscr;	U+1D4CF	𝓏
zwj;	U+0200D	‍
zwnj;	U+0200C	‌
This data is also available as a JSON file.

The glyphs displayed above are non-normative. Refer to the Unicode specifications for formal definitions of the characters listed above.

The character reference names originate from the XML Entity Definitions for Characters specification, though only the above is considered normative. [XMLENTITY]

13 The XML syntax

Support: xhtml
Chrome for Android	64+
Chrome	4+
iOS Safari	3.2+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	9+
Opera Mini	all+
Safari	3.1+
Edge	12+
Android Browser	2.1+
Opera	9+

Source: caniuse.com

This section only describes the rules for XML resources. Rules for text/html resources are discussed in the section above entitled "The HTML syntax".

13.1 Writing documents in the XML syntax
The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons, because no such term is used for the HTML syntaxes of MathML and SVG).

The syntax for XML is defined in the XML and Namespaces in XML specifications. [XML] [XMLNS]

This specification does not define any syntax-level requirements beyond those defined for XML proper.

XML documents may contain a DOCTYPE if desired, but this is not required to conform to this specification. This specification does not define a public or system identifier, nor provide a formal DTD.

According to the XML specification, XML processors are not guaranteed to process the external DTD subset referenced in the DOCTYPE. This means, for example, that using entity references for characters in XML documents is unsafe if they are defined in an external file (except for &lt;, &gt;, &amp;, &quot; and &apos;).

13.2 Parsing XML documents
This section describes the relationship between XML and the DOM, with a particular emphasis on how this interacts with HTML.

An XML parser, for the purposes of this specification, is a construct that follows the rules given in the XML specification to map a string of bytes or characters into a Document object.

At the time of writing, no such rules actually exist.

An XML parser is either associated with a Document object when it is created, or creates one implicitly.

This Document must then be populated with DOM nodes that represent the tree structure of the input passed to the parser, as defined by the XML specification, the Namespaces in XML specification, and the WHATWG DOM standard. When creating DOM nodes representing elements, the create an element for a token algorithm or some equivalent that operates on appropriate XML datastructures must be used, to ensure the proper element interfaces are created and that custom elements are set up correctly.

DOM mutation events must not fire for the operations that the XML parser performs on the Document's tree, but the user agent must act as if elements and attributes were individually appended and set respectively so as to trigger rules in this specification regarding what happens when an element is inserted into a document or has its attributes set, and the WHATWG DOM standard's requirements regarding mutation observers mean that mutation observers are fired (unlike mutation events). [XML] [XMLNS] [DOM] [UIEVENTS]

Between the time an element's start tag is parsed and the time either the element's end tag is parsed or the parser detects a well-formedness error, the user agent must act as if the element was in a stack of open elements.

This is used, e.g. by the object element to avoid instantiating plugins before the param element children have been parsed.

This specification provides the following additional information that user agents should use when retrieving an external entity: the public identifiers given in the following list all correspond to the URL given by this link. (This URL is a DTD containing the entity declarations for the names listed in the named character references section.) [XML]

-//W3C//DTD XHTML 1.0 Transitional//EN
-//W3C//DTD XHTML 1.1//EN
-//W3C//DTD XHTML 1.0 Strict//EN
-//W3C//DTD XHTML 1.0 Frameset//EN
-//W3C//DTD XHTML Basic 1.0//EN
-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN
-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN
-//W3C//DTD MathML 2.0//EN
-//WAPFORUM//DTD XHTML Mobile 1.0//EN
Furthermore, user agents should attempt to retrieve the above external entity's content when one of the above public identifiers is used, and should not attempt to retrieve any other external entity's content.

This is not strictly a violation of the XML specification, but it does contradict the spirit of the XML specification's requirements. This is motivated by a desire for user agents to all handle entities in an interoperable fashion without requiring any network access for handling external subsets. [XML]

XML parsers can be invoked with XML scripting support enabled or XML scripting support disabled. Except where otherwise specified, XML parsers are invoked with XML scripting support enabled.

When an XML parser with XML scripting support enabled creates a script element, it must be marked as being "parser-inserted" and its "non-blocking" flag must be unset. If the parser was originally created for the XML fragment parsing algorithm, then the element must be marked as "already started" also. When the element's end tag is subsequently parsed, the user agent must perform a microtask checkpoint, and then prepare the script element. If this causes there to be a pending parsing-blocking script, then the user agent must run the following steps:

Block this instance of the XML parser, such that the event loop will not run tasks that invoke it.

Spin the event loop until the parser's Document has no style sheet that is blocking scripts and the pending parsing-blocking script's "ready to be parser-executed" flag is set.

Unblock this instance of the XML parser, such that tasks that invoke it can again be run.

Execute the pending parsing-blocking script.

There is no longer a pending parsing-blocking script.

Since the document.write() API is not available for XML documents, much of the complexity in the HTML parser is not needed in the XML parser.

When the XML parser has XML scripting support disabled, none of this happens.

When an XML parser would append a node to a template element, it must instead append it to the template element's template contents (a DocumentFragment node).

This is a willful violation of the XML specification; unfortunately, XML is not formally extensible in the manner that is needed for template processing. [XML]

When an XML parser creates a Node object, its node document must be set to the node document of the node into which the newly created node is to be inserted.

Certain algorithms in this specification spoon-feed the parser characters one string at a time. In such cases, the XML parser must act as it would have if faced with a single string consisting of the concatenation of all those characters.

When an XML parser reaches the end of its input, it must stop parsing, following the same rules as the HTML parser. An XML parser can also be aborted, which must again be done in the same way as for an HTML parser.

For the purposes of conformance checkers, if a resource is determined to be in the XML syntax, then it is an XML document.

13.3 Serializing XML fragments
The XML fragment serialization algorithm for a Document or Element node either returns a fragment of XML that represents that node or throws an exception.

For Documents, the algorithm must return a string in the form of a document entity, if none of the error cases below apply.

For Elements, the algorithm must return a string in the form of an internal general parsed entity, if none of the error cases below apply.

In both cases, the string returned must be XML namespace-well-formed and must be an isomorphic serialization of all of that node's relevant child nodes, in tree order. User agents may adjust prefixes and namespace declarations in the serialization (and indeed might be forced to do so in some cases to obtain namespace-well-formed XML). User agents may use a combination of regular text and character references to represent Text nodes in the DOM.

A node's relevant child nodes are those that apply given the following rules:

For template elements
The relevant child nodes are the child nodes of the template element's template contents, if any.
For all other nodes
The relevant child nodes are the child nodes of node itself, if any.
For Elements, if any of the elements in the serialization are in no namespace, the default namespace in scope for those elements must be explicitly declared as the empty string. (This doesn't apply in the Document case.) [XML] [XMLNS]

For the purposes of this section, an internal general parsed entity is considered XML namespace-well-formed if a document consisting of an element with no namespace declarations whose contents are the internal general parsed entity would itself be XML namespace-well-formed.

If any of the following error cases are found in the DOM subtree being serialized, then the algorithm must throw an "InvalidStateError" DOMException instead of returning a string:

A Document node with no child element nodes.
A DocumentType node that has an external subset public identifier that contains characters that are not matched by the XML PubidChar production. [XML]
A DocumentType node that has an external subset system identifier that contains both a U+0022 QUOTATION MARK (") and a U+0027 APOSTROPHE (') or that contains characters that are not matched by the XML Char production. [XML]
A node with a local name containing a U+003A COLON (:).
A node with a local name that does not match the XML Name production. [XML]
An Attr node with no namespace whose local name is the lowercase string "xmlns". [XMLNS]
An Element node with two or more attributes with the same local name and namespace.
An Attr node, Text node, Comment node, or ProcessingInstruction node whose data contains characters that are not matched by the XML Char production. [XML]
A Comment node whose data contains two adjacent U+002D HYPHEN-MINUS characters (-) or ends with such a character.
A ProcessingInstruction node whose target name is an ASCII case-insensitive match for the string "xml".
A ProcessingInstruction node whose target name contains a U+003A COLON (:).
A ProcessingInstruction node whose data contains the string "?>".
These are the only ways to make a DOM unserialisable. The DOM enforces all the other XML constraints; for example, trying to append two elements to a Document node will throw a "HierarchyRequestError" DOMException.

13.4 Parsing XML fragments
The XML fragment parsing algorithm either returns a Document or throws a "SyntaxError" DOMException. Given a string input and a context element context, the algorithm is as follows:

Create a new XML parser.

Feed the parser just created the string corresponding to the start tag of the context element, declaring all the namespace prefixes that are in scope on that element in the DOM, as well as declaring the default namespace (if any) that is in scope on that element in the DOM.

A namespace prefix is in scope if the DOM lookupNamespaceURI() method on the element would return a non-null value for that prefix.

The default namespace is the namespace for which the DOM isDefaultNamespace() method on the element would return true.

No DOCTYPE is passed to the parser, and therefore no external subset is referenced, and therefore no entities will be recognized.

Feed the parser just created the string input.

Feed the parser just created the string corresponding to the end tag of the context element.

If there is an XML well-formedness or XML namespace well-formedness error, then throw a "SyntaxError" DOMException.

If the document element of the resulting Document has any sibling nodes, then throw a "SyntaxError" DOMException.

Return the child nodes of the document element of the resulting Document, in tree order.

14 Rendering
User agents are not required to present HTML documents in any particular way. However, this section provides a set of suggestions for rendering HTML documents that, if followed, are likely to lead to a user experience that closely resembles the experience intended by the documents' authors. So as to avoid confusion regarding the normativity of this section, "must" has not been used. Instead, the term "expected" is used to indicate behavior that will lead to this experience. For the purposes of conformance for user agents designated as supporting the suggested default rendering, the term "expected" in this section has the same conformance implications as "must".

14.1 Introduction
In general, user agents are expected to support CSS, and many of the suggestions in this section are expressed in CSS terms. User agents that use other presentation mechanisms can derive their expected behavior by translating from the CSS rules given in this section.

In the absence of style-layer rules to the contrary (e.g. author style sheets), user agents are expected to render an element so that it conveys to the user the meaning that the element represents, as described by this specification.

The suggestions in this section generally assume a visual output medium with a resolution of 96dpi or greater, but HTML is intended to apply to multiple media (it is a media-independent language). User agent implementers are encouraged to adapt the suggestions in this section to their target media.

An element is being rendered if it has any associated CSS layout boxes, SVG layout boxes, or some equivalent in other styling languages.

Just being off-screen does not mean the element is not being rendered. The presence of the hidden attribute normally means the element is not being rendered, though this might be overridden by the style sheets.

User agents that do not honor author-level CSS style sheets are nonetheless expected to act as if they applied the CSS rules given in these sections in a manner consistent with this specification and the relevant CSS and Unicode specifications. [CSS] [UNICODE] [BIDI]

This is especially important for issues relating to the 'display', 'unicode-bidi', and 'direction' properties.

14.2 The CSS user agent style sheet and presentational hints
The CSS rules given in these subsections are, except where otherwise specified, expected to be used as part of the user-agent level style sheet defaults for all documents that contain HTML elements.

Some rules are intended for the author-level zero-specificity presentational hints part of the CSS cascade; these are explicitly called out as presentational hints.

When the text below says that an attribute attribute on an element element maps to the pixel length property (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the parsed value as a pixel length for a presentational hint for properties.

When the text below says that an attribute attribute on an element element maps to the dimension property (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for parsing dimension values doesn't generate an error, then the user agent is expected to use the parsed dimension as the value for a presentational hint for properties, with the value given as a pixel length if the dimension was a length, and with the value given as a percentage if the dimension was a percentage.

When the text below says that an attribute attribute on an element element maps to the dimension property (ignoring zero) (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for parsing nonzero dimension values doesn't generate an error, then the user agent is expected to use the parsed dimension as the value for a presentational hint for properties, with the value given as a pixel length if the dimension was a length, and with the value given as a percentage if the dimension was a percentage.

When a user agent is to align descendants of a node, the user agent is expected to align only those descendants that have both their 'margin-inline-start' and 'margin-inline-end' properties computing to a value other than 'auto', that are over-constrained and that have one of those two margins with a used value forced to a greater value, and that do not themselves have an applicable align attribute. When multiple elements are to align a particular descendant, the most deeply nested such element is expected to override the others. Aligned elements are expected to be aligned by having the used values of their margins on the line-left and line-right sides be set accordingly. [CSSLOGICAL] [CSSWM]

14.3 Non-replaced elements
14.3.1 Hidden elements
@namespace url(http://www.w3.org/1999/xhtml);

[hidden], area, base, basefont, datalist, head, link, meta, noembed,
noframes, param, rp, script, source, style, template, track, title {
  display: none;
}

embed[hidden] { display: inline; height: 0; width: 0; }

input[type=hidden i] { display: none !important; }

@media (scripting) {
  noscript { display: none !important; }
}
14.3.2 The page
@namespace url(http://www.w3.org/1999/xhtml);

html, body { display: block; }
For each property in the table below, given a body element, the first attribute that exists maps to the pixel length property on the body element. If none of the attributes for a property are found, or if the value of the attribute that was found cannot be parsed successfully, then a default value of 8px is expected to be used for that property instead.

Property	Source
'margin-top'	The body element's marginheight attribute
The body element's topmargin attribute
The body element's container frame element's marginheight attribute
'margin-right'	The body element's marginwidth attribute
The body element's rightmargin attribute
The body element's container frame element's marginwidth attribute
'margin-bottom'	The body element's marginheight attribute
The body element's bottommargin attribute
The body element's container frame element's marginheight attribute
'margin-left'	The body element's marginwidth attribute
The body element's leftmargin attribute
The body element's container frame element's marginwidth attribute
If the body element's node document's browsing context is a nested browsing context, and the browsing context container of that nested browsing context is a frame or iframe element, then the container frame element of the body element is that frame or iframe element. Otherwise, there is no container frame element.

The above requirements imply that a page can change the margins of another page (including one from another origin) using, for example, an iframe. This is potentially a security risk, as it might in some cases allow an attack to contrive a situation in which a page is rendered not as the author intended, possibly for the purposes of phishing or otherwise misleading the user.

If a Document is in a nested browsing context, it is expected to be positioned and sized to fit inside the content box of its browsing context container. If a browsing context's browsing context container is not being rendered, the browsing context is expected to have a viewport with zero width and zero height.

If the Document is in a nested browsing context, and the browsing context container of that nested browsing context is a frame or iframe element, and that element has a scrolling attribute, and that attribute's value is an ASCII case-insensitive match for the string "off", "noscroll", or "no", then the user agent is expected to prevent any scroll bars from being shown for the viewport of the nested browsing context, regardless of the 'overflow' property that applies to that viewport.

When a body element has a background attribute set to a non-empty value, the new value is expected to be parsed relative to the element's node document, and if this is successful, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-image' property to the resulting URL string.

When a body element has a bgcolor attribute set, the new value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-color' property to the resulting color.

When a body element has a text attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'color' property to the resulting color.

When a body element has a link attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the 'color' property of any element in the Document matching the :link pseudo-class to the resulting color.

When a body element has a vlink attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the 'color' property of any element in the Document matching the :visited pseudo-class to the resulting color.

When a body element has an alink attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the 'color' property of any element in the Document matching the :active pseudo-class and either the :link pseudo-class or the :visited pseudo-class to the resulting color.

14.3.3 Flow content
@namespace url(http://www.w3.org/1999/xhtml);

address, blockquote, center, dialog, div, figure, figcaption, footer, form,
header, hr, legend, listing, main, p, plaintext, pre, xmp {
  display: block;
}

blockquote, figure, listing, p, plaintext, pre, xmp {
  margin-block-start: 1em; margin-block-end: 1em;
}

blockquote, figure { margin-inline-start: 40px; margin-inline-end: 40px; }

address { font-style: italic; }
listing, plaintext, pre, xmp {
  font-family: monospace; white-space: pre;
}

dialog:not([open]) { display: none; }
dialog {
  position: absolute;
  offset-inline-start: 0; offset-inline-end: 0;
  width: fit-content;
  height: fit-content;
  margin: auto;
  border: solid;
  padding: 1em;
  background: white;
  color: black;
}
dialog::backdrop {
  background: rgba(0,0,0,0.1);
}

slot {
  display: contents;
}
The following rules are also expected to apply, as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

pre[wrap] { white-space: pre-wrap; }
In quirks mode, the following rules are also expected to apply:

@namespace url(http://www.w3.org/1999/xhtml);

form { margin-block-end: 1em; }
The center element, and the div element when it has an align attribute whose value is an ASCII case-insensitive match for either the string "center" or the string "middle", are expected to center text within themselves, as if they had their 'text-align' property set to 'center' in a presentational hint, and to align descendants to the center.

The div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "left", is expected to left-align text within itself, as if it had its 'text-align' property set to 'left' in a presentational hint, and to align descendants to the left.

The div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "right", is expected to right-align text within itself, as if it had its 'text-align' property set to 'right' in a presentational hint, and to align descendants to the right.

The div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "justify", is expected to full-justify text within itself, as if it had its 'text-align' property set to 'justify' in a presentational hint, and to align descendants to the left.

14.3.4 Phrasing content
@namespace url(http://www.w3.org/1999/xhtml);

cite, dfn, em, i, var { font-style: italic; }
b, strong { font-weight: bolder; }
code, kbd, samp, tt { font-family: monospace; }
big { font-size: larger; }
small { font-size: smaller; }

sub { vertical-align: sub; }
sup { vertical-align: super; }
sub, sup { line-height: normal; font-size: smaller; }

ruby { display: ruby; }
rt { display: ruby-text; }

:link { color: #0000EE; }
:visited { color: #551A8B; }
:link:active, :visited:active { color: #FF0000; }
:link, :visited { text-decoration: underline; cursor: pointer; }
a:link[rel~=help i], a:visited[rel~=help i],
area:link[rel~=help i], area:visited[rel~=help i] { cursor: help; }

:focus { outline: auto; }

mark { background: yellow; color: black; } /* this color is just a suggestion and can be changed based on implementation feedback */

abbr[title], acronym[title] { text-decoration: dotted underline; }
ins, u { text-decoration: underline; }
del, s, strike { text-decoration: line-through; }

q::before { content: open-quote; }
q::after { content: close-quote; }

br { display-outside: newline; } /* this also has bidi implications */
nobr { white-space: nowrap; }
wbr { display-outside: break-opportunity; } /* this also has bidi implications */
nobr wbr { white-space: normal; }
The following rules are also expected to apply, as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

br[clear=left i] { clear: left; }
br[clear=right i] { clear: right; }
br[clear=all i], br[clear=both i] { clear: both; }
For the purposes of the CSS ruby model, runs of children of ruby elements that are not rt or rp elements are expected to be wrapped in anonymous boxes whose 'display' property has the value 'ruby-base'. [CSSRUBY]

When a particular part of a ruby has more than one annotation, the annotations should be distributed on both sides of the base text so as to minimize the stacking of ruby annotations on one side.

When it becomes possible to do so, the preceding requirement will be updated to be expressed in terms of CSS ruby. (Currently, CSS ruby does not handle nested ruby elements or multiple sequential rt elements, which is how this semantic is expressed.)

User agents that do not support correct ruby rendering are expected to render parentheses around the text of rt elements in the absence of rp elements.

User agents are expected to support the 'clear' property on inline elements (in order to render br elements with clear attributes) in the manner described in the non-normative note to this effect in the CSS specification.

The initial value for the 'color' property is expected to be black. The initial value for the 'background-color' property is expected to be 'transparent'. The canvas's background is expected to be white.

When a font element has a color attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'color' property to the resulting color.

The font element is expected to override the color of any text decoration that spans the text of the element to the used value of the element's 'color' property.

When a font element has a face attribute, the user agent is expected to treat the attribute as a presentational hint setting the element's 'font-family' property to the attribute's value.

When a font element has a size attribute, the user agent is expected to use the following steps, known as the rules for parsing a legacy font size, to treat the attribute as a presentational hint setting the element's 'font-size' property:

Let input be the attribute's value.

Let position be a pointer into input, initially pointing at the start of the string.

Skip ASCII whitespace within input given position.

If position is past the end of input, there is no presentational hint. Return.

If the character at position is a U+002B PLUS SIGN character (+), then let mode be relative-plus, and advance position to the next character. Otherwise, if the character at position is a U+002D HYPHEN-MINUS character (-), then let mode be relative-minus, and advance position to the next character. Otherwise, let mode be absolute.

Collect a sequence of code points that are ASCII digits from input given position, and let the resulting sequence be digits.

If digits is the empty string, there is no presentational hint. Return.

Interpret digits as a base-ten integer. Let value be the resulting number.

If mode is relative-plus, then increment value by 3. If mode is relative-minus, then let value be the result of subtracting value from 3.

If value is greater than 7, let it be 7.

If value is less than 1, let it be 1.

Set 'font-size' to the keyword corresponding to the value of value according to the following table:

value	'font-size' keyword	Notes
1	'x-small'
2	'small'
3	'medium'
4	'large'
5	'x-large'
6	'xx-large'
7	'xxx-large'	see below
The 'xxx-large' value is a non-CSS value used here to indicate a font size 50% larger than 'xx-large'.

14.3.5 Bidirectional text
@namespace url(http://www.w3.org/1999/xhtml);

[dir]:dir(ltr), bdi:dir(ltr), input[type=tel i]:dir(ltr) { direction: ltr; }
[dir]:dir(rtl), bdi:dir(rtl) { direction: rtl; }

address, blockquote, center, div, figure, figcaption, footer, form, header, hr,
legend, listing, main, p, plaintext, pre, summary, xmp, article, aside, h1, h2,
h3, h4, h5, h6, hgroup, nav, section, table, caption, colgroup, col, thead,
tbody, tfoot, tr, td, th, dir, dd, dl, dt, menu, ol, ul, li, bdi, output,
[dir=ltr i], [dir=rtl i], [dir=auto i] {
  unicode-bidi: isolate;
}

bdo, bdo[dir] { unicode-bidi: isolate-override; }

input[dir=auto i]:matches([type=search i], [type=tel i], [type=url i],
[type=email i]), textarea[dir=auto i], pre[dir=auto i] {
  unicode-bidi: plaintext;
}
/* see prose for input elements whose type attribute is in the Text state */

/* the rules setting the 'content' property on br and wbr elements also has bidi implications */
When an input element's dir attribute is in the auto state and its type attribute is in the Text state, then the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'unicode-bidi' property to 'plaintext'.

Input fields (i.e. textarea elements, and input elements when their type attribute is in the Text, Search, Telephone, URL, or E-mail state) are expected to present an editing user interface with a directionality that matches the element's 'direction' property.

When the document's character encoding is ISO-8859-8, the following rules are additionally expected to apply, following those above: [ENCODING]

@namespace url(http://www.w3.org/1999/xhtml);

address, blockquote, center, div, figure, figcaption, footer, form, header, hr,
legend, listing, main, p, plaintext, pre, summary, xmp, article, aside, h1, h2,
h3, h4, h5, h6, hgroup, nav, section, table, caption, colgroup, col, thead,
tbody, tfoot, tr, td, th, dir, dd, dl, dt, menu, ol, ul, li, [dir=ltr i],
[dir=rtl i], [dir=auto i], *|* {
  unicode-bidi: bidi-override;
}
input:not([type=submit i]):not([type=reset i]):not([type=button i]),
textarea {
  unicode-bidi: normal;
}
14.3.6 Quotes
This block is automatically generated from the Unicode Common Locale Data Repository. [CLDR]

User agents are expected to use either the block below (which will be regularly updated) or to automatically generate their own copy directly from the source material. The language codes are derived from the CLDR file names. The quotes are derived from the delimiter blocks, with fallback handled as specified in the CLDR documentation.

@namespace url(http://www.w3.org/1999/xhtml);

:root                                                         { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(af),       :not(:lang(af)) > :lang(af)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(agq),      :not(:lang(agq)) > :lang(agq)           { quotes: '\201e' '\201d' '\201a' '\2019' } /* „ ” ‚ ’ */
:root:lang(ak),       :not(:lang(ak)) > :lang(ak)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(am),       :not(:lang(am)) > :lang(am)             { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(ar),       :not(:lang(ar)) > :lang(ar)             { quotes: '\201d' '\201c' '\2019' '\2018' } /* ” “ ’ ‘ */
:root:lang(asa),      :not(:lang(asa)) > :lang(asa)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ast),      :not(:lang(ast)) > :lang(ast)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(az),       :not(:lang(az)) > :lang(az)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(az-Cyrl),  :not(:lang(az-Cyrl)) > :lang(az-Cyrl)   { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(bas),      :not(:lang(bas)) > :lang(bas)           { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(be),       :not(:lang(be)) > :lang(be)             { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(bem),      :not(:lang(bem)) > :lang(bem)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(bez),      :not(:lang(bez)) > :lang(bez)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(bg),       :not(:lang(bg)) > :lang(bg)             { quotes: '\201e' '\201c' '\201e' '\201c' } /* „ “ „ “ */
:root:lang(bm),       :not(:lang(bm)) > :lang(bm)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(bn),       :not(:lang(bn)) > :lang(bn)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(br),       :not(:lang(br)) > :lang(br)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(brx),      :not(:lang(brx)) > :lang(brx)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(bs),       :not(:lang(bs)) > :lang(bs)             { quotes: '\201e' '\201d' '\2018' '\2019' } /* „ ” ‘ ’ */
:root:lang(bs-Cyrl),  :not(:lang(bs-Cyrl)) > :lang(bs-Cyrl)   { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(ca),       :not(:lang(ca)) > :lang(ca)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(cgg),      :not(:lang(cgg)) > :lang(cgg)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(chr),      :not(:lang(chr)) > :lang(chr)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(cs),       :not(:lang(cs)) > :lang(cs)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(cy),       :not(:lang(cy)) > :lang(cy)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(da),       :not(:lang(da)) > :lang(da)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(dav),      :not(:lang(dav)) > :lang(dav)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(de),       :not(:lang(de)) > :lang(de)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(dje),      :not(:lang(dje)) > :lang(dje)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(dsb),      :not(:lang(dsb)) > :lang(dsb)           { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(dua),      :not(:lang(dua)) > :lang(dua)           { quotes: '\00ab' '\00bb' '\2018' '\2019' } /* « » ‘ ’ */
:root:lang(dyo),      :not(:lang(dyo)) > :lang(dyo)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(dz),       :not(:lang(dz)) > :lang(dz)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ebu),      :not(:lang(ebu)) > :lang(ebu)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ee),       :not(:lang(ee)) > :lang(ee)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(el),       :not(:lang(el)) > :lang(el)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(en),       :not(:lang(en)) > :lang(en)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(es),       :not(:lang(es)) > :lang(es)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(et),       :not(:lang(et)) > :lang(et)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(eu),       :not(:lang(eu)) > :lang(eu)             { quotes: '\201c' '\201d' '\201c' '\201d' } /* “ ” “ ” */
:root:lang(ewo),      :not(:lang(ewo)) > :lang(ewo)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(fa),       :not(:lang(fa)) > :lang(fa)             { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(ff),       :not(:lang(ff)) > :lang(ff)             { quotes: '\201e' '\201d' '\201a' '\2019' } /* „ ” ‚ ’ */
:root:lang(fi),       :not(:lang(fi)) > :lang(fi)             { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(fil),      :not(:lang(fil)) > :lang(fil)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(fo),       :not(:lang(fo)) > :lang(fo)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(fr),       :not(:lang(fr)) > :lang(fr)             { quotes: '\00ab' '\00bb' '\00ab' '\00bb' } /* « » « » */
:root:lang(fr-CH),    :not(:lang(fr-CH)) > :lang(fr-CH)       { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(ga),       :not(:lang(ga)) > :lang(ga)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(gd),       :not(:lang(gd)) > :lang(gd)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(gl),       :not(:lang(gl)) > :lang(gl)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(gsw),      :not(:lang(gsw)) > :lang(gsw)           { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(gu),       :not(:lang(gu)) > :lang(gu)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(guz),      :not(:lang(guz)) > :lang(guz)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ha),       :not(:lang(ha)) > :lang(ha)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(he),       :not(:lang(he)) > :lang(he)             { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(hi),       :not(:lang(hi)) > :lang(hi)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(hr),       :not(:lang(hr)) > :lang(hr)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(hsb),      :not(:lang(hsb)) > :lang(hsb)           { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(hu),       :not(:lang(hu)) > :lang(hu)             { quotes: '\201e' '\201d' '\00bb' '\00ab' } /* „ ” » « */
:root:lang(hy),       :not(:lang(hy)) > :lang(hy)             { quotes: '\00ab' '\00bb' '\00ab' '\00bb' } /* « » « » */
:root:lang(id),       :not(:lang(id)) > :lang(id)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ig),       :not(:lang(ig)) > :lang(ig)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(is),       :not(:lang(is)) > :lang(is)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(it),       :not(:lang(it)) > :lang(it)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(ja),       :not(:lang(ja)) > :lang(ja)             { quotes: '\300c' '\300d' '\300e' '\300f' } /* 「 」 『 』 */
:root:lang(jgo),      :not(:lang(jgo)) > :lang(jgo)           { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(jmc),      :not(:lang(jmc)) > :lang(jmc)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ka),       :not(:lang(ka)) > :lang(ka)             { quotes: '\201e' '\201c' '\00ab' '\00bb' } /* „ “ « » */
:root:lang(kab),      :not(:lang(kab)) > :lang(kab)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(kam),      :not(:lang(kam)) > :lang(kam)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(kde),      :not(:lang(kde)) > :lang(kde)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(kea),      :not(:lang(kea)) > :lang(kea)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(khq),      :not(:lang(khq)) > :lang(khq)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ki),       :not(:lang(ki)) > :lang(ki)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(kk),       :not(:lang(kk)) > :lang(kk)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(kkj),      :not(:lang(kkj)) > :lang(kkj)           { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(kln),      :not(:lang(kln)) > :lang(kln)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(km),       :not(:lang(km)) > :lang(km)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(kn),       :not(:lang(kn)) > :lang(kn)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ko),       :not(:lang(ko)) > :lang(ko)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ksb),      :not(:lang(ksb)) > :lang(ksb)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ksf),      :not(:lang(ksf)) > :lang(ksf)           { quotes: '\00ab' '\00bb' '\2018' '\2019' } /* « » ‘ ’ */
:root:lang(ky),       :not(:lang(ky)) > :lang(ky)             { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(lag),      :not(:lang(lag)) > :lang(lag)           { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(lb),       :not(:lang(lb)) > :lang(lb)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(lg),       :not(:lang(lg)) > :lang(lg)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ln),       :not(:lang(ln)) > :lang(ln)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(lo),       :not(:lang(lo)) > :lang(lo)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(lrc),      :not(:lang(lrc)) > :lang(lrc)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(lt),       :not(:lang(lt)) > :lang(lt)             { quotes: '\201e' '\201c' '\201e' '\201c' } /* „ “ „ “ */
:root:lang(lu),       :not(:lang(lu)) > :lang(lu)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(luo),      :not(:lang(luo)) > :lang(luo)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(luy),      :not(:lang(luy)) > :lang(luy)           { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(lv),       :not(:lang(lv)) > :lang(lv)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mas),      :not(:lang(mas)) > :lang(mas)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mer),      :not(:lang(mer)) > :lang(mer)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mfe),      :not(:lang(mfe)) > :lang(mfe)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mg),       :not(:lang(mg)) > :lang(mg)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(mgo),      :not(:lang(mgo)) > :lang(mgo)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mk),       :not(:lang(mk)) > :lang(mk)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(ml),       :not(:lang(ml)) > :lang(ml)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mn),       :not(:lang(mn)) > :lang(mn)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mr),       :not(:lang(mr)) > :lang(mr)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ms),       :not(:lang(ms)) > :lang(ms)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mt),       :not(:lang(mt)) > :lang(mt)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mua),      :not(:lang(mua)) > :lang(mua)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(my),       :not(:lang(my)) > :lang(my)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(mzn),      :not(:lang(mzn)) > :lang(mzn)           { quotes: '\00ab' '\00bb' '\2039' '\203a' } /* « » ‹ › */
:root:lang(naq),      :not(:lang(naq)) > :lang(naq)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(nb),       :not(:lang(nb)) > :lang(nb)             { quotes: '\00ab' '\00bb' '\2018' '\2019' } /* « » ‘ ’ */
:root:lang(nd),       :not(:lang(nd)) > :lang(nd)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ne),       :not(:lang(ne)) > :lang(ne)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(nl),       :not(:lang(nl)) > :lang(nl)             { quotes: '\2018' '\2019' '\201c' '\201d' } /* ‘ ’ “ ” */
:root:lang(nmg),      :not(:lang(nmg)) > :lang(nmg)           { quotes: '\201e' '\201d' '\00ab' '\00bb' } /* „ ” « » */
:root:lang(nn),       :not(:lang(nn)) > :lang(nn)             { quotes: '\00ab' '\00bb' '\2018' '\2019' } /* « » ‘ ’ */
:root:lang(nnh),      :not(:lang(nnh)) > :lang(nnh)           { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(nus),      :not(:lang(nus)) > :lang(nus)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(nyn),      :not(:lang(nyn)) > :lang(nyn)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(pa),       :not(:lang(pa)) > :lang(pa)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(pl),       :not(:lang(pl)) > :lang(pl)             { quotes: '\201e' '\201d' '\00ab' '\00bb' } /* „ ” « » */
:root:lang(pt),       :not(:lang(pt)) > :lang(pt)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(pt-PT),    :not(:lang(pt-PT)) > :lang(pt-PT)       { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(rn),       :not(:lang(rn)) > :lang(rn)             { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(ro),       :not(:lang(ro)) > :lang(ro)             { quotes: '\201e' '\201d' '\00ab' '\00bb' } /* „ ” « » */
:root:lang(rof),      :not(:lang(rof)) > :lang(rof)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ru),       :not(:lang(ru)) > :lang(ru)             { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(rw),       :not(:lang(rw)) > :lang(rw)             { quotes: '\00ab' '\00bb' '\2018' '\2019' } /* « » ‘ ’ */
:root:lang(rwk),      :not(:lang(rwk)) > :lang(rwk)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(sah),      :not(:lang(sah)) > :lang(sah)           { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(saq),      :not(:lang(saq)) > :lang(saq)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(sbp),      :not(:lang(sbp)) > :lang(sbp)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(seh),      :not(:lang(seh)) > :lang(seh)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ses),      :not(:lang(ses)) > :lang(ses)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(sg),       :not(:lang(sg)) > :lang(sg)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(shi),      :not(:lang(shi)) > :lang(shi)           { quotes: '\00ab' '\00bb' '\201e' '\201d' } /* « » „ ” */
:root:lang(shi-Latn), :not(:lang(shi-Latn)) > :lang(shi-Latn) { quotes: '\00ab' '\00bb' '\201e' '\201d' } /* « » „ ” */
:root:lang(si),       :not(:lang(si)) > :lang(si)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(sk),       :not(:lang(sk)) > :lang(sk)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(sl),       :not(:lang(sl)) > :lang(sl)             { quotes: '\201e' '\201c' '\201a' '\2018' } /* „ “ ‚ ‘ */
:root:lang(sn),       :not(:lang(sn)) > :lang(sn)             { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(so),       :not(:lang(so)) > :lang(so)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(sq),       :not(:lang(sq)) > :lang(sq)             { quotes: '\00ab' '\00bb' '\201c' '\201d' } /* « » “ ” */
:root:lang(sr),       :not(:lang(sr)) > :lang(sr)             { quotes: '\201e' '\201c' '\2018' '\2018' } /* „ “ ‘ ‘ */
:root:lang(sr-Latn),  :not(:lang(sr-Latn)) > :lang(sr-Latn)   { quotes: '\201e' '\201c' '\2018' '\2018' } /* „ “ ‘ ‘ */
:root:lang(sv),       :not(:lang(sv)) > :lang(sv)             { quotes: '\201d' '\201d' '\2019' '\2019' } /* ” ” ’ ’ */
:root:lang(sw),       :not(:lang(sw)) > :lang(sw)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ta),       :not(:lang(ta)) > :lang(ta)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(te),       :not(:lang(te)) > :lang(te)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(teo),      :not(:lang(teo)) > :lang(teo)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(th),       :not(:lang(th)) > :lang(th)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(ti-ER),    :not(:lang(ti-ER)) > :lang(ti-ER)       { quotes: '\2018' '\2019' '\201c' '\201d' } /* ‘ ’ “ ” */
:root:lang(tk),       :not(:lang(tk)) > :lang(tk)             { quotes: '\201c' '\201d' '\201c' '\201d' } /* “ ” “ ” */
:root:lang(to),       :not(:lang(to)) > :lang(to)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(tr),       :not(:lang(tr)) > :lang(tr)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(twq),      :not(:lang(twq)) > :lang(twq)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(tzm),      :not(:lang(tzm)) > :lang(tzm)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(uk),       :not(:lang(uk)) > :lang(uk)             { quotes: '\00ab' '\00bb' '\201e' '\201c' } /* « » „ “ */
:root:lang(ur),       :not(:lang(ur)) > :lang(ur)             { quotes: '\201d' '\201c' '\2019' '\2018' } /* ” “ ’ ‘ */
:root:lang(uz),       :not(:lang(uz)) > :lang(uz)             { quotes: '\201c' '\201d' '\2019' '\2018' } /* “ ” ’ ‘ */
:root:lang(uz-Cyrl),  :not(:lang(uz-Cyrl)) > :lang(uz-Cyrl)   { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(vai),      :not(:lang(vai)) > :lang(vai)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(vai-Latn), :not(:lang(vai-Latn)) > :lang(vai-Latn) { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(vi),       :not(:lang(vi)) > :lang(vi)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(vun),      :not(:lang(vun)) > :lang(vun)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(xog),      :not(:lang(xog)) > :lang(xog)           { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(yav),      :not(:lang(yav)) > :lang(yav)           { quotes: '\00ab' '\00bb' '\00ab' '\00bb' } /* « » « » */
:root:lang(yo),       :not(:lang(yo)) > :lang(yo)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(yue),      :not(:lang(yue)) > :lang(yue)           { quotes: '\300c' '\300d' '\300e' '\300f' } /* 「 」 『 』 */
:root:lang(yue-Hans), :not(:lang(yue-Hans)) > :lang(yue-Hans) { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(zgh),      :not(:lang(zgh)) > :lang(zgh)           { quotes: '\00ab' '\00bb' '\201e' '\201d' } /* « » „ ” */
:root:lang(zh),       :not(:lang(zh)) > :lang(zh)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
:root:lang(zh-Hant),  :not(:lang(zh-Hant)) > :lang(zh-Hant)   { quotes: '\300c' '\300d' '\300e' '\300f' } /* 「 」 『 』 */
:root:lang(zu),       :not(:lang(zu)) > :lang(zu)             { quotes: '\201c' '\201d' '\2018' '\2019' } /* “ ” ‘ ’ */
14.3.7 Sections and headings
@namespace url(http://www.w3.org/1999/xhtml);

article, aside, h1, h2, h3, h4, h5, h6, hgroup, nav, section {
  display: block;
}

h1 { margin-block-start: 0.67em; margin-block-end: 0.67em; font-size: 2.00em; font-weight: bold; }
h2 { margin-block-start: 0.83em; margin-block-end: 0.83em; font-size: 1.50em; font-weight: bold; }
h3 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; font-weight: bold; }
h4 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; font-weight: bold; }
h5 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; font-weight: bold; }
h6 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; font-weight: bold; }
In the following CSS block, x is shorthand for the following selector: :matches(article, aside, nav, section)

@namespace url(http://www.w3.org/1999/xhtml);

x h1 { margin-block-start: 0.83em; margin-block-end: 0.83em; font-size: 1.50em; }
x x h1 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; }
x x x h1 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; }
x x x x h1 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; }
x x x x x h1 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h2 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; }
x x hgroup > h1 ~ h2 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; }
x x x hgroup > h1 ~ h2 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; }
x x x x hgroup > h1 ~ h2 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h3 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; }
x x hgroup > h1 ~ h3 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; }
x x x hgroup > h1 ~ h3 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h4 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; }
x x hgroup > h1 ~ h4 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h5 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }
The shorthand is used to keep this block at least mildly readable.

14.3.8 Lists

Spec bugs: 17770

@namespace url(http://www.w3.org/1999/xhtml);

dir, dd, dl, dt, menu, ol, ul { display: block; }
li { display: list-item; }

dir, dl, menu, ol, ul { margin-block-start: 1em; margin-block-end: 1em; }

:matches(dir, dl, menu, ol, ul) :matches(dir, dl, menu, ol, ul) {
  margin-block-start: 0; margin-block-end: 0;
}

dd { margin-inline-start: 40px; }
dir, menu, ol, ul { padding-inline-start: 40px; }

ol { list-style-type: decimal; }

dir, menu, ul {
  list-style-type: disc;
}
:matches(dir, menu, ol, ul) :matches(dir, menu, ul) {
  list-style-type: circle;
}
:matches(dir, menu, ol, ul) :matches(dir, menu, ol, ul) :matches(dir, menu, ul) {
  list-style-type: square;
}
The following rules are also expected to apply, as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

ol[type="1"], li[type="1"] { list-style-type: decimal; }
ol[type=a], li[type=a] { list-style-type: lower-alpha; }
ol[type=A], li[type=A] { list-style-type: upper-alpha; }
ol[type=i], li[type=i] { list-style-type: lower-roman; }
ol[type=I], li[type=I] { list-style-type: upper-roman; }
ul[type=none i], li[type=none i] { list-style-type: none; }
ul[type=disc i], li[type=disc i] { list-style-type: disc; }
ul[type=circle i], li[type=circle i] { list-style-type: circle; }
ul[type=square i], li[type=square i] { list-style-type: square; }
In the above stylesheet, the attribute selectors for the ol and li elements are expected to be treated as case-sensitive.

When rendering li elements, non-CSS user agents are expected to use the ordinal value of the li element to render the counter in the list item marker.

This specification does not yet define the CSS-specific rules for rendering li elements, because CSS doesn't yet provide sufficient hooks for this purpose.

14.3.9 Tables
@namespace url(http://www.w3.org/1999/xhtml);

table { display: table; }
caption { display: table-caption; }
colgroup, colgroup[hidden] { display: table-column-group; }
col, col[hidden] { display: table-column; }
thead, thead[hidden] { display: table-header-group; }
tbody, tbody[hidden] { display: table-row-group; }
tfoot, tfoot[hidden] { display: table-footer-group; }
tr, tr[hidden] { display: table-row; }
td, th, td[hidden], th[hidden] { display: table-cell; }

colgroup[hidden], col[hidden], thead[hidden], tbody[hidden],
tfoot[hidden], tr[hidden], td[hidden], th[hidden] {
  visibility: collapse;
}

table {
  box-sizing: border-box;
  border-spacing: 2px;
  border-collapse: separate;
  text-indent: initial;
}
td, th { padding: 1px; }
th { font-weight: bold; }

caption { text-align: center; }
thead, tbody, tfoot, table > tr { vertical-align: middle; }
tr, td, th { vertical-align: inherit; }

table, td, th { border-color: gray; }
thead, tbody, tfoot, tr { border-color: inherit; }
table[rules=none i], table[rules=groups i], table[rules=rows i],
table[rules=cols i], table[rules=all i], table[frame=void i],
table[frame=above i], table[frame=below i], table[frame=hsides i],
table[frame=lhs i], table[frame=rhs i], table[frame=vsides i],
table[frame=box i], table[frame=border i],
table[rules=none i] > tr > td, table[rules=none i] > tr > th,
table[rules=groups i] > tr > td, table[rules=groups i] > tr > th,
table[rules=rows i] > tr > td, table[rules=rows i] > tr > th,
table[rules=cols i] > tr > td, table[rules=cols i] > tr > th,
table[rules=all i] > tr > td, table[rules=all i] > tr > th,
table[rules=none i] > thead > tr > td, table[rules=none i] > thead > tr > th,
table[rules=groups i] > thead > tr > td, table[rules=groups i] > thead > tr > th,
table[rules=rows i] > thead > tr > td, table[rules=rows i] > thead > tr > th,
table[rules=cols i] > thead > tr > td, table[rules=cols i] > thead > tr > th,
table[rules=all i] > thead > tr > td, table[rules=all i] > thead > tr > th,
table[rules=none i] > tbody > tr > td, table[rules=none i] > tbody > tr > th,
table[rules=groups i] > tbody > tr > td, table[rules=groups i] > tbody > tr > th,
table[rules=rows i] > tbody > tr > td, table[rules=rows i] > tbody > tr > th,
table[rules=cols i] > tbody > tr > td, table[rules=cols i] > tbody > tr > th,
table[rules=all i] > tbody > tr > td, table[rules=all i] > tbody > tr > th,
table[rules=none i] > tfoot > tr > td, table[rules=none i] > tfoot > tr > th,
table[rules=groups i] > tfoot > tr > td, table[rules=groups i] > tfoot > tr > th,
table[rules=rows i] > tfoot > tr > td, table[rules=rows i] > tfoot > tr > th,
table[rules=cols i] > tfoot > tr > td, table[rules=cols i] > tfoot > tr > th,
table[rules=all i] > tfoot > tr > td, table[rules=all i] > tfoot > tr > th {
  border-color: black;
}
The following rules are also expected to apply, as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

table[align=left i] { float: left; }
table[align=right i] { float: right; }
table[align=center i] { margin-inline-start: auto; margin-inline-end: auto; }
thead[align=absmiddle i], tbody[align=absmiddle i], tfoot[align=absmiddle i],
tr[align=absmiddle i], td[align=absmiddle i], th[align=absmiddle i] {
  text-align: center;
}

caption[align=bottom i] { caption-side: bottom; }
p[align=left i], h1[align=left i], h2[align=left i], h3[align=left i],
h4[align=left i], h5[align=left i], h6[align=left i] {
  text-align: left;
}
p[align=right i], h1[align=right i], h2[align=right i], h3[align=right i],
h4[align=right i], h5[align=right i], h6[align=right i] {
  text-align: right;
}
p[align=center i], h1[align=center i], h2[align=center i], h3[align=center i],
h4[align=center i], h5[align=center i], h6[align=center i] {
  text-align: center;
}
p[align=justify i], h1[align=justify i], h2[align=justify i], h3[align=justify i],
h4[align=justify i], h5[align=justify i], h6[align=justify i] {
  text-align: justify;
}
thead[valign=top i], tbody[valign=top i], tfoot[valign=top i],
tr[valign=top i], td[valign=top i], th[valign=top i] {
  vertical-align: top;
}
thead[valign=middle i], tbody[valign=middle i], tfoot[valign=middle i],
tr[valign=middle i], td[valign=middle i], th[valign=middle i] {
  vertical-align: middle;
}
thead[valign=bottom i], tbody[valign=bottom i], tfoot[valign=bottom i],
tr[valign=bottom i], td[valign=bottom i], th[valign=bottom i] {
  vertical-align: bottom;
}
thead[valign=baseline i], tbody[valign=baseline i], tfoot[valign=baseline i],
tr[valign=baseline i], td[valign=baseline i], th[valign=baseline i] {
  vertical-align: baseline;
}

td[nowrap], th[nowrap] { white-space: nowrap; }

table[rules=none i], table[rules=groups i], table[rules=rows i],
table[rules=cols i], table[rules=all i] {
  border-style: hidden;
  border-collapse: collapse;
}
table[border] { border-style: outset; } /* only if border is not equivalent to zero */
table[frame=void i] { border-style: hidden; }
table[frame=above i] { border-style: outset hidden hidden hidden; }
table[frame=below i] { border-style: hidden hidden outset hidden; }
table[frame=hsides i] { border-style: outset hidden outset hidden; }
table[frame=lhs i] { border-style: hidden hidden hidden outset; }
table[frame=rhs i] { border-style: hidden outset hidden hidden; }
table[frame=vsides i] { border-style: hidden outset; }
table[frame=box i], table[frame=border i] { border-style: outset; }

table[border] > tr > td, table[border] > tr > th,
table[border] > thead > tr > td, table[border] > thead > tr > th,
table[border] > tbody > tr > td, table[border] > tbody > tr > th,
table[border] > tfoot > tr > td, table[border] > tfoot > tr > th {
  /* only if border is not equivalent to zero */
  border-width: 1px;
  border-style: inset;
}
table[rules=none i] > tr > td, table[rules=none i] > tr > th,
table[rules=none i] > thead > tr > td, table[rules=none i] > thead > tr > th,
table[rules=none i] > tbody > tr > td, table[rules=none i] > tbody > tr > th,
table[rules=none i] > tfoot > tr > td, table[rules=none i] > tfoot > tr > th,
table[rules=groups i] > tr > td, table[rules=groups i] > tr > th,
table[rules=groups i] > thead > tr > td, table[rules=groups i] > thead > tr > th,
table[rules=groups i] > tbody > tr > td, table[rules=groups i] > tbody > tr > th,
table[rules=groups i] > tfoot > tr > td, table[rules=groups i] > tfoot > tr > th,
table[rules=rows i] > tr > td, table[rules=rows i] > tr > th,
table[rules=rows i] > thead > tr > td, table[rules=rows i] > thead > tr > th,
table[rules=rows i] > tbody > tr > td, table[rules=rows i] > tbody > tr > th,
table[rules=rows i] > tfoot > tr > td, table[rules=rows i] > tfoot > tr > th {
  border-width: 1px;
  border-style: none;
}
table[rules=cols i] > tr > td, table[rules=cols i] > tr > th,
table[rules=cols i] > thead > tr > td, table[rules=cols i] > thead > tr > th,
table[rules=cols i] > tbody > tr > td, table[rules=cols i] > tbody > tr > th,
table[rules=cols i] > tfoot > tr > td, table[rules=cols i] > tfoot > tr > th {
  border-width: 1px;
  border-block-start-style: none;
  border-inline-end-style: solid;
  border-block-end-style: none;
  border-inline-start-style: solid;
}
table[rules=all i] > tr > td, table[rules=all i] > tr > th,
table[rules=all i] > thead > tr > td, table[rules=all i] > thead > tr > th,
table[rules=all i] > tbody > tr > td, table[rules=all i] > tbody > tr > th,
table[rules=all i] > tfoot > tr > td, table[rules=all i] > tfoot > tr > th {
  border-width: 1px;
  border-style: solid;
}

table[rules=groups i] > colgroup {
  border-inline-start-width: 1px;
  border-inline-start-style: solid;
  border-inline-end-width: 1px;
  border-inline-end-style: solid;
}
table[rules=groups i] > thead,
table[rules=groups i] > tbody,
table[rules=groups i] > tfoot {
  border-block-start-width: 1px;
  border-block-start-style: solid;
  border-block-end-width: 1px;
  border-block-end-style: solid;
}

table[rules=rows i] > tr, table[rules=rows i] > thead > tr,
table[rules=rows i] > tbody > tr, table[rules=rows i] > tfoot > tr {
  border-block-start-width: 1px;
  border-block-start-style: solid;
  border-block-end-width: 1px;
  border-block-end-style: solid;
}
In quirks mode, the following rules are also expected to apply:

@namespace url(http://www.w3.org/1999/xhtml);

table {
  font-weight: initial;
  font-style: initial;
  font-variant: initial;
  font-size: initial;
  line-height: initial;
  white-space: initial;
  text-align: initial;
}
For the purposes of the CSS table model, the col element is expected to be treated as if it was present as many times as its span attribute specifies.

For the purposes of the CSS table model, the colgroup element, if it contains no col element, is expected to be treated as if it had as many such children as its span attribute specifies.

For the purposes of the CSS table model, the colspan and rowspan attributes on td and th elements are expected to provide the special knowledge regarding cells spanning rows and columns.

In HTML documents, the following rules are also expected to apply:

@namespace url(http://www.w3.org/1999/xhtml);

:matches(table, thead, tbody, tfoot, tr) > form { display: none !important; }
The table element's cellspacing attribute maps to the pixel length property 'border-spacing' on the element.

The table element's cellpadding attribute maps to the pixel length properties 'padding-top', 'padding-right', 'padding-bottom', and 'padding-left' of any td and th elements that have corresponding cells in the table corresponding to the table element.

The table element's height attribute maps to the dimension property (ignoring zero) 'height' on the table element.

The table element's width attribute maps to the dimension property (ignoring zero) 'width' on the table element.

The col element's width attribute maps to the dimension property (ignoring zero) 'width' on the col element.

The tr element's height attribute maps to the dimension property (ignoring zero) 'height' on the tr element.

The td and th elements' height attributes map to the dimension property (ignoring zero) 'height' on the element.

The td and th elements' width attributes map to the dimension property (ignoring zero) 'width' on the element.

The thead, tbody, tfoot, tr, td, and th elements, when they have an align attribute whose value is an ASCII case-insensitive match for either the string "center" or the string "middle", are expected to center text within themselves, as if they had their 'text-align' property set to 'center' in a presentational hint, and to align descendants to the center.

The thead, tbody, tfoot, tr, td, and th elements, when they have an align attribute whose value is an ASCII case-insensitive match for the string "left", are expected to left-align text within themselves, as if they had their 'text-align' property set to 'left' in a presentational hint, and to align descendants to the left.

The thead, tbody, tfoot, tr, td, and th elements, when they have an align attribute whose value is an ASCII case-insensitive match for the string "right", are expected to right-align text within themselves, as if they had their 'text-align' property set to 'right' in a presentational hint, and to align descendants to the right.

The thead, tbody, tfoot, tr, td, and th elements, when they have an align attribute whose value is an ASCII case-insensitive match for the string "justify", are expected to full-justify text within themselves, as if they had their 'text-align' property set to 'justify' in a presentational hint, and to align descendants to the left.

User agents are expected to have a rule in their user agent stylesheet that matches th elements that have a parent node whose computed value for the 'text-align' property is its initial value, whose declaration block consists of just a single declaration that sets the 'text-align' property to the value 'center'.

When a table, thead, tbody, tfoot, tr, td, or th element has a background attribute set to a non-empty value, the new value is expected to be parsed relative to the element's node document, and if this is successful, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-image' property to the resulting URL string.

When a table, thead, tbody, tfoot, tr, td, or th element has a bgcolor attribute set, the new value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-color' property to the resulting color.

When a table element has a bordercolor attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'border-top-color', 'border-right-color', 'border-bottom-color', and 'border-left-color' properties to the resulting color.

The table element's border attribute maps to the pixel length properties 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width' on the element. If the attribute is present but parsing the attribute's value using the rules for parsing non-negative integers generates an error, a default value of 1px is expected to be used for that property instead.

Rules marked "only if border is not equivalent to zero" in the CSS block above is expected to only be applied if the border attribute mentioned in the selectors for the rule is not only present but, when parsed using the rules for parsing non-negative integers, is also found to have a value other than zero or to generate an error.

In quirks mode, a td element or a th element that has a nowrap attribute but also has a width attribute whose value, when parsed using the rules for parsing nonzero dimension values, is found to be a length (not an error or a number classified as a percentage), is expected to have a presentational hint setting the element's 'white-space' property to 'normal', overriding the rule in the CSS block above that sets it to 'nowrap'.

14.3.10 Margin collapsing quirks
A node is substantial if it is a text node that is not inter-element whitespace, or if it is an element node.

A node is blank if it is an element that contains no substantial nodes.

The elements with default margins are the following elements: blockquote, dir, dl, h1, h2, h3, h4, h5, h6, listing, menu, ol, p, plaintext, pre, ul, xmp

In quirks mode, any element with default margins that is the child of a body, td, or th element and has no substantial previous siblings is expected to have a user-agent level style sheet rule that sets its 'margin-block-start' property to zero.

In quirks mode, any element with default margins that is the child of a body, td, or th element, has no substantial previous siblings, and is blank, is expected to have a user-agent level style sheet rule that sets its 'margin-block-end' property to zero also.

In quirks mode, any element with default margins that is the child of a td or th element, has no substantial following siblings, and is blank, is expected to have a user-agent level style sheet rule that sets its 'margin-block-start' property to zero.

In quirks mode, any p element that is the child of a td or th element and has no substantial following siblings, is expected to have a user-agent level style sheet rule that sets its 'margin-block-end' property to zero.

14.3.11 Form controls
@namespace url(http://www.w3.org/1999/xhtml);

input, select, option, optgroup, button, textarea {
  text-indent: initial;
}

input:matches([type=radio i], [type=checkbox i], [type=reset i], [type=button i],
[type=submit i], [type=search i]), select, button {
  box-sizing: border-box;
}

textarea { white-space: pre-wrap; }
In quirks mode, the following rules are also expected to apply:

@namespace url(http://www.w3.org/1999/xhtml);

input:not([type=image i]), textarea { box-sizing: border-box; }
Each kind of form control is also described in the Widgets section, which describes the look and feel of the control.

14.3.12 The hr element
@namespace url(http://www.w3.org/1999/xhtml);

hr {
  color: gray;
  border-style: inset;
  border-width: 1px;
  margin-block-start: 0.5em;
  margin-inline-end: auto;
  margin-block-end: 0.5em;
  margin-inline-start: auto;
  overflow: hidden;
}
The following rules are also expected to apply, as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

hr[align=left i] { margin-left: 0; margin-right: auto; }
hr[align=right i] { margin-left: auto; margin-right: 0; }
hr[align=center i] { margin-left: auto; margin-right: auto; }
hr[color], hr[noshade] { border-style: solid; }
If an hr element has either a color attribute or a noshade attribute, and furthermore also has a size attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the parsed value divided by two as a pixel length for presentational hints for the properties 'border-top-width', 'border-right-width', 'border-bottom-width', and 'border-left-width' on the element.

Otherwise, if an hr element has neither a color attribute nor a noshade attribute, but does have a size attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then: if the parsed value is one, then the user agent is expected to use the attribute as a presentational hint setting the element's 'border-bottom-width' to 0; otherwise, if the parsed value is greater than one, then the user agent is expected to use the parsed value minus two as a pixel length for presentational hints for the 'height' property on the element.

The width attribute on an hr element maps to the dimension property 'width' on the element.

When an hr element has a color attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'color' property to the resulting color.

14.3.13 The fieldset and legend elements
@namespace url(http://www.w3.org/1999/xhtml);

fieldset {
  display: block;
  margin-inline-start: 2px;
  margin-inline-end: 2px;
  border: groove 2px ThreeDFace;
  padding-block-start: 0.35em;
  padding-inline-end: 0.625em;
  padding-block-end: 0.75em;
  padding-inline-start: 0.625em;
  min-width: min-content;
}

legend {
  padding-inline-start: 2px; padding-inline-end: 2px;
}
The fieldset element is expected to establish a new block formatting context.

If the fieldset element has a child that matches the conditions in the list below, then the first such child is the fieldset element's rendered legend:

The child is a legend element.
The child is not out-of-flow (e.g. not absolutely positioned or floated).
The child is generating a box (e.g. it is not 'display:none' or 'display:contents').
A fieldset element's rendered legend, if any, is expected to be rendered over the block-start border edge of the fieldset element as a block box (overriding any explicit 'display' value). In the absence of an explicit inline size, the box should shrink-wrap. The element is expected to establish a new block formatting context. If the legend element in question has an align attribute, and its value is an ASCII case-insensitive match for one of the strings in the first column of the following table, then the legend is expected to be rendered aligned in the inline direction over the border edge in the position given in the corresponding cell on the same row in the second column. If the attribute is absent or has a value that doesn't match any of the cases in the table, then the position is expected to be on the inline-start side. [CSSWM]

Attribute value	Alignment position
left	On the line-left side
right	On the line-right side
center	In the middle
14.4 Replaced elements
The following elements can be replaced elements: audio, canvas, embed, iframe, img, input, object, and video.

14.4.1 Embedded content
The embed, iframe, and video elements are expected to be treated as replaced elements.

A canvas element that represents embedded content is expected to be treated as a replaced element; the contents of such elements are the element's bitmap, if any, or else a transparent black bitmap with the same intrinsic dimensions as the element. Other canvas elements are expected to be treated as ordinary elements in the rendering model.

An object element that represents an image, plugin, or nested browsing context is expected to be treated as a replaced element. Other object elements are expected to be treated as ordinary elements in the rendering model.

The audio element, when it is exposing a user interface, is expected to be treated as a replaced element about one line high, as wide as is necessary to expose the user agent's user interface features. When an audio element is not exposing a user interface, the user agent is expected to force its 'display' property to compute to 'none', irrespective of CSS rules.

Whether a video element is exposing a user interface is not expected to affect the size of the rendering; controls are expected to be overlaid above the page content without causing any layout changes, and are expected to disappear when the user does not need them.

When a video element represents a poster frame or frame of video, the poster frame or frame of video is expected to be rendered at the largest size that maintains the aspect ratio of that poster frame or frame of video without being taller or wider than the video element itself, and is expected to be centered in the video element.

Any subtitles or captions are expected to be overlayed directly on top of their video element, as defined by the relevant rendering rules; for WebVTT, those are the rules for updating the display of WebVTT text tracks. [WEBVTT]

When the user agent starts exposing a user interface for a video element, the user agent should run the rules for updating the text track rendering of each of the text tracks in the video element's list of text tracks that are showing and whose text track kind is one of subtitles or captions (e.g., for text tracks based on WebVTT, the rules for updating the display of WebVTT text tracks). [WEBVTT]

Resizing video and canvas elements does not interrupt video playback or clear the canvas.

The following CSS rules are expected to apply:

@namespace url(http://www.w3.org/1999/xhtml);

iframe { border: 2px inset; }
video { object-fit: contain; }
14.4.2 Images
User agents are expected to render img elements and input elements whose type attributes are in the Image Button state, according to the first applicable rules from the following list:

If the element represents an image
The user agent is expected to treat the element as a replaced element and render the image according to the rules for doing so defined in CSS.
 If the element does not represent an image, but the element already has intrinsic dimensions (e.g. from the dimension attributes or CSS rules), and either:
the user agent has reason to believe that the image will become available and be rendered in due course, or
the element has no alt attribute, or
the Document is in quirks mode
The user agent is expected to treat the element as a replaced element whose content is the text that the element represents, if any, optionally alongside an icon indicating that the image is being obtained (if applicable). For input elements, the element is expected to appear button-like to indicate that the element is a button.
If the element is an img element that represents some text and the user agent does not expect this to change
The user agent is expected to treat the element as a non-replaced phrasing element whose content is the text, optionally with an icon indicating that an image is missing, so that the user can request the image be displayed or investigate why it is not rendering. In non-graphical contexts, such an icon should be omitted.
If the element is an img element that represents nothing and the user agent does not expect this to change
The user agent is expected to treat the element as an empty inline element. (In the absence of further styles, this will cause the element to essentially not be rendered.)
If the element is an input element that does not represent an image and the user agent does not expect this to change
The user agent is expected to treat the element as a replaced element consisting of a button whose content is the element's alternative text. The intrinsic dimensions of the button are expected to be about one line in height and whatever width is necessary to render the text on one line.
The icons mentioned above are expected to be relatively small so as not to disrupt most text but be easily clickable. In a visual environment, for instance, icons could be 16 pixels by 16 pixels square, or 1em by 1em if the images are scalable. In an audio environment, the icon could be a short bleep. The icons are intended to indicate to the user that they can be used to get to whatever options the UA provides for images, and, where appropriate, are expected to provide access to the context menu that would have come up if the user interacted with the actual image.

All animated images with the same absolute URL and the same image data are expected to be rendered synchronized to the same timeline as a group, with the timeline starting at the time of the least recent addition to the group.

In other words, when a second image with the same absolute URL and animated image data is inserted into a document, it jumps to the point in the animation cycle that is currently being displayed by the first image.

When a user agent is to restart the animation for an img element showing an animated image, all animated images with the same absolute URL and the same image data in that img element's node document are expected to restart their animation from the beginning.

The following CSS rules are expected to apply when the Document is in quirks mode:

@namespace url(http://www.w3.org/1999/xhtml);

img[align=left i] { margin-right: 3px; }
img[align=right i] { margin-left: 3px; }
14.4.3 Attributes for embedded content and images
The following CSS rules are expected to apply as presentational hints:

@namespace url(http://www.w3.org/1999/xhtml);

iframe[frameborder=0], iframe[frameborder=no i] { border: none; }

embed[align=left i], iframe[align=left i], img[align=left i],
input[type=image i][align=left i], object[align=left i] {
  float: left;
}

embed[align=right i], iframe[align=right i], img[align=right i],
input[type=image i][align=right i], object[align=right i] {
  float: right;
}

embed[align=top i], iframe[align=top i], img[align=top i],
input[type=image i][align=top i], object[align=top i] {
  vertical-align: top;
}

embed[align=baseline i], iframe[align=baseline i], img[align=baseline i],
input[type=image i][align=baseline i], object[align=baseline i] {
  vertical-align: baseline;
}

embed[align=texttop i], iframe[align=texttop i], img[align=texttop i],
input[type=image i][align=texttop i], object[align=texttop i] {
  vertical-align: text-top;
}

embed[align=absmiddle i], iframe[align=absmiddle i], img[align=absmiddle i],
input[type=image i][align=absmiddle i], object[align=absmiddle i],
embed[align=abscenter i], iframe[align=abscenter i], img[align=abscenter i],
input[type=image i][align=abscenter i], object[align=abscenter i] {
  vertical-align: middle;
}

embed[align=bottom i], iframe[align=bottom i], img[align=bottom i],
input[type=image i][align=bottom i], object[align=bottom i] {
  vertical-align: bottom;
}
When an embed, iframe, img, or object element, or an input element whose type attribute is in the Image Button state, has an align attribute whose value is an ASCII case-insensitive match for the string "center" or the string "middle", the user agent is expected to act as if the element's 'vertical-align' property was set to a value that aligns the vertical middle of the element with the parent element's baseline.

The hspace attribute of embed, iframe, img, or object elements, and input elements with a type attribute in the Image Button state, maps to the dimension properties 'margin-left' and 'margin-right' on the element.

The vspace attribute of embed, iframe, img, or object elements, and input elements with a type attribute in the Image Button state, maps to the dimension properties 'margin-top' and 'margin-bottom' on the element.

When an img element, object element, or input element with a type attribute in the Image Button state has a border attribute whose value, when parsed using the rules for parsing non-negative integers, is found to be a number greater than zero, the user agent is expected to use the parsed value for eight presentational hints: four setting the parsed value as a pixel length for the element's 'border-top-width', 'border-right-width', 'border-bottom-width', and 'border-left-width' properties, and four setting the element's 'border-top-style', 'border-right-style', 'border-bottom-style', and 'border-left-style' properties to the value 'solid'.

The width and height attributes on embed, iframe, img, object or video elements, and input elements with a type attribute in the Image Button state and that either represents an image or that the user expects will eventually represent an image, map to the dimension properties 'width' and 'height' on the element respectively.

14.4.4 Image maps
Shapes on an image map are expected to act, for the purpose of the CSS cascade, as elements independent of the original area element that happen to match the same style rules but inherit from the img or object element.

For the purposes of the rendering, only the 'cursor' property is expected to have any effect on the shape.

Thus, for example, if an area element has a style attribute that sets the 'cursor' property to 'help', then when the user designates that shape, the cursor would change to a Help cursor.

Similarly, if an area element had a CSS rule that set its 'cursor' property to 'inherit' (or if no rule setting the 'cursor' property matched the element at all), the shape's cursor would be inherited from the img or object element of the image map, not from the parent of the area element.

14.5 Widgets
14.5.1 Introduction
The elements defined in this section can be rendered in a variety of manners, within the guidelines provided below. User agents are encouraged to set the 'appearance' CSS property appropriately to achieve platform-native appearances for widgets, and are expected to implement any relevant animations, etc, that are appropriate for the platform.

14.5.2 The button element
The button element expected to render as an 'inline-block' box depicting a button whose contents are the contents of the element.

14.5.3 The details and summary elements
@namespace url(http://www.w3.org/1999/xhtml);

summary {
  display: list-item;
  counter-increment: list-item 0;
  list-style: disclosure-closed inside;
}
details[open] > summary {
  list-style-type: disclosure-open;
}
The details element is expected to render as a block box. The element's shadow tree is expected to take the element's first summary element child, if any, and place it in a first block box container, and then take the element's remaining descendants, if any, and place them in a second block box container.

The first container is expected to allow the user to request the details be shown or hidden.

The second container is expected to be removed from the rendering when the details element does not have an open attribute.

14.5.4 The input element as a text entry widget

Spec bugs: 24296

An input element whose type attribute is in the Text, Search, Telephone, URL, or E-mail state, is expected to render as an 'inline-block' box depicting a text control. Additionally, the 'line-height' property, if it has a computed value equivalent to a value that is less than 1.0, must have a used value of 1.0.

An input element whose type attribute is in the Password state is expected to render as an 'inline-block' box depicting a text control that obscures data entry.

If these text controls provide a text selection, then, when the user changes the current selection, the user agent is expected to queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.

If an input element whose type attribute is in one of the above states has a size attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a presentational hint for the 'width' property on the element, with the value obtained from applying the converting a character width to pixels algorithm to the value of the attribute.

If an input element whose type attribute is in one of the above states does not have a size attribute, then the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'width' property on the element to the value obtained from applying the converting a character width to pixels algorithm to the number 20.

The converting a character width to pixels algorithm returns (size-1)×avg + max, where size is the character width to convert, avg is the average character width of the primary font for the element for which the algorithm is being run, in pixels, and max is the maximum character width of that same font, also in pixels. (The element's 'letter-spacing' property does not affect the result.)

14.5.5 The input element as domain-specific widgets
An input element whose type attribute is in the Date state is expected to render as an 'inline-block' box depicting a date control.

An input element whose type attribute is in the Month state is expected to render as an 'inline-block' box depicting a month control.

An input element whose type attribute is in the Week state is expected to render as an 'inline-block' box depicting a week control.

An input element whose type attribute is in the Time state is expected to render as an 'inline-block' box depicting a time control.

An input element whose type attribute is in the Local Date and Time state is expected to render as an 'inline-block' box depicting a local date and time control.

An input element whose type attribute is in the Number state is expected to render as an 'inline-block' box depicting a number control.

These controls are all expected to be about one line high, and about as wide as necessary to show the widest possible value.

14.5.6 The input element as a range control
An input element whose type attribute is in the Range state is expected to render as an 'inline-block' box depicting a slider control.

When the control is wider than it is tall (or square), the control is expected to be a horizontal slider, with the lowest value on the right if the 'direction' property on this element has a computed value of 'rtl', and on the left otherwise. When the control is taller than it is wide, it is expected to be a vertical slider, with the lowest value on the bottom.

Predefined suggested values (provided by the list attribute) are expected to be shown as tick marks on the slider, which the slider can snap to.

User agents are expected to use the used value of the 'direction' property on the element to determine the direction in which the slider operates. Typically, a left-to-right ('ltr') horizontal control would have the lowest value on the left and the highest value on the right, and vice versa.

14.5.7 The input element as a color well
An input element whose type attribute is in the Color state is expected to render as an 'inline-block' box depicting a color well, which, when activated, provides the user with a color picker (e.g. a color wheel or color palette) from which the color can be changed.

Predefined suggested values (provided by the list attribute) are expected to be shown in the color picker interface, not on the color well itself.

14.5.8 The input element as a checkbox and radio button widgets
An input element whose type attribute is in the Checkbox state is expected to render as an 'inline-block' box containing a single checkbox control, with no label.

An input element whose type attribute is in the Radio Button state is expected to render as an 'inline-block' box containing a single radio button control, with no label.

14.5.9 The input element as a file upload control
An input element whose type attribute is in the File Upload state is expected to render as an 'inline-block' box containing a span of text giving the file name(s) of the selected files, if any, followed by a button that, when activated, provides the user with a file picker from which the selection can be changed.

14.5.10 The input element as a button
An input element whose type attribute is in the Submit Button, Reset Button, or Button state is expected to render as an 'inline-block' box depicting a button, about one line high, containing the contents of the element's value attribute, if any, or text derived from the element's type attribute in a user-agent-defined (and probably locale-specific) fashion, if not.

14.5.11 The marquee element
The marquee element, while turned on, is expected to render in an animated fashion according to its attributes as follows:

If the element's behavior attribute is in the scroll state
Slide the contents of the element in the direction described by the direction attribute as defined below, such that it begins off the start side of the marquee, and ends flush with the inner end side.

For example, if the direction attribute is left (the default), then the contents would start such that their left edge are off the side of the right edge of the marquee's content area, and the contents would then slide up to the point where the left edge of the contents are flush with the left inner edge of the marquee's content area.

Once the animation has ended, the user agent is expected to increment the marquee current loop index. If the element is still turned on after this, then the user agent is expected to restart the animation.

If the element's behavior attribute is in the slide state
Slide the contents of the element in the direction described by the direction attribute as defined below, such that it begins off the start side of the marquee, and ends off the end side of the marquee.

For example, if the direction attribute is left (the default), then the contents would start such that their left edge are off the side of the right edge of the marquee's content area, and the contents would then slide up to the point where the right edge of the contents are flush with the left inner edge of the marquee's content area.

Once the animation has ended, the user agent is expected to increment the marquee current loop index. If the element is still turned on after this, then the user agent is expected to restart the animation.

If the element's behavior attribute is in the alternate state
When the marquee current loop index is even (or zero), slide the contents of the element in the direction described by the direction attribute as defined below, such that it begins flush with the start side of the marquee, and ends flush with the end side of the marquee.

When the marquee current loop index is odd, slide the contents of the element in the opposite direction than that described by the direction attribute as defined below, such that it begins flush with the end side of the marquee, and ends flush with the start side of the marquee.

For example, if the direction attribute is left (the default), then the contents would with their right edge flush with the right inner edge of the marquee's content area, and the contents would then slide up to the point where the left edge of the contents are flush with the left inner edge of the marquee's content area.

Once the animation has ended, the user agent is expected to increment the marquee current loop index. If the element is still turned on after this, then the user agent is expected to continue the animation.

The direction attribute has the meanings described in the following table:

direction attribute state	Direction of animation	Start edge	End edge	Opposite direction
left	← Right to left	Right	Left	→ Left to Right
right	→ Left to Right	Left	Right	← Right to left
up	↑ Up (Bottom to Top)	Bottom	Top	↓ Down (Top to Bottom)
down	↓ Down (Top to Bottom)	Top	Bottom	↑ Up (Bottom to Top)
In any case, the animation should proceed such that there is a delay given by the marquee scroll interval between each frame, and such that the content moves at most the distance given by the marquee scroll distance with each frame.

When a marquee element has a bgcolor attribute set, the value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-color' property to the resulting color.

The width and height attributes on a marquee element map to the dimension properties 'width' and 'height' on the element respectively.

The intrinsic height of a marquee element with its direction attribute in the up or down states is 200 CSS pixels.

The vspace attribute of a marquee element maps to the dimension properties 'margin-top' and 'margin-bottom' on the element. The hspace attribute of a marquee element maps to the dimension properties 'margin-left' and 'margin-right' on the element.

The 'overflow' property on the marquee element is expected to be ignored; overflow is expected to always be hidden.

14.5.12 The meter element
The meter element is expected to render as an 'inline-block' box with a 'height' of '1em' and a 'width' of '5em', a 'vertical-align' of '-0.2em', and with its contents depicting a gauge.

When the element is wider than it is tall (or square), the depiction is expected to be of a horizontal gauge, with the minimum value on the right if the 'direction' property on this element has a computed value of 'rtl', and on the left otherwise. When the element is taller than it is wide, it is expected to depict a vertical gauge, with the minimum value on the bottom.

User agents are expected to use a presentation consistent with platform conventions for gauges, if any.

Requirements for what must be depicted in the gauge are included in the definition of the meter element.

14.5.13 The progress element
The progress element is expected to render as an 'inline-block' box with a 'height' of '1em' and a 'width' of '10em', and a 'vertical-align' of '-0.2em'.

When the element is wider than it is tall, the element is expected to be depicted as a horizontal progress bar, with the start on the right and the end on the left if the 'direction' property on this element has a computed value of 'rtl', and with the start on the left and the end on the right otherwise. When the element is taller than it is wide, it is expected to be depicted as a vertical progress bar, with the lowest value on the bottom. When the element is square, it is expected to be depicted as a direction-independent progress widget (e.g. a circular progress ring).

User agents are expected to use a presentation consistent with platform conventions for progress bars. In particular, user agents are expected to use different presentations for determinate and indeterminate progress bars. User agents are also expected to vary the presentation based on the dimensions of the element.

For example, on some platforms for showing indeterminate progress there is a "spinner" progress indicator with square dimensions, which could be used when the element is square, and an indeterminate progress bar, which could be used when the element is wide.

Requirements for how to determine if the progress bar is determinate or indeterminate, and what progress a determinate progress bar is to show, are included in the definition of the progress element.

14.5.14 The select element
A select element whose multiple attribute is present is expected to render as a multi-select list box.

A select element whose multiple attribute is absent, and whose display size is greater than 1, is expected to render as a single-select list box.

When the element renders as a list box, it is expected to render as an 'inline-block' box whose 'height' is the height necessary to contain as many rows for items as given by the element's display size, or four rows if the attribute is absent, and whose 'width' is the width of the select's labels plus the width of a scrollbar.

A select element whose multiple attribute is absent, and whose display size is 1, is expected to render as a one-line drop down box whose width is the width of the select's labels.

In either case (list box or drop-down box), the element's items are expected to be the element's list of options, with the element's optgroup element children providing headers for groups of options where applicable.

An optgroup element is expected to be rendered by displaying the element's label attribute.

An option element is expected to be rendered by displaying the element's label, indented under its optgroup element if it has one.

The width of the select's labels is the wider of the width necessary to render the widest optgroup, and the width necessary to render the widest option element in the element's list of options (including its indent, if any).

If a select element contains a placeholder label option, the user agent is expected to render that option in a manner that conveys that it is a label, rather than a valid option of the control. This can include preventing the placeholder label option from being explicitly selected by the user. When the placeholder label option's selectedness is true, the control is expected to be displayed in a fashion that indicates that no valid option is currently selected.

User agents are expected to render the labels in a select in such a manner that any alignment remains consistent whether the label is being displayed as part of the page or in a menu control.

14.5.15 The textarea element
The textarea element is expected to render as an 'inline-block' box depicting a multiline text control. If this multiline text control provides a selection, then, when the user changes the current selection, the user agent is expected to queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.

If the element has a cols attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a presentational hint for the 'width' property on the element, with the value being the textarea effective width (as defined below). Otherwise, the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'width' property on the element to the textarea effective width.

The textarea effective width of a textarea element is size×avg + sbw, where size is the element's character width, avg is the average character width of the primary font of the element, in CSS pixels, and sbw is the width of a scroll bar, in CSS pixels. (The element's 'letter-spacing' property does not affect the result.)

If the element has a rows attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a presentational hint for the 'height' property on the element, with the value being the textarea effective height (as defined below). Otherwise, the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'height' property on the element to the textarea effective height.

The textarea effective height of a textarea element is the height in CSS pixels of the number of lines specified the element's character height, plus the height of a scrollbar in CSS pixels.

User agents are expected to apply the 'white-space' CSS property to textarea elements. For historical reasons, if the element has a wrap attribute whose value is an ASCII case-insensitive match for the string "off", then the user agent is expected to treat the attribute as a presentational hint setting the element's 'white-space' property to 'pre'.

14.6 Frames and framesets
User agent are expected to render frameset elements as a box with the height and width of the viewport, with a surface rendered according to the following layout algorithm:

The cols and rows variables are lists of zero or more pairs consisting of a number and a unit, the unit being one of percentage, relative, and absolute.

Use the rules for parsing a list of dimensions to parse the value of the element's cols attribute, if there is one. Let cols be the result, or an empty list if there is no such attribute.

Use the rules for parsing a list of dimensions to parse the value of the element's rows attribute, if there is one. Let rows be the result, or an empty list if there is no such attribute.

For any of the entries in cols or rows that have the number zero and the unit relative, change the entry's number to one.

If cols has no entries, then add a single entry consisting of the value 1 and the unit relative to cols.

If rows has no entries, then add a single entry consisting of the value 1 and the unit relative to rows.

Invoke the algorithm defined below to convert a list of dimensions to a list of pixel values using cols as the input list, and the width of the surface that the frameset is being rendered into, in CSS pixels, as the input dimension. Let sized cols be the resulting list.

Invoke the algorithm defined below to convert a list of dimensions to a list of pixel values using rows as the input list, and the height of the surface that the frameset is being rendered into, in CSS pixels, as the input dimension. Let sized rows be the resulting list.

Split the surface into a grid of w×h rectangles, where w is the number of entries in sized cols and h is the number of entries in sized rows.

Size the columns so that each column in the grid is as many CSS pixels wide as the corresponding entry in the sized cols list.

Size the rows so that each row in the grid is as many CSS pixels high as the corresponding entry in the sized rows list.

Let children be the list of frame and frameset elements that are children of the frameset element for which the algorithm was invoked.

For each row of the grid of rectangles created in the previous step, from top to bottom, run these substeps:

For each rectangle in the row, from left to right, run these substeps:

If there are any elements left in children, take the first element in the list, and assign it to the rectangle.

If this is a frameset element, then recurse the entire frameset layout algorithm for that frameset element, with the rectangle as the surface.

Otherwise, it is a frame element; render its nested browsing context, positioned and sized to fit the rectangle.

If there are any elements left in children, remove the first element from children.

If the frameset element has a border, draw an outer set of borders around the rectangles, using the element's frame border color.

For each rectangle, if there is an element assigned to that rectangle, and that element has a border, draw an inner set of borders around that rectangle, using the element's frame border color.

For each (visible) border that does not abut a rectangle that is assigned a frame element with a noresize attribute (including rectangles in further nested frameset elements), the user agent is expected to allow the user to move the border, resizing the rectangles within, keeping the proportions of any nested frameset grids.

A frameset or frame element has a border if the following algorithm returns true:

If the element has a frameborder attribute whose value is not the empty string and whose first character is either a U+0031 DIGIT ONE (1) character, a U+0079 LATIN SMALL LETTER Y character (y), or a U+0059 LATIN CAPITAL LETTER Y character (Y), then return true.

Otherwise, if the element has a frameborder attribute, return false.

Otherwise, if the element has a parent element that is a frameset element, then return true if that element has a border, and false if it does not.

Otherwise, return true.

The frame border color of a frameset or frame element is the color obtained from the following algorithm:

If the element has a bordercolor attribute, and applying the rules for parsing a legacy color value to that attribute's value does not result in an error, then return the color so obtained.

Otherwise, if the element has a parent element that is a frameset element, then return the frame border color of that element.

Otherwise, return gray.

The algorithm to convert a list of dimensions to a list of pixel values consists of the following steps:

Let input list be the list of numbers and units passed to the algorithm.

Let output list be a list of numbers the same length as input list, all zero.

Entries in output list correspond to the entries in input list that have the same position.

Let input dimension be the size passed to the algorithm.

Let count percentage be the number of entries in input list whose unit is percentage.

Let total percentage be the sum of all the numbers in input list whose unit is percentage.

Let count relative be the number of entries in input list whose unit is relative.

Let total relative be the sum of all the numbers in input list whose unit is relative.

Let count absolute be the number of entries in input list whose unit is absolute.

Let total absolute be the sum of all the numbers in input list whose unit is absolute.

Let remaining space be the value of input dimension.

If total absolute is greater than remaining space, then for each entry in input list whose unit is absolute, set the corresponding value in output list to the number of the entry in input list multiplied by remaining space and divided by total absolute. Then, set remaining space to zero.

Otherwise, for each entry in input list whose unit is absolute, set the corresponding value in output list to the number of the entry in input list. Then, decrement remaining space by total absolute.

If total percentage multiplied by the input dimension and divided by 100 is greater than remaining space, then for each entry in input list whose unit is percentage, set the corresponding value in output list to the number of the entry in input list multiplied by remaining space and divided by total percentage. Then, set remaining space to zero.

Otherwise, for each entry in input list whose unit is percentage, set the corresponding value in output list to the number of the entry in input list multiplied by the input dimension and divided by 100. Then, decrement remaining space by total percentage multiplied by the input dimension and divided by 100.

For each entry in input list whose unit is relative, set the corresponding value in output list to the number of the entry in input list multiplied by remaining space and divided by total relative.

Return output list.

User agents working with integer values for frame widths (as opposed to user agents that can lay frames out with subpixel accuracy) are expected to distribute the remainder first to the last entry whose unit is relative, then equally (not proportionally) to each entry whose unit is percentage, then equally (not proportionally) to each entry whose unit is absolute, and finally, failing all else, to the last entry.

The contents of a frame element that does not have a frameset parent are expected to be rendered as transparent black; the user agent is expected to not render the nested browsing context in this case, and that nested browsing context is expected to have a viewport with zero width and zero height.

14.7 Interactive media
14.7.1 Links, forms, and navigation
User agents are expected to allow the user to control aspects of hyperlink activation and form submission, such as which browsing context is to be used for the subsequent navigation.

User agents are expected to allow users to discover the destination of hyperlinks and of forms before triggering their navigation.

User agents are expected to inform the user of whether a hyperlink includes hyperlink auditing, and to let them know at a minimum which domains will be contacted as part of such auditing.

User agents may allow users to navigate browsing contexts to the URLs indicated by the cite attributes on q, blockquote, ins, and del elements.

User agents may surface hyperlinks created by link elements in their user interface.

While link elements that create hyperlinks will match the :link or :visited pseudo-classes, will react to clicks if visible, and so forth, this does not extend to any browser interface constructs that expose those same links. Activating a link through the browser's interface, rather than in the page itself, does not trigger click events and the like.

14.7.2 The title attribute
User agents are expected to expose the advisory information of elements upon user request, and to make the user aware of the presence of such information.

On interactive graphical systems where the user can use a pointing device, this could take the form of a tooltip. When the user is unable to use a pointing device, then the user agent is expected to make the content available in some other fashion, e.g. by making the element a focusable area and always displaying the advisory information of the currently focused element, or by showing the advisory information of the elements under the user's finger on a touch device as the user pans around the screen.

U+000A LINE FEED (LF) characters are expected to cause line breaks in the tooltip; U+0009 CHARACTER TABULATION (tab) characters are expected to render as a nonzero horizontal shift that lines up the next glyph with the next tab stop, with tab stops occurring at points that are multiples of 8 times the width of a U+0020 SPACE character.

For example, a visual user agent could make elements with a title attribute focusable, and could make any focused element with a title attribute show its tooltip under the element while the element has focus. This would allow a user to tab around the document to find all the advisory text.

As another example, a screen reader could provide an audio cue when reading an element with a tooltip, with an associated key to read the last tooltip for which a cue was played.

14.7.3 Editing hosts
The current text editing caret (i.e. the active range, if it is empty and in an editing host), if any, is expected to act like an inline replaced element with the vertical dimensions of the caret and with zero width for the purposes of the CSS rendering model.

This means that even an empty block can have the caret inside it, and that when the caret is in such an element, it prevents margins from collapsing through the element.

14.7.4 Text rendered in native user interfaces
User agents are expected to honor the Unicode semantics of text that is exposed in user interfaces, for example supporting the bidirectional algorithm in text shown in dialogs, title bars, pop-up menus, and tooltips. Text from the contents of elements is expected to be rendered in a manner that honors the directionality of the element from which the text was obtained. Text from attributes is expected to be rendered in a manner that honours the directionality of the attribute.

Consider the following markup, which has Hebrew text asking for a programming language, the languages being text for which a left-to-right direction is important given the punctuation in some of their names:

<p dir="rtl" lang="he">
 <label>
  בחר שפת תכנות:
  <select>
   <option dir="ltr">C++</option>
   <option dir="ltr">C#</option>
   <option dir="ltr">FreePascal</option>
   <option dir="ltr">F#</option>
  </select>
 </label>
</p>
If the select element was rendered as a drop down box, a correct rendering would ensure that the punctuation was the same both in the drop down, and in the box showing the current selection.



The directionality of attributes depends on the attribute and on the element's dir attribute, as the following example demonstrates. Consider this markup:

<table>
 <tr>
  <th abbr="(א" dir=ltr>A
  <th abbr="(א" dir=rtl>A
  <th abbr="(א" dir=auto>A
</table>
If the abbr attributes are rendered, e.g. in a tooltip or other user interface, the first will have a left parenthesis (because the direction is 'ltr'), the second will have a right parenthesis (because the direction is 'rtl'), and the third will have a right parenthesis (because the direction is determined from the attribute value to be 'rtl').

However, if instead the attribute was not a directionality-capable attribute, the results would be different:

<table>
 <tr>
  <th data-abbr="(א" dir=ltr>A
  <th data-abbr="(א" dir=rtl>A
  <th data-abbr="(א" dir=auto>A
</table>
In this case, if the user agent were to expose the data-abbr attribute in the user interface (e.g. in a debugging environment), the last case would be rendered with a left parenthesis, because the direction would be determined from the element's contents.

A string provided by a script (e.g. the argument to window.alert()) is expected to be treated as an independent set of one or more bidirectional algorithm paragraphs when displayed, as defined by the bidirectional algorithm, including, for instance, supporting the paragraph-breaking behavior of U+000A LINE FEED (LF) characters. For the purposes of determining the paragraph level of such text in the bidirectional algorithm, this specification does not provide a higher-level override of rules P2 and P3. [BIDI]

When necessary, authors can enforce a particular direction for a given paragraph by starting it with the Unicode U+200E LEFT-TO-RIGHT MARK or U+200F RIGHT-TO-LEFT MARK characters.

Thus, the following script:

alert('\u05DC\u05DE\u05D3 HTML \u05D4\u05D9\u05D5\u05DD!')
...would always result in a message reading "למד LMTH היום!" (not "דמל HTML םויה!"), regardless of the language of the user agent interface or the direction of the page or any of its elements.

For a more complex example, consider the following script:

/* Warning: this script does not handle right-to-left scripts correctly */
var s;
if (s = prompt('What is your name?')) {
  alert(s + '! Ok, Fred, ' + s + ', and Wilma will get the car.');
}
When the user enters "Kitty", the user agent would alert "Kitty! Ok, Fred, Kitty, and Wilma will get the car.". However, if the user enters "لا أفهم", then the bidirectional algorithm will determine that the direction of the paragraph is right-to-left, and so the output will be the following unintended mess: "لا أفهم! derF ,kO, لا أفهم, rac eht teg lliw amliW dna."

To force an alert that starts with user-provided text (or other text of unknown directionality) to render left-to-right, the string can be prefixed with a U+200E LEFT-TO-RIGHT MARK character:

var s;
if (s = prompt('What is your name?')) {
  alert('\u200E' + s + '! Ok, Fred, ' + s + ', and Wilma will get the car.');
}
14.8 Print media
User agents are expected to allow the user to request the opportunity to obtain a physical form (or a representation of a physical form) of a Document. For example, selecting the option to print a page or convert it to PDF format. [PDF]

When the user actually obtains a physical form (or a representation of a physical form) of a Document, the user agent is expected to create a new rendering of the Document for the print media.

14.9 Unstyled XML documents
HTML user agents may, in certain circumstances, find themselves rendering non-HTML documents that use vocabularies for which they lack any built-in knowledge. This section provides for a way for user agents to handle such documents in a somewhat useful manner.

While a Document is an unstyled document, the user agent is expected to render an unstyled document view.

A Document is an unstyled document while it matches the following conditions:

The Document has no author style sheets (whether referenced by HTTP headers, processing instructions, elements like link, inline elements like style, or any other mechanism).
None of the elements in the Document have any presentational hints.
None of the elements in the Document have any style attributes.
None of the elements in the Document are in any of the following namespaces: HTML namespace, SVG namespace, MathML namespace
The Document has no focusable area (e.g. from XLink) other than the viewport.
The Document has no hyperlinks (e.g. from XLink).
There exists no script whose settings object specifies this Document as the responsible document.
None of the elements in the Document have any registered event listeners.
An unstyled document view is one where the DOM is not rendered according to CSS (which would, since there are no applicable styles in this context, just result in a wall of text), but is instead rendered in a manner that is useful for a developer. This could consist of just showing the Document object's source, maybe with syntax highlighting, or it could consist of displaying just the DOM tree, or simply a message saying that the page is not a styled document.

If a Document stops being an unstyled document, then the conditions above stop applying, and thus a user agent following these requirements will switch to using the regular CSS rendering.

15 Obsolete features
15.1 Obsolete but conforming features
Features listed in this section will trigger warnings in conformance checkers.

Authors should not specify a border attribute on an img element. If the attribute is present, its value must be the string "0". CSS should be used instead.

Authors should not specify a charset attribute on a script element. If the attribute is present, its value must be an ASCII case-insensitive match for "utf-8". (This has no effect in a document that conforms to the requirements elsewhere in this standard of being encoded as UTF-8.)

Authors should not specify a language attribute on a script element. If the attribute is present, its value must be an ASCII case-insensitive match for the string "JavaScript" and either the type attribute must be omitted or its value must be an ASCII case-insensitive match for the string "text/javascript". The attribute should be entirely omitted instead (with the value "JavaScript", it has no effect), or replaced with use of the type attribute.

Authors should not specify a value for the type attribute on script elements that is the empty string or a JavaScript MIME type essence match. Instead, they should omit the attribute, which has the same effect.

Authors should not specify a type attribute on a style element. If the attribute is present, its value must be an ASCII case-insensitive match for "text/css".

Authors should not specify the name attribute on a elements. If the attribute is present, its value must not be the empty string and must neither be equal to the value of any of the IDs in the element's tree other than the element's own ID, if any, nor be equal to the value of any of the other name attributes on a elements in the element's tree. If this attribute is present and the element has an ID, then the attribute's value must be equal to the element's ID. In earlier versions of the language, this attribute was intended as a way to specify possible targets for fragments in URLs. The id attribute should be used instead.

Authors should not, but may despite requirements to the contrary elsewhere in this specification, specify the maxlength and size attributes on input elements whose type attributes are in the Number state. One valid reason for using these attributes regardless is to help legacy user agents that do not support input elements with type="number" to still render the text control with a useful width.

15.1.1 Warnings for obsolete but conforming features
To ease the transition from HTML4 Transitional documents to the language defined in this specification, and to discourage certain features that are only allowed in very few circumstances, conformance checkers must warn the user when the following features are used in a document. These are generally old obsolete features that have no effect, and are allowed only to distinguish between likely mistakes (regular conformance errors) and mere vestigial markup or unusual and discouraged practices (these warnings).

The following features must be categorized as described above:

The presence of a border attribute on an img element if its value is the string "0".

The presence of a charset attribute on a script element if its value is an ASCII case-insensitive match for "utf-8".

The presence of a language attribute on a script element if its value is an ASCII case-insensitive match for the string "JavaScript" and if there is no type attribute or there is and its value is an ASCII case-insensitive match for the string "text/javascript".

The presence of a type attribute on a script element if its value is a JavaScript MIME type essence match.

The presence of a type attribute on a style element if its value is an ASCII case-insensitive match for "text/css".

The presence of a name attribute on an a element, if its value is not the empty string.

The presence of a maxlength attribute on an input element whose type attribute is in the Number state.

The presence of a size attribute on an input element whose type attribute is in the Number state.

Conformance checkers must distinguish between pages that have no conformance errors and have none of these obsolete features, and pages that have no conformance errors but do have some of these obsolete features.

For example, a validator could report some pages as "Valid HTML" and others as "Valid HTML with warnings".

15.2 Non-conforming features
Elements in the following list are entirely obsolete, and must not be used by authors:

applet
Use embed or object instead.

acronym
Use abbr instead.

bgsound
Use audio instead.

dir
Use ul instead.

frame
frameset
noframes
Either use iframe and CSS instead, or use server-side includes to generate complete pages with the various invariant parts merged in.

isindex
Use an explicit form and text control combination instead.

keygen
For enterprise device management use cases, use native on-device management capabilities.

For certificate enrollment use cases, use the Web Cryptography API to generate a keypair for the certificate, and then export the certificate and key to allow the user to install them manually. [WEBCRYPTO]

listing
Use pre and code instead.

menuitem
To implement a custom context menu, use script to handle the contextmenu event.

nextid
Use GUIDs instead.

noembed
Use object instead of embed when fallback is necessary.

plaintext
Use the "text/plain" MIME type instead.

rb
rtc
Providing the ruby base directly inside the ruby element or using nested ruby elements is sufficient.

strike
Use del instead if the element is marking an edit, otherwise use s instead.

xmp
Use pre and code instead, and escape "<" and "&" characters as "&lt;" and "&amp;" respectively.

basefont
big
blink
center
font
marquee
multicol
nobr
spacer
tt
Use appropriate elements or CSS instead.

Where the tt element would have been used for marking up keyboard input, consider the kbd element; for variables, consider the var element; for computer code, consider the code element; and for computer output, consider the samp element.

Similarly, if the big element is being used to denote a heading, consider using the h1 element; if it is being used for marking up important passages, consider the strong element; and if it is being used for highlighting text for reference purposes, consider the mark element.

See also the text-level semantics usage summary for more suggestions with examples.

The following attributes are obsolete (though the elements are still part of the language), and must not be used by authors:

charset on a elements
charset on link elements
Use an HTTP `Content-Type` header on the linked resource instead.

charset on script elements (except as noted in the previous section)
Omit the attribute. Both documents and scripts are required to use UTF-8, so it is redundant to specify it on the script element since it inherits from the document.

coords on a elements
shape on a elements
Use area instead of a for image maps.

methods on a elements
methods on link elements
Use the HTTP OPTIONS feature instead.

name on a elements (except as noted in the previous section)
name on embed elements
name on img elements
name on option elements
Use the id attribute instead.

rev on a elements
rev on link elements
Use the rel attribute instead, with an opposite term. (For example, instead of rev="made", use rel="author".)

urn on a elements
urn on link elements
Specify the preferred persistent identifier using the href attribute instead.

accept on form elements
Use the accept attribute directly on the input elements instead.

hreflang on area elements
type on area elements
These attributes do not do anything useful, and for historical reasons there are no corresponding IDL attributes on area elements. Omit them altogether.

nohref on area elements
Omitting the href attribute is sufficient; the nohref attribute is unnecessary. Omit it altogether.

profile on head elements
Unnecessary. Omit it altogether.

version on html elements
Unnecessary. Omit it altogether.

ismap on input elements
Unnecessary. Omit it altogether. All input elements with a type attribute in the Image Button state are processed as server-side image maps.

usemap on input elements
Use img instead of input for image maps.

longdesc on iframe elements
longdesc on img elements
Use a regular a element to link to the description, or (in the case of images) use an image map to provide a link from the image to the image's description.

lowsrc on img elements
Use a progressive JPEG image (given in the src attribute), instead of using two separate images.

target on link elements
Unnecessary. Omit it altogether.

type on menu elements
To implement a custom context menu, use script to handle the contextmenu event. For toolbar menus, omit the attribute.

label on menu elements
contextmenu on all elements
onshow on all elements
To implement a custom context menu, use script to handle the contextmenu event.

scheme on meta elements
Use only one scheme per field, or make the scheme declaration part of the value.

archive on object elements
classid on object elements
code on object elements
codebase on object elements
codetype on object elements
Use the data and type attributes to invoke plugins. To set parameters with these names in particular, the param element can be used.

declare on object elements
Repeat the object element completely each time the resource is to be reused.

standby on object elements
Optimize the linked resource so that it loads quickly or, at least, incrementally.

type on param elements
valuetype on param elements
Use the name and value attributes without declaring value types.

language on script elements (except as noted in the previous section)
Omit the attribute for JavaScript; for data blocks, use the type attribute instead.

event on script elements
for on script elements
Use DOM events mechanisms to register event listeners. [DOM]

type on style elements (except as noted in the previous section)
Omit the attribute for CSS; for data blocks, use script as the container instead of style.

datapagesize on table elements
Unnecessary. Omit it altogether.

summary on table elements
Use one of the techniques for describing tables given in the table section instead.

abbr on td elements
Use text that begins in an unambiguous and terse manner, and include any more elaborate text after that. The title attribute can also be useful in including more detailed text, so that the cell's contents can be made terse. If it's a heading, use th (which has an abbr attribute).

axis on td and th elements
Use the scope attribute on the relevant th.

scope on td elements
Use th elements for heading cells.

datasrc on a, button, div, frame, iframe, img, input, label, legend, marquee, object, option, select, span, table, and textarea elements
datafld on a, button, div, fieldset, frame, iframe, img, input, label, legend, marquee, object, param, select, span, and textarea elements
dataformatas on button, div, input, label, legend, marquee, object, option, select, span, and table elements
Use script and a mechanism such as XMLHttpRequest to populate the page dynamically. [XHR]

dropzone on all elements
Use script to handle the dragenter and dragover events instead.

alink on body elements
bgcolor on body elements
bottommargin on body elements
leftmargin on body elements
link on body elements
marginheight on body elements
marginwidth on body elements
rightmargin on body elements
text on body elements
margintop on body elements
vlink on body elements
clear on br elements
align on caption elements
align on col elements
char on col elements
charoff on col elements
valign on col elements
width on col elements
align on div elements
compact on dl elements
align on embed elements
hspace on embed elements
vspace on embed elements
align on hr elements
color on hr elements
noshade on hr elements
size on hr elements
width on hr elements
align on h1—h6 elements
align on iframe elements
allowtransparency on iframe elements
frameborder on iframe elements
framespacing on iframe elements
hspace on iframe elements
marginheight on iframe elements
marginwidth on iframe elements
scrolling on iframe elements
vspace on iframe elements
align on input elements
border on input elements
hspace on input elements
vspace on input elements
align on img elements
border on img elements (except as noted in the previous section)
hspace on img elements
vspace on img elements
align on legend elements
type on li elements
compact on menu elements
align on object elements
border on object elements
hspace on object elements
vspace on object elements
compact on ol elements
align on p elements
width on pre elements
align on table elements
bgcolor on table elements
border on table elements
bordercolor on table elements
cellpadding on table elements
cellspacing on table elements
frame on table elements
height on table elements
rules on table elements
width on table elements
align on tbody, thead, and tfoot elements
char on tbody, thead, and tfoot elements
charoff on tbody, thead, and tfoot elements
valign on tbody, thead, and tfoot elements
align on td and th elements
bgcolor on td and th elements
char on td and th elements
charoff on td and th elements
height on td and th elements
nowrap on td and th elements
valign on td and th elements
width on td and th elements
align on tr elements
bgcolor on tr elements
char on tr elements
charoff on tr elements
height on tr elements
valign on tr elements
compact on ul elements
type on ul elements
background on body, table, thead, tbody, tfoot, tr, td, and th elements
Use CSS instead.

15.3 Requirements for implementations
15.3.1 The marquee element
The marquee element is a presentational element that animates content. CSS transitions and animations are a more appropriate mechanism. [CSSANIMATIONS] [CSSTRANSITIONS]

The task source for tasks mentioned in this section is the DOM manipulation task source.

The marquee element must implement the HTMLMarqueeElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLMarqueeElement : HTMLElement {
  [CEReactions] attribute DOMString behavior;
  [CEReactions] attribute DOMString bgColor;
  [CEReactions] attribute DOMString direction;
  [CEReactions] attribute DOMString height;
  [CEReactions] attribute unsigned long hspace;
  [CEReactions] attribute long loop;
  [CEReactions] attribute unsigned long scrollAmount;
  [CEReactions] attribute unsigned long scrollDelay;
  [CEReactions] attribute boolean trueSpeed;
  [CEReactions] attribute unsigned long vspace;
  [CEReactions] attribute DOMString width;

  attribute EventHandler onbounce;
  attribute EventHandler onfinish;
  attribute EventHandler onstart;

  void start();
  void stop();
};
A marquee element can be turned on or turned off. When it is created, it is turned on.

When the start() method is called, the marquee element must be turned on.

When the stop() method is called, the marquee element must be turned off.

When a marquee element is created, the user agent must queue a task to fire an event named start at the element.

The behavior content attribute on marquee elements is an enumerated attribute with the following keywords (all non-conforming):

Keyword	State
scroll	scroll
slide	slide
alternate	alternate
The missing value default and invalid value default are the scroll state.

The direction content attribute on marquee elements is an enumerated attribute with the following keywords (all non-conforming):

Keyword	State
left	left
right	right
up	up
down	down
The missing value default and invalid value default are the left state.

The truespeed content attribute on marquee elements is a boolean attribute.

A marquee element has a marquee scroll interval, which is obtained as follows:

If the element has a scrolldelay attribute, and parsing its value using the rules for parsing non-negative integers does not return an error, then let delay be the parsed value. Otherwise, let delay be 85.

If the element does not have a truespeed attribute, and the delay value is less than 60, then let delay be 60 instead.

The marquee scroll interval is delay, interpreted in milliseconds.

A marquee element has a marquee scroll distance, which, if the element has a scrollamount attribute, and parsing its value using the rules for parsing non-negative integers does not return an error, is the parsed value interpreted in CSS pixels, and otherwise is 6 CSS pixels.

A marquee element has a marquee loop count, which, if the element has a loop attribute, and parsing its value using the rules for parsing integers does not return an error or a number less than 1, is the parsed value, and otherwise is −1.

The loop IDL attribute, on getting, must return the element's marquee loop count; and on setting, if the new value is different than the element's marquee loop count and either greater than zero or equal to −1, must set the element's loop content attribute (adding it if necessary) to the valid integer that represents the new value. (Other values are ignored.)

A marquee element also has a marquee current loop index, which is zero when the element is created.

The rendering layer will occasionally increment the marquee current loop index, which must cause the following steps to be run:

If the marquee loop count is −1, then return.

Increment the marquee current loop index by one.

If the marquee current loop index is now equal to or greater than the element's marquee loop count, turn off the marquee element and queue a task to fire an event named finish at the marquee element.

Otherwise, if the behavior attribute is in the alternate state, then queue a task to fire an event named bounce at the marquee element.

Otherwise, queue a task to fire an event named start at the marquee element.

The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler content attributes and event handler IDL attributes, by marquee elements:

Event handler	Event handler event type
onbounce	bounce
onfinish	finish
onstart	start
The behavior, direction, height, hspace, vspace, and width IDL attributes must reflect the respective content attributes of the same name.

The bgColor IDL attribute must reflect the bgcolor content attribute.

The scrollAmount IDL attribute must reflect the scrollamount content attribute. The default value is 6.

The scrollDelay IDL attribute must reflect the scrolldelay content attribute. The default value is 85.

The trueSpeed IDL attribute must reflect the truespeed content attribute.

15.3.2 Frames
The frameset element acts as the body element in documents that use frames.

The frameset element must implement the HTMLFrameSetElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLFrameSetElement : HTMLElement {
  [CEReactions] attribute DOMString cols;
  [CEReactions] attribute DOMString rows;
};
HTMLFrameSetElement includes WindowEventHandlers;
The cols and rows IDL attributes of the frameset element must reflect the respective content attributes of the same name.

The frameset element exposes as event handler content attributes a number of the event handlers of the Window object. It also mirrors their event handler IDL attributes.

The onblur, onerror, onfocus, onload, onresize, and onscroll event handlers of the Window object, exposed on the frameset element, replace the generic event handlers with the same names normally supported by HTML elements.

The frame element defines a nested browsing context similar to the iframe element, but rendered within a frameset element.

A frame element is said to be an active frame element when it is in a document.

When a frame element is created as an active frame element, or becomes an active frame element after not having been one, the user agent must create a new browsing context, set the element's nested browsing context to the newly-created browsing context, and then process the frame attributes for the first time. If the element has a name attribute, the browsing context name must be set to the value of this attribute; otherwise, the browsing context name must be set to the empty string.

When a frame element stops being an active frame element, the user agent must discard the element's nested browsing context, and then set the element's nested browsing context to null.

Whenever a frame element with a non-null nested browsing context has its src attribute set, changed, or removed, the user agent must process the frame attributes.

When the user agent is to process the frame attributes, it must run the first appropriate steps from the following list:

If the element has no src attribute specified, and the user agent is processing the frame's attributes for the first time
Queue a task to fire an event named load at the frame element using the DOM manipulation task source.

Otherwise
Run the otherwise steps for iframe or frame elements.

Any navigation required of the user agent in the process the frame attributes algorithm must use the frame element's node document's browsing context as the source browsing context.

Furthermore, if the active document of the element's nested browsing context before such a navigation was not completely loaded at the time of the new navigation, then the navigation must be completed with replacement enabled.

Similarly, if the nested browsing context's session history contained only one Document when the process the frame attributes algorithm was invoked, and that was the about:blank Document created when the nested browsing context was created, then any navigation required of the user agent in that algorithm must be completed with replacement enabled.

When a Document in a frame is marked as completely loaded, the user agent must fire an event named load at the frame element.

When a frame element has a non-null nested browsing context, and its nested browsing context's active document is not ready for post-load tasks, and when anything is delaying the load event of the frame element's browsing context's active document, and when the frame element's browsing context is in the delaying load events mode, the frame must delay the load event of its document.

Whenever the name attribute is set and the frame element's nested browsing context is non-null, the nested browsing context's name must be changed to the new value. If the attribute is removed, the browsing context name must be set to the empty string.

The frame element must implement the HTMLFrameElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLFrameElement : HTMLElement {
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString scrolling;
  [CEReactions] attribute USVString src;
  [CEReactions] attribute DOMString frameBorder;
  [CEReactions] attribute USVString longDesc;
  [CEReactions] attribute boolean noResize;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString marginHeight;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString marginWidth;
};
The name, scrolling, and src IDL attributes of the frame element must reflect the respective content attributes of the same name. For the purposes of reflection, the frame element's src content attribute is defined as containing a URL.

The frameBorder IDL attribute of the frame element must reflect the element's frameborder content attribute.

The longDesc IDL attribute of the frame element must reflect the element's longdesc content attribute, which for the purposes of reflection is defined as containing a URL.

The noResize IDL attribute of the frame element must reflect the element's noresize content attribute.

The contentDocument IDL attribute, on getting, must return the frame element's content document.

The contentWindow IDL attribute must return the WindowProxy object of the frame element's nested browsing context, if the element's nested browsing context is non-null, or return null otherwise.

The marginHeight IDL attribute of the frame element must reflect the element's marginheight content attribute.

The marginWidth IDL attribute of the frame element must reflect the element's marginwidth content attribute.

15.3.3 Other elements, attributes and APIs
User agents must treat acronym elements in a manner equivalent to abbr elements in terms of semantics and for purposes of rendering.

partial interface HTMLAnchorElement {
  [CEReactions] attribute DOMString coords;
  [CEReactions] attribute DOMString charset;
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute DOMString rev;
  [CEReactions] attribute DOMString shape;
};
The coords, charset, name, rev, and shape IDL attributes of the a element must reflect the respective content attributes of the same name.

partial interface HTMLAreaElement {
  [CEReactions] attribute boolean noHref;
};
The noHref IDL attribute of the area element must reflect the element's nohref content attribute.

partial interface HTMLBodyElement {
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString text;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString link;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vLink;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString aLink;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;
  [CEReactions] attribute DOMString background;
};
The text IDL attribute of the body element must reflect the element's text content attribute.

The link IDL attribute of the body element must reflect the element's link content attribute.

The aLink IDL attribute of the body element must reflect the element's alink content attribute.

The vLink IDL attribute of the body element must reflect the element's vlink content attribute.

The bgColor IDL attribute of the body element must reflect the element's bgcolor content attribute.

The background IDL attribute of the body element must reflect the element's background content attribute. (The background content is not defined to contain a URL, despite rules regarding its handling in the rendering section above.)

partial interface HTMLBRElement {
  [CEReactions] attribute DOMString clear;
};
The clear IDL attribute of the br element must reflect the content attribute of the same name.

partial interface HTMLTableCaptionElement {
  [CEReactions] attribute DOMString align;
};
The align IDL attribute of the caption element must reflect the content attribute of the same name.

partial interface HTMLTableColElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString ch;
  [CEReactions] attribute DOMString chOff;
  [CEReactions] attribute DOMString vAlign;
  [CEReactions] attribute DOMString width;
};
The align and width IDL attributes of the col element must reflect the respective content attributes of the same name.

The ch IDL attribute of the col element must reflect the element's char content attribute.

The chOff IDL attribute of the col element must reflect the element's charoff content attribute.

The vAlign IDL attribute of the col element must reflect the element's valign content attribute.

User agents must treat dir elements in a manner equivalent to ul elements in terms of semantics and for purposes of rendering.

The dir element must implement the HTMLDirectoryElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLDirectoryElement : HTMLElement {
  [CEReactions] attribute boolean compact;
};
The compact IDL attribute of the dir element must reflect the content attribute of the same name.

partial interface HTMLDivElement {
  [CEReactions] attribute DOMString align;
};
The align IDL attribute of the div element must reflect the content attribute of the same name.

partial interface HTMLDListElement {
  [CEReactions] attribute boolean compact;
};
The compact IDL attribute of the dl element must reflect the content attribute of the same name.

partial interface HTMLEmbedElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString name;
};
The name and align IDL attributes of the embed element must reflect the respective content attributes of the same name.

The font element must implement the HTMLFontElement interface.

[Exposed=Window,
 HTMLConstructor]
interface HTMLFontElement : HTMLElement {
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString color;
  [CEReactions] attribute DOMString face;
  [CEReactions] attribute DOMString size;
};
The color, face, and size IDL attributes of the font element must reflect the respective content attributes of the same name.

partial interface HTMLHeadingElement {
  [CEReactions] attribute DOMString align;
};
The align IDL attribute of the h1–h6 elements must reflect the content attribute of the same name.

The profile IDL attribute on head elements (with the HTMLHeadElement interface) is intentionally omitted. Unless so required by another applicable specification, implementations would therefore not support this attribute. (It is mentioned here as it was defined in a previous version of the DOM specifications.)

partial interface HTMLHRElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString color;
  [CEReactions] attribute boolean noShade;
  [CEReactions] attribute DOMString size;
  [CEReactions] attribute DOMString width;
};
The align, color, size, and width IDL attributes of the hr element must reflect the respective content attributes of the same name.

The noShade IDL attribute of the hr element must reflect the element's noshade content attribute.

partial interface HTMLHtmlElement {
  [CEReactions] attribute DOMString version;
};
The version IDL attribute of the html element must reflect the content attribute of the same name.

partial interface HTMLIFrameElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString scrolling;
  [CEReactions] attribute DOMString frameBorder;
  [CEReactions] attribute USVString longDesc;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString marginHeight;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString marginWidth;
};
The align and scrolling IDL attributes of the iframe element must reflect the respective content attributes of the same name.

The frameBorder IDL attribute of the iframe element must reflect the element's frameborder content attribute.

The longDesc IDL attribute of the iframe element must reflect the element's longdesc content attribute, which for the purposes of reflection is defined as containing a URL.

The marginHeight IDL attribute of the iframe element must reflect the element's marginheight content attribute.

The marginWidth IDL attribute of the iframe element must reflect the element's marginwidth content attribute.

partial interface HTMLImageElement {
  [CEReactions] attribute DOMString name;
  [CEReactions] attribute USVString lowsrc;
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute unsigned long hspace;
  [CEReactions] attribute unsigned long vspace;
  [CEReactions] attribute USVString longDesc;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString border;
};
The name, align, border, hspace, and vspace IDL attributes of the img element must reflect the respective content attributes of the same name.

The longDesc IDL attribute of the img element must reflect the element's longdesc content attribute, which for the purposes of reflection is defined as containing a URL.

The lowsrc IDL attribute of the img element must reflect the element's lowsrc content attribute, which for the purposes of reflection is defined as containing a URL.

partial interface HTMLInputElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString useMap;
};
The align IDL attribute of the input element must reflect the content attribute of the same name.

The useMap IDL attribute of the input element must reflect the element's usemap content attribute.

partial interface HTMLLegendElement {
  [CEReactions] attribute DOMString align;
};
The align IDL attribute of the legend element must reflect the content attribute of the same name.

partial interface HTMLLIElement {
  [CEReactions] attribute DOMString type;
};
The type IDL attribute of the li element must reflect the content attribute of the same name.

partial interface HTMLLinkElement {
  [CEReactions] attribute DOMString charset;
  [CEReactions] attribute DOMString rev;
  [CEReactions] attribute DOMString target;
};
The charset, rev, and target IDL attributes of the link element must reflect the respective content attributes of the same name.

User agents must treat listing elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering.

partial interface HTMLMenuElement {
  [CEReactions] attribute boolean compact;
};
The compact IDL attribute of the menu element must reflect the content attribute of the same name.

partial interface HTMLMetaElement {
  [CEReactions] attribute DOMString scheme;
};
User agents may treat the scheme content attribute on the meta element as an extension of the element's name content attribute when processing a meta element with a name attribute whose value is one that the user agent recognizes as supporting the scheme attribute.

User agents are encouraged to ignore the scheme attribute and instead process the value given to the metadata name as if it had been specified for each expected value of the scheme attribute.

For example, if the user agent acts on meta elements with name attributes having the value "eGMS.subject.keyword", and knows that the scheme attribute is used with this metadata name, then it could take the scheme attribute into account, acting as if it was an extension of the name attribute. Thus the following two meta elements could be treated as two elements giving values for two different metadata names, one consisting of a combination of "eGMS.subject.keyword" and "LGCL", and the other consisting of a combination of "eGMS.subject.keyword" and "ORLY":

<!-- this markup is invalid -->
<meta name="eGMS.subject.keyword" scheme="LGCL" content="Abandoned vehicles">
<meta name="eGMS.subject.keyword" scheme="ORLY" content="Mah car: kthxbye">
The suggested processing of this markup, however, would be equivalent to the following:

<meta name="eGMS.subject.keyword" content="Abandoned vehicles">
<meta name="eGMS.subject.keyword" content="Mah car: kthxbye">
The scheme IDL attribute of the meta element must reflect the content attribute of the same name.

partial interface HTMLObjectElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString archive;
  [CEReactions] attribute DOMString code;
  [CEReactions] attribute boolean declare;
  [CEReactions] attribute unsigned long hspace;
  [CEReactions] attribute DOMString standby;
  [CEReactions] attribute unsigned long vspace;
  [CEReactions] attribute DOMString codeBase;
  [CEReactions] attribute DOMString codeType;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString border;
};
The align, archive, border, code, declare, hspace, standby, and vspace IDL attributes of the object element must reflect the respective content attributes of the same name.

The codeBase IDL attribute of the object element must reflect the element's codebase content attribute, which for the purposes of reflection is defined as containing a URL.

The codeType IDL attribute of the object element must reflect the element's codetype content attribute.

partial interface HTMLOListElement {
  [CEReactions] attribute boolean compact;
};
The compact IDL attribute of the ol element must reflect the content attribute of the same name.

partial interface HTMLParagraphElement {
  [CEReactions] attribute DOMString align;
};
The align IDL attribute of the p element must reflect the content attribute of the same name.

partial interface HTMLParamElement {
  [CEReactions] attribute DOMString type;
  [CEReactions] attribute DOMString valueType;
};
The type IDL attribute of the param element must reflect the content attribute of the same name.

The valueType IDL attribute of the param element must reflect the element's valuetype content attribute.

User agents must treat plaintext elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering. (The parser has special behavior for this element, though.)

partial interface HTMLPreElement {
  [CEReactions] attribute long width;
};
The width IDL attribute of the pre element must reflect the content attribute of the same name.

partial interface HTMLStyleElement {
  [CEReactions] attribute DOMString type;
};
The type IDL attribute of the style element must reflect the element's type content attribute.

partial interface HTMLScriptElement {
  [CEReactions] attribute DOMString charset;
  [CEReactions] attribute DOMString event;
  [CEReactions] attribute DOMString htmlFor;
};
The charset and event IDL attributes of the script element must reflect the respective content attributes of the same name.

The htmlFor IDL attribute of the script element must reflect the element's for content attribute.

partial interface HTMLTableElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString border;
  [CEReactions] attribute DOMString frame;
  [CEReactions] attribute DOMString rules;
  [CEReactions] attribute DOMString summary;
  [CEReactions] attribute DOMString width;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString cellPadding;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString cellSpacing;
};
The align, border, frame, summary, rules, and width, IDL attributes of the table element must reflect the respective content attributes of the same name.

The bgColor IDL attribute of the table element must reflect the element's bgcolor content attribute.

The cellPadding IDL attribute of the table element must reflect the element's cellpadding content attribute.

The cellSpacing IDL attribute of the table element must reflect the element's cellspacing content attribute.

partial interface HTMLTableSectionElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString ch;
  [CEReactions] attribute DOMString chOff;
  [CEReactions] attribute DOMString vAlign;
};
The align IDL attribute of the tbody, thead, and tfoot elements must reflect the content attribute of the same name.

The ch IDL attribute of the tbody, thead, and tfoot elements must reflect the elements' char content attributes.

The chOff IDL attribute of the tbody, thead, and tfoot elements must reflect the elements' charoff content attributes.

The vAlign IDL attribute of the tbody, thead, and tfoot element must reflect the elements' valign content attributes.

partial interface HTMLTableCellElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString axis;
  [CEReactions] attribute DOMString height;
  [CEReactions] attribute DOMString width;

  [CEReactions] attribute DOMString ch;
  [CEReactions] attribute DOMString chOff;
  [CEReactions] attribute boolean noWrap;
  [CEReactions] attribute DOMString vAlign;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;
};
The align, axis, height, and width IDL attributes of the td and th elements must reflect the respective content attributes of the same name.

The ch IDL attribute of the td and th elements must reflect the elements' char content attributes.

The chOff IDL attribute of the td and th elements must reflect the elements' charoff content attributes.

The noWrap IDL attribute of the td and th elements must reflect the elements' nowrap content attributes.

The vAlign IDL attribute of the td and th elements must reflect the elements' valign content attributes.

The bgColor IDL attribute of the td and th elements must reflect the elements' bgcolor content attributes.

partial interface HTMLTableRowElement {
  [CEReactions] attribute DOMString align;
  [CEReactions] attribute DOMString ch;
  [CEReactions] attribute DOMString chOff;
  [CEReactions] attribute DOMString vAlign;

  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;
};
The align IDL attribute of the tr element must reflect the content attribute of the same name.

The ch IDL attribute of the tr element must reflect the element's char content attribute.

The chOff IDL attribute of the tr element must reflect the element's charoff content attribute.

The vAlign IDL attribute of the tr element must reflect the element's valign content attribute.

The bgColor IDL attribute of the tr element must reflect the element's bgcolor content attribute.

partial interface HTMLUListElement {
  [CEReactions] attribute boolean compact;
  [CEReactions] attribute DOMString type;
};
The compact and type IDL attributes of the ul element must reflect the respective content attributes of the same name.

User agents must treat xmp elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering. (The parser has special behavior for this element though.)

partial interface Document {
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString linkColor;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor;
  [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;

  [SameObject] readonly attribute HTMLCollection anchors;
  [SameObject] readonly attribute HTMLCollection applets;

  void clear();
  void captureEvents();
  void releaseEvents();

  [SameObject] readonly attribute HTMLAllCollection all;
};
The attributes of the Document object listed in the first column of the following table must reflect the content attribute on the body element with the name given in the corresponding cell in the second column on the same row, if the body element is a body element (as opposed to a frameset element). When there is no body element or if it is a frameset element, the attributes must instead return the empty string on getting and do nothing on setting.

IDL attribute	Content attribute
fgColor	text
linkColor	link
vlinkColor	vlink
alinkColor	alink
bgColor	bgcolor
The anchors attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with name attributes.

The applets attribute must return an HTMLCollection rooted at the Document node, whose filter matches nothing. (It exists for historical reasons.)

The clear(), captureEvents(), and releaseEvents() methods must do nothing.

The all attribute must return an HTMLAllCollection rooted at the Document node, whose filter matches all elements.

partial interface Window {
  void captureEvents();
  void releaseEvents();

  [Replaceable, SameObject] readonly attribute External external;
};
The captureEvents() and releaseEvents() methods must do nothing.

The external attribute of the Window interface must return an instance of the External interface:

[Exposed=Window,
 NoInterfaceObject]
interface External {
  void AddSearchProvider();
  void IsSearchProviderInstalled();
};
The AddSearchProvider() and IsSearchProviderInstalled() methods must do nothing.

16 IANA considerations
16.1 text/html
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
text
Subtype name:
html
Required parameters:
No required parameters
Optional parameters:
charset
The charset parameter may be provided to specify the document's character encoding, overriding any character encoding declarations in the document other than a Byte Order Mark (BOM). The parameter's value must be an ASCII case-insensitive match for the string "utf-8". [ENCODING]

Encoding considerations:
8bit (see the section on character encoding declarations)
Security considerations:
Entire novels have been written about the security considerations that apply to HTML documents. Many are listed in this document, to which the reader is referred for more details. Some general concerns bear mentioning here, however:

HTML is scripted language, and has a large number of APIs (some of which are described in this document). Script can expose the user to potential risks of information leakage, credential leakage, cross-site scripting attacks, cross-site request forgeries, and a host of other problems. While the designs in this specification are intended to be safe if implemented correctly, a full implementation is a massive undertaking and, as with any software, user agents are likely to have security bugs.

Even without scripting, there are specific features in HTML which, for historical reasons, are required for broad compatibility with legacy content but that expose the user to unfortunate security problems. In particular, the img element can be used in conjunction with some other features as a way to effect a port scan from the user's location on the Internet. This can expose local network topologies that the attacker would otherwise not be able to determine.

HTML relies on a compartmentalization scheme sometimes known as the same-origin policy. An origin in most cases consists of all the pages served from the same host, on the same port, using the same protocol.

It is critical, therefore, to ensure that any untrusted content that forms part of a site be hosted on a different origin than any sensitive content on that site. Untrusted content can easily spoof any other page on the same origin, read data from that origin, cause scripts in that origin to execute, submit forms to and from that origin even if they are protected from cross-site request forgery attacks by unique tokens, and make use of any third-party resources exposed to or rights granted to that origin.

Interoperability considerations:
Rules for processing both conforming and non-conforming content are defined in this specification.
Published specification:
This document is the relevant specification. Labeling a resource with the text/html type asserts that the resource is an HTML document using the HTML syntax.
Applications that use this media type:
Web browsers, tools for processing Web content, HTML authoring tools, search engines, validators.
Additional information:
Magic number(s):
No sequence of bytes can uniquely identify an HTML document. More information on detecting HTML documents is available in the WHATWG MIME Sniffing standard. [MIMESNIFF]
File extension(s):
"html" and "htm" are commonly, but certainly not exclusively, used as the extension for HTML documents.
Macintosh file type code(s):
TEXT
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
No restrictions apply.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments used with text/html resources either refer to the indicated part of the document or provide state information for in-page scripts.

16.2 multipart/x-mixed-replace
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
multipart
Subtype name:
x-mixed-replace
Required parameters:
boundary (defined in RFC2046) [RFC2046]
Optional parameters:
No optional parameters.
Encoding considerations:
binary
Security considerations:
Subresources of a multipart/x-mixed-replace resource can be of any type, including types with non-trivial security implications such as text/html.
Interoperability considerations:
None.
Published specification:
This specification describes processing rules for Web browsers. Conformance requirements for generating resources with this type are the same as for multipart/mixed. [RFC2046]
Applications that use this media type:
This type is intended to be used in resources generated by Web servers, for consumption by Web browsers.
Additional information:
Magic number(s):
No sequence of bytes can uniquely identify a multipart/x-mixed-replace resource.
File extension(s):
No specific file extensions are recommended for this type.
Macintosh file type code(s):
No specific Macintosh file type codes are recommended for this type.
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
No restrictions apply.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments used with multipart/x-mixed-replace resources apply to each body part as defined by the type used by that body part.

16.3 application/xhtml+xml
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
application
Subtype name:
xhtml+xml
Required parameters:
Same as for application/xml [RFC7303]
Optional parameters:
Same as for application/xml [RFC7303]
Encoding considerations:
Same as for application/xml [RFC7303]
Security considerations:
Same as for application/xml [RFC7303]
Interoperability considerations:
Same as for application/xml [RFC7303]
Published specification:
Labeling a resource with the application/xhtml+xml type asserts that the resource is an XML document that likely has a document element from the HTML namespace. Thus, the relevant specifications are the XML specification, the Namespaces in XML specification, and this specification. [XML] [XMLNS]
Applications that use this media type:
Same as for application/xml [RFC7303]
Additional information:
Magic number(s):
Same as for application/xml [RFC7303]
File extension(s):
"xhtml" and "xht" are sometimes used as extensions for XML resources that have a document element from the HTML namespace.
Macintosh file type code(s):
TEXT
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
No restrictions apply.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments used with application/xhtml+xml resources have the same semantics as with any XML MIME type. [RFC7303]

16.4 text/cache-manifest
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
text
Subtype name:
cache-manifest
Required parameters:
No parameters
Optional parameters:
charset
The charset parameter may be provided. The parameter's value must be "utf-8". This parameter serves no purpose; it is only allowed for compatibility with legacy servers.

Encoding considerations:
8bit (always UTF-8)
Security considerations:
Cache manifests themselves pose no immediate risk unless sensitive information is included within the manifest. Implementations, however, are required to follow specific rules when populating a cache based on a cache manifest, to ensure that certain origin-based restrictions are honored. Failure to correctly implement these rules can result in information leakage, cross-site scripting attacks, and the like.

Interoperability considerations:
Rules for processing both conforming and non-conforming content are defined in this specification.
Published specification:
This document is the relevant specification.
Applications that use this media type:
Web browsers.
Additional information:
Magic number(s):
Cache manifests begin with the string "CACHE MANIFEST", followed by either a U+0020 SPACE character, a U+0009 CHARACTER TABULATION (tab) character, a U+000A LINE FEED (LF) character, or a U+000D CARRIAGE RETURN (CR) character.
File extension(s):
"appcache"
Macintosh file type code(s):
No specific Macintosh file type codes are recommended for this type.
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
No restrictions apply.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments have no meaning with text/cache-manifest resources.

16.5 text/ping
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
text
Subtype name:
ping
Required parameters:
No parameters
Optional parameters:
charset
The charset parameter may be provided. The parameter's value must be "utf-8". This parameter serves no purpose; it is only allowed for compatibility with legacy servers.

Encoding considerations:
Not applicable.
Security considerations:
If used exclusively in the fashion described in the context of hyperlink auditing, this type introduces no new security concerns.

Interoperability considerations:
Rules applicable to this type are defined in this specification.
Published specification:
This document is the relevant specification.
Applications that use this media type:
Web browsers.
Additional information:
Magic number(s):
text/ping resources always consist of the four bytes 0x50 0x49 0x4E 0x47 (`PING`).
File extension(s):
No specific file extension is recommended for this type.
Macintosh file type code(s):
No specific Macintosh file type codes are recommended for this type.
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
Only intended for use with HTTP POST requests generated as part of a Web browser's processing of the ping attribute.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments have no meaning with text/ping resources.

16.6 application/microdata+json
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
application
Subtype name:
microdata+json
Required parameters:
Same as for application/json [JSON]
Optional parameters:
Same as for application/json [JSON]
Encoding considerations:
8bit (always UTF-8)
Security considerations:
Same as for application/json [JSON]
Interoperability considerations:
Same as for application/json [JSON]
Published specification:
Labeling a resource with the application/microdata+json type asserts that the resource is a JSON text that consists of an object with a single entry called "items" consisting of an array of entries, each of which consists of an object with an entry called "id" whose value is a string, an entry called "type" whose value is another string, and an entry called "properties" whose value is an object whose entries each have a value consisting of an array of either objects or strings, the objects being of the same form as the objects in the aforementioned "items" entry. Thus, the relevant specifications are the JSON specification and this specification. [JSON]
Applications that use this media type:
Applications that transfer data intended for use with HTML's microdata feature, especially in the context of drag-and-drop, are the primary application class for this type.

Additional information:
Magic number(s):
Same as for application/json [JSON]
File extension(s):
Same as for application/json [JSON]
Macintosh file type code(s):
Same as for application/json [JSON]
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
No restrictions apply.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments used with application/microdata+json resources have the same semantics as when used with application/json (namely, at the time of writing, no semantics at all). [JSON]

16.7 text/event-stream
This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:
text
Subtype name:
event-stream
Required parameters:
No parameters
Optional parameters:
charset
The charset parameter may be provided. The parameter's value must be "utf-8". This parameter serves no purpose; it is only allowed for compatibility with legacy servers.

Encoding considerations:
8bit (always UTF-8)
Security considerations:
An event stream from an origin distinct from the origin of the content consuming the event stream can result in information leakage. To avoid this, user agents are required to apply CORS semantics. [FETCH]

Event streams can overwhelm a user agent; a user agent is expected to apply suitable restrictions to avoid depleting local resources because of an overabundance of information from an event stream.

Servers can be overwhelmed if a situation develops in which the server is causing clients to reconnect rapidly. Servers should use a 5xx status code to indicate capacity problems, as this will prevent conforming clients from reconnecting automatically.

Interoperability considerations:
Rules for processing both conforming and non-conforming content are defined in this specification.
Published specification:
This document is the relevant specification.
Applications that use this media type:
Web browsers and tools using Web services.
Additional information:
Magic number(s):
No sequence of bytes can uniquely identify an event stream.
File extension(s):
No specific file extensions are recommended for this type.
Macintosh file type code(s):
No specific Macintosh file type codes are recommended for this type.
Person & email address to contact for further information:
Ian Hickson <ian@hixie.ch>
Intended usage:
Common
Restrictions on usage:
This format is only expected to be used by dynamic open-ended streams served using HTTP or a similar protocol. Finite resources are not expected to be labeled with this type.
Author:
Ian Hickson <ian@hixie.ch>
Change controller:
W3C
Fragments have no meaning with text/event-stream resources.

16.8 `Ping-From`
This section describes a header for registration in the Permanent Message Header Field Registry. [RFC3864]

Header field name:
Ping-From
Applicable protocol:
http
Status:
standard
Author/Change controller:
W3C
Specification document(s):
This document is the relevant specification.
Related information:
None.
16.9 `Ping-To`
This section describes a header for registration in the Permanent Message Header Field Registry. [RFC3864]

Header field name:
Ping-To
Applicable protocol:
http
Status:
standard
Author/Change controller:
W3C
Specification document(s):
This document is the relevant specification.
Related information:
None.
16.10 `Refresh`
This section describes a header for registration in the Permanent Message Header Field Registry. [RFC3864]

Header field name:
Refresh
Applicable protocol:
http
Status:
standard
Author/Change controller:
WHATWG
Specification document(s):
This document is the relevant specification.
Related information:
None.
16.11 `Last-Event-ID`
This section describes a header for registration in the Permanent Message Header Field Registry. [RFC3864]

Header field name:
Last-Event-ID
Applicable protocol:
http
Status:
standard
Author/Change controller:
W3C
Specification document(s):
This document is the relevant specification.
Related information:
None.
16.12 web+ scheme prefix

Spec bugs: 18496, 18671

This section describes a convention for use with the IANA URI scheme registry. It does not itself register a specific scheme. [RFC7595]

Scheme name:
Schemes starting with the four characters "web+" followed by one or more letters in the range a-z.
Status:
Permanent
Scheme syntax:
Scheme-specific.
Scheme semantics:
Scheme-specific.
Encoding considerations:
All "web+" schemes should use UTF-8 encodings where relevant.
Applications/protocols that use this scheme name:
Scheme-specific.
Interoperability considerations:
The scheme is expected to be used in the context of Web applications.
Security considerations:
Any Web page is able to register a handler for all "web+" schemes. As such, these schemes must not be used for features intended to be core platform features (e.g. network transfer protocols like HTTP or FTP). Similarly, such schemes must not store confidential information in their URLs, such as usernames, passwords, personal information, or confidential project names.
Contact:
Ian Hickson <ian@hixie.ch>
Change controller:
Ian Hickson <ian@hixie.ch>
References:
Custom scheme handlers, HTML Living Standard: https://html.spec.whatwg.org/#custom-handlers
Index
The following sections only cover conforming elements and features.

Elements
This section is non-normative.

List of elements
Element	Description	Categories	Parents†	Children	Attributes	Interface
a	Hyperlink	flow; phrasing*; interactive; palpable	phrasing	transparent*	globals; href; target; download; ping; rel; hreflang; type; referrerpolicy	HTMLAnchorElement
abbr	Abbreviation	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
address	Contact information for a page or article element	flow; palpable	flow	flow*	globals	HTMLElement
area	Hyperlink or dead area on an image map	flow; phrasing	phrasing*	empty	globals; alt; coords; shape; href; target; download; ping; rel; referrerpolicy	HTMLAreaElement
article	Self-contained syndicatable or reusable composition	flow; sectioning; palpable	flow	flow	globals	HTMLElement
aside	Sidebar for tangentially related content	flow; sectioning; palpable	flow	flow	globals	HTMLElement
audio	Audio player	flow; phrasing; embedded; interactive; palpable*	phrasing	source*; track*; transparent*	globals; src; crossorigin; preload; autoplay; loop; muted; controls	HTMLAudioElement
b	Keywords	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
base	Base URL and default target browsing context for hyperlinks and forms	metadata	head	empty	globals; href; target	HTMLBaseElement
bdi	Text directionality isolation	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
bdo	Text directionality formatting	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
blockquote	A section quoted from another source	flow; sectioning root; palpable	flow	flow	globals; cite	HTMLQuoteElement
body	Document body	sectioning root	html	flow	globals; onafterprint; onbeforeprint; onbeforeunload; onhashchange; onlanguagechange; onmessage; onmessageerror; onoffline; ononline; onpagehide; onpageshow; onpopstate; onrejectionhandled; onstorage; onunhandledrejection; onunload	HTMLBodyElement
br	Line break, e.g. in poem or postal address	flow; phrasing	phrasing	empty	globals	HTMLBRElement
button	Button control	flow; phrasing; interactive; listed; labelable; submittable; form-associated; palpable	phrasing	phrasing*	globals; autofocus; disabled; form; formaction; formenctype; formmethod; formnovalidate; formtarget; name; type; value	HTMLButtonElement
canvas	Scriptable bitmap canvas	flow; phrasing; embedded; palpable	phrasing	transparent	globals; width; height	HTMLCanvasElement
caption	Table caption	none	table	flow*	globals	HTMLTableCaptionElement
cite	Title of a work	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
code	Computer code	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
col	Table column	none	colgroup	empty	globals; span	HTMLTableColElement
colgroup	Group of columns in a table	none	table	col*; template*	globals; span	HTMLTableColElement
data	Machine-readable equivalent	flow; phrasing; palpable	phrasing	phrasing	globals; value	HTMLDataElement
datalist	Container for options for combo box control	flow; phrasing	phrasing	phrasing*; option*; script-supporting elements*	globals	HTMLDataListElement
dd	Content for corresponding dt element(s)	none	dl; div*	flow	globals	HTMLElement
del	A removal from the document	flow; phrasing*	phrasing	transparent	globals; cite; datetime	HTMLModElement
details	Disclosure control for hiding details	flow; sectioning root; interactive; palpable	flow	summary*; flow	globals; open	HTMLDetailsElement
dfn	Defining instance	flow; phrasing; palpable	phrasing	phrasing*	globals	HTMLElement
dialog	Dialog box or window	flow; sectioning root	flow	flow	globals; open	HTMLDialogElement
div	Generic flow container, or container for name-value groups in dl elements	flow; palpable	flow; dl	flow	globals	HTMLDivElement
dl	Association list consisting of zero or more name-value groups	flow; palpable	flow	dt*; dd*; div*; script-supporting elements	globals	HTMLDListElement
dt	Legend for corresponding dd element(s)	none	dl; div*	flow*	globals	HTMLElement
em	Stress emphasis	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
embed	Plugin	flow; phrasing; embedded; interactive; palpable	phrasing	empty	globals; src; type; width; height; any*	HTMLEmbedElement
fieldset	Group of form controls	flow; sectioning root; listed; form-associated; palpable	flow	legend*; flow	globals; disabled; form; name	HTMLFieldSetElement
figcaption	Caption for figure	none	figure	flow	globals	HTMLElement
figure	Figure with optional caption	flow; sectioning root; palpable	flow	figcaption*; flow	globals	HTMLElement
footer	Footer for a page or section	flow; palpable	flow	flow*	globals	HTMLElement
form	User-submittable form	flow; palpable	flow	flow*	globals; accept-charset; action; autocomplete; enctype; method; name; novalidate; target	HTMLFormElement
h1, h2, h3, h4, h5, h6	Section heading	flow; heading; palpable	hgroup; flow	phrasing	globals	HTMLHeadingElement
head	Container for document metadata	none	html	metadata content*	globals	HTMLHeadElement
header	Introductory or navigational aids for a page or section	flow; palpable	flow	flow*	globals	HTMLElement
hgroup	heading group	flow; heading; palpable	flow	One or more h1, h2, h3, h4, h5, h6, and template	globals	HTMLElement
hr	Thematic break	flow	flow	empty	globals	HTMLHRElement
html	Root element	none	none*	head*; body*	globals; manifest	HTMLHtmlElement
i	Alternate voice	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
iframe	Nested browsing context	flow; phrasing; embedded; interactive; palpable	phrasing	empty	globals; src; srcdoc; name; sandbox; allowfullscreen; allowpaymentrequest; allowusermedia; width; height; referrerpolicy	HTMLIFrameElement
img	Image	flow; phrasing; embedded; interactive*; form-associated; palpable	phrasing; picture	empty	globals; alt; src; srcset; crossorigin; usemap; ismap; width; height; decoding; referrerpolicy	HTMLImageElement
input	Form control	flow; phrasing; interactive*; listed; labelable; submittable; resettable; form-associated; palpable*	phrasing	empty	globals; accept; alt; autocomplete; autofocus; checked; dirname; disabled; form; formaction; formenctype; formmethod; formnovalidate; formtarget; height; list; max; maxlength; min; minlength; multiple; name; pattern; placeholder; readonly; required; size; src; step; type; value; width	HTMLInputElement
ins	An addition to the document	flow; phrasing*; palpable	phrasing	transparent	globals; cite; datetime	HTMLModElement
kbd	User input	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
label	Caption for a form control	flow; phrasing; interactive; palpable	phrasing	phrasing*	globals; for	HTMLLabelElement
legend	Caption for fieldset	none	fieldset	phrasing	globals	HTMLLegendElement
li	List item	none	ol; ul; menu*	flow	globals; value*	HTMLLIElement
link	Link metadata	metadata; flow*; phrasing*	head; noscript*; phrasing*	empty	globals; href; crossorigin; rel; as; media; hreflang; type; sizes; referrerpolicy; integrity	HTMLLinkElement
main	Container for the dominant contents of the document	flow; palpable	flow*	flow	globals	HTMLElement
map	Image map	flow; phrasing*; palpable	phrasing	transparent; area*	globals; name	HTMLMapElement
mark	Highlight	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
MathML math	MathML root	flow; phrasing; embedded; palpable	phrasing	per [MATHML]	per [MATHML]	Element
menu	Menu of commands	flow; palpable*	flow	li; script-supporting elements	globals	HTMLMenuElement
meta	Text metadata	metadata; flow*; phrasing*	head; noscript*; phrasing*	empty	globals; name; http-equiv; content; charset	HTMLMetaElement
meter	Gauge	flow; phrasing; labelable; palpable	phrasing	phrasing*	globals; value; min; max; low; high; optimum	HTMLMeterElement
nav	Section with navigational links	flow; sectioning; palpable	flow	flow	globals	HTMLElement
noscript	Fallback content for script	metadata; flow; phrasing	head*; phrasing*	varies*	globals	HTMLElement
object	Image, nested browsing context, or plugin	flow; phrasing; embedded; interactive*; listed; submittable; form-associated; palpable	phrasing	param*; transparent	globals; data; type; typemustmatch; name; usemap; form; width; height	HTMLObjectElement
ol	Ordered list	flow; palpable*	flow	li; script-supporting elements	globals; reversed; start; type	HTMLOListElement
optgroup	Group of options in a list box	none	select	option; script-supporting elements	globals; disabled; label	HTMLOptGroupElement
option	Option in a list box or combo box control	none	select; datalist; optgroup	text*	globals; disabled; label; selected; value	HTMLOptionElement
output	Calculated output value	flow; phrasing; listed; labelable; resettable; form-associated; palpable	phrasing	phrasing	globals; for; form; name	HTMLOutputElement
p	Paragraph	flow; palpable	flow	phrasing	globals	HTMLParagraphElement
param	Parameter for object	none	object	empty	globals; name; value	HTMLParamElement
picture	Image	flow; phrasing; embedded	phrasing	source*; one img; script-supporting elements	globals	HTMLPictureElement
pre	Block of preformatted text	flow; palpable	flow	phrasing	globals	HTMLPreElement
progress	Progress bar	flow; phrasing; labelable; palpable	phrasing	phrasing*	globals; value; max	HTMLProgressElement
q	Quotation	flow; phrasing; palpable	phrasing	phrasing	globals; cite	HTMLQuoteElement
rp	Parenthesis for ruby annotation text	none	ruby	text	globals	HTMLElement
rt	Ruby annotation text	none	ruby	phrasing	globals	HTMLElement
ruby	Ruby annotation(s)	flow; phrasing; palpable	phrasing	phrasing; rt; rp*	globals	HTMLElement
s	Inaccurate text	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
samp	Computer output	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
script	Embedded script	metadata; flow; phrasing; script-supporting	head; phrasing; script-supporting	script, data, or script documentation*	globals; src; type; async; defer; crossorigin; integrity	HTMLScriptElement
section	Generic document or application section	flow; sectioning; palpable	flow	flow	globals	HTMLElement
select	List box control	flow; phrasing; interactive; listed; labelable; submittable; resettable; form-associated; palpable	phrasing	option; optgroup; script-supporting elements	globals; autocomplete; autofocus; disabled; form; multiple; name; required; size	HTMLSelectElement
slot	Shadow tree slot	flow; phrasing	phrasing	transparent	globals; name	HTMLSlotElement
small	Side comment	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
source	Image source for img or media source for video or audio	none	picture; video; audio	empty	globals; src; type srcset; sizes; media	HTMLSourceElement
span	Generic phrasing container	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLSpanElement
strong	Importance	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
style	Embedded styling information	metadata	head; noscript*	text*	globals; media;	HTMLStyleElement
sub	Subscript	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
summary	Caption for details	none	details	phrasing	globals	HTMLElement
sup	Superscript	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
SVG svg	SVG root	flow; phrasing; embedded; palpable	phrasing	per [SVG]	per [SVG]	SVGSVGElement
table	Table	flow; palpable	flow	caption*; colgroup*; thead*; tbody*; tfoot*; tr*; script-supporting elements	globals	HTMLTableElement
tbody	Group of rows in a table	none	table	tr; script-supporting elements	globals	HTMLTableSectionElement
td	Table cell	sectioning root	tr	flow	globals; colspan; rowspan; headers	HTMLTableCellElement
template	Template	metadata; flow; phrasing; script-supporting	metadata; phrasing; script-supporting; colgroup*	empty	globals	HTMLTemplateElement
textarea	Multiline text controls	flow; phrasing; interactive; listed; labelable; submittable; resettable; form-associated; palpable	phrasing	text	globals; autofocus; cols; dirname; disabled; form; maxlength; minlength; name; placeholder; readonly; required; rows; wrap	HTMLTextAreaElement
tfoot	Group of footer rows in a table	none	table	tr; script-supporting elements	globals	HTMLTableSectionElement
th	Table header cell	interactive*	tr	flow*	globals; colspan; rowspan; headers; scope; abbr	HTMLTableCellElement
thead	Group of heading rows in a table	none	table	tr; script-supporting elements	globals	HTMLTableSectionElement
time	Machine-readable equivalent of date- or time-related data	flow; phrasing; palpable	phrasing	phrasing	globals; datetime	HTMLTimeElement
title	Document title	metadata	head	text*	globals	HTMLTitleElement
tr	Table row	none	table; thead; tbody; tfoot	th*; td; script-supporting elements	globals	HTMLTableRowElement
track	Timed text track	none	audio; video	empty	globals; default; kind; label; src; srclang	HTMLTrackElement
u	Keywords	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
ul	List	flow; palpable*	flow	li; script-supporting elements	globals	HTMLUListElement
var	Variable	flow; phrasing; palpable	phrasing	phrasing	globals	HTMLElement
video	Video player	flow; phrasing; embedded; interactive; palpable	phrasing	source*; track*; transparent*	globals; src; crossorigin; poster; preload; autoplay; playsinline; loop; muted; controls; width; height	HTMLVideoElement
wbr	Line breaking opportunity	flow; phrasing	phrasing	empty	globals	HTMLElement
autonomous custom elements	Author-defined elements	flow; phrasing; palpable	flow; phrasing	transparent	globals; any, as decided by the element's author	Supplied by the element's author (inherits from HTMLElement)
An asterisk (*) in a cell indicates that the actual rules are more complicated than indicated in the table above.

† Categories in the "Parents" column refer to parents that list the given categories in their content model, not to elements that themselves are in those categories. For example, the a element's "Parents" column says "phrasing", so any element whose content model contains the "phrasing" category could be a parent of an a element. Since the "flow" category includes all the "phrasing" elements, that means the th element could be a parent to an a element.

Element content categories
This section is non-normative.

List of element content categories
Category	Elements	Elements with exceptions
Metadata content	base; link; meta; noscript; script; style; template; title	—
Flow content	a; abbr; address; article; aside; audio; b; bdi; bdo; blockquote; br; button; canvas; cite; code; data; datalist; del; details; dfn; dialog; div; dl; em; embed; fieldset; figure; footer; form; h1; h2; h3; h4; h5; h6; header; hgroup; hr; i; iframe; img; input; ins; kbd; label; map; mark; MathML math; menu; meter; nav; noscript; object; ol; output; p; picture; pre; progress; q; ruby; s; samp; script; section; select; slot; small; span; strong; sub; sup; SVG svg; table; template; textarea; time; u; ul; var; video; wbr; autonomous custom elements; Text	area (if it is a descendant of a map element); link (if it is allowed in the body); main (if it is a hierarchically correct main element); meta (if the itemprop attribute is present)
Sectioning content	article; aside; nav; section	—
Heading content	h1; h2; h3; h4; h5; h6; hgroup	—
Phrasing content	a; abbr; audio; b; bdi; bdo; br; button; canvas; cite; code; data; datalist; del; dfn; em; embed; i; iframe; img; input; ins; kbd; label; map; mark; MathML math; meter; noscript; object; output; picture; progress; q; ruby; s; samp; script; select; slot; small; span; strong; sub; sup; SVG svg; template; textarea; time; u; var; video; wbr; autonomous custom elements; Text	area (if it is a descendant of a map element); link (if it is allowed in the body); meta (if the itemprop attribute is present)
Embedded content	audio; canvas; embed; iframe; img; MathML math; object; picture; SVG svg; video	—
Interactive content*	button; details; embed; iframe; label; select; textarea	a (if the href attribute is present); audio (if the controls attribute is present); img (if the usemap attribute is present); input (if the type attribute is not in the Hidden state); object (if the usemap attribute is present); video (if the controls attribute is present)
Sectioning roots	blockquote; body; details; dialog; fieldset; figure; td	—
Form-associated elements	button; fieldset; input; label; object; output; select; textarea; img	—
Listed elements	button; fieldset; input; object; output; select; textarea	—
Submittable elements	button; input; object; select; textarea	—
Resettable elements	input; output; select; textarea	—
Autocapitalize-inheriting elements	button; fieldset; input; output; select; textarea	—
Labelable elements	button; input; meter; output; progress; select; textarea	—
Palpable content	a; abbr; address; article; aside; b; bdi; bdo; blockquote; button; canvas; cite; code; data; details; dfn; div; em; embed; fieldset; figure; footer; form; h1; h2; h3; h4; h5; h6; header; hgroup; i; iframe; img; ins; kbd; label; main; map; mark; MathML math; meter; nav; object; output; p; pre; progress; q; ruby; s; samp; section; select; small; span; strong; sub; sup; SVG svg; table; textarea; time; u; var; video; autonomous custom elements	audio (if the controls attribute is present); dl (if the element's children include at least one name-value group); input (if the type attribute is not in the Hidden state); menu (if the element's children include at least one li element); ol (if the element's children include at least one li element); ul (if the element's children include at least one li element); Text that is not inter-element whitespace
Script-supporting elements	script; template	—
* The tabindex attribute can also make any element into interactive content.

Attributes
This section is non-normative.

List of attributes (excluding event handler content attributes)
Attribute	Element(s)	Description	Value
abbr	th	Alternative label to use for the header cell when referencing the cell in other contexts	Text*
accept	input	Hint for expected file type in file upload controls	Set of comma-separated tokens* consisting of valid MIME type strings with no parameters or audio/*, video/*, or image/*
accept-charset	form	Character encodings to use for form submission	Ordered set of unique space-separated tokens, ASCII case-insensitive, consisting of labels of ASCII-compatible encodings*
accesskey	HTML elements	Keyboard shortcut to activate or focus element	Ordered set of unique space-separated tokens, case-sensitive, consisting of one code point in length
action	form	URL to use for form submission	Valid non-empty URL potentially surrounded by spaces
allowfullscreen	iframe	Whether to allow the iframe's contents to use requestFullscreen()	Boolean attribute
allowpaymentrequest	iframe	Whether the iframe's contents are allowed to use the PaymentRequest interface to make payment requests	Boolean attribute
allowusermedia	iframe	Whether to allow the iframe's contents to use getUserMedia()	Boolean attribute
alt	area; img; input	Replacement text for use when images are not available	Text*
as	link	Potential destination for a preload request (for rel="preload" and rel="modulepreload")	Potential destination, for rel="preload"; script-like destination, for rel="modulepreload"
async	script	Execute script when available, without blocking	Boolean attribute
autocapitalize	HTML elements	Recommended autocapitalization behavior (for supported input methods)	"on"; "off"; "none"; "sentences"; "words"; "characters"
autocomplete	form	Default setting for autofill feature for controls in the form	"on"; "off"
autocomplete	input; select; textarea	Hint for form autofill feature	Autofill field name and related tokens*
autofocus	button; input; select; textarea	Automatically focus the form control when the page is loaded	Boolean attribute
autoplay	audio; video	Hint that the media resource can be started automatically when the page is loaded	Boolean attribute
charset	meta	Character encoding declaration	"utf-8"
checked	input	Whether the control is checked	Boolean attribute
cite	blockquote; del; ins; q	Link to the source of the quotation or more information about the edit	Valid URL potentially surrounded by spaces
class	HTML elements	Classes to which the element belongs	Set of space-separated tokens
color	link	Color to use when customizing a site's icon (for rel="mask-icon")	CSS <color>
cols	textarea	Maximum number of characters per line	Valid non-negative integer greater than zero
colspan	td; th	Number of columns that the cell is to span	Valid non-negative integer greater than zero
content	meta	Value of the element	Text*
contenteditable	HTML elements	Whether the element is editable	"true"; "false"
controls	audio; video	Show user agent controls	Boolean attribute
coords	area	Coordinates for the shape to be created in an image map	Valid list of floating-point numbers*
crossorigin	audio; img; link; script; video	How the element handles crossorigin requests	"anonymous"; "use-credentials"
data	object	Address of the resource	Valid non-empty URL potentially surrounded by spaces
datetime	del; ins	Date and (optionally) time of the change	Valid date string with optional time
datetime	time	Machine-readable value	Valid month string, valid date string, valid yearless date string, valid time string, valid local date and time string, valid time-zone offset string, valid global date and time string, valid week string, valid non-negative integer, or valid duration string
decoding	img	Decoding hint to use when processing this image for presentation	"sync"; "async"; "auto"
default	track	Enable the track if no other text track is more suitable	Boolean attribute
defer	script	Defer script execution	Boolean attribute
dir	HTML elements	The text directionality of the element	"ltr"; "rtl"; "auto"
dir	bdo	The text directionality of the element	"ltr"; "rtl"
dirname	input; textarea	Name of form control to use for sending the element's directionality in form submission	Text*
disabled	button; fieldset; input; optgroup; option; select; textarea	Whether the form control is disabled	Boolean attribute
download	a; area	Whether to download the resource instead of navigating to it, and its file name if so	Text
draggable	HTML elements	Whether the element is draggable	"true"; "false"
enctype	form	Form data set encoding type to use for form submission	"application/x-www-form-urlencoded"; "multipart/form-data"; "text/plain"
for	label	Associate the label with form control	ID*
for	output	Specifies controls from which the output was calculated	Unordered set of unique space-separated tokens, case-sensitive, consisting of IDs*
form	button; fieldset; input; object; output; select; textarea	Associates the control with a form element	ID*
formaction	button; input	URL to use for form submission	Valid non-empty URL potentially surrounded by spaces
formenctype	button; input	Form data set encoding type to use for form submission	"application/x-www-form-urlencoded"; "multipart/form-data"; "text/plain"
formmethod	button; input	HTTP method to use for form submission	"GET"; "POST"
formnovalidate	button; input	Bypass form control validation for form submission	Boolean attribute
formtarget	button; input	Browsing context for form submission	Valid browsing context name or keyword
headers	td; th	The header cells for this cell	Unordered set of unique space-separated tokens, case-sensitive, consisting of IDs*
height	canvas; embed; iframe; img; input; object; video	Vertical dimension	Valid non-negative integer
hidden	HTML elements	Whether the element is relevant	Boolean attribute
high	meter	Low limit of high range	Valid floating-point number*
href	a; area	Address of the hyperlink	Valid URL potentially surrounded by spaces
href	link	Address of the hyperlink	Valid non-empty URL potentially surrounded by spaces
href	base	Document base URL	Valid URL potentially surrounded by spaces
hreflang	a; link	Language of the linked resource	Valid BCP 47 language tag
http-equiv	meta	Pragma directive	"content-type"; "default-style"; "refresh"; "x-ua-compatible"; "Content-Security-Policy"
id	HTML elements	The element's ID	Text*
inputmode	HTML elements	Hint for selecting an input modality	"none"; "text"; "tel"; "email"; "url" "numeric"; "decimal"; "search";
integrity	link; script	Integrity metadata used in Subresource Integrity checks [SRI]	Text
is	HTML elements	Creates a customized built-in element	Valid custom element name of a defined customized built-in element
ismap	img	Whether the image is a server-side image map	Boolean attribute
itemid	HTML elements	Global identifier for a microdata item	Valid URL potentially surrounded by spaces
itemprop	HTML elements	Property names of a microdata item	Unordered set of unique space-separated tokens, case-sensitive, consisting of valid absolute URLs, defined property names, or text*
itemref	HTML elements	Referenced elements	Unordered set of unique space-separated tokens, case-sensitive, consisting of IDs*
itemscope	HTML elements	Introduces a microdata item	Boolean attribute
itemtype	HTML elements	Item types of a microdata item	Unordered set of unique space-separated tokens, case-sensitive, consisting of valid absolute URL*
kind	track	The type of text track	"subtitles"; "captions"; "descriptions"; "chapters"; "metadata"
label	optgroup; option; track	User-visible label	Text
lang	HTML elements	Language of the element	Valid BCP 47 language tag or the empty string
list	input	List of autocomplete options	ID*
loop	audio; video	Whether to loop the media resource	Boolean attribute
low	meter	High limit of low range	Valid floating-point number*
manifest	html	Application cache manifest	Valid non-empty URL potentially surrounded by spaces
max	input	Maximum value	Varies*
max	meter; progress	Upper bound of range	Valid floating-point number*
maxlength	input; textarea	Maximum length of value	Valid non-negative integer
media	link; source; style	Applicable media	Valid media query list
method	form	HTTP method to use for form submission	"GET"; "POST"; "dialog"
min	input	Minimum value	Varies*
min	meter	Lower bound of range	Valid floating-point number*
minlength	input; textarea	Minimum length of value	Valid non-negative integer
multiple	input; select	Whether to allow multiple values	Boolean attribute
muted	audio; video	Whether to mute the media resource by default	Boolean attribute
name	button; fieldset; input; output; select; textarea	Name of form control to use for form submission and in the form.elements API	Text*
name	form	Name of form to use in the document.forms API	Text*
name	iframe; object	Name of nested browsing context	Valid browsing context name or keyword
name	map	Name of image map to reference from the usemap attribute	Text*
name	meta	Metadata name	Text*
name	param	Name of parameter	Text
name	slot	Name of shadow tree slot	Text
nomodule	script	Prevents execution in user agents that support module scripts	Boolean attribute
nonce	HTML elements	Cryptographic nonce used in Content Security Policy checks [CSP]	Text
novalidate	form	Bypass form control validation for form submission	Boolean attribute
open	details	Whether the details are visible	Boolean attribute
open	dialog	Whether the dialog box is showing	Boolean attribute
optimum	meter	Optimum value in gauge	Valid floating-point number*
pattern	input	Pattern to be matched by the form control's value	Regular expression matching the JavaScript Pattern production
ping	a; area	URLs to ping	Set of space-separated tokens consisting of valid non-empty URLs
placeholder	input; textarea	User-visible label to be placed within the form control	Text*
playsinline	video	Encourage the user agent to display video content within the element's playback area	Boolean attribute
poster	video	Poster frame to show prior to video playback	Valid non-empty URL potentially surrounded by spaces
preload	audio; video	Hints how much buffering the media resource will likely need	"none"; "metadata"; "auto"
readonly	input; textarea	Whether to allow the value to be edited by the user	Boolean attribute
referrerpolicy	a; area; iframe; img; link	Referrer policy for fetches initiated by the element	Referrer policy
rel	a; area	Relationship between the location in the document containing the hyperlink and the destination resource	Set of space-separated tokens*
rel	link	Relationship between the document containing the hyperlink and the destination resource	Set of space-separated tokens*
required	input; select; textarea	Whether the control is required for form submission	Boolean attribute
reversed	ol	Number the list backwards	Boolean attribute
rows	textarea	Number of lines to show	Valid non-negative integer greater than zero
rowspan	td; th	Number of rows that the cell is to span	Valid non-negative integer
sandbox	iframe	Security rules for nested content	Unordered set of unique space-separated tokens, ASCII case-insensitive, consisting of "allow-forms", "allow-modals", "allow-orientation-lock", "allow-pointer-lock", "allow-popups", "allow-popups-to-escape-sandbox", "allow-presentation", "allow-same-origin", "allow-scripts" and "allow-top-navigation"
scope	th	Specifies which cells the header cell applies to	"row"; "col"; "rowgroup"; "colgroup"
selected	option	Whether the option is selected by default	Boolean attribute
shape	area	The kind of shape to be created in an image map	"circle"; "default"; "poly"; "rect"
size	input; select	Size of the control	Valid non-negative integer greater than zero
sizes	link	Sizes of the icons (for rel="icon")	Unordered set of unique space-separated tokens, ASCII case-insensitive, consisting of sizes*
sizes	img; source	Image sizes for different page layouts	Valid source size list
slot	HTML elements	The element's desired slot	Text
span	col; colgroup	Number of columns spanned by the element	Valid non-negative integer greater than zero
spellcheck	HTML elements	Whether the element is to have its spelling and grammar checked	"true"; "false"
src	audio; embed; iframe; img; input; script; source; track; video	Address of the resource	Valid non-empty URL potentially surrounded by spaces
srcdoc	iframe	A document to render in the iframe	The source of an iframe srcdoc document*
srclang	track	Language of the text track	Valid BCP 47 language tag
srcset	img; source	Images to use in different situations (e.g. high-resolution displays, small monitors, etc)	Comma-separated list of image candidate strings
start	ol	Starting value of the list	Valid integer
step	input	Granularity to be matched by the form control's value	Valid floating-point number greater than zero, or "any"
style	HTML elements	Presentational and formatting instructions	CSS declarations*
tabindex	HTML elements	Whether the element is focusable, and the relative order of the element for the purposes of sequential focus navigation	Valid integer
target	a; area	Browsing context for hyperlink navigation	Valid browsing context name or keyword
target	base	Default browsing context for hyperlink navigation and form submission	Valid browsing context name or keyword
target	form	Browsing context for form submission	Valid browsing context name or keyword
title	HTML elements	Advisory information for the element	Text
title	abbr; dfn	Full term or expansion of abbreviation	Text
title	input	Description of pattern (when used with pattern attribute)	Text
title	link	Title of the link	Text
title	link; style	CSS style sheet set name	Text
translate	HTML elements	Whether the element is to be translated when the page is localized	"yes"; "no"
type	a; link	Hint for the type of the referenced resource	Valid MIME type string
type	button	Type of button	"submit"; "reset"; "button"
type	embed; object; source	Type of embedded resource	Valid MIME type string
type	input	Type of form control	input type keyword
type	ol	Kind of list marker	"1"; "a"; "A"; "i"; "I"
type	script	Type of script	"module"; a valid MIME type string that is not a JavaScript MIME type essence match
typemustmatch	object	Whether the type attribute and the Content-Type value need to match for the resource to be used	Boolean attribute
usemap	img; object	Name of image map to use	Valid hash-name reference*
value	button; option	Value to be used for form submission	Text
value	data	Machine-readable value	Text*
value	input	Value of the form control	Varies*
value	li	Ordinal value of the list item	Valid integer
value	meter; progress	Current value of the element	Valid floating-point number
value	param	Value of parameter	Text
width	canvas; embed; iframe; img; input; object; video	Horizontal dimension	Valid non-negative integer
wrap	textarea	How the value of the form control is to be wrapped for form submission	"soft"; "hard"
An asterisk (*) in a cell indicates that the actual rules are more complicated than indicated in the table above.

List of event handler content attributes
Attribute	Element(s)	Description	Value
onabort	HTML elements	abort event handler	Event handler content attribute
onauxclick	HTML elements	auxclick event handler	Event handler content attribute
onafterprint	body	afterprint event handler for Window object	Event handler content attribute
onbeforeprint	body	beforeprint event handler for Window object	Event handler content attribute
onbeforeunload	body	beforeunload event handler for Window object	Event handler content attribute
onblur	HTML elements	blur event handler	Event handler content attribute
oncancel	HTML elements	cancel event handler	Event handler content attribute
oncanplay	HTML elements	canplay event handler	Event handler content attribute
oncanplaythrough	HTML elements	canplaythrough event handler	Event handler content attribute
onchange	HTML elements	change event handler	Event handler content attribute
onclick	HTML elements	click event handler	Event handler content attribute
onclose	HTML elements	close event handler	Event handler content attribute
oncontextmenu	HTML elements	contextmenu event handler	Event handler content attribute
oncopy	HTML elements	copy event handler	Event handler content attribute
oncuechange	HTML elements	cuechange event handler	Event handler content attribute
oncut	HTML elements	cut event handler	Event handler content attribute
ondblclick	HTML elements	dblclick event handler	Event handler content attribute
ondrag	HTML elements	drag event handler	Event handler content attribute
ondragend	HTML elements	dragend event handler	Event handler content attribute
ondragenter	HTML elements	dragenter event handler	Event handler content attribute
ondragexit	HTML elements	dragexit event handler	Event handler content attribute
ondragleave	HTML elements	dragleave event handler	Event handler content attribute
ondragover	HTML elements	dragover event handler	Event handler content attribute
ondragstart	HTML elements	dragstart event handler	Event handler content attribute
ondrop	HTML elements	drop event handler	Event handler content attribute
ondurationchange	HTML elements	durationchange event handler	Event handler content attribute
onemptied	HTML elements	emptied event handler	Event handler content attribute
onended	HTML elements	ended event handler	Event handler content attribute
onerror	HTML elements	error event handler	Event handler content attribute
onfocus	HTML elements	focus event handler	Event handler content attribute
onhashchange	body	hashchange event handler for Window object	Event handler content attribute
oninput	HTML elements	input event handler	Event handler content attribute
oninvalid	HTML elements	invalid event handler	Event handler content attribute
onkeydown	HTML elements	keydown event handler	Event handler content attribute
onkeypress	HTML elements	keypress event handler	Event handler content attribute
onkeyup	HTML elements	keyup event handler	Event handler content attribute
onlanguagechange	body	languagechange event handler for Window object	Event handler content attribute
onload	HTML elements	load event handler	Event handler content attribute
onloadeddata	HTML elements	loadeddata event handler	Event handler content attribute
onloadedmetadata	HTML elements	loadedmetadata event handler	Event handler content attribute
onloadend	HTML elements	loadend event handler	Event handler content attribute
onloadstart	HTML elements	loadstart event handler	Event handler content attribute
onmessage	body	message event handler for Window object	Event handler content attribute
onmessageerror	body	messageerror event handler for Window object	Event handler content attribute
onmousedown	HTML elements	mousedown event handler	Event handler content attribute
onmouseenter	HTML elements	mouseenter event handler	Event handler content attribute
onmouseleave	HTML elements	mouseleave event handler	Event handler content attribute
onmousemove	HTML elements	mousemove event handler	Event handler content attribute
onmouseout	HTML elements	mouseout event handler	Event handler content attribute
onmouseover	HTML elements	mouseover event handler	Event handler content attribute
onmouseup	HTML elements	mouseup event handler	Event handler content attribute
onwheel	HTML elements	wheel event handler	Event handler content attribute
onoffline	body	offline event handler for Window object	Event handler content attribute
ononline	body	online event handler for Window object	Event handler content attribute
onpagehide	body	pagehide event handler for Window object	Event handler content attribute
onpageshow	body	pageshow event handler for Window object	Event handler content attribute
onpaste	HTML elements	paste event handler	Event handler content attribute
onpause	HTML elements	pause event handler	Event handler content attribute
onplay	HTML elements	play event handler	Event handler content attribute
onplaying	HTML elements	playing event handler	Event handler content attribute
onpopstate	body	popstate event handler for Window object	Event handler content attribute
onprogress	HTML elements	progress event handler	Event handler content attribute
onratechange	HTML elements	ratechange event handler	Event handler content attribute
onreset	HTML elements	reset event handler	Event handler content attribute
onresize	HTML elements	resize event handler	Event handler content attribute
onrejectionhandled	body	rejectionhandled event handler for Window object	Event handler content attribute
onscroll	HTML elements	scroll event handler	Event handler content attribute
onsecuritypolicyviolation	HTML elements	securitypolicyviolation event handler	Event handler content attribute
onseeked	HTML elements	seeked event handler	Event handler content attribute
onseeking	HTML elements	seeking event handler	Event handler content attribute
onselect	HTML elements	select event handler	Event handler content attribute
onstalled	HTML elements	stalled event handler	Event handler content attribute
onstorage	body	storage event handler for Window object	Event handler content attribute
onsubmit	HTML elements	submit event handler	Event handler content attribute
onsuspend	HTML elements	suspend event handler	Event handler content attribute
ontimeupdate	HTML elements	timeupdate event handler	Event handler content attribute
ontoggle	HTML elements	toggle event handler	Event handler content attribute
onunhandledrejection	body	unhandledrejection event handler for Window object	Event handler content attribute
onunload	body	unload event handler for Window object	Event handler content attribute
onvolumechange	HTML elements	volumechange event handler	Event handler content attribute
onwaiting	HTML elements	waiting event handler	Event handler content attribute
Element Interfaces
This section is non-normative.

List of interfaces for elements
Element(s)	Interface(s)
a	HTMLAnchorElement : HTMLElement
abbr	HTMLElement
address	HTMLElement
area	HTMLAreaElement : HTMLElement
article	HTMLElement
aside	HTMLElement
audio	HTMLAudioElement : HTMLMediaElement : HTMLElement
b	HTMLElement
base	HTMLBaseElement : HTMLElement
bdi	HTMLElement
bdo	HTMLElement
blockquote	HTMLQuoteElement : HTMLElement
body	HTMLBodyElement : HTMLElement
br	HTMLBRElement : HTMLElement
button	HTMLButtonElement : HTMLElement
canvas	HTMLCanvasElement : HTMLElement
caption	HTMLTableCaptionElement : HTMLElement
cite	HTMLElement
code	HTMLElement
col	HTMLTableColElement : HTMLElement
colgroup	HTMLTableColElement : HTMLElement
data	HTMLDataElement : HTMLElement
datalist	HTMLDataListElement : HTMLElement
dd	HTMLElement
del	HTMLModElement : HTMLElement
details	HTMLDetailsElement : HTMLElement
dfn	HTMLElement
dialog	HTMLDialogElement : HTMLElement
div	HTMLDivElement : HTMLElement
dl	HTMLDListElement : HTMLElement
dt	HTMLElement
em	HTMLElement
embed	HTMLEmbedElement : HTMLElement
fieldset	HTMLFieldSetElement : HTMLElement
figcaption	HTMLElement
figure	HTMLElement
footer	HTMLElement
form	HTMLFormElement : HTMLElement
h1	HTMLHeadingElement : HTMLElement
h2	HTMLHeadingElement : HTMLElement
h3	HTMLHeadingElement : HTMLElement
h4	HTMLHeadingElement : HTMLElement
h5	HTMLHeadingElement : HTMLElement
h6	HTMLHeadingElement : HTMLElement
head	HTMLHeadElement : HTMLElement
header	HTMLElement
hgroup	HTMLElement
hr	HTMLHRElement : HTMLElement
html	HTMLHtmlElement : HTMLElement
i	HTMLElement
iframe	HTMLIFrameElement : HTMLElement
img	HTMLImageElement : HTMLElement
input	HTMLInputElement : HTMLElement
ins	HTMLModElement : HTMLElement
kbd	HTMLElement
label	HTMLLabelElement : HTMLElement
legend	HTMLLegendElement : HTMLElement
li	HTMLLIElement : HTMLElement
link	HTMLLinkElement : HTMLElement
main	HTMLElement
map	HTMLMapElement : HTMLElement
mark	HTMLElement
menu	HTMLMenuElement : HTMLElement
meta	HTMLMetaElement : HTMLElement
meter	HTMLMeterElement : HTMLElement
nav	HTMLElement
noscript	HTMLElement
object	HTMLObjectElement : HTMLElement
ol	HTMLOListElement : HTMLElement
optgroup	HTMLOptGroupElement : HTMLElement
option	HTMLOptionElement : HTMLElement
output	HTMLOutputElement : HTMLElement
p	HTMLParagraphElement : HTMLElement
param	HTMLParamElement : HTMLElement
picture	HTMLPictureElement : HTMLElement
pre	HTMLPreElement : HTMLElement
progress	HTMLProgressElement : HTMLElement
q	HTMLQuoteElement : HTMLElement
rp	HTMLElement
rt	HTMLElement
ruby	HTMLElement
s	HTMLElement
samp	HTMLElement
script	HTMLScriptElement : HTMLElement
section	HTMLElement
select	HTMLSelectElement : HTMLElement
slot	HTMLSlotElement : HTMLElement
small	HTMLElement
source	HTMLSourceElement : HTMLElement
span	HTMLSpanElement : HTMLElement
strong	HTMLElement
style	HTMLStyleElement : HTMLElement
sub	HTMLElement
summary	HTMLElement
sup	HTMLElement
table	HTMLTableElement : HTMLElement
tbody	HTMLTableSectionElement : HTMLElement
td	HTMLTableCellElement : HTMLElement
template	HTMLTemplateElement : HTMLElement
textarea	HTMLTextAreaElement : HTMLElement
tfoot	HTMLTableSectionElement : HTMLElement
th	HTMLTableCellElement : HTMLElement
thead	HTMLTableSectionElement : HTMLElement
time	HTMLTimeElement : HTMLElement
title	HTMLTitleElement : HTMLElement
tr	HTMLTableRowElement : HTMLElement
track	HTMLTrackElement : HTMLElement
u	HTMLElement
ul	HTMLUListElement : HTMLElement
var	HTMLElement
video	HTMLVideoElement : HTMLMediaElement : HTMLElement
wbr	HTMLElement
custom elements	supplied by the element's author (inherits from HTMLElement)
All Interfaces
This section is non-normative.

ApplicationCache
AudioTrack
AudioTrackList
BarProp
BeforeUnloadEvent
BroadcastChannel
CanvasGradient
CanvasPattern
CanvasRenderingContext2D
CloseEvent
CustomElementRegistry
DOMStringList
DOMStringMap
DataTransfer
DataTransferItem
DataTransferItemList
DedicatedWorkerGlobalScope
Document, partial 1 1
DragEvent
ErrorEvent
EventSource
External
HTMLAllCollection
HTMLAnchorElement, partial
HTMLAreaElement, partial
HTMLAudioElement
HTMLBRElement, partial
HTMLBaseElement
HTMLBodyElement, partial
HTMLButtonElement
HTMLCanvasElement
HTMLDListElement, partial
HTMLDataElement
HTMLDataListElement
HTMLDetailsElement
HTMLDialogElement
HTMLDirectoryElement
HTMLDivElement, partial
HTMLElement
HTMLEmbedElement, partial
HTMLFieldSetElement
HTMLFontElement
HTMLFormControlsCollection
HTMLFormElement
HTMLFrameElement
HTMLFrameSetElement
HTMLHRElement, partial
HTMLHeadElement
HTMLHeadingElement, partial
HTMLHtmlElement, partial
HTMLIFrameElement, partial
HTMLImageElement, partial
HTMLInputElement, partial
HTMLLIElement, partial
HTMLLabelElement
HTMLLegendElement, partial
HTMLLinkElement, partial
HTMLMapElement
HTMLMarqueeElement
HTMLMediaElement
HTMLMenuElement, partial
HTMLMetaElement, partial
HTMLMeterElement
HTMLModElement
HTMLOListElement, partial
HTMLObjectElement, partial
HTMLOptGroupElement
HTMLOptionElement
HTMLOptionsCollection
HTMLOutputElement
HTMLParagraphElement, partial
HTMLParamElement, partial
HTMLPictureElement
HTMLPreElement, partial
HTMLProgressElement
HTMLQuoteElement
HTMLScriptElement, partial
HTMLSelectElement
HTMLSlotElement
HTMLSourceElement
HTMLSpanElement
HTMLStyleElement, partial
HTMLTableCaptionElement, partial
HTMLTableCellElement, partial
HTMLTableColElement, partial
HTMLTableElement, partial
HTMLTableRowElement, partial
HTMLTableSectionElement, partial
HTMLTemplateElement
HTMLTextAreaElement
HTMLTimeElement
HTMLTitleElement
HTMLTrackElement
HTMLUListElement, partial
HTMLUnknownElement
HTMLVideoElement
HashChangeEvent
History
ImageBitmap
ImageBitmapRenderingContext
ImageData
Location
MediaError
MessageChannel
MessageEvent
MessagePort
MimeType
MimeTypeArray
Navigator
NavigatorID, partial
OffscreenCanvas
OffscreenCanvasRenderingContext2D
PageTransitionEvent
Path2D
Plugin
PluginArray
PopStateEvent
PromiseRejectionEvent
RadioNodeList
SharedWorker
SharedWorkerGlobalScope
Storage
StorageEvent
TextMetrics
TextTrack
TextTrackCue
TextTrackCueList
TextTrackList
TimeRanges
TrackEvent
ValidityState
VideoTrack
VideoTrackList
WebSocket
Window, partial
Worker
WorkerGlobalScope
WorkerLocation
WorkerNavigator
Events
This section is non-normative.

List of events
Event	Interface	Interesting targets	Description
abort	Event	Window	Fired at the Window when the download was aborted by the user
DOMContentLoaded	Event	Document	Fired at the Document once the parser has finished
afterprint	Event	Window	Fired at the Window after printing
beforeprint	Event	Window	Fired at the Window before printing
beforeunload	BeforeUnloadEvent	Window	Fired at the Window when the page is about to be unloaded, in case the page would like to show a warning prompt
blur	Event	Window, elements	Fired at nodes when they stop being focused
cancel	Event	dialog elements	Fired at dialog elements when they are canceled by the user (e.g. by pressing the Escape key)
change	Event	Form controls	Fired at controls when the user commits a value change (see also the input event)
click	MouseEvent	Elements	Normally a mouse event; also synthetically fired at an element before its activation behavior is run, when an element is activated from a non-pointer input device (e.g. a keyboard)
close	Event	dialog elements, WebSocket	Fired at dialog elements when they are closed, and at WebSocket elements when the connection is terminated
connect	MessageEvent	SharedWorkerGlobalScope	Fired at a shared worker's global scope when a new client connects
contextmenu	MouseEvent	Elements	Fired at elements when the user requests their context menu
copy	Event	Elements	Fired at elements when the user copies data to the clipboard
cut	Event	Elements	Fired at elements when the user copies the selected data on the clipboard and removes the selection from the document
error	Event or ErrorEvent	Global scope objects, Worker objects, elements, networking-related objects	Fired when unexpected errors occur (e.g. networking errors, script errors, decoding errors)
focus	Event	Window, elements	Fired at nodes gaining focus
hashchange	HashChangeEvent	Window	Fired at the Window when the fragment part of the document's URL changes
input
Support: input-event
Chrome for Android	64+
Chrome	15+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	3.6+
Samsung Internet	4+
IE	10+
Opera Mini	None
Safari	5.1+
Edge	12+
Android Browser	2.3+
Opera	12.1+

Source: caniuse.com

Event	Form controls	Fired at controls when the user changes the value (see also the change event)
invalid	Event	Form controls	Fired at controls during form validation if they do not satisfy their constraints
languagechange	Event	Global scope objects	Fired at the global scope object when the user's preferred languages change
load	Event	Window, elements	Fired at the Window when the document has finished loading; fired at an element containing a resource (e.g. img, embed) when its resource has finished loading
loadend	Event or ProgressEvent	img elements	Fired at img elements after a successful load
loadstart	ProgressEvent	img elements	Fired at img elements when a load begins (see also media element events)
message	MessageEvent	Window, EventSource, WebSocket, MessagePort, BroadcastChannel, DedicatedWorkerGlobalScope, Worker, ServiceWorkerContainer	Fired at an object when it receives a message
messageerror	MessageEvent	Window, MessagePort, BroadcastChannel, DedicatedWorkerGlobalScope, Worker, ServiceWorkerContainer	Fired at an object when it receives a message that cannot be deserialized
offline	Event	Global scope objects	Fired at the global scope object when the network connections fails
online	Event	Global scope objects	Fired at the global scope object when the network connections returns
open	Event	EventSource, WebSocket	Fired at networking-related objects when a connection is established
pagehide	PageTransitionEvent	Window	Fired at the Window when the page's entry in the session history stops being the current entry
pageshow
Support: page-transition-events
Chrome for Android	64+
Chrome	4+
iOS Safari	5.0+
UC Browser for Android	11.8+
Firefox	2+
Samsung Internet	4+
IE	11+
Opera Mini	None
Safari	5+
Edge	12+
Android Browser	2.3+
Opera	15+

Source: caniuse.com

PageTransitionEvent	Window	Fired at the Window when the page's entry in the session history becomes the current entry
paste	Event	Elements	Fired at elements when the user will insert the clipboard data in the most suitable format (if any) supported for the given context
popstate	PopStateEvent	Window	Fired at the Window when the user navigates the session history
progress	ProgressEvent	img elements	Fired at img elements during a CORS-same-origin image load (see also media element events)
readystatechange	Event	Document	Fired at the Document when it finishes parsing and again when all its subresources have finished loading
rejectionhandled	PromiseRejectionEvent	Global scope objects	Fired at global scope objects when a previously-unhandled promise rejection becomes handled
reset	Event	form elements	Fired at a form element when it is reset
securitypolicyviolation	Event	Elements	Fired at elements when a Content Security Policy violation is generated [CSP]
select	Event	Form controls	Fired at form controls when their text selection is adjusted (whether by an API or by the user)
storage	StorageEvent	Window	Fired at Window event when the corresponding localStorage or sessionStorage storage areas change
submit	Event	form elements	Fired at a form element when it is submitted
toggle	Event	details element	Fired at details elements when they open or close
unhandledrejection	PromiseRejectionEvent	Global scope objects	Fired at global scope objects when a promise rejection goes unhandled
unload	Event	Window	Fired at the Window object when the page is going away
See also media element events, application cache events, and drag-and-drop events.

MIME Types
This section is non-normative.

The following MIME types are mentioned in this specification:

application/atom+xml
Atom [ATOM]
application/ecmascript
JavaScript (legacy type) [JAVASCRIPT]
application/javascript
JavaScript (legacy type) [JAVASCRIPT]
application/json
JSON [JSON]
application/x-ecmascript
JavaScript (legacy type) [JAVASCRIPT]
application/x-javascript
JavaScript (legacy type) [JAVASCRIPT]
application/octet-stream
Generic binary data [RFC2046]
application/microdata+json
Microdata as JSON
application/rss+xml
RSS
application/x-www-form-urlencoded
Form submission
application/xhtml+xml
HTML
application/xml
XML [XML] [RFC7303]
image/gif
GIF images [GIF]
image/jpeg
JPEG images [JPEG]
image/png
PNG images [PNG]
image/svg+xml
SVG images [SVG]
multipart/form-data
Form submission [RFC7578]
multipart/mixed
Generic mixed content [RFC2046]
multipart/x-mixed-replace
Streaming server push
text/cache-manifest
Offline application cache manifests
text/css
CSS [CSS]
text/ecmascript
JavaScript (legacy type) [JAVASCRIPT]
text/event-stream
Server-sent event streams
text/javascript
JavaScript [JAVASCRIPT]
text/javascript1.0
JavaScript (legacy type) [JAVASCRIPT]
text/javascript1.1
JavaScript (legacy type) [JAVASCRIPT]
text/javascript1.2
JavaScript (legacy type) [JAVASCRIPT]
text/javascript1.3
JavaScript (legacy type) [JAVASCRIPT]
text/javascript1.4
JavaScript (legacy type) [JAVASCRIPT]
text/javascript1.5
JavaScript (legacy type) [JAVASCRIPT]
text/jscript
JavaScript (legacy type) [JAVASCRIPT]
text/json
JSON (legacy type)
text/livescript
JavaScript (legacy type) [JAVASCRIPT]
text/plain
Generic plain text [RFC2046] [RFC3676]
text/html
HTML
text/ping
Hyperlink auditing
text/uri-list
List of URLs [RFC2483]
text/vcard
vCard [RFC6350]
text/vtt
WebVTT [WEBVTT]
text/x-ecmascript
JavaScript (legacy type) [JAVASCRIPT]
text/x-javascript
JavaScript (legacy type) [JAVASCRIPT]
text/xml
XML [XML] [RFC7303]
video/mp4
MPEG-4 video [RFC4337]
video/mpeg
MPEG video [RFC2046]
References
All references are normative unless marked "Non-normative".

[ABNF]
Augmented BNF for Syntax Specifications: ABNF, D. Crocker, P. Overell. IETF.
[ABOUT]
The 'about' URI scheme, S. Moonesamy. IETF.
[APNG]
(Non-normative) APNG Specification. S. Parmenter, V. Vukicevic, A. Smith. Mozilla.
[ARIA]
Accessible Rich Internet Applications (WAI-ARIA), J. Diggs, J. Craig, S. McCarron, M. Cooper. W3C.
[ARIAHTML]
ARIA in HTML, S. Faulkner. W3C.
[ATAG]
(Non-normative) Authoring Tool Accessibility Guidelines (ATAG) 2.0, J. Richards, J. Spellman, J. Treviranus. W3C.
[ATOM]
(Non-normative) The Atom Syndication Format, M. Nottingham, R. Sayre. IETF.
[BATTERY]
(Non-normative) Battery Status API, A. Kostiainen, M. Lamouri. W3C.
[BCP47]
Tags for Identifying Languages; Matching of Language Tags, A. Phillips, M. Davis. IETF.
[BEZIER]
Courbes à poles, P. de Casteljau. INPI, 1959.
[BIDI]
UAX #9: Unicode Bidirectional Algorithm, M. Davis. Unicode Consortium.
[BOCU1]
(Non-normative) UTN #6: BOCU-1: MIME-Compatible Unicode Compression, M. Scherer, M. Davis. Unicode Consortium.
[CESU8]
(Non-normative) UTR #26: Compatibility Encoding Scheme For UTF-16: 8-BIT (CESU-8), T. Phipps. Unicode Consortium.
[CHARMOD]
(Non-normative) Character Model for the World Wide Web 1.0: Fundamentals, M. Dürst, F. Yergeau, R. Ishida, M. Wolf, T. Texin. W3C.
[CLDR]
Unicode Common Locale Data Repository. Unicode.
[COMPOSITE]
Compositing and Blending, R. Cabanier, N. Andronikos. W3C.
[COMPUTABLE]
(Non-normative) On computable numbers, with an application to the Entscheidungsproblem, A. Turing. In Proceedings of the London Mathematical Society, series 2, volume 42, pages 230-265. London Mathematical Society, 1937.
[COOKIES]
HTTP State Management Mechanism, A. Barth. IETF.
[CSP]
Content Security Policy, M. West, D. Veditz. W3C.
[CSS]
Cascading Style Sheets Level 2 Revision 2, B. Bos, T. Çelik, I. Hickson, H. Lie. W3C.
[CSSANIMATIONS]
CSS Animations, D. Jackson, D. Hyatt, C. Marrin, S. Galineau, L. Baron. W3C.
[CSSATTR]
CSS Style Attributes, T. Çelik, E. Etemad. W3C.
[CSSBG]
CSS Backgrounds and Borders , B. Bos, E. Etemad, B. Kemper. W3C.
[CSSCASCADE]
CSS Cascading and Inheritance, E. Etemad, T. Atkins. W3C.
[CSSCOLOR]
CSS Color Module, T. Çelik, C. Lilley, L. Baron. W3C.
[CSSDISPLAY]
CSS Display, T. Atkins, E. Etemad. W3C.
[CSSFONTLOAD]
CSS Font Loading, T. Atkins, J. Daggett. W3C.
[CSSFONTS]
CSS Fonts, J. Daggett. W3C.
[CSSGC]
CSS Generated Content, H. Lie, E. Etemad, I. Hickson. W3C.
[CSSIMAGES]
CSS Image Values and Replaced Content Module, E. Etemad, T. Atkins. W3C.
[CSSLISTS]
CSS Lists and Counters, T. Atkins. W3C.
[CSSLOGICAL]
CSS Logical Properties, R. Atanassov, E. Etemad. W3C.
[CSSOM]
Cascading Style Sheets Object Model (CSSOM), S. Pieters, G. Adams. W3C.
[CSSOMVIEW]
CSSOM View Module, S. Pieters, G. Adams. W3C.
[CSSOVERFLOW]
CSS Overflow Module, L. Baron, F. Rivoal. W3C.
[CSSPOSITION]
CSS Positioned Layout, R. Atanassov, A. Eicholz. W3C.
[CSSRUBY]
CSS3 Ruby Module, R. Ishida. W3C.
[CSSTRANSITIONS]
(Non-normative) CSS Transitions, D. Jackson, D. Hyatt, C. Marrin, L. Baron. W3C.
[CSSUI]
CSS3 Basic User Interface Module, T. Çelik. W3C.
[CSSSYNTAX]
CSS Syntax, T. Atkins, S. Sapin. W3C.
[CSSTABLE]
CSS Table, F. Remy, G. Whitworth. W3C.
[CSSTEXT]
CSS Text, E. Etemad, K. Ishii. W3C.
[CSSVALUES]
CSS3 Values and Units, H. Lie, T. Atkins, E. Etemad. W3C.
[CSSWM]
CSS Writing Modes, E. Etemad, K. Ishii. W3C.
[DASH]
Dynamic adaptive streaming over HTTP (DASH). ISO.
[DOM]
DOM, A. van Kesteren, A. Gregor, Ms2ger. WHATWG.
[DOMPARSING]
DOM Parsing and Serialization, T. Leithead. W3C.
[DOT]
(Non-normative) The DOT Language. Graphviz.
[E163]
Recommendation E.163 — Numbering Plan for The International Telephone Service, CCITT Blue Book, Fascicle II.2, pp. 128-134, November 1988.
[ENCODING]
Encoding, A. van Kesteren, J. Bell. WHATWG.
[EXECCOMMAND]
execCommand, J. Wilm, A. Gregor. W3C Editing APIs CG.
[EXIF]
(Non-normative) Exchangeable image file format. JEITA.
[FETCH]
Fetch, A. van Kesteren. WHATWG.
[FILEAPI]
File API, A. Ranganathan. W3C.
[FILTERS]
Filter Effects, D. Jackson, E. Dahlström, D. Schulze. W3C.
[FULLSCREEN]
Fullscreen, A. van Kesteren, T. Çelik. WHATWG.
[GEOMETRY]
Geometry Interfaces Module. S. Pieters, D. Schulze, R. Cabanier. W3C.
[GIF]
(Non-normative) Graphics Interchange Format. CompuServe.
[GRAPHICS]
(Non-normative) Computer Graphics: Principles and Practice in C, Second Edition, J. Foley, A. van Dam, S. Feiner, J. Hughes. Addison-Wesley. ISBN 0-201-84840-6.
[GREGORIAN]
(Non-normative) Inter Gravissimas, A. Lilius, C. Clavius. Gregory XIII Papal Bull, February 1582.
[HRT]
High Resolution Time, I. Grigorik, J. Simonsen, J. Mann. W3C.
[HTMLAAM]
HTML Accessibility API Mappings 1.0, S. Faulkner, J. Kiss, A. Surkov. W3C.
[HTTP]
Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing, R. Fielding, J. Reschke. IETF.
Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, R. Fielding, J. Reschke. IETF.
Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests, R. Fielding, J. Reschke. IETF.
Hypertext Transfer Protocol (HTTP/1.1): Range Requests, R. Fielding, Y. Lafon, J. Reschke. IETF.
Hypertext Transfer Protocol (HTTP/1.1): Caching, R. Fielding, M. Nottingham, J. Reschke. IETF.
Hypertext Transfer Protocol (HTTP/1.1): Authentication, R. Fielding, J. Reschke. IETF.
[INDEXEDDB]
Indexed Database API, A. Alabbas, J. Bell. W3C.
[INBAND]
Sourcing In-band Media Resource Tracks from Media Containers into HTML, S. Pfeiffer, B. Lund. W3C.
[INFRA]
Infra, A. van Kesteren, D. Denicola. WHATWG.
[INTERSECTIONOBSERVER]
Intersection Observer, S. Zager. W3C.
[ISO3166]
ISO 3166: Codes for the representation of names of countries and their subdivisions. ISO.
[ISO4217]
ISO 4217: Codes for the representation of currencies and funds. ISO.
[ISO8601]
(Non-normative) ISO8601: Data elements and interchange formats — Information interchange — Representation of dates and times. ISO.
[JAVASCRIPT]
ECMAScript Language Specification. Ecma International.
[JLREQ]
Requirements for Japanese Text Layout. W3C.
[JPEG]
JPEG File Interchange Format, E. Hamilton.
[JSBIGINT]
BigInt. Ecma International.
[JSIMPORT]
import(). Ecma International.
[JSIMPORTMETA]
import.meta. Ecma International.
[JSINTL]
ECMAScript Internationalization API Specification. Ecma International.
[JSON]
The JavaScript Object Notation (JSON) Data Interchange Format, T. Bray. IETF.
[MAILTO]
(Non-normative) The 'mailto' URI scheme, M. Duerst, L. Masinter, J. Zawinski. IETF.
[MATHML]
Mathematical Markup Language (MathML), D. Carlisle, P. Ion, R. Miner. W3C.
[MEDIAFRAG]
Media Fragments URI, R. Troncy, E. Mannens, S. Pfeiffer, D. Van Deursen. W3C.
[MEDIASOURCE]
Media Source Extensions, A. Colwell, A. Bateman, M. Watson. W3C.
[MEDIASTREAM]
Media Capture and Streams, D. Burnett, A. Bergkvist, C. Jennings, A. Narayanan. W3C.
[MFREL]
Microformats Wiki: existing rel values. Microformats.
[MIMESNIFF]
MIME Sniffing, G. Hemsley. WHATWG.
[MIX]
Mixed Content, M. West. W3C.
[MNG]
MNG (Multiple-image Network Graphics) Format. G. Randers-Pehrson.
[MPEG2]
ISO/IEC 13818-1: Information technology — Generic coding of moving pictures and associated audio information: Systems. ISO/IEC.
[MPEG4]
ISO/IEC 14496-12: ISO base media file format. ISO/IEC.
[MQ]
Media Queries, H. Lie, T. Çelik, D. Glazman, A. van Kesteren. W3C.
[NPAPI]
(Non-normative) Gecko Plugin API Reference. Mozilla.
[OGGSKELETONHEADERS]
SkeletonHeaders. Xiph.Org.
[OPENSEARCH]
Autodiscovery in HTML/XHTML. In OpenSearch 1.1 Draft 4, Section 4.6.2. OpenSearch.org.
[ORIGIN]
(Non-normative) The Web Origin Concept, A. Barth. IETF.
[PAGEVIS]
(Non-normative) Page Visibility, J. Mann, A. Jain. W3C.
[PAYMENTREQUEST]
Payment Request API, A. Bateman, Z. Koch, R. McElmurry. W3C.
[PDF]
(Non-normative) Document management — Portable document format — Part 1: PDF. ISO.
[PINGBACK]
Pingback 1.0, S. Langridge, I. Hickson.
[PNG]
Portable Network Graphics (PNG) Specification, D. Duce. W3C.
[POINTEREVENTS]
Pointer Events, J. Rossi, M. Brubeck, R. Byers, P. H. Lauke. W3C.
[POINTERLOCK]
Pointer Lock, V. Scheib. W3C.
[PPUTF8]
(Non-normative) The Properties and Promises of UTF-8, M. Dürst. University of Zürich. In Proceedings of the 11th International Unicode Conference.
[PRELOAD]
Preload, I. Grigorik. W3C.
[PRESENTATION]
Presentation API, M. Foltz, D. Röttsches. W3C.
[PSL]
Public Suffix List. Mozilla Foundation.
[REFERRERPOLICY]
Referrer Policy, J. Eisinger, E. Stark. W3C.
[RESOURCEHINTS]
Resource Hints, I. Grigorik. W3C.
[RFC1034]
Domain Names - Concepts and Facilities, P. Mockapetris. IETF, November 1987.
[RFC1123]
Requirements for Internet Hosts -- Application and Support, R. Braden. IETF, October 1989.
[RFC2046]
Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types, N. Freed, N. Borenstein. IETF.
[RFC2397]
The "data" URL scheme, L. Masinter. IETF.
[RFC5545]
Internet Calendaring and Scheduling Core Object Specification (iCalendar), B. Desruisseaux. IETF.
[RFC2483]
URI Resolution Services Necessary for URN Resolution, M. Mealling, R. Daniel. IETF.
[RFC3676]
The Text/Plain Format and DelSp Parameters, R. Gellens. IETF.
[RFC3864]
Registration Procedures for Message Header Fields, G. Klyne, M. Nottingham, J. Mogul. IETF.
[RFC4329]
(Non-normative) Scripting Media Types, B. Höhrmann. IETF.
[RFC4337]
(Non-normative) MIME Type Registration for MPEG-4, Y. Lim, D. Singer. IETF.
[RFC7595]
Guidelines and Registration Procedures for URI Schemes, D. Thaler, T. Hansen, T. Hardie. IETF.
[RFC5322]
Internet Message Format, P. Resnick. IETF.
[RFC6381]
The 'Codecs' and 'Profiles' Parameters for "Bucket" Media Types, R. Gellens, D. Singer, P. Frojdh. IETF.
[RFC6266]
Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP), J. Reschke. IETF.
[RFC6350]
vCard Format Specification, S. Perreault. IETF.
[RFC6596]
The Canonical Link Relation, M. Ohye, J. Kupke. IETF.
[RFC7303]
XML Media Types, H. Thompson, C. Lilley. IETF.
[RFC7578]
Returning Values from Forms: multipart/form-data, L. Masinter. IETF.
[SCREENORIENTATION]
Screen Orientation API, M. Lamouri, M. Cáceres. W3C.
[SCSU]
(Non-normative) UTR #6: A Standard Compression Scheme For Unicode, M. Wolf, K. Whistler, C. Wicksteed, M. Davis, A. Freytag, M. Scherer. Unicode Consortium.
[SECURE-CONTEXTS]
Secure Contexts, M. West. W3C.
[SELECTION]
Selection API, R. Niwa. W3C.
[SELECTORS]
Selectors, E. Etemad, T. Çelik, D. Glazman, I. Hickson, P. Linss, J. Williams. W3C.
[SMS]
(Non-normative) URI Scheme for Global System for Mobile Communications (GSM) Short Message Service (SMS), E. Wilde, A. Vaha-Sipila. IETF.
[SRGB]
IEC 61966-2-1: Multimedia systems and equipment — Colour measurement and management — Part 2-1: Colour management — Default RGB colour space — sRGB. IEC.
[SRI]
Subresource Integrity, D. Akhawe, F. Braun, F. Marier, J. Weinberger. W3C.
[SVG]
Scalable Vector Graphics (SVG) 1.1 (Second Edition), E. Dahlström, P. Dengler, A. Grasso, C. Lilley, C. McCormack, D. Schepers, J. Watt, J. Ferraiolo, J. Fujisawa, D. Jackson. W3C.
[SVGTINY12]
Scalable Vector Graphics (SVG) Tiny 1.2, O. Andersson, R. Berjon, E. Dahlström, A. Emmons, J. Ferraiolo, A. Grasso, V. Hardy, S. Hayman, D. Jackson, C. Lilley, C. McCormack, A. Neumann, C. Northway, A. Quint, N. Ramani, D. Schepers, A. Shellshear. W3C.
[SVG2]
(Non-normative) Scalable Vector Graphics (SVG) 2, N. Andronikos, R. Atanassov, T. Bah, A. Bellamy-Royds, B. Birtles, B. Brinza, C. Concolato, E. Dahlström, C. Lilley, C. McCormack, D. Schepers, D. Schulze, R. Schwerdtfeger, S. Takagi, J. Watt. W3C.
[SW]
Service Workers, A. Russell, J. Song, J. Archibald. W3C.
[TOR]
(Non-normative) Tor.
[TOUCH]
Touch Events, D. Schepers, S. Moon, M. Brubeck, A. Barstow, R. Byers. W3C.
[TZDATABASE]
(Non-normative) Time Zone Database. IANA.
[UAAG]
(Non-normative) User Agent Accessibility Guidelines (UAAG) 2.0, J. Allan, K. Ford, J. Richards, J. Spellman. W3C.
[UIEVENTS]
UI Events Specification, G. Kacmarcik, T. Leithead. W3C.
[UNICODE]
The Unicode Standard. Unicode Consortium.
[UNIVCHARDET]
(Non-normative) A composite approach to language/encoding detection, S. Li, K. Momoi. Netscape. In Proceedings of the 19th International Unicode Conference.
[URL]
URL, A. van Kesteren. WHATWG.
[URN]
URN Syntax, R. Moats. IETF.
[UTF7]
(Non-normative) UTF-7: A Mail-Safe Transformation Format of Unicode, D. Goldsmith, M. Davis. IETF.
[UTF8DET]
(Non-normative) Multilingual form encoding, M. Dürst. W3C.
[UTR36]
(Non-normative) UTR #36: Unicode Security Considerations, M. Davis, M. Suignard. Unicode Consortium.
[WCAG]
(Non-normative) Web Content Accessibility Guidelines (WCAG) 2.0, B. Caldwell, M. Cooper, L. Reid, G. Vanderheiden. W3C.
[WEBANIMATIONS]
Web Animations, B. Birtles, S. Stephens, D. Stockwell. W3C.
[WEBCRYPTO]
(Non-normative) Web Cryptography API, M. Watson. W3C.
[WEBGL]
WebGL Specification, D. Jackson. Khronos Group.
[WEBIDL]
Web IDL, C. McCormack. W3C.
[WEBLINK]
Web Linking, M. Nottingham. IETF.
[WEBMCG]
WebM Container Guidelines. The WebM Project.
[WEBVTT]
WebVTT, S. Pieters. W3C.
[WHATWGWIKI]
The WHATWG Wiki. WHATWG.
[WORKLETS]
Worklets. I. Kilpatrick. W3C.
[WSP]
The WebSocket protocol, I. Fette, A. Melnikov. IETF.
[X121]
Recommendation X.121 — International Numbering Plan for Public Data Networks, CCITT Blue Book, Fascicle VIII.3, pp. 317-332.
[XFN]
XFN 1.1 profile, T. Çelik, M. Mullenweg, E. Meyer. GMPG.
[XHR]
XMLHttpRequest, A. van Kesteren. WHATWG.
[XKCD1288]
(Non-normative) Substitutions, Randall Munroe. xkcd.
[XML]
Extensible Markup Language, T. Bray, J. Paoli, C. Sperberg-McQueen, E. Maler, F. Yergeau. W3C.
[XMLENTITY]
(Non-normative) XML Entity Definitions for Characters, D. Carlisle, P. Ion. W3C.
[XMLNS]
Namespaces in XML, T. Bray, D. Hollander, A. Layman, R. Tobin. W3C.
[XMLSSPI]
Associating Style Sheets with XML documents, J. Clark, S. Pieters, H. Thompson. W3C.
[XPATH10]
XML Path Language (XPath) Version 1.0, J. Clark, S. DeRose. W3C.
[XSLT10]
(Non-normative) XSL Transformations (XSLT) Version 1.0, J. Clark. W3C.
[XSLTP]
(Non-normative) DOM XSLTProcessor, WHATWG Wiki. WHATWG.
Acknowledgments
Thanks to Tim Berners-Lee for inventing HTML, without which none of this would exist.

Thanks to Aankhen, Aaron Boodman, Aaron Leventhal, Abhishek Gupta, Adam Barth, Adam de Boor, Adam Hepton, Adam Klein, Adam Roben, Addison Phillips, Adele Peterson, Adrian Bateman, Adrian Roselli, Adrian Sutton, Agustín Fernández, Aharon (Vladimir) Lanin, Ajai Tirumali, Akatsuki Kitamura, Alan Plum, Alastair Campbell, Alejandro G. Castro, Aleksey Shvayka, Alex Bishop, Alex Nicolaou, Alex Nozdriukhin, Alex Rousskov, Alexander Farkas, Alexander J. Vincent, Alexandre Morgaut, Alexey Feldgendler, Алексей Проскуряков (Alexey Proskuryakov), Alexis Deveria, Alfred Agrell, Ali Juma, Alice Boxhall, Alice Wonder, Allan Clements, Allen Wirfs-Brock, Alex Komoroske, Alex Russell, Alphan Chen, Ami Fischman, Amos Jeffries, Anders Carlsson, André Bargull, André E. Veltstra, Andrea Rendine, Andreas, Andreas Kling, Andrei Popescu, Andres Gomez, Andres Rios, Andrew Barfield, Andrew Clover, Andrew Gove, Andrew Grieve, Andrew Oakley, Andrew Sidwell, Andrew Simons, Andrew Smith, Andrew W. Hagen, Andrey V. Lukyanov, Andry Rendy, Andy Earnshaw, Andy Heydon, Andy Palay, Anjana Vakil, Ankur Kaushal, Anna Belle Leiserson, Anthony Boyd, Anthony Bryan, Anthony Hickson, Anthony Ramine, Anthony Ricaud, Anton Vayvod, Antti Koivisto, Arkadiusz Michalski, Arne Thomassen, Aron Spohr, Arphen Lin, Arthur Stolyar, Arun Patole, Aryeh Gregor, Asbjørn Ulsberg, Ashley Gullen, Ashley Sheridan, Atsushi Takayama, Aurelien Levy, Ave Wrigley, Avi Drissman, Axel Dahmen, Ben Boyle, Ben Godfrey, Ben Kelly, Ben Lerner, Ben Leslie, Ben Meadowcroft, Ben Millard, Benjamin Carl Wiley Sittler, Benjamin Hawkes-Lewis, Benoit Ren, Bert Bos, Bijan Parsia, Bil Corry, Bill Mason, Bill McCoy, Billy Wong, Billy Woods, Bjartur Thorlacius, Björn Höhrmann, Blake Frantz, Bob Lund, Bob Owen, Bobby Holley, Boris Zbarsky, Brad Fults, Brad Neuberg, Brad Spencer, Bradley Meck, Brady Eidson, Brandon Jones, Brendan Eich, Brenton Simpson, Brett Wilson, Brett Zamir, Brian Birtles, Brian Blakely, Brian Campbell, Brian Korver, Brian Kuhn, Brian M. Dube, Brian Ryner, Brian Smith, Brian Wilson, Bryan Sullivan, Bruce Bailey, Bruce D'Arcus, Bruce Lawson, Bruce Miller, Bugs Nash, C. Scott Ananian, C. Williams, Cameron McCormack, Cameron Zemek, Cao Yipeng, Carlos Amengual, Carlos Gabriel Cardona, Carlos Perelló Marín, Casey Leask, Cătălin Badea, Cătălin Mariș, Chao Cai, 윤석찬 (Channy Yun), Charl van Niekerk, Charlene Wright, Charles Iliya Krempeaux, Charles McCathie Nevile, Charlie Reis, Chris Apers, Chris Cressman, Chris Dumez, Chris Evans, Chris Harrelson, Chris Markiewicz, Chris Morris, Chris Pearce, Chris Peterson, Chris Rebert, Chris Weber, Chris Wilson, Christian Biesinger, Christian Johansen, Christian Schmidt, Christoph Päper, Christophe Dumez, Christopher Aillon, Christopher Ferris, Chriswa, Clark Buehler, Cole Robison, Colin Fine, Collin Jackson, Corey Farwell, Corprew Reed, Craig Cockburn, Csaba Gabor, Csaba Marton, Cynthia Shelly, Cyrille Tuzi, Daksh Shah, Dan Callahan, Dan Ehrenberg, Dan Yoder, Dane Foster, Daniel Barclay, Daniel Bratell, Daniel Brooks, Daniel Brumbaugh Keeney, Daniel Buchner, Daniel Cheng, Daniel Davis, Daniel Glazman, Daniel Peng, Daniel Schattenkirchner, Daniel Spång, Daniel Steinberg, Daniel Trebbien, Danny Sullivan, Darin Adler, Darin Fisher, Darxus, Dave Camp, Dave Cramer, Dave Hodder, Dave Lampton, Dave Singer, Dave Tapuska, Dave Townsend, David Baron, David Bloom, David Bruant, David Carlisle, David E. Cleary, David Egan Evans, David Fink, David Flanagan, David Gerard, David Grogan, David Håsäther, David Hyatt, David I. Lehn, David John Burrowes, David Kendal, David Matja, David Remahl, David Resseguie, David Smith, David Vest, David Woolley, David Zbarsky, Dave Methvin, DeWitt Clinton, Dean Edridge, Dean Edwards, Dean Jackson, Debi Orton, Delan Azabani, Derek Featherstone, Devarshi Pant, Devdatta, Diego Ferreiro Val, Diego Ponce de León, Dimitri Glazkov, Dimitry Golubovsky, Dirk Pranke, Dirk Schulze, Dirkjan Ochtman, Divya Manian, Dmitry Titov, dolphinling, Dominic Cooney, Dominic Farolino, Dominique Hazaël-Massieux, Don Brutzman, Donovan Glover, Doron Rosenberg, Doug Kramer, Doug Simpkinson, Drew Wilson, Edgar Chen, Edmund Lai, Eduard Pascual, Eduardo Vela, Edward Welbourne, Edward Z. Yang, Ehsan Akhgari, Eira Monstad, Eitan Adler, Eli Friedman, Eli Grey, Eliot Graff, Elisabeth Robson, Elizabeth Castro, Elliott Sprehn, Elliotte Harold, Emilio Cobos Álvarez, Emily Stark, Eric Carlson, Eric Casler, Eric Lawrence, Eric Rescorla, Eric Semling, Erik Arvidsson, Erik Charlebois, Erik Rose, espretto, Evan Jacobs, Evan Martin, Evan Prodromou, Evan Stade, Evert, Evgeny Kapun, Ezequiel Garzón, fantasai, Félix Sanz, Felix Sasaki, Fernando Altomare Serboncini, Forbes Lindesay, Francesco Schwarz, Francis Brosnan Blazquez, Franck 'Shift' Quélain, François Marier, Frank Barchard, Frank Liberato, Fredrik Söderquist, 鵜飼文敏 (Fumitoshi Ukai), Futomi Hatano, Gavin Carothers, Gavin Kistner, Gareth Rees, Garrett Smith, Gary Kacmarcik, Gary Katsevman, Geoff Richards, Geoffrey Garen, Geoffrey Sneddon, Georg Neis, George Lund, Gianmarco Armellin, Giovanni Campagna, Giuseppe Pascale, Glenn Adams, Glenn Maynard, Graham Klyne, Greg Botten, Greg Houston, Greg Wilkins, Gregg Tavares, Gregory J. Rosmaita, Grey, Guilherme Johansson Tramontina, guest271314, Gytis Jakutonis, Håkon Wium Lie, Habib Virji, Hajime Morrita, Hallvord Reiar Michaelsen Steen, Hans S. Tømmerhalt, Hans Stimer, Harald Alvestrand, Hayato Ito, Henri Sivonen, Henrik Lied, Henry Lewis, Henry Mason, Henry Story, Hermann Donfack Zeufack, Hiroshige Hayashizaki, Hongchan Choi, Hugh Bellamy, Hugh Guiney, Hugh Winkler, Ian Bicking, Ian Clelland, Ian Davis, Ian Fette, Ian Kilpatrick, Ibrahim Ahmed, Ido Green, Ignacio Javier, Igor Oliveira, Ingvar Stepanyan, isonmad, Iurii Kucherov, Ivan Enderlin, Ivan Nikulin, Ivo Emanuel Gonçalves, J. King, J.C. Jones, Jackson Ray Hamilton, Jacob Davies, Jacques Distler, Jake Archibald, Jake Verbaten, Jakub Vrána, Jakub Łopuszański, Jakub Wilk, James Craig, James Graham, James Greene, James Justin Harrell, James Kozianski, James M Snell, James Perrett, James Robinson, Jamie Lokier, Jan Kühle, Jan Miksovsky, Janusz Majnert, Jan-Klaas Kollhof, Jared Jacobs, Jason Duell, Jason Kersey, Jason Lustig, Jason Orendorff, Jason White, Jasper Bryant-Greene, Jasper St. Pierre, Jatinder Mann, Jean-Yves Avenard, Jed Hartman, Jeff Balogh, Jeff Cutsinger, Jeff "=JeffH" Hodges, Jeff Schiller, Jeff Walden, Jeffrey Yasskin, Jeffrey Zeldman, 胡慧鋒 (Jennifer Braithwaite), Jellybean Stonerfish, Jennifer Apacible, Jens Bannmann, Jens Fendler, Jens Oliver Meiert, Jens Widell, Jer Noble, Jeremey Hustman, Jeremy Keith, Jeremy Orlow, Jeroen van der Meer, Jerry Smith, Jesse Renée Beach, Jessica Jong, jfkthame, Jian Li, Jihye Hong, Jim Jewett, Jim Ley, Jim Meehan, Jim Michaels, Jinho Bang, Jinjiang (勾三股四), Jirka Kosek, Jjgod Jiang, João Eiras, Jochen Eisinger, Joe Clark, Joe Gregorio, Joel Spolsky, Joel Verhagen, Johan Herland, John Boyer, John Bussjaeger, John Carpenter, John Daggett, John Fallows, John Foliot, John Harding, John Keiser, John Snyders, John Stockton, John-Mark Bell, Johnny Stenback, Jon Coppeard, Jon Ferraiolo, Jon Gibbins, Jon Perlow, Jonas Sicking, Jonathan Cook, Jonathan Neal, Jonathan Oddy, Jonathan Rees, Jonathan Watt, Jonathan Worent, Jonny Axelsson, Jordan Tucker, Jorgen Horstink, Joris van der Wel, Jorunn Danielsen Newth, Joseph Kesselman, Joseph Mansfield, Joseph Pecoraro, Josh Aas, Josh Hart, Josh Juran, Josh Levenberg, Josh Matthews, Joshua Bell, Joshua Randall, Jukka K. Korpela, Jules Clément-Ripoche, Julian Reschke, Julio Lopez, Jun Yang (harttle), Jungkee Song, Jürgen Jeka, Justin Lebar, Justin Novosad, Justin Rogers, Justin Schuh, Justin Sinclair, Juuso Lapinlampi, Ka-Sing Chou, Kagami Sascha Rosylight, Kai Hendry, Kamishetty Sreeja, 呂康豪 (KangHao Lu), Karl Dubost, Karl Tomlinson, Kartikaya Gupta, Kat Graff, Kathy Walton, Keith Rollin, Keith Yeung, Kelly Ford, Kelly Norton, Kenji Baheux, Kevin Benson, Kevin Cole, Kevin Gadd, Kevin Venkiteswaran, Kinuko Yasuda, Koji Ishii, Kornél Pál, Kornel Lesinski, 上野 康平 (UENO, Kouhei), Kris Northfield, Kristof Zelechovski, Krzysztof Maczyński, 黒澤剛志 (Kurosawa Takeshi), Kyle Barnhart, Kyle Hofmann, Kyle Huey, Léonard Bouchet, Léonie Watson, Lachlan Hunt, Larry Masinter, Larry Page, Lars Gunther, Lars Solberg, Laura Carlson, Laura Granka, Laura L. Carlson, Laura Wisewell, Laurens Holst, Lawrence Forooghian, Lee Kowalkowski, Leif Halvard Silli, Leif Kornstaedt, Lenny Domnitser, Leonard Rosenthol, Leons Petrazickis, Lobotom Dysmon, Logan, Loune, Lucas Gadani, Łukasz Pilorz, Luke Kenneth Casson Leighton, Maciej Stachowiak, Magne Andersson, Magnus Kristiansen, Maik Merten, Majid Valipour, Malcolm Rowe, Manish Goregaokar, Manish Tripathi, Marc Hoyois, Marc-André Choquette, Marc-André Lafortune, Marco Zehe, Marcus Bointon, Marijn Kruisselbrink, Mark Amery, Mark Birbeck, Mark Davis, Mark Miller, Mark Nottingham, Mark Pilgrim, Mark Rowe, Mark Schenk, Mark Vickers, Mark Wilton-Jones, Markus Stange, Martijn Wargers, Martin Atkins, Martin Chaov, Martin Dürst, Martin Honnen, Martin Janecke, Martin Kutschker, Martin Nilsson, Martin Thomson, Masataka Yakura, Masatoshi Kimura, Mason Mize, Mathias Bynens, Mathieu Henri, Matias Larsson, Matt Brubeck, Matt Di Pasquale, Matt Falkenhagen, Matt Schmidt, Matt Wright, Matthew Gregan, Matthew Mastracci, Matthew Noorenberghe, Matthew Raymond, Matthew Thomas, Mattias Waldau, Max Romantschuk, Menachem Salomon, Menno van Slooten, Micah Dubinko, Michael 'Ratt' Iannarelli, Michael A. Nachbaur, Michael A. Puls II, Michael Carter, Michael Daskalov, Michael Day, Michael Dyck, Michael Enright, Michael Gratton, Michael Kohler, Michael McKelvey, Michael Nordman, Michael Powers, Michael Rakowski, Michael(tm) Smith, Michael Walmsley, Michal Zalewski, Michel Buffa, Michel Fortin, Michelangelo De Simone, Michiel van der Blonk, Mihai Şucan, Mihai Parparita, Mike Brown, Mike Dierken, Mike Dixon, Mike Hearn, Mike Pennisi, Mike Schinkel, Mike Shaver, Mikko Rantalainen, Mingye Wang, Mohamed Zergaoui, Mohammad Al Houssami, Mohammad Reza Zakerinasab, Momdo Nakamura, Morten Stenshorne, Mounir Lamouri, Ms2ger, Mukilan Thiyagarajan, Nadia Heninger, NARUSE Yui, Navid Zolghadr, Neil Deakin, Neil Rashbrook, Neil Soiffer, Nicholas Shanks, Nicholas Stimpson, Nicholas Zakas, Nickolay Ponomarev, Nicolas Gallagher, Nikki Bee, Noah Mendelsohn, Noah Slater, Noel Gordon, Nolan Waite, NoozNooz42, Norbert Lindenberg, Ojan Vafai, Olaf Hoffmann, Olav Junker Kjær, Oldřich Vetešník, Oli Studholme, Oliver Hunt, Oliver Rigby, Olivier Gendrin, Olli Pettay, Ori Avtalion, oSand, Pablo Flouret, Patrick Dark, Patrick Garies, Patrick H. Lauke, Patrik Persson, Paul Adenot, Paul Lewis, Paul Norman, Per-Erik Brodin, 一丝 (percyley), Perry Smith, Peter Beverloo, Peter Karlsson, Peter Kasting, Peter Moulder, Peter Occil, Peter Stark, Peter Van der Beken, Peter van der Zee, Peter-Paul Koch, Phil Pickering, Philip Taylor, Philip TAYLOR, Philippe De Ryck, Pooja Sanklecha, Prashant Hiremath, Prashanth Chandra, Prateek Rungta, Pravir Gupta, Prayag Verma, 李普君 (Pujun Li), Rachid Finge, Rafael Weinstein, Rafał Miłecki, Raj Doshi, Rajas Moonka, Ralf Stoltze, Ralph Giles, Raphael Champeimont, Rebecca Star, Remci Mizkur, Remco, Remy Sharp, Rene Saarsoo, Rene Stach, Ric Hardacre, Rich Clark, Rich Doughty, Richa Rupela, Richard Gibson, Richard Ishida, Rigo Wenning, Rikkert Koppes, Rimantas Liubertas, Riona Macnamara, Rob Buis, Rob Ennals, Rob Jellinghaus, Rob S, Robert Blaut, Robert Collins, Robert Hogan, Robert Kieffer, Robert Millan, Robert O'Callahan, Robert Sayre, Robin Berjon, Robin Schaufler, Rodger Combs, Roland Steiner, Roma Matusevich, Roman Ivanov, Roy Fielding, Rune Lillesveen, Russell Bicknell, Ruud Steltenpool, Ryan King, Ryan Landay, Ryan Sleevi, Ryo Kato, Ryosuke Niwa, S. Mike Dierken, Salvatore Loreto, Sam Dutton, Sam Kuper, Sam Ruby, Sam Weinig, Samikshya Chand, Samuel Bronson, Samy Kamkar, Sander van Lambalgen, Sanjoy Pal, Sarven Capadisli, Scott Beardsley, Scott González, Scott Hess, Scott Miles, Scott O'Hara, Sean Fraser, Sean Hayes, Sean Hogan, Sean Knapp, Sebastian Markbåge, Sebastian Schnitzenbaumer, Sendil Kumar N, Seth Call, Seth Dillingham, Shannon Moeller, Shanti Rao, Shaun Inman, Shiino Yuki, 贺师俊 (HE Shi-Jun), Shiki Okasaka, Shivani Sharma, shreyateeza, Shubheksha Jalan, Sierk Bornemann, Sigbjørn Finne, Sigbjørn Vik, Silver Ghost, Silvia Pfeiffer, Šime Vidas, Simon Fraser, Simon Montagu, Simon Sapin, Simon Spiegel, skeww, Smylers, Srirama Chandra Sekhar Mogali, Stanton McCandlish, Stefan Håkansson, Stefan Haustein, Stefan Santesson, Stefan Schumacher, Stefan Weiss, Steffen Meschkat, Stephen Ma, Stephen Stewart, Stephen White, Steve Comstock, Steve Faulkner, Steve Orvell, Steve Runyon, Steven Bennett, Steven Garrity, Steven Tate, Stewart Brodie, Stuart Ballard, Stuart Langridge, Stuart Parmenter, Subramanian Peruvemba, Sudhanshu Jaiswal, sudokus999, Sunava Dutta, Susan Borgrink, Susan Lesch, Sylvain Pasche, T. J. Crowder, Tab Atkins-Bittner, Taiju Tsuiki, Takashi Toyoshima, Takayoshi Kochi, Takeshi Yoshino, Tantek Çelik, 田村健人 (TAMURA Kent), Taylor Hunt, Ted Mielczarek, Terrence Wood, Tetsuharu OHZEKI, Theresa O'Connor, Thijs van der Vossen, Thomas Broyer, Thomas Koetter, Thomas O'Connor, Tim Altman, Tim Johansson, Tim Perry, Tim van der Lippe, TJ VanToll, Tobias Schneider, Tobie Langel, Toby Inkster, Todd Moody, Tom Baker, Tom Pike, Tom Schuster, Tommy Thorsen, Tony Ross, Tooru Fujisawa, Travis Leithead, Trevor Rowbotham, Trevor Saunders, triple-underscore, Tyler Close, Valentin Gosu, Vardhan Gupta, Veli Şenol, Victor Carbune, Victor Costan, Vipul Snehadeep Chawathe, Vitya Muhachev, Vlad Levin, Vladimir Katardjiev, Vladimir Vukićević, Vyacheslav Aristov, voracity, Walter Steiner, Wakaba, Wayne Carr, Wayne Pollock, Wellington Fernando de Macedo, Weston Ruter, Wilhelm Joys Andersen, Will Levine, Will Ray, William Chen, William Swanson, Willy Martin Aguirre Rodriguez, Wladimir Palant, Wojciech Mach, Wolfram Kriesing, Xan Gregg, xenotheme, XhmikosR, Xida Chen, Xidorn Quan, Xue Fuqiao, Yang Chen, Yay295, Ye-Kui Wang, Yehuda Katz, Yi-An Huang, Yngve Nysaeter Pettersen, Yoav Weiss, Yonathan Randolph, Yury Delendik, Yuzo Fujishima, Zhenbin Xu, 张智强 (Zhiqiang Zhang), Zoltan Herczeg, and Øistein E. Andersen, for their useful comments, both large and small, that have led to changes to this specification over the years.

Thanks also to everyone who has ever posted about HTML to their blogs, public mailing lists, or forums, including all the contributors to the various W3C HTML WG lists and the various WHATWG lists.

Special thanks to Richard Williamson for creating the first implementation of canvas in Safari, from which the canvas feature was designed.

Special thanks also to the Microsoft employees who first implemented the event-based drag-and-drop mechanism, contenteditable, and other features first widely deployed by the Windows Internet Explorer browser.

Special thanks and $10,000 to David Hyatt who came up with a broken implementation of the adoption agency algorithm that the editor had to reverse engineer and fix before using it in the parsing section.

Thanks to the participants of the microdata usability study for allowing us to use their mistakes as a guide for designing the microdata feature.

Thanks to the many sources that provided inspiration for the examples used in the specification.

Thanks also to the Microsoft blogging community for some ideas, to the attendees of the W3C Workshop on Web Applications and Compound Documents for inspiration, to the #mrt crew, the #mrt.no crew, and the #whatwg crew, and to Pillar and Hedral for their ideas and support.

Thanks to Igor Zhbanov for generating PDF versions of the specification.

Special thanks to the RICG for developing the picture element and related features; in particular thanks to Adrian Bateman, Bruce Lawson, David Newton, Ilya Grigorik, John Schoenick, Leon de Rijke, Mat Marquis, Marcos Cáceres, Tab Atkins, Theresa O'Connor, and Yoav Weiss for their contributions.

Special thanks to the WPWG for incubating the custom elements feature. In particular, thanks to David Hyatt and Ian Hickson for their influence through the XBL specifications, Dimitri Glazkov for the first draft of the custom elements specification, and to Alex Komoroske, Alex Russell, Andres Rios, Boris Zbarsky, Brian Kardell, Daniel Buchner, Dominic Cooney, Erik Arvidsson, Elliott Sprehn, Hajime Morrita, Hayato Ito, Jan Miksovsky, Jonas Sicking, Olli Pettay, Rafael Weinstein, Roland Steiner, Ryosuke Niwa, Scott Miles, Steve Faulkner, Steve Orvell, Tab Atkins, Theresa O'Connor, Tim Perry, and William Chen for their contributions.

Part of the revision history of the picture element and related features can be found in the ResponsiveImagesCG/picture-element repository.

Part of the revision history of the theme-color metadata name can be found in the whatwg/meta-theme-color repository.

Part of the revision history of the custom elements feature can be found in the w3c/webcomponents repository, which is available under the W3C Permissive Document License.

Part of the revision history of the innerText IDL attribute can be found in the rocallahan/innerText-spec repository.

For about ten years starting in 2003, this standard was almost entirely written by Ian Hickson (Google, ian@hixie.ch). More recently, Simon Pieters (Bocoup, zcorpan@gmail.com), Anne van Kesteren (Mozilla, annevk@annevk.nl), Philip Jägenstedt (Google, philip@foolip.org), and Domenic Denicola (Google, d@domenic.me), all previously long-time contributors, have joined Ian in editing the text directly.

The image in the introduction is based on a photo by Wonderlane. (CC BY 2.0)

The image of the wolf in the embedded content introduction is based on a photo by Barry O'Neill. (Public domain)

The image of the kettlebell swing in the embedded content introduction is based on a photo by kokkarina. (CC0 1.0)

The Blue Robot Player sprite used in the canvas demo is based on a work by JohnColburn. (CC BY-SA 3.0)

The photograph of robot 148 climbing the tower at the FIRST Robotics Competition 2013 Silicon Valley Regional is based on a work by Lenore Edman. (CC BY 2.0)

The diagram showing how async and defer impact script loading is based on a similar diagram from a blog post by Peter Beverloo. (CC0 1.0)

The image decoding demo used to demonstrate module-based workers draws on some example code from a tutorial by Ilmari Heikkinen. (CC BY 3.0)

The <flag-icon> example was inspired by a custom element by Steven Skelton. (MIT)

Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a Creative Commons Attribution 4.0 International License.